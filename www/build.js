(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//

var _$db = require( "./app/db.js" )
var _$samsara = require( "./app/samsara.js" )
var _$utils = require( "./app/utils.js" )


var Vue = require( 'vue' )
Vue.config.debug = false
var VueRouter = require( "vue-router" )
var VueTouch = require( 'vue-touch' )
Vue.use( VueRouter )
Vue.use( VueTouch )




_.mixin( {
	'parseBool': function ( bool ) {
		if ( _.isString( bool ) ) {
			bool = bool.toLowerCase()
		}
		switch ( bool ) {
		case true:
		case "true":
		case "t":
		case 1:
		case "1":
		case "on":
		case "yes":
			return true
		case false:
		case "false":
		case "f":
		case 0:
		case "0":
		case "off":
		case "no":
			return false
		default:
			return undefined
		}
	}
} )

_.mixin( {
	'mathClamp': function ( x, a, b ) {
		return Math.min( Math.max( x, a ), b )
	}
} )

_.mixin( {
	'getMoment': function ( stamp, seconds ) {
		var str = 'h:mm A'
		if ( seconds == true ) {
			str = 'h:mm:ss A'
		}
		return moment( stamp ).calendar( _.now(), {
			sameDay: str,
			lastDay: '[Yesterday @] h:mm A',
			lastWeek: '[Past] ddd [@] h:mm A',
			sameElse: 'ddd MMM D [@] h:mm A'
		} )
	}
} )

_.mixin( {
	'strInsert': function ( str, index, value ) {
		return str.substr( 0, index ) + value + str.substr( index )
	}
} )

_.mixin( {
	'parsePhone': function ( numb ) {
		numb = numb.match( /\d/g )
		numb = numb.join( "" )
		numb = numb.substring( numb.length - 10, numb.length )
		numb = "1" + numb
		return numb
	}
} )

_.mixin( {
	'prettyPhone': function ( numb ) {
		numb = _.parsePhone( numb )
		numb = numb.substring( numb.length - 10, numb.length )
		numb = numb.replace( /(\d{3})(\d{3})(\d{4})/, "$1-$2-$3" )
		return numb
	}
} )



VueTouch.registerCustomEvent( 'doubletap', {
	type: 'tap',
	threshold: 3,
	interval: 300,
	taps: 2
} )

VueTouch.registerCustomEvent( 'quicktaphold', {
	type: 'press',
	threshold: 10,
	time: 250
} )

VueTouch.registerCustomEvent( 'quintap', {
	type: 'tap',
	threshold: 3,
	interval: 300,
	taps: 5
} )

VueTouch.registerCustomEvent( 'taphold', {
	type: 'press',
	threshold: 10,
	time: 500
} )

VueTouch.registerCustomEvent( 'swipeleft', {
	type: 'swipe',
	velocity: 0.5,
	threshold: 10,
	direction: HM_DIRECTION_LEFT
} )

VueTouch.registerCustomEvent( 'swiperight', {
	type: 'swipe',
	velocity: 0.5,
	threshold: 10,
	direction: HM_DIRECTION_RIGHT
} )

VueTouch.registerCustomEvent( 'taphelphold', {
	type: 'press',
	threshold: 100,
	time: 1000
} )

var _$App = Vue.extend( {
	data: function () {
		var data = {}
		data.idk = "butt munch"
		return data
	},
	ready: function () {
		console.warn( 'SREADDYYYY' )

		var arr = [
			'register',
			'about',
			'login'
		]

		// setTimeout( function () {
		// 	_$router.go( {
		// 		name: 'public.' + arr[ _.random( 0, 2 ) ]
		// 	} )
		// }, 2000 )
	}
} )



_$router = new VueRouter( {
	// abstract: false,
	// hashbang: false,
	// root: '/',
	// history: true
} )

_$router.beforeEach( function ( trans ) {

	if ( _.isEmpty( trans.from ) ) { // during deviceready/first load it transes
		trans.next()
		return
	}

	if ( !window.plugins ) {
		trans.next()
		return
	}

	window.plugins.nativepagetransitions.slide( {
		direction: 'left'
	}, function () {
		trans.next()
	} )

} )

_$router.afterEach( function ( trans ) {

	// console.log( '_$router.afterEach > trans >', trans )

	Lockr.set( 'location.hash', location.hash )

} )





_$router.map( {

	'/public': {
		component: require( './routes/public/tabs/tabs.js' ),
		subRoutes: {
			'/login': {
				component: require( './routes/public/login/login.js' ),
				name: 'public.login'
			},
			'/about': {
				component: require( './routes/public/about/about.js' ),
				name: 'public.about'
			},
			'/register': {
				component: require( './routes/public/register/register.js' ),
				name: 'public.register'
			}
		}
	}

} )

_$router.redirect( {
	'*': '/public/home'
} )









var dbReady = false
var deviceReady = false

var start = function () {
	console.warn( 'START' )

	if ( window.cordova ) {
		window.plugins.nativepagetransitions.globalOptions.duration = 250
		window.plugins.nativepagetransitions.globalOptions.iosdelay = -1
		window.plugins.nativepagetransitions.globalOptions.androiddelay = -1
		window.plugins.nativepagetransitions.globalOptions.winphonedelay = -1
		window.plugins.nativepagetransitions.globalOptions.slowdownfactor = 3

		if ( device.platform == "iOS" ) {
			var el = document.getElementById( 'app' )
			el.style.top = '20px'
		}
	}

	_$router.start( _$App, '#app' )

}

_$utils.events.once( 'db.ready', function () {
	// console.warn( 'db.ready' )
	dbReady = true

	if ( deviceReady == false ) {
		return
	}
	start()
} )

var ready = function () {
	// console.warn( 'ready' )
	deviceReady = true

	if ( dbReady == false ) {
		return
	}
	start()
}

/*===================================
=            DEVICEREADY            =
===================================*/
document.addEventListener( "DOMContentLoaded", function () {

	_$samsara.init()

	if ( window.cordova ) {
		return
	}

	ready()

} )

document.addEventListener( "deviceready", ready )




















































//


},{"./app/db.js":5,"./app/samsara.js":10,"./app/utils.js":14,"./routes/public/about/about.js":28,"./routes/public/login/login.js":30,"./routes/public/register/register.js":32,"./routes/public/tabs/tabs.js":34,"vue":25,"vue-router":23,"vue-touch":24}],2:[function(require,module,exports){
//

var Curves = {
	linear: function ( t ) {
		return t;
	},

	easeIn: function ( t ) {
		return t * t;
	},

	easeOut: function ( t ) {
		return t * ( 2 - t );
	},

	easeInOut: function ( t ) {
		if ( t <= 0.5 ) return 2 * t * t;
		else return -2 * t * t + 4 * t - 1;
	},

	easeOutBounce: function ( t ) {
		return t * ( 3 - 2 * t );
	},

	spring: function ( t ) {
		return ( 1 - t ) * Math.sin( 6 * Math.PI * t ) + t;
	},

	inQuad: function ( t ) {
		return t * t;
	},

	outQuad: function ( t ) {
		return -( t -= 1 ) * t + 1;
	},

	inOutQuad: function ( t ) {
		if ( ( t /= .5 ) < 1 ) return .5 * t * t;
		return -.5 * ( ( --t ) * ( t - 2 ) - 1 );
	},

	inCubic: function ( t ) {
		return t * t * t;
	},

	outCubic: function ( t ) {
		return ( ( --t ) * t * t + 1 );
	},

	inOutCubic: function ( t ) {
		if ( ( t /= .5 ) < 1 ) return .5 * t * t * t;
		return .5 * ( ( t -= 2 ) * t * t + 2 );
	},

	inQuart: function ( t ) {
		return t * t * t * t;
	},

	outQuart: function ( t ) {
		return -( ( --t ) * t * t * t - 1 );
	},

	inOutQuart: function ( t ) {
		if ( ( t /= .5 ) < 1 ) return .5 * t * t * t * t;
		return -.5 * ( ( t -= 2 ) * t * t * t - 2 );
	},

	inQuint: function ( t ) {
		return t * t * t * t * t;
	},

	outQuint: function ( t ) {
		return ( ( --t ) * t * t * t * t + 1 );
	},

	inOutQuint: function ( t ) {
		if ( ( t /= .5 ) < 1 ) return .5 * t * t * t * t * t;
		return .5 * ( ( t -= 2 ) * t * t * t * t + 2 );
	},

	inSine: function ( t ) {
		return -1.0 * Math.cos( t * ( Math.PI / 2 ) ) + 1.0;
	},

	outSine: function ( t ) {
		return Math.sin( t * ( Math.PI / 2 ) );
	},

	inOutSine: function ( t ) {
		return -.5 * ( Math.cos( Math.PI * t ) - 1 );
	},

	inExpo: function ( t ) {
		return ( t === 0 ) ? 0.0 : Math.pow( 2, 10 * ( t - 1 ) );
	},

	outExpo: function ( t ) {
		return ( t === 1.0 ) ? 1.0 : ( -Math.pow( 2, -10 * t ) + 1 );
	},

	inOutExpo: function ( t ) {
		if ( t === 0 ) return 0.0;
		if ( t === 1.0 ) return 1.0;
		if ( ( t /= .5 ) < 1 ) return .5 * Math.pow( 2, 10 * ( t - 1 ) );
		return .5 * ( -Math.pow( 2, -10 * --t ) + 2 );
	},

	inCirc: function ( t ) {
		return -( Math.sqrt( 1 - t * t ) - 1 );
	},

	outCirc: function ( t ) {
		return Math.sqrt( 1 - ( --t ) * t );
	},

	inOutCirc: function ( t ) {
		if ( ( t /= .5 ) < 1 ) return -.5 * ( Math.sqrt( 1 - t * t ) - 1 );
		return .5 * ( Math.sqrt( 1 - ( t -= 2 ) * t ) + 1 );
	},

	inElastic: function ( t ) {
		var s = 1.70158;
		var p = 0;
		var a = 1.0;
		if ( t === 0 ) return 0.0;
		if ( t === 1 ) return 1.0;
		if ( !p ) p = .3;
		s = p / ( 2 * Math.PI ) * Math.asin( 1.0 / a );
		return -( a * Math.pow( 2, 10 * ( t -= 1 ) ) * Math.sin( ( t - s ) * ( 2 * Math.PI ) / p ) );
	},

	outElastic: function ( t ) {
		var s = 1.70158;
		var p = 0;
		var a = 1.0;
		if ( t === 0 ) return 0.0;
		if ( t === 1 ) return 1.0;
		if ( !p ) p = .3;
		s = p / ( 2 * Math.PI ) * Math.asin( 1.0 / a );
		return a * Math.pow( 2, -10 * t ) * Math.sin( ( t - s ) * ( 2 * Math.PI ) / p ) + 1.0;
	},

	inOutElastic: function ( t ) {
		var s = 1.70158;
		var p = 0;
		var a = 1.0;
		if ( t === 0 ) return 0.0;
		if ( ( t /= .5 ) === 2 ) return 1.0;
		if ( !p ) p = ( .3 * 1.5 );
		s = p / ( 2 * Math.PI ) * Math.asin( 1.0 / a );
		if ( t < 1 ) return -.5 * ( a * Math.pow( 2, 10 * ( t -= 1 ) ) * Math.sin( ( t - s ) * ( 2 * Math.PI ) / p ) );
		return a * Math.pow( 2, -10 * ( t -= 1 ) ) * Math.sin( ( t - s ) * ( 2 * Math.PI ) / p ) * .5 + 1.0;
	},

	inBack: function ( t, s ) {
		if ( s === undefined ) s = 1.70158;
		return t * t * ( ( s + 1 ) * t - s );
	},

	outBack: function ( t, s ) {
		if ( s === undefined ) s = 1.70158;
		return ( ( --t ) * t * ( ( s + 1 ) * t + s ) + 1 );
	},

	inOutBack: function ( t, s ) {
		if ( s === undefined ) s = 1.70158;
		if ( ( t /= .5 ) < 1 ) return .5 * ( t * t * ( ( ( s *= ( 1.525 ) ) + 1 ) * t - s ) );
		return .5 * ( ( t -= 2 ) * t * ( ( ( s *= ( 1.525 ) ) + 1 ) * t + s ) + 2 );
	},

	inBounce: function ( t ) {
		return 1.0 - Curves.outBounce( 1.0 - t );
	},

	outBounce: function ( t ) {
		if ( t < ( 1 / 2.75 ) ) {
			return ( 7.5625 * t * t );
		} else if ( t < ( 2 / 2.75 ) ) {
			return ( 7.5625 * ( t -= ( 1.5 / 2.75 ) ) * t + .75 );
		} else if ( t < ( 2.5 / 2.75 ) ) {
			return ( 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + .9375 );
		} else {
			return ( 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + .984375 );
		}
	},

	inOutBounce: function ( t ) {
		if ( t < .5 ) return Curves.inBounce( t * 2 ) * .5;
		return Curves.outBounce( t * 2 - 1.0 ) * .5 + .5;
	},

	flat: function () {
		return 0;
	}
};

module.exports = Curves;


},{}],3:[function(require,module,exports){
//

var _$utils = require( './utils.js' )



var version = 1
var name = 'convoy.db_1'
var tables = [ {
	name: 'contacts',
	schema: 'id, uname'
}, {
	name: 'boundaries',
	schema: 'id, type'
}, {
	name: 'activities',
	schema: 'uuid, type, stamp, xid'
}, {
	name: 'geo',
	schema: 'uuid, stamp, xid'
} ]



var stores = {}
var i, len = tables.length
for ( i = 0; i < len; i++ ) {
	stores[ tables[ i ].name ] = tables[ i ].schema
	tables[ i ].indices = tables[ i ].schema.split( ', ' )
}

var dexie = new Dexie( name )
dexie.version( version ).stores( stores )
	// dexie.open()

dexie._version = version
dexie._name = name
dexie._tables = tables

var that = {
	dexie: dexie
}

Promise.resolve().bind( that ).then( function () {
	return this.dexie.open()
} ).catch( function ( err ) {
	console.warn( '_$db.init > FIRST catch >' )
	console.error( err )
	console.error( err.stack )
	navigator.notification.alert( 'DATABASE NOT SUPPORTED ON DEVICE!', null, 'FATAL ERROR!!!', ':(' )
} ).then( function () {
	return _$utils.events.emit( 'db.opened' )
} ).catch( function ( err ) {
	console.warn( '_$db.init > SECOND catch >' )
	console.error( err )
	console.error( err.stack )
} )



module.exports = dexie
























































//


},{"./utils.js":14}],4:[function(require,module,exports){
//

var Loki = require( 'lokijs' )
var dexie = require( './db-dexie.js' )
var _$utils = require( './utils.js' )


/*===========================
=            _$DB           =
===========================*/

module.exports = DB

function DB( opts ) {

	// {
	// 	"name": "geo",
	// 	"schema": "uuid, stamp, xid",
	// 	"indices": [
	// 		"uuid",
	// 		"stamp",
	// 		"xid"
	// 	]
	// }

	this.opts = opts

	this.loki = new Loki.Collection( this.opts.name, {
		indices: this.opts.indices,
		unique: this.opts.indices[ 0 ]
	} )

	// var xid = Lockr.get( 'user.xid' )
	// if ( _.isUndefined( xid ) ) {
	// 	return
	// }

	var that = {
		opts: this.opts,
		loki: this.loki
	}

	if ( this.opts.name == 'geo' ) {
		console.log( 'this.loki.data >', this.loki.data )
		
		return
	}

	Promise.resolve().bind( that ).then( function () {

		if ( this.opts.name == 'activities' ) {
			return dexie[ this.opts.name ].orderBy( 'stamp' ).reverse().limit( 50 ).toArray()
		}

		return dexie[ this.opts.name ].toArray()

	} ).then( function ( docs ) {

		if ( _.isEmpty( docs ) ) { // dont load any geo positions into memory
			return null
		}

		var i, len = docs.length
		for ( i = 0; i < len; i++ ) {
			this.loki.insert( docs[ i ] )
		}

		console.log( 'this.loki.data >', this.loki.data )

	} ).catch( function ( err ) {
		console.error( err )
		console.error( err.stack )
	} )


}

DB.prototype.initGeo = function () {
	console.warn( 'INITGEO >' )





}


DB.prototype.insert = function ( doc ) {
	console.log( 'INSERT > doc >', doc )
}





















































//


},{"./db-dexie.js":3,"./utils.js":14,"lokijs":19}],5:[function(require,module,exports){
//

var DB = require( './db-object.js' )
var dexie = require( './db-dexie.js' )
var _$utils = require( './utils.js' )



_$utils.events.once( 'db.opened', function () {
	console.info( 'db.opened' )

	var tables = dexie._tables
	var i, len = tables.length
	for ( i = 0; i < len; i++ ) {
		this[ tables[ i ].name ] = new DB( tables[ i ] ).loki

		_$utils.events.emit( 'db.ready' )
	}

}.bind( this ) )




this.putitlogin = function ( response ) { // DEV for login
	console.log( 'putitlogin > response >', response )
	
	
	
}

this.putitsocket = function ( response ) {
	console.log( 'putitsocket > response >', response )

	// var geos = response.geos
	// var i, len = geos.length
	// for ( i = 0; i < len; i++ ) {
	// 	var doc = JSON.parse( geos[ i ].doc )
	// 	doc.xid = geos[ i ].xid
	// 	doc.stamp = geos[ i ].stamp
	// 	doc.uuid = doc.xid + doc.stamp
	// 	console.log( 'doc >', JSON.stringify( doc, true, 4 ) )
	// 	dexie.geo.add( doc )
	// }
	
	// var actives = response.actives
	// var i, len = actives.length
	// for ( i = 0; i < len; i++ ) {
	// 	var doc = JSON.parse( actives[ i ] )
	// 	doc.uuid = doc.xid + doc.stamp
	// 	console.log( 'doc >', JSON.stringify( doc, true, 4 ) )
	// 	dexie.activities.add( doc )
	// }

}



































if ( ENV_DEVELOPMENT == true ) {
	window.db = this
}
module.exports = this








//


},{"./db-dexie.js":3,"./db-object.js":4,"./utils.js":14}],6:[function(require,module,exports){
//

var moment = require( 'moment' )
var _$utils = require( './utils.js' )

/*==============================
=            _$HTTP            =
==============================*/
var _$http = {}
var self = {}





self.headers = function () {

	var heads = {}

	heads[ 'x-bytes' ] = forge.util.bytesToHex( forge.random.getBytesSync( 8 ) )

	// if ( _$scope.data.user.preKey ) {
	// 	heads[ 'x-pre-key' ] = _$scope.data.user.preKey + "." + _.now()
	// }

	// if ( _$scope.data.user.token && _$scope.data.user.xid ) {
	// 	heads[ 'x-id' ] = _$scope.data.user.xid
	// 	heads[ 'x-tok' ] = _$scope.data.user.token + "." + _.now()
	// }

	return heads
}



_$http.post = function ( url, data, callback ) {
	var sendi = {}
	_.forEach( data, function ( val, ind ) {
		sendi[ ind ] = JSON.stringify( val )
	} )
	window.cordovaHTTP.post( "http://192.168.1.125:1337/api" + url, sendi, self.headers(), function ( res ) {

		if ( res.status == 200 && res.data == "" ) {
			console.error( 'HTTP POST NULL' )
			return callback( null, null )
		}

		var data = {}
		try {
			data = JSON.parse( res.data )
		} catch ( err ) {
			console.error( "JSON PARSING ERROR" )
			return callback( err )
		}

		if ( data.err == true ) {
			if ( data.msg ) {
				window.plugins.toast.hide()
				window.plugins.toast.showShortCenter( data.msg )
			}
			return callback( data )
		} else {
			var stringified = JSON.stringify( data, true, 4 )
			var filter = [
				'/socket/update',
				'/public/login'
			]

			if ( _.includes( filter, url ) && stringified.length > 256 ) {
				stringified = stringified.substring( 0, 256 )
				console.log( '%c_$http.POST > ' + url + ' >', "color: blue; font-size: 9pt; font-weight: bold;", '\n\n' + stringified + '\n\n' )
				console.info( '%c< TRUNCATED', "color: orange; font-size: 9pt; font-weight: bold;" )
			} else {
				console.log( '%c_$http.POST > ' + url + ' >', "color: blue; font-size: 9pt; font-weight: bold;", '\n\n' + stringified + '\n\n' )
			}

			return callback( null, data )
		}

		// try {
		// 	var data = JSON.parse( res.data )
		// 	if ( data.err == true && data.msg ) {
		// 		window.plugins.toast.showLongCenter( data.msg )
		// 	}
		// 	return callback( null, data )
		// } catch ( err ) {
		// 	console.error( "JSON PARSING ERROR" )
		// 	return callback( err )
		// }
	}, function ( rej ) {
		console.error( 'HTTP POST REJECT > ', rej )

		if ( rej.status == 418 && ENV_PRODUCTION ) {
			window.plugins.toast.showLongCenter( 'New session detected.\nLogin credentials required!' )
			_$router.go( {
				name: 'public.login',
				query: {
					direction: 'up'
				}
			} )
		}

		return callback( rej )
	} )
}









document.addEventListener( 'deviceready', function () {

	// _$scope.data.user.uuid = forge.md.sha1.create().update( device.uuid ).digest().toHex()
	self.uuid = device.uuid

	window.cordovaHTTP.enableSSLPinning( false, function () {
		// console.log( 'success!' );
	}, function () {
		console.log( 'error :(' );
	} )

	window.cordovaHTTP.acceptAllCerts( true, function () {
		// console.log( 'success!' );
	}, function () {
		console.log( 'error :(' );
	} )

	window.cordovaHTTP.setHeader( "x-uuid", self.uuid, function ( msg ) {
		// console.log( 'msg >', msg )
	}, function ( msg ) {
		console.warn( msg )
	} )

	window.cordovaHTTP.setHeader( "Accepts", "application/json", function ( msg ) {
		// console.log( 'msg >', msg )
	}, function ( msg ) {
		console.warn( msg )
	} )

} )






if ( ENV_PRODUCTION ) {

	self.sendErrors = _.debounce( function () {
		// console.log( 'self.sendErrors > C_ERRORS >', JSON.stringify( C_ERRORS, true, 4 ) )

		var sendiErrors = _.cloneDeep( C_ERRORS )
		C_ERRORS = {}

		_$http.post( '/public/error', {
			errors: sendiErrors
		}, function ( err, response ) {} )

	}, 1000, {
		maxWait: 3000
	} )

	window.onerror = function ( msg, url, line, column, err ) {

		var deviceType = "N/A"
		var deviceModel = "N/A"
		var deviceVersion = "N/A"
		if ( device ) {
			if ( device.platform ) {
				deviceType = device.platform
			}
			if ( device.platform ) {
				deviceModel = device.model
			}
			if ( device.platform ) {
				deviceVersion = device.version
			}
		}

		var xid = Lockr.get( 'user.xid' ) || "N/A"
		var dname = Lockr.get( 'user.dname' ) || "N/A"
		var stamp = _.now()
		var trace = url + ":" + line
		var hash = forge.md.sha1.create().update( msg + trace ).digest().toHex()

		C_ERRORS[ hash ] = {
			message: msg,
			trace: trace,
			err: err,
			stamp: stamp,
			time: moment( stamp ).format( 'ddd, MMM D, hh:mm:ss A' ),
			appVersion: ENV_VERSION,
			deviceType: deviceType,
			deviceModel: deviceModel,
			deviceVersion: deviceVersion,
			xid: xid,
			dname: dname
		}

		self.sendErrors()

		// console.error( 'Error: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber + ' Column: ' + column + ' StackTrace: ' + errorObj )
	}

}















































module.exports = _$http

//


},{"./utils.js":14,"moment":20}],7:[function(require,module,exports){
//

var _$utils = require( './utils.js' )
var Curves = require( './Curves.js' )
var Samsara = require( 'samsarajs' )
var Surface = Samsara.DOM.Surface
var ContainerSurface = Samsara.DOM.ContainerSurface
var Transform = Samsara.Core.Transform
var LayoutNode = Samsara.Core.LayoutNode
var View = Samsara.Core.View
var MouseInput = Samsara.Inputs.MouseInput
var TouchInput = Samsara.Inputs.TouchInput
var SequentialLayout = Samsara.Layouts.SequentialLayout
var Transitionable = Samsara.Core.Transitionable
var Accumulator = Samsara.Streams.Accumulator
var Timer = Samsara.Core.Timer



module.exports = View.extend( {

	defaults: {
		width: 100,
		height: 80
	},

	initialize: function ( opts ) {

		this.setSize( [ opts.width, opts.height ] )

		var temp = opts.theTemp

		var content = '<div class="list tabs side-tab tabs-icon-top"><li class="item tab-item"><i class="icon ' + temp.icon + '"></i>' + temp.text + '</li></div>'
		if ( temp.activeState == "help" ) {
			content = '<div class="list tabs side-tab tabs-icon-top help-me"><li class="item tab-item"><i class="icon ' + temp.icon + '"></i>' + temp.text + '</li></div>'
		}

		this.surf = new Surface( {
			content: content,
			size: [ opts.width, opts.height ]
		} )

		this.surf.scales = new Transitionable( 1 )
		this.scalesTrans = this.surf.scales.map( function ( value ) {
			return Transform.scale( [ value, 1 ] )
		} )

		this.surf.theTemp = temp
		this.surf.temp = opts.temp

		this.surf.on( 'touchstart', this.hrefPrep )

		this.add( {
			transform: this.scalesTrans
		} ).add( this.surf )

	},


	hrefPrep: function () {
		// console.log( 'this >', this )

		// if ( _$router._currentRoute.name == this.theTemp.state ) {
		// 	_$utils.events.emit( 'samsara.fixMenus' )
		// 	return
		// }

		// var curName = _$router._currentRoute.name.split( '.' )[ 0 ]
		// if ( curName == 'public' ) {
		// 	_$utils.events.emit( 'samsara.fixMenus' )
		// 	return
		// }

		// if ( this.theTemp.activeState == 'help' ) {
		// 	_$router.app.openSOS()
		// 	return
		// }

		// var iFrom = _.findIndex( this.temp, function ( v ) {
		// 	return v.state == curName
		// } )
		// console.log( 'iFrom >', iFrom )

		// var direct = 'left'
		// if ( iFrom > this.theTemp.index ) {
		// 	direct = 'down'
		// } else if ( iFrom < this.theTemp.index ) {
		// 	direct = 'up'
		// }

		this.scales.set( 1.25 )

		// _$router.go( {
		// 	name: this.theTemp.state,
		// 	query: {
		// 		direction: direct
		// 	}
		// } )

		Timer.after( function () {
			this.scales.set( 1 )
		}.bind( this ), 5 )

	}








} )






























































//


},{"./Curves.js":2,"./utils.js":14,"samsarajs":22}],8:[function(require,module,exports){
//

var _$utils = require( './utils.js' )
var Curves = require( './Curves.js' )
var Samsara = require( 'samsarajs' )
var Surface = Samsara.DOM.Surface
var ContainerSurface = Samsara.DOM.ContainerSurface
var Transform = Samsara.Core.Transform
var LayoutNode = Samsara.Core.LayoutNode
var View = Samsara.Core.View
var MouseInput = Samsara.Inputs.MouseInput
var TouchInput = Samsara.Inputs.TouchInput
var SequentialLayout = Samsara.Layouts.SequentialLayout
var Transitionable = Samsara.Core.Transitionable
var Accumulator = Samsara.Streams.Accumulator
var mMenu_SURF = require( './mmenu-surf.js' )



module.exports = View.extend( {

	initialize: function () {
		this.wWidth = window.innerWidth
		this.wHeight = window.innerHeight

		this.index = 401
		this.width = 100
		this.height = 80
		this.shown = false
		this.showing = false
		this.activeClass = ''

		this.temp = [ {
			text: "S.O.S",
			icon: "ion-help-buoy",
			activeState: 'help',
			index: 0
		}, {
			text: "Map",
			icon: "ion-map",
			state: "map.index",
			activeState: 'map',
			index: 1
		}, {
			text: "My Convoy",
			icon: "ion-person-stalker",
			state: "contacts.index",
			activeState: 'contacts',
			index: 2
		}, {
			text: "Activities",
			icon: "ion-ios-pulse-strong",
			state: "activity.index",
			activeState: 'activity',
			index: 3
		}, {
			text: "Settings",
			icon: "ion-settings",
			state: "settings.index",
			activeState: 'settings',
			index: 4
		} ]

		this.surfs = []
		this.layout = new SequentialLayout( {
			direction: 1
		} )

		this.x = new Transitionable( -100 )
		this.opa = new Transitionable( 0 )

		this.xTrans = this.x.map( function ( v ) {
			var val = v
			return Transform.translate( [ val, -449 ] )
		} )

		var i, len = this.temp.length
		for ( i = 0; i < len; i++ ) {
			this.surfs[ i ] = new mMenu_SURF( {
				theTemp: this.temp[ i ],
				temp: this.temp
			} )
		}

		this.layout.addItems( this.surfs )







		this.add( {
			align: [ 0, 1 ],
			transform: this.xTrans,
			opacity: this.opa
		} ).add( this.layout )





	},



	toggle: function () {
		if ( this.showing == true ) {
			return
		}

		if ( this.shown == true ) {
			this.close()
		} else {
			this.open()
		}
	},



	open: function () {
		if ( this.shown == true ) {
			return
		}

		_$utils.events.emit( 'samsara.sMenu.close' )
		this.showing = true

		this.opa.set( 1, {
			duration: 200
		} )
		this.x.set( 0, {
			duration: 200,
			curve: Curves.outBack
		}, function () {
			this.shown = true
			this.showing = false
		}.bind( this ) )

	},



	close: function ( now ) {
		if ( this.shown == false ) {
			return
		}

		this.showing = true

		if ( now == true ) {
			this.opa.set( 0 )
			this.opa.reset( 0 )
			this.x.set( -100 )
			this.x.reset( -100 )
			this.showing = false
			this.shown = false
			return
		}

		this.opa.set( 0, {
			duration: 250,
			curve: Curves.easeIn
		} )
		this.x.set( -100, {
			duration: 250,
			curve: Curves.easeIn
		}, function () {
			this.shown = false
			this.showing = false
		}.bind( this ) )
	}








} )






























































//


},{"./Curves.js":2,"./mmenu-surf.js":7,"./utils.js":14,"samsarajs":22}],9:[function(require,module,exports){
//

var Curves = require( './Curves.js' )
var Samsara = require( 'samsarajs' )
var Surface = Samsara.DOM.Surface
var Transform = Samsara.Core.Transform
var MouseInput = Samsara.Inputs.MouseInput
var TouchInput = Samsara.Inputs.TouchInput
var SequentialLayout = Samsara.Layouts.SequentialLayout
var Transitionable = Samsara.Core.Transitionable
var Accumulator = Samsara.Streams.Accumulator



function Prog( context ) {
	this.wWidth = window.innerWidth
	this.halfwWidth = this.wWidth * 0.5
	this.wHeight = window.innerHeight
	this.halfwHeight = this.wHeight * 0.5

	this.index = 501
	this.posX = 0
	this.active = false
	this.err = false
	this.width = this.wWidth * 0.25
	this.height = 5



	this.x = new Transitionable( this.posX )
	this.opa = new Transitionable( 0 )

	this.xTrans = this.x.map( function ( v ) {
		return Transform.translateX( v )
	} )

	this.surf = new Surface( {
		size: [ this.width, this.height ],
		origin: [ 0.5, 0 ],
		opacity: this.opa,
		attributes: {
			id: 'prog_surf'
		},
		properties: {
			background: '#11C1F3'
		}
	} )

	this.swap = function () {
		if ( this.active == false || this.err == true ) {
			return
		}

		this.posX = ( this.posX ) ? 0 : this.wWidth
		this.x.set( this.posX, {
			duration: 1000,
			curve: 'easeOutBounce'
		}, function () {
			if ( this.active == false ) {
				this.x.reset( 0 )
				this.x.set( 0 )
				return
			}

			this.swap()
		}.bind( this ) )
	}

	this.done = function () {
		if ( this.err == true ) {
			return
		}

		this.active = false
		this.posX = 0

		this.opa.reset( 0 )

		this.surf.setProperties( {
			background: '#11C1F3'
		} )

	}

	this.start = function () {
		if ( this.active == true || this.err == true ) {
			return
		}

		this.active = true
		this.posX = 0

		this.opa.set( 1 )

		this.x.reset( 0 )

		this.swap()
	}

	this.stop = function () {
		if ( this.active == false || this.err == true ) {
			return
		}

		this.surf.setProperties( {
			background: '#33CD5F'
		} )

		this.opa.set( 0, {
			duration: 500
		}, function () {
			if ( this.active == false ) {
				return
			}
			this.done()
		}.bind( this ) )
	}

	this.error = function () {
		if ( this.err == true ) {
			return
		}
		
		this.err = true
		this.active = true
		this.surf.setProperties( {
			background: '#EF473A'
		} )

		this.opa.reset( 1 )
		this.opa.set( 1 )
		this.surf.setSize( [ this.wWidth, this.height ] )

		this.x.reset( this.wWidth * 1.5 )

		this.x.set( this.wWidth * 0.5, {
			duration: 1000,
			curve: Curves.outBounce
		}, function () {
			this.opa.set( 0, {
				duration: 1000
			}, function () {
				this.surf.setSize( [ this.width, this.height ] )
				this.err = false
				this.done()
			}.bind( this ) )
		}.bind( this ) )

	}

	context.add( {
		transform: this.xTrans
	} ).add( this.surf )

}





module.exports = Prog

//


},{"./Curves.js":2,"samsarajs":22}],10:[function(require,module,exports){
//

var _$utils = require( './utils.js' )
var Samsara = require( 'samsarajs' )
var Context = Samsara.DOM.Context

var tuts = require( './tuts.js' )
var prog = require( './prog.js' )
var _mMenu = require( './mmenu.js' )
var sMenu = require( './smenu.js' )
var sBar = require( './sbar.js' )



var _$samsara = {}
_$samsara.tuts = {}
_$samsara.prog = {}
_$samsara.mMenu = {}
_$samsara.sMenu = {}
_$samsara.sBar = {}



_$samsara.init = function () {

	var context = new Context()
	context.setPerspective( 1000 )

	// _$samsara.tuts = new tuts( context )
	// _$samsara.prog = new prog( context )

	var mMenu = new _mMenu()
	context.add( mMenu )
	
	// console.log( 'mMenu >', mMenu )
	
	_$samsara.mMenu.toggle = mMenu.toggle
	_$samsara.mMenu.open = mMenu.open
	_$samsara.mMenu.close = mMenu.close
	
	

	// _$samsara.sMenu = new sMenu( context )
	// _$samsara.sBar = new sBar( context )

	context.mount( document.body )

	/*=====  MAIN MENU  ======*/
	// _$utils.events.on( 'samsara.mMenu.open', _$samsara.mMenu.open )
	// _$utils.events.on( 'samsara.mMenu.close', _$samsara.mMenu.close )
	// _$utils.events.on( 'sos-bar-header', _$samsara.mMenu.sosBarHeader )
	// _$utils.events.on( 'samsara.activities', _$samsara.mMenu.activities )

	/*=====  SIDE MENU  ======*/
	// _$utils.events.on( 'samsara.sMenu.open', _$samsara.sMenu.open )
	// _$utils.events.on( 'samsara.sMenu.close', _$samsara.sMenu.close )

	/*=====  SWIPE BAR  ======*/
	// _$utils.events.on( 'samsara.sBar.centerIt', _$samsara.sBar.centerIt )

	/*=====  OTHER  ======*/
	// _$utils.events.on( 'samsara.fixMenus', _$samsara.fixMenus )

}

// document.addEventListener( "DOMContentLoaded", _$samsara.init )

_$samsara.setGpuSettings = function ( bool, platform ) {
	console.warn( '_$samsara.setGpuSettings' )
}


_$samsara.fixMenus = function ( now ) {
	// _$samsara.mMenu.close( now )
	// _$samsara.sMenu.close( now )
	// _$samsara.tuts.close( now )
	// 	// _$samsara.quickie.close( now )
	// _$samsara.sBar.centerIt( now )
}







































module.exports = _$samsara



//


},{"./mmenu.js":8,"./prog.js":9,"./sbar.js":11,"./smenu.js":12,"./tuts.js":13,"./utils.js":14,"samsarajs":22}],11:[function(require,module,exports){
//

var _$utils = require( './utils.js' )
var Curves = require( './Curves.js' )
var Samsara = require( 'samsarajs' )
var Surface = Samsara.DOM.Surface
var Transform = Samsara.Core.Transform
var Timer = Samsara.Core.Timer
var MouseInput = Samsara.Inputs.MouseInput
var TouchInput = Samsara.Inputs.TouchInput
var ContainerSurface = Samsara.DOM.ContainerSurface
var SequentialLayout = Samsara.Layouts.SequentialLayout
var Transitionable = Samsara.Core.Transitionable
var Accumulator = Samsara.Streams.Accumulator



function sBar( context ) {
	this.wWidth = window.innerWidth
	this.halfwWidth = this.wWidth * 0.5
	this.wHeight = window.innerHeight
	this.halfwHeight = this.wHeight * 0.5

	this.index = 451
	this.xDelta = this.wWidth * 0.25
	this.height = 49
	this.swipeYThreshold = 40
	this.clickThreshold = 10

	this.clamp = function ( x, a, b ) {
		return Math.min( Math.max( x, a ), b )
	}

	this.temp = [ {}, {}, {}, {}, {}, {}, {}, {} ]
	this.surfs = []
	this.nodes = []
	this.scales = []
	this.scalesTrans = []
	this.jumps = []
	this.jumpsTrans = []

	this.layout = new SequentialLayout( {
		direction: 0
	} )

	this.input = new TouchInput()

	this.x = new Transitionable( 0 )
	this.transform = this.x.map( function ( v ) {
		// console.log( 'v >', v )
		return Transform.translateX( v + ( this.xDelta * 0.5 ) )
	}.bind( this ) )

	var i, len = this.temp.length
	for ( i = 0; i < len; i++ ) {
		this.nodes[ i ] = new ContainerSurface( {
			size: [ this.xDelta, this.height ]
		} )

		this.surfs[ i ] = new Surface( {
			content: '',
			size: [ this.xDelta, this.height ],
			origin: [ 0.5, 1 ]
		} )

		this.temp[ i ].click = null
		this.temp[ i ].clickHold = null
		this.temp[ i ].href = null
		this.temp[ i ].hidden = false

		this.input.subscribe( this.surfs[ i ] )

		this.scales[ i ] = new Transitionable( 1 )
		this.scalesTrans[ i ] = this.scales[ i ].map( function ( value ) {
			return Transform.scale( [ value, value ] )
		} )

		this.jumps[ i ] = new Transitionable( 0 )
		this.jumpsTrans[ i ] = this.jumps[ i ].map( function ( value ) {
			return Transform.translateY( value )
		} )

		this.nodes[ i ].add( {
			transform: this.scalesTrans[ i ]
		} ).add( {
			transform: this.jumpsTrans[ i ]
		} ).add( this.surfs[ i ] )

	}

	this.layout.addItems( this.nodes )

	this.clickHoldFn = function ( posX ) {
		if ( this.absAccu > this.clickThreshold || this.didClick == true ) {
			return
		}

		var i = this.getSurfByPos( posX )

		if ( _.isFunction( this.temp[ i ].clickHold ) ) {

			this.didClick = true
			this.stopDragging = true

			navigator.vibrate( 50 )

			this.temp[ i ].clickHold()
			this.didClick = true

			this.scales[ i ].reset( 1.5 )
			this.scales[ i ].set( 1, {
				duration: 1000,
				curve: Curves.outBounce
			} )

			this.jumps[ i ].reset( -this.height )
			this.jumps[ i ].set( 0, {
				duration: 1000,
				curve: Curves.outBounce
			}, function () {
				this.centerIt()
			}.bind( this ) )

			// this.temp[ i ].scaleComp.set( 1.5, 1.5, 1 )
			// this.temp[ i ].scaleComp.set( 1, 1, 1, {
			// 	duration: 1000,
			// 	curve: 'outBounce'
			// } )

			// this.temp[ i ].posComp.setY( -73.5 )
			// this.temp[ i ].posComp.setY( 0, {
			// 	duration: 1000,
			// 	curve: 'outBounce'
			// }, function () {
			// 	this.centerIt()
			// }.bind( this ) )

		}

	}

	this.input.on( 'start', function ( pay ) {
		// console.warn( 'START > pay >', JSON.stringify( pay, true, 4 ) )

		this.x.reset()

		this.down = 0
		this.absAccu = 0
		this.accu = 0
		this.didClick = false
		this.stopDragging = false

		var i = pay.clientX
		this.timeout = Timer.after( function () {
			this.clickHoldFn( i )
		}.bind( this ), 25 )

		_$utils.events.emit( 'samsara.mMenu.close' )
		_$utils.events.emit( 'samsara.sMenu.close' )

	}.bind( this ) )

	this.input.on( 'update', function ( pay ) {
		// console.log( 'UPDATE > pay >', JSON.stringify( pay, true, 4 ) )

		if ( this.stopDragging == true ) {
			return
		}

		var delta = pay.delta
		var velocity = pay.velocity
		var value = pay.value

		if ( this.down < this.swipeYThreshold ) {
			this.down = this.down + ( ( delta[ 1 ] * velocity[ 1 ] ) - ( delta[ 0 ] * velocity[ 0 ] ) )
		} else {
			_$utils.events.emit( 'samsara.mMenu.open' )
			this.stopDragging = true
			this.didClick = true
			this.centerIt()
			return
		}

		if ( this.absAccu < this.clickThreshold ) { // for getting a threshold on click events
			this.absAccu = this.absAccu + Math.abs( delta[ 0 ] ) + Math.abs( delta[ 1 ] )
		}

		var boost = this.clamp( Math.abs( velocity[ 0 ] * 1.25 ), 1, 3 )
		var accu = this.accu + ( delta[ 0 ] * boost )
		this.accu = this.clamp( accu, -this.xDelta, this.xDelta )
		this.x.set( this.accu )



		if ( Math.abs( this.accu ) >= this.xDelta ) {

			if ( this.accu > 0 ) { // test if its left or right

				if ( _.isFunction( this.temp[ 0 ].click ) ) {
					var classes = this.surfs[ 0 ].getClassList()
					if ( classes.indexOf( 'sBar-active' ) == -1 ) {
						this.surfs[ 0 ].addClass( 'sBar-active' )
					}

					this.didClick = true
					this.stopDragging = true

					if ( this.temp[ 0 ].href != true ) {
						this.temp[ 0 ].click()
						Timer.after( function () {
							this.centerIt()
						}.bind( this ), 5 )
						return
					}

					Timer.after( function () {
						this.temp[ 0 ].click()
							// Timer.after( function () {
							// 	this.centerIt( true )
							// }.bind( this ), 5 )
					}.bind( this ), 5 )
				}

			} else {

				if ( _.isFunction( this.temp[ 5 ].click ) ) {
					var classes = this.surfs[ 5 ].getClassList()
					if ( classes.indexOf( 'sBar-active' ) == -1 ) {
						this.surfs[ 5 ].addClass( 'sBar-active' )
					}

					this.didClick = true
					this.stopDragging = true

					if ( this.temp[ 5 ].href != true ) {
						this.temp[ 5 ].click()
						Timer.after( function () {
							this.centerIt()
						}.bind( this ), 5 )
						return
					}

					Timer.after( function () {
						this.temp[ 5 ].click()
							// Timer.after( function () {
							// 	this.centerIt( true )
							// }.bind( this ), 5 )
					}.bind( this ), 5 )

				}
			}

			return
		}

		if ( this.accu > 0 ) { // test if its left or right
			var classes = this.surfs[ 0 ].getClassList()
			if ( classes.indexOf( 'sBar-active' ) != -1 ) {
				this.surfs[ 0 ].removeClass( 'sBar-active' )
			}
		} else {
			var classes = this.surfs[ 5 ].getClassList()
			if ( classes.indexOf( 'sBar-active' ) != -1 ) {
				this.surfs[ 5 ].removeClass( 'sBar-active' )
			}
		}

	}.bind( this ) )

	this.input.on( 'end', function ( pay ) {
		// console.warn( 'END > pay >', JSON.stringify( pay, true, 4 ) )

		if ( this.timeout ) {
			Timer.clear( this.timeout )
			this.timeout = null
		}

		if ( this.didClick == true ) {
			return
		}

		if ( this.absAccu < this.clickThreshold ) {

			var i = this.getSurfByPos( pay.clientX )

			if ( _.isFunction( this.temp[ i ].click ) ) {

				this.didClick = true

				if ( this.temp[ i ].href == true ) {
					this.scales[ i ].set( 1.25 )

					Timer.after( function () {
						this.temp[ i ].click()
						Timer.after( function () {
							this.scales[ i ].set( 1 )
						}.bind( this ), 5 )
					}.bind( this ), 5 )
					return
				}

				this.temp[ i ].click()
				this.scales[ i ].set( 1.25, {
					duration: 100,
					curve: Curves.easeOutBounce
				}, function () {
					this.scales[ i ].set( 1, {
						duration: 100,
						curve: Curves.easeIn
					}, function () {
						this.centerIt()
					}.bind( this ) )
				}.bind( this ) )

				return
			}
		}

		this.centerIt()

	}.bind( this ) )


	this.update = function ( temp ) {

		// if ( _$router.histArr[ 1 ] ) {
		// 	var backable = _.parseBool( _$router.histArr[ 0 ].query.backable )
		// 	if ( backable == true ) {
		// 		temp[ 0 ] = {
		// 			_text: "Go Back",
		// 			_icon: "ion-arrow-left-c",
		// 			_color: 'assertive',
		// 			_href: true,
		// 			_click: function () {
		// 				_$router.goBack()
		// 			}.bind( this )
		// 		}
		// 		_$router.histArr[ 0 ].query = _.omit( _$router.histArr[ 0 ].query, 'backable' )
		// 	}
		// }

		var i, len = temp.length
		for ( i = 0; i < len; i++ ) {

			this.temp[ i ].href = null
			if ( temp[ i ]._href ) {
				this.temp[ i ].href = true
			}

			var classes = ''
			if ( i == 1 ) {
				classes = ' sBar-left-' + temp[ 0 ]._color
			}
			if ( i == 4 && temp[ 5 ]._color ) {
				classes = ' sBar-right-' + temp[ 5 ]._color
			}

			var icon = ''
			if ( temp[ i ]._icon ) {
				icon = ' ' + temp[ i ]._icon
			}

			var text = ''
			if ( temp[ i ]._text ) {
				text = temp[ i ]._text
			}

			this.surfs[ i ].setContent( '<div class="tabs tabs-icon-top' + classes + '"><a class="tab-item"><i class="icon' + icon + '"></i>' + text + '</a></div>' )

			this.temp[ i ].click = null
			if ( temp[ i ]._click ) {
				this.temp[ i ].click = temp[ i ]._click
			}

			this.temp[ i ].clickHold = null
			if ( temp[ i ]._clickHold ) {
				this.temp[ i ].clickHold = temp[ i ]._clickHold
			}

			if ( i >= 1 && i <= 4 && this.temp[ i ]._hidden == true ) {
				this.show( i )
			}

		}

		this.surfs[ 0 ].setClasses( [] )
		this.surfs[ 5 ].setClasses( [] )

		this.surfs[ 0 ].addClass( [ 'sBar-' + temp[ 0 ]._color ] )
		if ( temp[ 5 ]._color ) {
			this.surfs[ 5 ].addClass( [ 'sBar-' + temp[ 5 ]._color ] )
		}

	}



	this.centerIt = function ( now ) {
		if ( now == true ) {
			this.x.set( 0 )
			return
		}

		this.x.set( 0, {
			duration: 250,
			curve: Curves.outBack
		} )
	}

	this.show = function ( i ) {
		this.surfs[ i ].removeClass( 'sbar-hide' )
		this.temp[ i ]._hidden = false
	}

	this.hide = function ( i ) {
		this.surfs[ i ].addClass( 'sbar-hide' )
		this.temp[ i ]._hidden = true
	}

	this.getSurfByPos = function ( posX ) {
		if ( _.inRange( posX, 0, this.xDelta ) ) {
			return 1
		} else if ( _.inRange( posX, this.xDelta, this.xDelta * 2 ) ) {
			return 2
		} else if ( _.inRange( posX, this.xDelta * 2, this.xDelta * 3 ) ) {
			return 3
		} else if ( _.inRange( posX, this.xDelta * 3, this.xDelta * 4 ) ) {
			return 4
		} else {
			console.error( 'this.getSurfByPos >' )
			console.error( 'WTF NOT IN RANGE???' )
		}
	}



	context.add( {
		align: [ 0, 1 ],
		transform: Transform.translate( [ -this.xDelta, 0 ] )
	} ).add( {
		transform: this.transform
	} ).add( this.layout )

}
































module.exports = sBar

//


},{"./Curves.js":2,"./utils.js":14,"samsarajs":22}],12:[function(require,module,exports){
//

var _$utils = require( './utils.js' )
var Curves = require( './Curves.js' )
var Samsara = require( 'samsarajs' )
var Surface = Samsara.DOM.Surface
var ContainerSurface = Samsara.DOM.ContainerSurface
var Timer = Samsara.Core.Timer
var Transform = Samsara.Core.Transform
var MouseInput = Samsara.Inputs.MouseInput
var TouchInput = Samsara.Inputs.TouchInput
var SequentialLayout = Samsara.Layouts.SequentialLayout
var Transitionable = Samsara.Core.Transitionable
var Accumulator = Samsara.Streams.Accumulator



function sMenu( context ) {
	// this.wWidth = window.innerWidth
	// this.halfwWidth = this.wWidth * 0.5
	// this.wHeight = window.innerHeight
	// this.halfwHeight = this.wHeight * 0.5

	const wWidth = window.innerWidth

	this.index = 301
	this.shown = false
	this.showing = false
	this.temp = [ {}, {}, {}, {}, {}, {}, {}, {} ]

	this.width = _.mathClamp( 250, 0, wWidth * 0.8 )
	this.height = 50

	this.surfs = []
	this.nodes = []
	this.scales = []
	this.scalesTrans = []
	this.layout = new SequentialLayout( {
		direction: 1
	} )

	this.y = new Transitionable( 0 )

	this.yTrans = this.y.map( function ( v ) {
		return Transform.translate( [ wWidth * 0.5, v + 50 ] )
	}.bind( this ) )

	this.touched = function ( i ) {
		if ( !_.isFunction( this.temp[ i ].click ) ) {
			return
		}

		this.scales[ i ].reset( 1.2 )
		this.temp[ i ].click()

		this.scales[ i ].set( 1, {
			duration: 100
		}, function () {
			this.close()
		}.bind( this ) )

	}

	_.forEach( this.temp, function ( v, i ) {
		this.nodes[ i ] = new ContainerSurface( {
			size: [ this.width, this.height ],
			origin: [ 0.5, 1 ]
		} )

		this.surfs[ i ] = new Surface( {
			content: '<ul class="list"><li class="item">' + i + '</li></ul>',
			size: [ this.width, this.height ],
			origin: [ 0.5, 1 ]
		} )

		this.temp[ i ].click = null
		this.nodes[ i ].on( 'touchstart', function () {
			this.touched( i )
		}.bind( this ) )

		this.scales[ i ] = new Transitionable( 1 )
		this.scalesTrans[ i ] = this.scales[ i ].map( function ( value ) {
			return Transform.scale( [ value, value ] )
		} )

		this.nodes[ i ].add( {
			transform: this.scalesTrans[ i ]
		} ).add( this.surfs[ i ] )

	}.bind( this ) )

	this.layout.addItems( this.nodes )

	this.open = function ( temp ) {
		if ( this.shown == true ) {
			return
		}

		this.showing = true

		_$utils.events.emit( 'samsara.mMenu.close' )

		var i, len = 8
		for ( i = 0; i < len; i++ ) {
			if ( temp[ i ] ) {
				var content = '<ul class="list"><li class="item">' + temp[ i ]._text + '</li></ul>'
				if ( temp[ i ]._icon ) {
					content = '<ul class="list"><li class="item item-icon-left"><i class="icon ' + temp[ i ]._icon + '"></i> ' + temp[ i ]._text + '</li></ul>'
				}

				this.surfs[ i ].setContent( content )

				this.temp[ i ].click = null
				if ( temp[ i ]._click ) {
					this.temp[ i ].click = temp[ i ]._click
				}

			}
			//  else {
			// 	// this.surfs[ i ].setContent( '<ul class="list"><li class="item">' + i + '</li></ul>' )
			// 	this.temp[ i ].click = null
			// }
		}

		Timer.after( function () {
			this.y.set( -( 49 + ( ( temp.length ) * 50 ) ), {
				duration: 200,
				curve: Curves.outBack
			}, function () {
				this.shown = true
				this.showing = false
			}.bind( this ) )
		}.bind( this ), 2 )

	}.bind( this )

	this.close = function ( now ) {
		if ( this.shown == false ) {
			return
		}

		this.showing = true

		if ( now == true ) {
			this.y.set( 0 )
			this.y.reset( 0 )
			this.showing = false
			this.shown = false
			return
		}

		this.y.set( 0, {
			duration: 250,
			curve: Curves.easeIn
		}, function () {
			Timer.after( function () {
				var i, len = this.temp.length
				for ( i = 0; i < len; i++ ) {
					this.surfs[ i ].setContent( '' )
					this.temp[ i ].click = null
				}

			this.y.reset( 0 )
			this.shown = false
			this.showing = false

			}.bind( this ), 10 )
		}.bind( this ) )

	}.bind( this )





	context.add( {
		align: [ 0, 1 ],
		transform: this.yTrans
	} ).add( this.layout )

}





















































module.exports = sMenu

//


},{"./Curves.js":2,"./utils.js":14,"samsarajs":22}],13:[function(require,module,exports){
//

var Curves = require( './Curves.js' )
var Samsara = require( 'samsarajs' )
var Surface = Samsara.DOM.Surface
var Timer = Samsara.Core.Timer
var Transform = Samsara.Core.Transform
var MouseInput = Samsara.Inputs.MouseInput
var TouchInput = Samsara.Inputs.TouchInput
var SequentialLayout = Samsara.Layouts.SequentialLayout
var Transitionable = Samsara.Core.Transitionable
var Accumulator = Samsara.Streams.Accumulator



function Tuts( context ) {
	this.wWidth = window.innerWidth
	this.halfwWidth = this.wWidth * 0.5
	this.wHeight = window.innerHeight
	this.halfwHeight = this.wHeight * 0.5

	this.index = 601
	this.top = 0
	this.shown = false
	this.showing = false



	this.y = new Transitionable( -this.wHeight )
	this.opa = new Transitionable( 1 )
	this.scale = new Transitionable( 1 )

	this.yTrans = this.y.map( function ( v ) {
		return Transform.translate( [ this.wWidth * 0.5, v + this.top + 44 ] )
	}.bind( this ) )
	this.scaleTrans = this.scale.map( function ( v ) {
		return Transform.scale( [ v, v ] )
	} )

	this.surf = new Surface( {
		size: [ this.wWidth, this.wHeight - 44 - 49 - this.top ],
		origin: [ 0.5, 0 ],
		opacity: this.opa,
		content: '',
		classes: [ 'help-surf' ],
		properties: {
			color: 'white',
			background: "rgba(0, 0, 0, 0.8)"
		}
	} )

	this.surf.on( 'touchstart', function () {
		this.close()
	}.bind( this ) )

	this.open = function ( temp ) {
		if ( this.shown == true ) {
			return
		}

		this.showing = true
		navigator.vibrate( 50 )

		this.surf.setContent( temp )

		Timer.after( function () {
			var duration = 250
			var curve = Curves.outBack

			this.opa.set( 1, {
				duration: duration,
				curve: curve
			} )
			this.scale.set( 1, {
				duration: duration,
				curve: curve
			} )

			this.y.set( 0, {
				duration: duration,
				curve: curve
			}, function () {
				this.shown = true
				this.showing = false
			}.bind( this ) )
		}.bind( this ), 2 )

	}

	this.close = function ( now ) {
		if ( this.shown == false ) {
			return
		}

		if ( now == true ) {
			this.opa.set( 0 )
			this.scale.set( 0.5 )
			this.y.set( -this.wHeight )
			return
		}

		this.showing = true

		var duration = 500
		var curve = Curves.easeIn

		this.opa.set( 0, {
			duration: duration,
			curve: curve
		} )
		this.scale.set( 0.5, {
			duration: duration,
			curve: curve
		} )

		this.y.set( -this.wHeight, {
			duration: duration,
			curve: curve
		}, function () {
			this.shown = false
			this.showing = false
		}.bind( this ) )

	}







	context.add( {
		transform: this.yTrans
	} ).add( {
		transform: this.scaleTrans
	} ).add( this.surf )

}

















































module.exports = Tuts

//


},{"./Curves.js":2,"samsarajs":22}],14:[function(require,module,exports){
//

var events = require( 'events' )
var moment = require( 'moment' )

/*==============================
=            _$utils           =
==============================*/

module.exports = {
	events: new events.EventEmitter()
}












console.info(
	"\n\n\n\n%c/*===================================================\n" +
	"=========           " + moment( _.now() ).format( 'hh:mm:ss:SSS' ) + "           ==========\n" +
	"===================================================*/", "color: blue; font-size: 10pt; font-weight: bolder;"
)









//


},{"events":16,"moment":20}],15:[function(require,module,exports){

},{}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],17:[function(require,module,exports){
/*! Hammer.JS - v2.0.6 - 2015-12-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2015 Jorik Tangelder;
 * Licensed under the  license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean=false} [merge]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.allow = true; // used by Input.TouchMouse to disable mouse events
    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down, and mouse events are allowed (see the TouchMouse input)
        if (!this.pressed || !this.allow) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        // when we're in a touch event, so  block all upcoming mouse events
        // most mobile browser also emit mouseevents, right after touchstart
        if (isTouch) {
            this.mouse.allow = false;
        } else if (isMouse && !this.mouse.allow) {
            return;
        }

        // reset the allowMouse when we're done
        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
            this.mouse.allow = true;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.6';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    each(manager.options.cssProps, function(value, name) {
        element.style[prefixed(element.style, name)] = add ? value : '';
    });
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (typeof define === 'function' && define.amd) {
    define(function() {
        return Hammer;
    });
} else if (typeof module != 'undefined' && module.exports) {
    module.exports = Hammer;
} else {
    window[exportName] = Hammer;
}

})(window, document, 'Hammer');

},{}],18:[function(require,module,exports){
/*
  Loki IndexedDb Adapter (need to include this script to use it)

  Indexeddb is highly async, but this adapter has been made 'console-friendly' as well.
  Anywhere a callback is omitted, it should return results (if applicable) to console.

  IndexedDb storage is provided per-domain, so we implement app/key/value database to allow separate contexts
  for separate apps within a domain.

  Examples :

  // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}
  // if appContect ('finance' in this example) is omitted, 'loki' will be used
  var idbAdapter = new LokiIndexedAdapter('finance');
  var db = new loki('test', { adapter: idbAdapter });
  var coll = db.addCollection('testColl');
  coll.insert({test: 'val'});
  db.saveDatabase();  // could pass callback if needed for async complete

  // LOAD
  var db = new loki('test', { adapter: idbAdapter });
  db.loadDatabase(function(result) {
    console.log('done');
  });

  // GET DATABASE LIST
  idbAdapter.getDatabaseList(function(result) {
    // result is array of string names for that appcontext ('finance')
    result.forEach(function(str) {
      console.log(str);
    });
  });

  // DELETE DATABASE
  idbAdapter.deleteDatabase('test'); // delete 'finance'/'test' value from catalog

  // CONSOLE USAGE : if using from console for management/diagnostic, here are a few examples :
  adapter.getDatabaseList(); // with no callback passed, this method will log results to console
  adapter.saveDatabase('UserDatabase', JSON.stringify(myDb));
  adapter.loadDatabase('UserDatabase'); // will log the serialized db to console
  adapter.deleteDatabase('UserDatabase');
*/

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS-like
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.LokiIndexedAdapter = factory();
    }
}(this, function () {
  return (function() {

    /**
     * IndexedAdapter - Loki persistence adapter class for indexedDb.
     *     This class fulfills abstract adapter interface which can be applied to other storage methods
     *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.
     *
     * @param {string} appname - Application name context can be used to distinguish subdomains or just 'loki'
     */
    function IndexedAdapter(appname)
    {
      this.app = 'loki';

      if (typeof (appname) !== 'undefined')
      {
        this.app = appname;
      }

      // keep reference to catalog class for base AKV operations
      this.catalog = null;

      if (!this.checkAvailability()) {
        throw new Error('indexedDB does not seem to be supported for your environment');
      }
    }

    /**
     * checkAvailability - used to check if adapter is available
     *
     * @returns {boolean} true if indexeddb is available, false if not.
     */
    IndexedAdapter.prototype.checkAvailability = function()
    {
      if (window && window.indexedDB) return true;

      return false;
    };

    /**
     * loadDatabase() - Retrieves a serialized db string from the catalog.
     *
     * @param {string} dbname - the name of the database to retrieve.
     * @param {function} callback - callback should accept string param containing serialized db string.
     */
    IndexedAdapter.prototype.loadDatabase = function(dbname, callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.loadDatabase(dbname, callback);
        });

        return;
      }

      // lookup up db string in AKV db
      this.catalog.getAppKey(appName, dbname, function(result) {
        if (typeof (callback) === 'function') {
          if (result.id === 0) {
            callback(null);
            return;
          }
          callback(result.val);
        }
        else {
          // support console use of api
          console.log(result.val);
        }
      });
    };

    // alias
    IndexedAdapter.prototype.loadKey = IndexedAdapter.prototype.loadDatabase;

    /**
     * saveDatabase() - Saves a serialized db to the catalog.
     *
     * @param {string} dbname - the name to give the serialized database within the catalog.
     * @param {string} dbstring - the serialized db string to save.
     * @param {function} callback - (Optional) callback passed obj.success with true or false
     */
    IndexedAdapter.prototype.saveDatabase = function(dbname, dbstring, callback)
    {
      var appName = this.app;
      var adapter = this;

      function saveCallback(result) {
        if (result && result.success === true) {
          callback(null);
        }
        else {
          callback(new Error("Error saving database"));
        }
      }

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          // now that catalog has been initialized, set (add/update) the AKV entry
          cat.setAppKey(appName, dbname, dbstring, saveCallback);
        });

        return;
      }

      // set (add/update) entry to AKV database
      this.catalog.setAppKey(appName, dbname, dbstring, saveCallback);
    };

    // alias
    IndexedAdapter.prototype.saveKey = IndexedAdapter.prototype.saveDatabase;

    /**
     * deleteDatabase() - Deletes a serialized db from the catalog.
     *
     * @param {string} dbname - the name of the database to delete from the catalog.
     */
    IndexedAdapter.prototype.deleteDatabase = function(dbname)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.deleteDatabase(dbname);
        });

        return;
      }

      // catalog was already initialized, so just lookup object and delete by id
      this.catalog.getAppKey(appName, dbname, function(result) {
        var id = result.id;

        if (id !== 0) {
          adapter.catalog.deleteAppKey(id);
        }
      });
    };

    // alias
    IndexedAdapter.prototype.deleteKey = IndexedAdapter.prototype.deleteDatabase;

    /**
     * getDatabaseList() - Retrieves object array of catalog entries for current app.
     *
     * @param {function} callback - should accept array of database names in the catalog for current app.
     */
    IndexedAdapter.prototype.getDatabaseList = function(callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference so dont -need- callback in constructor
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.getDatabaseList(callback);
        });

        return;
      }

      // catalog already initialized
      // get all keys for current appName, and transpose results so just string array
      this.catalog.getAppKeys(appName, function(results) {
        var names = [];

        for(var idx = 0; idx < results.length; idx++) {
          names.push(results[idx].key);
        }

        if (typeof (callback) === 'function') {
          callback(names);
        }
        else {
          names.forEach(function(obj) {
            console.log(obj);
          });
        }
      });
    };

    // alias
    IndexedAdapter.prototype.getKeyList = IndexedAdapter.prototype.getDatabaseList;

    /**
     * getCatalogSummary - allows retrieval of list of all keys in catalog along with size
     *
     * @param {function} callback - (Optional) callback to accept result array.
     */
    IndexedAdapter.prototype.getCatalogSummary = function(callback)
    {
      var appName = this.app;
      var adapter = this;

      // lazy open/create db reference
      if (this.catalog === null || this.catalog.db === null) {
        this.catalog = new LokiCatalog(function(cat) {
          adapter.catalog = cat;

          adapter.getCatalogSummary(callback);
        });

        return;
      }

      // catalog already initialized
      // get all keys for current appName, and transpose results so just string array
      this.catalog.getAllKeys(function(results) {
        var entries = [];
        var obj,
          size,
          oapp,
          okey,
          oval;

        for(var idx = 0; idx < results.length; idx++) {
          obj = results[idx];
          oapp = obj.app || '';
          okey = obj.key || '';
          oval = obj.val || '';

          // app and key are composited into an appkey column so we will mult by 2
          size = oapp.length * 2 + okey.length * 2 + oval.length + 1;

          entries.push({ "app": obj.app, "key": obj.key, "size": size });
        }

        if (typeof (callback) === 'function') {
          callback(entries);
        }
        else {
          entries.forEach(function(obj) {
            console.log(obj);
          });
        }
      });
    };

    /**
     * LokiCatalog - underlying App/Key/Value catalog persistence
     *    This non-interface class implements the actual persistence.
     *    Used by the IndexedAdapter class.
     */
    function LokiCatalog(callback)
    {
      this.db = null;
      this.initializeLokiCatalog(callback);
    }

    LokiCatalog.prototype.initializeLokiCatalog = function(callback) {
      var openRequest = indexedDB.open('LokiCatalog', 1);
      var cat = this;

      // If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)
      openRequest.onupgradeneeded = function(e) {
        var thisDB = e.target.result;
        if (thisDB.objectStoreNames.contains('LokiAKV')) {
          thisDB.deleteObjectStore('LokiAKV');
        }

        if(!thisDB.objectStoreNames.contains('LokiAKV')) {
          var objectStore = thisDB.createObjectStore('LokiAKV', { keyPath: 'id', autoIncrement:true });
          objectStore.createIndex('app', 'app', {unique:false});
          objectStore.createIndex('key', 'key', {unique:false});
          // hack to simulate composite key since overhead is low (main size should be in val field)
          // user (me) required to duplicate the app and key into comma delimited appkey field off object
          // This will allow retrieving single record with that composite key as well as
          // still supporting opening cursors on app or key alone
          objectStore.createIndex('appkey', 'appkey', {unique:true});
        }
      };

      openRequest.onsuccess = function(e) {
        cat.db = e.target.result;

        if (typeof (callback) === 'function') callback(cat);
      };

      openRequest.onerror = function(e) {
        throw e;
      };
    };

    LokiCatalog.prototype.getAppKey = function(app, key, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('appkey');
      var appkey = app + "," + key;
      var request = index.get(appkey);

      request.onsuccess = (function(usercallback) {
        return function(e) {
          var lres = e.target.result;

          if (lres === null || typeof(lres) === 'undefined') {
            lres = {
              id: 0,
              success: false
            };
          }

          if (typeof(usercallback) === 'function') {
            usercallback(lres);
          }
          else {
            console.log(lres);
          }
        };
      })(callback);

      request.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback({ id: 0, success: false });
          }
          else {
            throw e;
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.getAppKeyById = function (id, callback, data) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var request = store.get(id);

      request.onsuccess = (function(data, usercallback){
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback(e.target.result, data);
          }
          else {
            console.log(e.target.result);
          }
        };
      })(data, callback);
    };

    LokiCatalog.prototype.setAppKey = function (app, key, val, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readwrite');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('appkey');
      var appkey = app + "," + key;
      var request = index.get(appkey);

      // first try to retrieve an existing object by that key
      // need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey
      request.onsuccess = function(e) {
        var res = e.target.result;

        if (res === null || res === undefined) {
          res = {
            app:app,
            key:key,
            appkey: app + ',' + key,
            val:val
          };
        }
        else {
          res.val = val;
        }

        var requestPut = store.put(res);

        requestPut.onerror = (function(usercallback) {
          return function(e) {
            if (typeof(usercallback) === 'function') {
              usercallback({ success: false });
            }
            else {
              console.error('LokiCatalog.setAppKey (set) onerror');
              console.error(request.error);
            }
          };

        })(callback);

        requestPut.onsuccess = (function(usercallback) {
          return function(e) {
            if (typeof(usercallback) === 'function') {
              usercallback({ success: true });
            }
          };
        })(callback);
      };

      request.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback({ success: false });
          }
          else {
            console.error('LokiCatalog.setAppKey (get) onerror');
            console.error(request.error);
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.deleteAppKey = function (id, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readwrite');
      var store = transaction.objectStore('LokiAKV');
      var request = store.delete(id);

      request.onsuccess = (function(usercallback) {
        return function(evt) {
          if (typeof(usercallback) === 'function') usercallback({ success: true });
        };
      })(callback);

      request.onerror = (function(usercallback) {
        return function(evt) {
          if (typeof(usercallback) === 'function') {
            usercallback(false);
          }
          else {
            console.error('LokiCatalog.deleteAppKey raised onerror');
            console.error(request.error);
          }
        };
      })(callback);
    };

    LokiCatalog.prototype.getAppKeys = function(app, callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var index = store.index('app');

      // We want cursor to all values matching our (single) app param
      var singleKeyRange = IDBKeyRange.only(app);

      // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()
      var cursor = index.openCursor(singleKeyRange);

      // cursor internally, pushing results into this.data[] and return
      // this.data[] when done (similar to service)
      var localdata = [];

      cursor.onsuccess = (function(data, callback) {
        return function(e) {
          var cursor = e.target.result;
          if (cursor) {
            var currObject = cursor.value;

            data.push(currObject);

            cursor.continue();
          }
          else {
            if (typeof(callback) === 'function') {
              callback(data);
            }
            else {
              console.log(data);
            }
          }
        };
      })(localdata, callback);

      cursor.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') {
            usercallback(null);
          }
          else {
            console.error('LokiCatalog.getAppKeys raised onerror');
            console.error(e);
          }
        };
      })(callback);

    };

    // Hide 'cursoring' and return array of { id: id, key: key }
    LokiCatalog.prototype.getAllKeys = function (callback) {
      var transaction = this.db.transaction(['LokiAKV'], 'readonly');
      var store = transaction.objectStore('LokiAKV');
      var cursor = store.openCursor();

      var localdata = [];

      cursor.onsuccess = (function(data, callback) {
        return function(e) {
          var cursor = e.target.result;
          if (cursor) {
            var currObject = cursor.value;

            data.push(currObject);

            cursor.continue();
          }
          else {
            if (typeof(callback) === 'function') {
              callback(data);
            }
            else {
              console.log(data);
            }
          }
        };
      })(localdata, callback);

      cursor.onerror = (function(usercallback) {
        return function(e) {
          if (typeof(usercallback) === 'function') usercallback(null);
        };
      })(callback);

    };

    return IndexedAdapter;

  }());
}));

},{}],19:[function(require,module,exports){
(function (global){
/**
 * LokiJS
 * @author Joe Minichino <joe.minichino@gmail.com>
 *
 * A lightweight document oriented javascript database
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof exports === 'object') {
    // CommonJS
    module.exports = factory();
  } else {
    // Browser globals
    root.loki = factory();
  }
}(this, function () {

  return (function () {
    'use strict';

    var Utils = {
      copyProperties: function (src, dest) {
        var prop;
        for (prop in src) {
          dest[prop] = src[prop];
        }
      },
      // used to recursively scan hierarchical transform step object for param substitution
      resolveTransformObject: function (subObj, params, depth) {
        var prop,
          pname;

        if (typeof depth !== 'number') {
          depth = 0;
        }

        if (++depth >= 10) return subObj;

        for (prop in subObj) {
          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf("[%lktxp]") === 0) {
            pname = subObj[prop].substring(8);
            if (params.hasOwnProperty(pname)) {
              subObj[prop] = params[pname];
            }
          } else if (typeof subObj[prop] === "object") {
            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);
          }
        }

        return subObj;
      },
      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution
      resolveTransformParams: function (transform, params) {
        var idx,
          prop,
          clonedStep,
          resolvedTransform = [];

        if (typeof params === 'undefined') return transform;

        // iterate all steps in the transform array
        for (idx = 0; idx < transform.length; idx++) {
          // clone transform so our scan and replace can operate directly on cloned transform
          clonedStep = JSON.parse(JSON.stringify(transform[idx]));
          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));
        }

        return resolvedTransform;
      }
    };

    // Sort helper that support null and undefined
    function ltHelper(prop1, prop2, equal) {
      if (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {
        return true;
      }
      if (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {
        return false;
      }

      if (prop1 < prop2) {
        return true;
      }

      if (prop1 > prop2) {
        return false;
      }

      // not lt and and not gt so equality assumed-- this ordering of tests is date compatible
      if (equal) {
        return true;
      } else {
        return false;
      }

    }

    function gtHelper(prop1, prop2, equal) {
      if (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {
        return false;
      }
      if (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {
        return true;
      }

      if (prop1 > prop2) {
        return true;
      }

      if (prop1 < prop2) {
        return false;
      }

      // not lt and and not gt so equality assumed-- this ordering of tests is date compatible
      if (equal) {
        return true;
      } else {
        return false;
      }

    }

    function sortHelper(prop1, prop2, desc) {
      if (ltHelper(prop1, prop2)) {
        if (desc) {
          return 1;
        }
        else {
          return -1;
        }
      }

      if (gtHelper(prop1, prop2)) {
        if (desc) {
          return -1;
        }
        else {
          return 1;
        }
      }

      // not lt, not gt so implied equality-- date compatible
      return 0;
    }

    function containsCheckFn(a, b) {
      if (Array.isArray(a)) {
        return function (curr) {
          return a.indexOf(curr) !== -1;
        };
      } else if (a && typeof a === 'string') {
        return function (curr) {
          return a.indexOf(curr) !== -1;
        };
      } else if (a && typeof a === 'object') {
        return function (curr) {
          return a.hasOwnProperty(curr);
        };
      }
    }

    var LokiOps = {
      // comparison operators
      // a is the value in the collection
      // b is the query value
      $eq: function (a, b) {
        return a === b;
      },

      $dteq: function(a, b) {
        if (ltHelper(a, b)) {
          return false;
        }

        if (gtHelper(a,b)) {
          return false;
        }

        return true;
      },

      $gt: function (a, b) {
        return gtHelper(a, b);
      },

      $gte: function (a, b) {
        return gtHelper(a, b, true);
      },

      $lt: function (a, b) {
        return ltHelper(a, b);
      },

      $lte: function (a, b) {
        return ltHelper(a, b, true);
      },

      $ne: function (a, b) {
        return a !== b;
      },

      $regex: function (a, b) {
        return b.test(a);
      },

      $in: function (a, b) {
        return b.indexOf(a) > -1;
      },

      $nin: function (a, b) {
        return b.indexOf(a) == -1;
      },

      $containsNone: function (a, b) {
        return !LokiOps.$containsAny(a, b);
      },

      $containsAny: function (a, b) {
        var checkFn;

        if (!Array.isArray(b)) {
          b = [b];
        }

        checkFn = containsCheckFn(a, b) || function () {
          return false;
        };

        return b.reduce(function (prev, curr) {
          if (prev) {
            return prev;
          }

          return checkFn(curr);
        }, false);
      },

      $contains: function (a, b) {
        var checkFn;

        if (!Array.isArray(b)) {
          b = [b];
        }

        // return false on check if no check fn is found
        checkFn = containsCheckFn(a, b) || function () {
          return false;
        };

        return b.reduce(function (prev, curr) {
          if (!prev) {
            return prev;
          }

          return checkFn(curr);
        }, true);
      }
    };

    var operators = {
      '$eq': LokiOps.$eq,
      '$dteq': LokiOps.$dteq,
      '$gt': LokiOps.$gt,
      '$gte': LokiOps.$gte,
      '$lt': LokiOps.$lt,
      '$lte': LokiOps.$lte,
      '$ne': LokiOps.$ne,
      '$regex': LokiOps.$regex,
      '$in': LokiOps.$in,
      '$nin': LokiOps.$nin,
      '$contains': LokiOps.$contains,
      '$containsAny': LokiOps.$containsAny,
      '$containsNone': LokiOps.$containsNone
    };

    // making indexing opt-in... our range function knows how to deal with these ops :
    var indexedOpsList = ['$eq', '$dteq', '$gt', '$gte', '$lt', '$lte'];

    function clone(data, method) {
      var cloneMethod = method || 'parse-stringify',
        cloned;

      switch (cloneMethod) {
        case "parse-stringify":
          cloned = JSON.parse(JSON.stringify(data));
          break;
        case "jquery-extend-deep":
          cloned = jQuery.extend(true, {}, data);
          break;
        case "shallow":
          cloned = Object.create(data.prototype || null);
          Object.keys(data).map(function (i) {
            cloned[i] = data[i];
          });
          break;
        default:
          break;
      }

      //if (cloneMethod === 'parse-stringify') {
      //  cloned = JSON.parse(JSON.stringify(data));
      //}
      return cloned;
    }

    function cloneObjectArray(objarray, method) {
      var i,
        result = [];

      if (method == "parse-stringify") {
        return clone(objarray, method);
      }

      i = objarray.length-1;

      for(;i<=0;i--) {
        result.push(clone(objarray[i], method));
      }

      return result;
    }

    function localStorageAvailable() {
      try {
        return ('localStorage' in window && window.localStorage !== null);
      } catch (e) {
        return false;
      }
    }


    /**
     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any
     * constructor that inherits EventEmitter to emit events and trigger
     * listeners that have been added to the event through the on(event, callback) method
     *
     * @constructor
     */
    function LokiEventEmitter() {}

    /**
     * @prop Events property is a hashmap, with each property being an array of callbacks
     */
    LokiEventEmitter.prototype.events = {};

    /**
     * @prop asyncListeners - boolean determines whether or not the callbacks associated with each event
     * should happen in an async fashion or not
     * Default is false, which means events are synchronous
     */
    LokiEventEmitter.prototype.asyncListeners = false;

    /**
     * @prop on(eventName, listener) - adds a listener to the queue of callbacks associated to an event
     * @returns {int} the index of the callback in the array of listeners for a particular event
     */
    LokiEventEmitter.prototype.on = function (eventName, listener) {
      var event = this.events[eventName];
      if (!event) {
        event = this.events[eventName] = [];
      }
      event.push(listener);
      return listener;
    };

    /**
     * @propt emit(eventName, data) - emits a particular event
     * with the option of passing optional parameters which are going to be processed by the callback
     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)
     * @param {string} eventName - the name of the event
     * @param {object} data - optional object passed with the event
     */
    LokiEventEmitter.prototype.emit = function (eventName, data) {
      var self = this;
      if (eventName && this.events[eventName]) {
        this.events[eventName].forEach(function (listener) {
          if (self.asyncListeners) {
            setTimeout(function () {
              listener(data);
            }, 1);
          } else {
            listener(data);
          }

        });
      } else {
        throw new Error('No event ' + eventName + ' defined');
      }
    };

    /**
     * @prop remove() - removes the listener at position 'index' from the event 'eventName'
     */
    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {
      if (this.events[eventName]) {
        var listeners = this.events[eventName];
        listeners.splice(listeners.indexOf(listener), 1);
      }
    };

    /**
     * Loki: The main database class
     * @constructor
     * @param {string} filename - name of the file to be saved to
     * @param {object} options - config object
     */
    function Loki(filename, options) {
      this.filename = filename || 'loki.db';
      this.collections = [];

      // persist version of code which created the database to the database.
      // could use for upgrade scenarios
      this.databaseVersion = 1.1;
      this.engineVersion = 1.1;

      // autosave support (disabled by default)
      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave
      this.autosave = false;
      this.autosaveInterval = 5000;
      this.autosaveHandle = null;

      this.options = {};

      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that
      // will not or cannot be deserialized.  You are required to configure persistence every time
      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.

      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'
      // this is optional option param, otherwise environment detection will be used
      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.
      this.persistenceMethod = null;

      // retain reference to optional (non-serializable) persistenceAdapter 'instance'
      this.persistenceAdapter = null;

      // enable console output if verbose flag is set (disabled by default)
      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;

      this.events = {
        'init': [],
        'loaded': [],
        'flushChanges': [],
        'close': [],
        'changes': [],
        'warning': []
      };

      var getENV = function () {
        if (typeof window === 'undefined') {
          return 'NODEJS';
        }

        if (typeof global !== 'undefined' && global.window) {
          return 'NODEJS'; //node-webkit
        }

        if (typeof document !== 'undefined') {
          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {
            return 'CORDOVA';
          }
          return 'BROWSER';
        }
        return 'CORDOVA';
      };

      // refactored environment detection due to invalid detection for browser environments.
      // if they do not specify an options.env we want to detect env rather than default to nodejs.
      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)
      //   might want to review whether we can consolidate.
      if (options && options.hasOwnProperty('env')) {
        this.ENV = options.env;
      } else {
        this.ENV = getENV();
      }

      // not sure if this is necessary now that i have refactored the line above
      if (this.ENV === 'undefined') {
        this.ENV = 'NODEJS';
      }

      //if (typeof (options) !== 'undefined') {
      this.configureOptions(options, true);
      //}

      this.on('init', this.clearChanges);

    }

    // db class is an EventEmitter
    Loki.prototype = new LokiEventEmitter();

    // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.
    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.
    Loki.prototype.getIndexedAdapter = function () {
      var adapter;

      if (typeof require === 'function') {
        adapter = require("./loki-indexed-adapter.js");
      }

      return adapter;
    };


    /**
     * configureOptions - allows reconfiguring database options
     *
     * @param {object} options - configuration options to apply to loki db object
     * @param {boolean} initialConfig - (optional) if this is a reconfig, don't pass this
     */
    Loki.prototype.configureOptions = function (options, initialConfig) {
      var defaultPersistence = {
          'NODEJS': 'fs',
          'BROWSER': 'localStorage',
          'CORDOVA': 'localStorage'
        },
        persistenceMethods = {
          'fs': LokiFsAdapter,
          'localStorage': LokiLocalStorageAdapter
        };

      this.options = {};

      this.persistenceMethod = null;
      // retain reference to optional persistence adapter 'instance'
      // currently keeping outside options because it can't be serialized
      this.persistenceAdapter = null;

      // process the options
      if (typeof (options) !== 'undefined') {
        this.options = options;


        if (this.options.hasOwnProperty('persistenceMethod')) {
          // check if the specified persistence method is known
          if (typeof (persistenceMethods[options.persistenceMethod]) == 'function') {
            this.persistenceMethod = options.persistenceMethod;
            this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();
          }
          // should be throw an error here, or just fall back to defaults ??
        }

        // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance
        if (this.options.hasOwnProperty('adapter')) {
          this.persistenceMethod = 'adapter';
          this.persistenceAdapter = options.adapter;
          this.options.adapter = null;
        }


        // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation
        if (options.autoload && initialConfig) {
          // for autoload, let the constructor complete before firing callback
          var self = this;
          setTimeout(function () {
            self.loadDatabase(options, options.autoloadCallback);
          }, 1);
        }

        if (this.options.hasOwnProperty('autosaveInterval')) {
          this.autosaveDisable();
          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
        }

        if (this.options.hasOwnProperty('autosave') && this.options.autosave) {
          this.autosaveDisable();
          this.autosave = true;

          if (this.options.hasOwnProperty('autosaveCallback')) {
            this.autosaveEnable(options, options.autosaveCallback);
          } else {
            this.autosaveEnable();
          }
        }
      } // end of options processing

      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults
      if (this.persistenceAdapter === null) {
        this.persistenceMethod = defaultPersistence[this.ENV];
        if (this.persistenceMethod) {
          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();
        }
      }

    };

    /**
     * anonym() - shorthand method for quickly creating and populating an anonymous collection.
     *    This collection is not referenced internally so upon losing scope it will be garbage collected.
     *
     *    Example : var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });
     *
     * @param {Array} docs - document array to initialize the anonymous collection with
     * @param {Array} indexesArray - (Optional) array of property names to index
     * @returns {Collection} New collection which you can query or chain
     */
    Loki.prototype.anonym = function (docs, indexesArray) {
      var collection = new Collection('anonym', indexesArray);
      collection.insert(docs);

      if(this.verbose)
        collection.console = console;

      return collection;
    };

    Loki.prototype.addCollection = function (name, options) {
      var collection = new Collection(name, options);
      this.collections.push(collection);

      if(this.verbose)
        collection.console = console;

      return collection;
    };

    Loki.prototype.loadCollection = function (collection) {
      if (!collection.name) {
        throw new Error('Collection must have a name property to be loaded');
      }
      this.collections.push(collection);
    };

    Loki.prototype.getCollection = function (collectionName) {
      var i,
        len = this.collections.length;

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          return this.collections[i];
        }
      }

      // no such collection
      this.emit('warning', 'collection ' + collectionName + ' not found');
      return null;
    };

    Loki.prototype.listCollections = function () {

      var i = this.collections.length,
        colls = [];

      while (i--) {
        colls.push({
          name: this.collections[i].name,
          type: this.collections[i].objType,
          count: this.collections[i].data.length
        });
      }
      return colls;
    };

    Loki.prototype.removeCollection = function (collectionName) {
      var i,
        len = this.collections.length;

      for (i = 0; i < len; i += 1) {
        if (this.collections[i].name === collectionName) {
          this.collections.splice(i, 1);
          return;
        }
      }
    };

    Loki.prototype.getName = function () {
      return this.name;
    };

    /**
     * serializeReplacer - used to prevent certain properties from being serialized
     *
     */
    Loki.prototype.serializeReplacer = function (key, value) {
      switch (key) {
      case 'autosaveHandle':
      case 'persistenceAdapter':
      case 'constraints':
        return null;
      default:
        return value;
      }
    };

    // toJson
    Loki.prototype.serialize = function () {
      return JSON.stringify(this, this.serializeReplacer);
    };
    // alias of serialize
    Loki.prototype.toJson = Loki.prototype.serialize;

    /**
     * loadJSON - inflates a loki database from a serialized JSON string
     *
     * @param {string} serializedDb - a serialized loki database string
     * @param {object} options - apply or override collection level settings
     */
    Loki.prototype.loadJSON = function (serializedDb, options) {

      if (serializedDb.length === 0) serializedDb = JSON.stringify({});
      var obj = JSON.parse(serializedDb),
        i = 0,
        len = obj.collections ? obj.collections.length : 0,
        coll,
        copyColl,
        clen,
        j;

      this.name = obj.name;

      // restore database version
      this.databaseVersion = 1.0;
      if (obj.hasOwnProperty('databaseVersion')) {
        this.databaseVersion = obj.databaseVersion;
      }

      this.collections = [];

      for (i; i < len; i += 1) {
        coll = obj.collections[i];
        copyColl = this.addCollection(coll.name);

        copyColl.transactional = coll.transactional;
        copyColl.asyncListeners = coll.asyncListeners;
        copyColl.disableChangesApi = coll.disableChangesApi;
        copyColl.cloneObjects = coll.cloneObjects;
        copyColl.cloneMethod = coll.cloneMethod || "parse-stringify";
        copyColl.autoupdate = coll.autoupdate;

        // load each element individually
        clen = coll.data.length;
        j = 0;
        if (options && options.hasOwnProperty(coll.name)) {

          var loader = options[coll.name].inflate ? options[coll.name].inflate : Utils.copyProperties;

          for (j; j < clen; j++) {
            var collObj = new(options[coll.name].proto)();
            loader(coll.data[j], collObj);
            copyColl.data[j] = collObj;
            copyColl.addAutoUpdateObserver(collObj);
          }
        } else {

          for (j; j < clen; j++) {
            copyColl.data[j] = coll.data[j];
            copyColl.addAutoUpdateObserver(copyColl.data[j]);
          }
        }

        copyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;
        copyColl.idIndex = coll.idIndex;
        if (typeof (coll.binaryIndices) !== 'undefined') {
          copyColl.binaryIndices = coll.binaryIndices;
        }
        if (typeof coll.transforms !== 'undefined') {
          copyColl.transforms = coll.transforms;
        }

        copyColl.ensureId();

        // regenerate unique indexes
        copyColl.uniqueNames = [];
        if (coll.hasOwnProperty("uniqueNames")) {
          copyColl.uniqueNames = coll.uniqueNames;
          for (j = 0; j < copyColl.uniqueNames.length; j++) {
            copyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);
          }
        }

        // in case they are loading a database created before we added dynamic views, handle undefined
        if (typeof (coll.DynamicViews) === 'undefined') continue;

        // reinflate DynamicViews and attached Resultsets
        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {
          var colldv = coll.DynamicViews[idx];

          var dv = copyColl.addDynamicView(colldv.name, colldv.options);
          dv.resultdata = colldv.resultdata;
          dv.resultsdirty = colldv.resultsdirty;
          dv.filterPipeline = colldv.filterPipeline;

          dv.sortCriteria = colldv.sortCriteria;
          dv.sortFunction = null;

          dv.sortDirty = colldv.sortDirty;
          dv.resultset.filteredrows = colldv.resultset.filteredrows;
          dv.resultset.searchIsChained = colldv.resultset.searchIsChained;
          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;

          dv.rematerialize({
            removeWhereFilters: true
          });
        }
      }
    };

    /**
     * close(callback) - emits the close event with an optional callback. Does not actually destroy the db
     * but useful from an API perspective
     */
    Loki.prototype.close = function (callback) {
      // for autosave scenarios, we will let close perform final save (if dirty)
      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes
      if (this.autosave) {
        this.autosaveDisable();
        if (this.autosaveDirty()) {
          this.saveDatabase(callback);
          callback = undefined;
        }
      }

      if (callback) {
        this.on('close', callback);
      }
      this.emit('close');
    };

    /**-------------------------+
    | Changes API               |
    +--------------------------*/

    /**
     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,
     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)
     */

    /**
     * generateChangesNotification() - takes all the changes stored in each
     * collection and creates a single array for the entire database. If an array of names
     * of collections is passed then only the included collections will be tracked.
     *
     * @param {array} optional array of collection names. No arg means all collections are processed.
     * @returns {array} array of changes
     * @see private method createChange() in Collection
     */
    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {
      function getCollName(coll) {
        return coll.name;
      }
      var changes = [],
        selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);

      this.collections.forEach(function (coll) {
        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {
          changes = changes.concat(coll.getChanges());
        }
      });
      return changes;
    };

    /**
     * serializeChanges() - stringify changes for network transmission
     * @returns {string} string representation of the changes
     */
    Loki.prototype.serializeChanges = function (collectionNamesArray) {
      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));
    };

    /**
     * clearChanges() - clears all the changes in all collections.
     */
    Loki.prototype.clearChanges = function () {
      this.collections.forEach(function (coll) {
        if (coll.flushChanges) {
          coll.flushChanges();
        }
      });
    };

    /*------------------+
    | PERSISTENCE       |
    -------------------*/


    /** there are two build in persistence adapters for internal use
     * fs             for use in Nodejs type environments
     * localStorage   for use in browser environment
     * defined as helper classes here so its easy and clean to use
     */

    /**
     * constructor for fs
     */
    function LokiFsAdapter() {
      this.fs = require('fs');
    }

    /**
     * loadDatabase() - Load data from file, will throw an error if the file does not exist
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     */
    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      this.fs.readFile(dbname, {
        encoding: 'utf8'
      }, function readFileCallback(err, data) {
        if (err) {
          callback(new Error(err));
        } else {
          callback(data);
        }
      });
    };

    /**
     * saveDatabase() - save data to file, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     */
    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      this.fs.writeFile(dbname, dbstring, callback);
    };


    /**
     * constructor for local storage
     */
    function LokiLocalStorageAdapter() {}

    /**
     * loadDatabase() - Load data from localstorage
     * @param {string} dbname - the name of the database to load
     * @param {function} callback - the callback to handle the result
     */
    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
      if (localStorageAvailable()) {
        callback(localStorage.getItem(dbname));
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved
     * might want to expand this to avoid dataloss on partial save
     * @param {string} dbname - the filename of the database to load
     * @param {function} callback - the callback to handle the result
     */
    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
      if (localStorageAvailable()) {
        localStorage.setItem(dbname, dbstring);
        callback(null);
      } else {
        callback(new Error('localStorage is not available'));
      }
    };

    /**
     * loadDatabase - Handles loading from file system, local storage, or adapter (indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function} callback - (Optional) user supplied async callback / error handler
     */
    Loki.prototype.loadDatabase = function (options, callback) {
      var cFun = callback || function (err, data) {
          if (err) {
            throw err;
          }
          return;
        },
        self = this;

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (this.persistenceAdapter !== null) {

        this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {
          if (typeof (dbString) === 'string') {
            self.loadJSON(dbString, options || {});
            cFun(null);
            self.emit('loaded', 'database ' + self.filename + ' loaded');
          } else {
            if (typeof (dbString) === "object") {
              cFun(dbString);
            } else {
              cFun('Database not found');
            }
          }
        });

      } else {
        cFun(new Error('persistenceAdapter not configured'));
      }
    };

    /**
     * saveDatabase - Handles saving to file system, local storage, or adapter (indexeddb)
     *    This method utilizes loki configuration options (if provided) to determine which
     *    persistence method to use, or environment detection (if configuration was not provided).
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function} callback - (Optional) user supplied async callback / error handler
     */
    Loki.prototype.saveDatabase = function (callback) {
      var cFun = callback || function (err) {
          if (err) {
            throw err;
          }
          return;
        },
        self = this;

      // the persistenceAdapter should be present if all is ok, but check to be sure.
      if (this.persistenceAdapter !== null) {
        // check if the adapter is requesting (and supports) a 'reference' mode export
        if (this.persistenceAdapter.mode === "reference" && typeof this.persistenceAdapter.exportDatabase === "function") {
          // filename may seem redundant but loadDatabase will need to expect this same filename
          this.persistenceAdapter.exportDatabase(this.filename, this, function exportDatabaseCallback(err) {
            self.autosaveClearFlags();
            cFun(err);
          });
        }
        // otherwise just pass the serialized database to adapter
        else {
          this.persistenceAdapter.saveDatabase(this.filename, self.serialize(), function saveDatabasecallback(err) {
            self.autosaveClearFlags();
            cFun(err);
          });
        }
      } else {
        cFun(new Error('persistenceAdapter not configured'));
      }
    };

    // alias
    Loki.prototype.save = Loki.prototype.saveDatabase;

    /**
     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database
     *
     * @returns {boolean} - true if database has changed since last autosave, false if not.
     */
    Loki.prototype.autosaveDirty = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        if (this.collections[idx].dirty) {
          return true;
        }
      }

      return false;
    };

    /**
     * autosaveClearFlags - resets dirty flags on all collections.
     *    Called from saveDatabase() after db is saved.
     *
     */
    Loki.prototype.autosaveClearFlags = function () {
      for (var idx = 0; idx < this.collections.length; idx++) {
        this.collections[idx].dirty = false;
      }
    };

    /**
     * autosaveEnable - begin a javascript interval to periodically save the database.
     *
     * @param {object} options - not currently used (remove or allow overrides?)
     * @param {function} callback - (Optional) user supplied async callback
     */
    Loki.prototype.autosaveEnable = function (options, callback) {
      this.autosave = true;

      var delay = 5000,
        self = this;

      if (typeof (this.autosaveInterval) !== 'undefined' && this.autosaveInterval !== null) {
        delay = this.autosaveInterval;
      }

      this.autosaveHandle = setInterval(function autosaveHandleInterval() {
        // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'
        // so next step will be to implement collection level dirty flags set on insert/update/remove
        // along with loki level isdirty() function which iterates all collections to see if any are dirty

        if (self.autosaveDirty()) {
          self.saveDatabase(callback);
        }
      }, delay);
    };

    /**
     * autosaveDisable - stop the autosave interval timer.
     *
     */
    Loki.prototype.autosaveDisable = function () {
      if (typeof (this.autosaveHandle) !== 'undefined' && this.autosaveHandle !== null) {
        clearInterval(this.autosaveHandle);
        this.autosaveHandle = null;
      }
    };


    /**
     * Resultset class allowing chainable queries.  Intended to be instanced internally.
     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.
     *
     *    Example:
     *    mycollection.chain()
     *      .find({ 'doors' : 4 })
     *      .where(function(obj) { return obj.name === 'Toyota' })
     *      .data();
     *
     * @constructor
     * @param {Collection} collection - The collection which this Resultset will query against.
     * @param {string} queryObj - Optional mongo-style query object to initialize resultset with.
     * @param {function} queryFunc - Optional javascript filter function to initialize resultset with.
     * @param {bool} firstOnly - Optional boolean used by collection.findOne().
     */
    function Resultset(collection, queryObj, queryFunc, firstOnly) {
      // retain reference to collection we are querying against
      this.collection = collection;

      // if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later
      this.searchIsChained = (!queryObj && !queryFunc);
      this.filteredrows = [];
      this.filterInitialized = false;

      // if user supplied initial queryObj or queryFunc, apply it
      if (typeof (queryObj) !== "undefined" && queryObj !== null) {
        return this.find(queryObj, firstOnly);
      }
      if (typeof (queryFunc) !== "undefined" && queryFunc !== null) {
        return this.where(queryFunc);
      }

      // otherwise return unfiltered Resultset for future filtering
      return this;
    }

    /**
     * toJSON() - Override of toJSON to avoid circular references
     *
     */
    Resultset.prototype.toJSON = function () {
      var copy = this.copy();
      copy.collection = null;
      return copy;
    };

    /**
     * limit() - Allows you to limit the number of documents passed to next chain operation.
     *    A resultset copy() is made to avoid altering original resultset.
     *
     * @param {int} qty - The number of documents to return.
     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.
     */
    Resultset.prototype.limit = function (qty) {
      // if this is chained resultset with no filters applied, we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      var rscopy = this.copy();

      rscopy.filteredrows = rscopy.filteredrows.slice(0, qty);

      return rscopy;
    };

    /**
     * offset() - Used for skipping 'pos' number of documents in the resultset.
     *
     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.
     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.
     */
    Resultset.prototype.offset = function (pos) {
      // if this is chained resultset with no filters applied, we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      var rscopy = this.copy();

      rscopy.filteredrows = rscopy.filteredrows.splice(pos, rscopy.filteredrows.length);

      return rscopy;
    };

    /**
     * copy() - To support reuse of resultset in branched query situations.
     *
     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.
     */
    Resultset.prototype.copy = function () {
      var result = new Resultset(this.collection, null, null);

      result.filteredrows = this.filteredrows.slice();
      result.filterInitialized = this.filterInitialized;

      return result;
    };

    // add branch() as alias of copy()
    Resultset.prototype.branch = Resultset.prototype.copy;

    /**
     * transform() - executes a named collection transform or raw array of transform steps against the resultset.
     *
     * @param transform {string|array} : (Optional) name of collection transform or raw transform array
     * @param parameters {object} : (Optional) object property hash of parameters, if the transform requires them.
     * @returns {Resultset} : either (this) resultset or a clone of of this resultset (depending on steps)
     */
    Resultset.prototype.transform = function (transform, parameters) {
      var idx,
        step,
        rs = this;

      // if transform is name, then do lookup first
      if (typeof transform === 'string') {
        if (this.collection.transforms.hasOwnProperty(transform)) {
          transform = this.collection.transforms[transform];
        }
      }

      // either they passed in raw transform array or we looked it up, so process
      if (typeof transform !== 'object' || !Array.isArray(transform)) {
          throw new Error("Invalid transform");
      }

      if (typeof parameters !== 'undefined') {
        transform = Utils.resolveTransformParams(transform, parameters);
      }

      for (idx = 0; idx < transform.length; idx++) {
        step = transform[idx];

        switch (step.type) {
        case "find":
          rs.find(step.value);
          break;
        case "where":
          rs.where(step.value);
          break;
        case "simplesort":
          rs.simplesort(step.property, step.desc);
          break;
        case "compoundsort":
          rs.compoundsort(step.value);
          break;
        case "sort":
          rs.sort(step.value);
          break;
        case "limit":
          rs = rs.limit(step.value);
          break; // limit makes copy so update reference
        case "offset":
          rs = rs.offset(step.value);
          break; // offset makes copy so update reference
        case "map":
          rs = rs.map(step.value);
          break;
        case "eqJoin":
          rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);
          break;
          // following cases break chain by returning array data so make any of these last in transform steps
        case "mapReduce":
          rs = rs.mapReduce(step.mapFunction, step.reduceFunction);
          break;
          // following cases update documents in current filtered resultset (use carefully)
        case "update":
          rs.update(step.value);
          break;
        case "remove":
          rs.remove();
          break;
        default:
          break;
        }
      }

      return rs;
    };

    /**
     * sort() - User supplied compare function is provided two documents to compare. (chainable)
     *    Example:
     *    rslt.sort(function(obj1, obj2) {
     *      if (obj1.name === obj2.name) return 0;
     *      if (obj1.name > obj2.name) return 1;
     *      if (obj1.name < obj2.name) return -1;
     *    });
     *
     * @param {function} comparefun - A javascript compare function used for sorting.
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     */
    Resultset.prototype.sort = function (comparefun) {
      // if this is chained resultset with no filters applied, just we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      var wrappedComparer =
        (function (userComparer, rslt) {
          return function (a, b) {
            var obj1 = rslt.collection.data[a];
            var obj2 = rslt.collection.data[b];

            return userComparer(obj1, obj2);
          };
        })(comparefun, this);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * simplesort() - Simpler, loose evaluation for user to sort based on a property name. (chainable)
     *
     * @param {string} propname - name of property to sort by.
     * @param {bool} isdesc - (Optional) If true, the property will be sorted in descending order
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     */
    Resultset.prototype.simplesort = function (propname, isdesc) {
      // if this is chained resultset with no filters applied, just we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      if (typeof (isdesc) === 'undefined') {
        isdesc = false;
      }

      var wrappedComparer =
        (function (prop, desc, rslt) {
          return function (a, b) {
            var obj1 = rslt.collection.data[a];
            var obj2 = rslt.collection.data[b];

            return sortHelper(obj1[prop], obj2[prop], desc);

          };
        })(propname, isdesc, this);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * compoundeval() - helper method for compoundsort(), performing individual object comparisons
     *
     * @param {array} properties - array of property names, in order, by which to evaluate sort order
     * @param {object} obj1 - first object to compare
     * @param {object} obj2 - second object to compare
     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first
     */
    Resultset.prototype.compoundeval = function (properties, obj1, obj2) {
      var propertyCount = properties.length;

      if (propertyCount === 0) {
        throw new Error("Invalid call to compoundeval, need at least one property");
      }

      // decode property, whether just a string property name or subarray [propname, isdesc]
      var isdesc = false;
      var firstProp = properties[0];
      if (typeof (firstProp) !== 'string') {
        if (Array.isArray(firstProp)) {
          isdesc = firstProp[1];
          firstProp = firstProp[0];
        }
      }

      if (obj1[firstProp] === obj2[firstProp]) {
        if (propertyCount === 1) {
          return 0;
        } else {
          return this.compoundeval(properties.slice(1), obj1, obj2, isdesc);
        }
      }

      return sortHelper(obj1[firstProp], obj2[firstProp], isdesc);
    };

    /**
     * compoundsort() - Allows sorting a resultset based on multiple columns.
     *    Example : rs.compoundsort(['age', 'name']); to sort by age and then name (both ascending)
     *    Example : rs.compoundsort(['age', ['name', true]); to sort by age (ascending) and then by name (descending)
     *
     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
     */
    Resultset.prototype.compoundsort = function (properties) {

      // if this is chained resultset with no filters applied, just we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      var wrappedComparer =
        (function (props, rslt) {
          return function (a, b) {
            var obj1 = rslt.collection.data[a];
            var obj2 = rslt.collection.data[b];

            return rslt.compoundeval(props, obj1, obj2);
          };
        })(properties, this);

      this.filteredrows.sort(wrappedComparer);

      return this;
    };

    /**
     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.
     *    this is used for collection.find() and first find filter of resultset/dynview
     *    slightly different than get() binary search in that get() hones in on 1 value,
     *    but we have to hone in on many (range)
     * @param {string} op - operation, such as $eq
     * @param {string} prop - name of property to calculate range for
     * @param {object} val - value to use for range calculation.
     * @returns {array} [start, end] index array positions
     */
    Resultset.prototype.calculateRange = function (op, prop, val) {
      var rcd = this.collection.data;
      var index = this.collection.binaryIndices[prop].values;
      var min = 0;
      var max = index.length - 1;
      var mid = null;
      var lbound = 0;
      var ubound = index.length - 1;

      // when no documents are in collection, return empty range condition
      if (rcd.length === 0) {
        return [0, -1];
      }

      var minVal = rcd[index[min]][prop];
      var maxVal = rcd[index[max]][prop];

      // if value falls outside of our range return [0, -1] to designate no results
      switch (op) {
      case '$eq':
        if (ltHelper(val, minVal) || gtHelper(val, maxVal)) {
          return [0, -1];
        }
        break;
      case '$dteq':
        if (ltHelper(val, minVal) || gtHelper(val, maxVal)) {
          return [0, -1];
        }
        break;
      case '$gt':
        if (gtHelper(val, maxVal, true)) {
          return [0, -1];
        }
        break;
      case '$gte':
        if (gtHelper(val, maxVal)) {
          return [0, -1];
        }
        break;
      case '$lt':
        if (ltHelper(val, minVal, true)) {
          return [0, -1];
        }
        if (ltHelper(maxVal, val)) {
          return [0, rcd.length - 1];
        }
        break;
      case '$lte':
        if (ltHelper(val, minVal)) {
          return [0, -1];
        }
        if (ltHelper(maxVal, val, true)) {
          return [0, rcd.length - 1];
        }
        break;
      }

      // hone in on start position of value
      while (min < max) {
        mid = Math.floor((min + max) / 2);

        if (ltHelper(rcd[index[mid]][prop], val)) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      lbound = min;

      min = 0;
      max = index.length - 1;

      // hone in on end position of value
      while (min < max) {
        mid = Math.floor((min + max) / 2);

        if (ltHelper(val, rcd[index[mid]][prop])) {
          max = mid;
        } else {
          min = mid + 1;
        }
      }

      ubound = max;

      var lval = rcd[index[lbound]][prop];
      var uval = rcd[index[ubound]][prop];

      switch (op) {
      case '$eq':
        if (lval !== val) {
          return [0, -1];
        }
        if (uval !== val) {
          ubound--;
        }

        return [lbound, ubound];
      case '$dteq':
        if (lval > val || lval < val) {
          return [0, -1];
        }
        if (uval > val || uval < val) {
          ubound--;
        }

        return [lbound, ubound];


      case '$gt':
        if (ltHelper(uval, val, true)) {
          return [0, -1];
        }

        return [ubound, rcd.length - 1];

      case '$gte':
        if (ltHelper(lval, val)) {
          return [0, -1];
        }

        return [lbound, rcd.length - 1];

      case '$lt':
        if (lbound === 0 && ltHelper(lval, val)) {
          return [0, 0];
        }
        return [0, lbound - 1];

      case '$lte':
        if (uval !== val) {
          ubound--;
        }

        if (ubound === 0 && ltHelper(uval, val)) {
          return [0, 0];
        }
        return [0, ubound];

      default:
        return [0, rcd.length - 1];
      }
    };

    /**
     * findOr() - oversee the operation of OR'ed query expressions.
     *    OR'ed expression evaluation runs each expression individually against the full collection,
     *    and finally does a set OR on each expression's results.
     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.
     *
     * @param {array} expressionArray - array of expressions
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.findOr = function (expressionArray) {
      var fri = 0,
        ei = 0,
        fr = null,
        docset = [],
        expResultset = null;

      // if filter is already initialized we need to query against only those items already in filter.
      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.
      if (this.filterInitialized) {
        docset = [];

        for (ei = 0; ei < expressionArray.length; ei++) {
          // we need to branch existing query to run each filter separately and combine results
          expResultset = this.branch();
          expResultset.find(expressionArray[ei]);
          expResultset.data();

          // add any document 'hits'
          fr = expResultset.filteredrows;
          for (fri = 0; fri < fr.length; fri++) {
            if (docset.indexOf(fr[fri]) === -1) {
              docset.push(fr[fri]);
            }
          }
        }

        this.filteredrows = docset;
      } else {
        for (ei = 0; ei < expressionArray.length; ei++) {
          // we will let each filter run independently against full collection and mashup document hits later
          expResultset = this.collection.chain();
          expResultset.find(expressionArray[ei]);
          expResultset.data();

          // add any document 'hits'
          fr = expResultset.filteredrows;
          for (fri = 0; fri < fr.length; fri++) {
            if (this.filteredrows.indexOf(fr[fri]) === -1) {
              this.filteredrows.push(fr[fri]);
            }
          }
        }
      }

      this.filterInitialized = true;

      // possibly sort indexes
      return this;
    };

    /**
     * findAnd() - oversee the operation of AND'ed query expressions.
     *    AND'ed expression evaluation runs each expression progressively against the full collection,
     *    internally utilizing existing chained resultset functionality.
     *    Only the first filter can utilize a binary index.
     *
     * @param {array} expressionArray - array of expressions
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.findAnd = function (expressionArray) {
      // we have already implementing method chaining in this (our Resultset class)
      // so lets just progressively apply user supplied and filters
      for (var i = 0; i < expressionArray.length; i++) {
        this.find(expressionArray[i]);
      }

      return this;
    };

    /**
     * dotSubScan - helper function used for dot notation queries.
     */
    Resultset.prototype.dotSubScan = function (root, property, fun, value) {
      var arrayRef = null;
      var pathIndex, subIndex;
      var paths = property.split('.');
      var path;

      for (pathIndex = 0; pathIndex < paths.length; pathIndex++) {
        path = paths[pathIndex];

        // foreach already detected parent was array so this must be where we iterate
        if (arrayRef) {
          // iterate all sub-array items to see if any yield hits
          for (subIndex = 0; subIndex < arrayRef.length; subIndex++) {
            if (fun(arrayRef[subIndex][path], value)) {
              return true;
            }
          }
        }
        // else not yet determined if subarray scan is involved
        else {
          // if the dot notation is invalid for the current document, then ignore this document
          if (typeof root === 'undefined' || root === null || !root.hasOwnProperty(path)) {
            return false;
          }
          root = root[path];
          if (Array.isArray(root)) {
            arrayRef = root;
          }
        }
      }

      // made it this far so must be dot notation on non-array property
      return fun(root, value);
    };

    /**
     * find() - Used for querying via a mongo-style query object.
     *
     * @param {object} query - A mongo-style query object used for filtering current results.
     * @param {boolean} firstOnly - (Optional) Used by collection.findOne()
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.find = function (query, firstOnly) {
      if (this.collection.data.length === 0) {
        if (this.searchIsChained) {
          this.filteredrows = [];
          this.filterInitialized = true;
          return this;
        }
        return [];
      }


      var queryObject = query || 'getAll',
        property,
        value,
        operator,
        p,
        key,
        searchByIndex = false,
        result = [],
        index = null,
        // comparison function
        fun,
        // collection data
        t,
        // collection data length
        i,
        emptyQO = true;

      // if this was note invoked via findOne()
      firstOnly = firstOnly || false;

      // if passed in empty object {}, interpret as 'getAll'
      // more performant than object.keys
      for (p in queryObject) {
        emptyQO = false;
        break;
      }
      if (emptyQO) {
        queryObject = 'getAll';
      }

      // apply no filters if they want all
      if (queryObject === 'getAll') {
        // chained queries can just do coll.chain().data() but let's
        // be versatile and allow this also coll.chain().find().data()
        if (this.searchIsChained) {
          this.filteredrows = Object.keys(this.collection.data).map(Number);
          this.filterInitialized = true;
          return this;
        }
        // not chained, so return collection data array
        else {
          return this.collection.data.slice();
        }
      }

      // if user is deep querying the object such as find('name.first': 'odin')
      var usingDotNotation = false;

      for (p in queryObject) {
        if (queryObject.hasOwnProperty(p)) {
          property = p;

          // injecting $and and $or expression tree evaluation here.
          if (p === '$and') {
            if (this.searchIsChained) {
              this.findAnd(queryObject[p]);

              // for chained find with firstonly,
              if (firstOnly && this.filteredrows.length > 1) {
                this.filteredrows = this.filteredrows.slice(0, 1);
              }

              return this;
            } else {
              // our $and operation internally chains filters
              result = this.collection.chain().findAnd(queryObject[p]).data();

              // if this was coll.findOne() return first object or empty array if null
              // since this is invoked from a constructor we can't return null, so we will
              // make null in coll.findOne();
              if (firstOnly) {
                if (result.length === 0) return [];

                return result[0];
              }

              // not first only return all results
              return result;
            }
          }

          if (p === '$or') {
            if (this.searchIsChained) {
              this.findOr(queryObject[p]);

              if (firstOnly && this.filteredrows.length > 1) {
                this.filteredrows = this.filteredrows.slice(0, 1);
              }

              return this;
            } else {
              // call out to helper function to determine $or results
              result = this.collection.chain().findOr(queryObject[p]).data();

              if (firstOnly) {
                if (result.length === 0) return [];

                return result[0];
              }

              // not first only return all results
              return result;
            }
          }

          if (p.indexOf('.') != -1) {
            usingDotNotation = true;
          }

          // see if query object is in shorthand mode (assuming eq operator)
          if (queryObject[p] === null || (typeof queryObject[p] !== 'object' || queryObject[p] instanceof Date)) {
            operator = '$eq';
            value = queryObject[p];
          } else if (typeof queryObject[p] === 'object') {
            for (key in queryObject[p]) {
              if (queryObject[p].hasOwnProperty(key)) {
                operator = key;
                value = queryObject[p][key];
              }
            }
          } else {
            throw new Error('Do not know what you want to do.');
          }
          break;
        }
      }

      // for regex ops, precompile
      if (operator === '$regex') {
        if (typeof(value) === 'object' && Array.isArray(value)) {
          value = new RegExp(value[0], value[1]);
        }
        else {
          value = new RegExp(value);
        }
      }

      if (this.collection.data === null) {
        throw new TypeError();
      }

      // if an index exists for the property being queried against, use it
      // for now only enabling for non-chained query (who's set of docs matches index)
      // or chained queries where it is the first filter applied and prop is indexed
      if ((!this.searchIsChained || (this.searchIsChained && !this.filterInitialized)) &&
        indexedOpsList.indexOf(operator) !== -1 && this.collection.binaryIndices.hasOwnProperty(property)) {
        // this is where our lazy index rebuilding will take place
        // basically we will leave all indexes dirty until we need them
        // so here we will rebuild only the index tied to this property
        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param
        this.collection.ensureIndex(property);

        searchByIndex = true;
        index = this.collection.binaryIndices[property];
      }

      // the comparison function
      fun = operators[operator];

      // Query executed differently depending on :
      //    - whether it is chained or not
      //    - whether the property being queried has an index defined
      //    - if chained, we handle first pass differently for initial filteredrows[] population
      //
      // For performance reasons, each case has its own if block to minimize in-loop calculations

      // If not a chained query, bypass filteredrows and work directly against data
      if (!this.searchIsChained) {
        if (!searchByIndex) {
          t = this.collection.data;
          i = t.length;

          if (firstOnly) {
            if (usingDotNotation) {
              while (i--) {
                if (this.dotSubScan(t[i], property, fun, value)) {
                  return (t[i]);
                }
              }
            } else {
              while (i--) {
                if (fun(t[i][property], value)) {
                  return (t[i]);
                }
              }
            }

            return [];
          } else {
            // if using dot notation then treat property as keypath such as 'name.first'.
            // currently supporting dot notation for non-indexed conditions only
            if (usingDotNotation) {
              while (i--) {
                if (this.dotSubScan(t[i], property, fun, value)) {
                  result.push(t[i]);
                }
              }
            } else {
              while (i--) {
                if (fun(t[i][property], value)) {
                  result.push(t[i]);
                }
              }
            }
          }
        } else {
          // searching by binary index via calculateRange() utility method
          t = this.collection.data;

          var seg = this.calculateRange(operator, property, value, this);

          // not chained so this 'find' was designated in Resultset constructor
          // so return object itself
          if (firstOnly) {
            if (seg[1] !== -1) {
              return t[index.values[seg[0]]];
            }

            return [];
          }

          for (i = seg[0]; i <= seg[1]; i++) {
            result.push(t[index.values[i]]);
          }

          this.filteredrows = result;
        }

        // not a chained query so return result as data[]
        return result;
      }
      // Otherwise this is a chained query
      else {
        // If the filteredrows[] is already initialized, use it
        if (this.filterInitialized) {
          // not searching by index
          if (!searchByIndex) {
            t = this.collection.data;
            i = this.filteredrows.length;

            // currently supporting dot notation for non-indexed conditions only
            if (usingDotNotation) {
              while (i--) {
                if (this.dotSubScan(t[this.filteredrows[i]], property, fun, value)) {
                  result.push(this.filteredrows[i]);
                }
              }
            } else {
              while (i--) {
                if (fun(t[this.filteredrows[i]][property], value)) {
                  result.push(this.filteredrows[i]);
                }
              }
            }
          } else {
            // search by index
            t = index;
            i = this.filteredrows.length;
            while (i--) {
              if (fun(t[this.filteredrows[i]], value)) {
                result.push(this.filteredrows[i]);
              }
            }
          }

          this.filteredrows = result;

          return this;
        }
        // first chained query so work against data[] but put results in filteredrows
        else {
          // if not searching by index
          if (!searchByIndex) {
            t = this.collection.data;
            i = t.length;

            if (usingDotNotation) {
              while (i--) {
                if (this.dotSubScan(t[i], property, fun, value)) {
                  result.push(i);
                }
              }
            } else {
              while (i--) {
                if (fun(t[i][property], value)) {
                  result.push(i);
                }
              }
            }
          } else {
            // search by index
            t = this.collection.data;
            var segm = this.calculateRange(operator, property, value, this);

            for (var idx = segm[0]; idx <= segm[1]; idx++) {
              result.push(index.values[idx]);
            }

            this.filteredrows = result;
          }

          this.filteredrows = result;
          this.filterInitialized = true; // next time work against filteredrows[]

          return this;
        }

      }
    };


    /**
     * where() - Used for filtering via a javascript filter function.
     *
     * @param {function} fun - A javascript function used for filtering current results by.
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.where = function (fun) {

      var viewFunction,
        result = [];

      if ('function' === typeof fun) {
        viewFunction = fun;
      } else {
        throw new TypeError('Argument is not a stored view or a function');
      }
      try {
        // if not a chained query then run directly against data[] and return object []
        if (!this.searchIsChained) {
          var i = this.collection.data.length;

          while (i--) {
            if (viewFunction(this.collection.data[i]) === true) {
              result.push(this.collection.data[i]);
            }
          }

          // not a chained query so returning result as data[]
          return result;
        }
        // else chained query, so run against filteredrows
        else {
          // If the filteredrows[] is already initialized, use it
          if (this.filterInitialized) {
            var j = this.filteredrows.length;

            while (j--) {
              if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {
                result.push(this.filteredrows[j]);
              }
            }

            this.filteredrows = result;

            return this;
          }
          // otherwise this is initial chained op, work against data, push into filteredrows[]
          else {
            var k = this.collection.data.length;

            while (k--) {
              if (viewFunction(this.collection.data[k]) === true) {
                result.push(k);
              }
            }

            this.filteredrows = result;
            this.filterInitialized = true;

            return this;
          }
        }
      } catch (err) {
        throw err;
      }
    };

    /**
     * data() - Terminates the chain and returns array of filtered documents
     *
     * @param options {object} : allows specifying 'forceClones' and 'forceCloneMethod' options.
     *    options :
     *      forceClones {boolean} : Allows forcing the return of cloned objects even when
     *        the collection is not configured for clone object.
     *      forceCloneMethod {string} : Allows overriding the default or collection specified cloning method.
     *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'
     *
     * @returns {array} Array of documents in the resultset
     */
    Resultset.prototype.data = function (options) {
      var result = [],
        cd,
        cl;

      options = options || {};

      // if this is chained resultset with no filters applied, just return collection.data
      if (this.searchIsChained && !this.filterInitialized) {
        if (this.filteredrows.length === 0) {
          // determine whether we need to clone objects or not
          if (this.collection.cloneObjects || options.forceClones) {
            cd = this.collection.data;
            cl = cl.length;

            for (i = 0; i < cl; i++) {
              result.push(clone(cd[i], (options.forceCloneMethod || this.collection.cloneMethod)));
            }
          }
          // otherwise we are not cloning so return sliced array with same object references
          else {
            return this.collection.data.slice();
          }
        } else {
          // filteredrows must have been set manually, so use it
          this.filterInitialized = true;
        }
      }

      var data = this.collection.data,
        fr = this.filteredrows;

      var i,
        len = this.filteredrows.length;

      for (i = 0; i < len; i++) {
        if (this.collection.cloneObjects || options.forceClones) {
          result.push(clone(data[fr[i]], (options.forceCloneMethod || this.collection.cloneMethod)));
        }
        else {
          result.push(data[fr[i]]);
        }
      }
      return result;
    };

    /**
     * update() - used to run an update operation on all documents currently in the resultset.
     *
     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.
     * @returns {Resultset} this resultset for further chain ops.
     */
    Resultset.prototype.update = function (updateFunction) {

      if (typeof (updateFunction) !== "function") {
        throw new TypeError('Argument is not a function');
      }

      // if this is chained resultset with no filters applied, we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      var len = this.filteredrows.length,
        rcd = this.collection.data;

      for (var idx = 0; idx < len; idx++) {
        // pass in each document object currently in resultset to user supplied updateFunction
        updateFunction(rcd[this.filteredrows[idx]]);

        // notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate
        this.collection.update(rcd[this.filteredrows[idx]]);
      }

      return this;
    };

    /**
     * remove() - removes all document objects which are currently in resultset from collection (as well as resultset)
     *
     * @returns {Resultset} this (empty) resultset for further chain ops.
     */
    Resultset.prototype.remove = function () {

      // if this is chained resultset with no filters applied, we need to populate filteredrows first
      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
        this.filteredrows = Object.keys(this.collection.data).map(Number);
      }

      this.collection.remove(this.data());

      this.filteredrows = [];

      return this;
    };

    /**
     * mapReduce() - data transformation via user supplied functions
     *
     * @param {function} mapFunction - this function accepts a single document for you to transform and return
     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
     * @returns The output of your reduceFunction
     */
    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };

    /**
     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties
     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key
     * @param {Array} joinData - Data array to join to.
     * @param {String,function} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on
     * @param {String,function} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on
     * @param {function} (optional) mapFun - A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}
     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]
     */
    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun) {

      var leftData = [],
        leftDataLength,
        rightData = [],
        rightDataLength,
        key,
        result = [],
        obj,
        leftKeyisFunction = typeof leftJoinKey === 'function',
        rightKeyisFunction = typeof rightJoinKey === 'function',
        joinMap = {};

      //get the left data
      leftData = this.data();
      leftDataLength = leftData.length;

      //get the right data
      if (joinData instanceof Resultset) {
        rightData = joinData.data();
      } else if (Array.isArray(joinData)) {
        rightData = joinData;
      } else {
        throw new TypeError('joinData needs to be an array or result set');
      }
      rightDataLength = rightData.length;

      //construct a lookup table

      for (var i = 0; i < rightDataLength; i++) {
        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];
        joinMap[key] = rightData[i];
      }

      if (!mapFun) {
        mapFun = function (left, right) {
          return {
            left: left,
            right: right
          };
        };
      }

      //Run map function over each object in the resultset
      for (var j = 0; j < leftDataLength; j++) {
        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];
        result.push(mapFun(leftData[j], joinMap[key] || {}));
      }

      //return return a new resultset with no filters
      this.collection = new Collection('joinData');
      this.collection.insert(result);
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    };

    Resultset.prototype.map = function (mapFun) {
      var data = this.data().map(mapFun);
      //return return a new resultset with no filters
      this.collection = new Collection('mappedData');
      this.collection.insert(data);
      this.filteredrows = [];
      this.filterInitialized = false;

      return this;
    };

    /**
     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.
     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it
     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)
     *
     *    Examples:
     *    var mydv = mycollection.addDynamicView('test');  // default is non-persistent
     *    mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });
     *    mydv.applyFind({ 'doors' : 4 });
     *    var results = mydv.data();
     *
     * @constructor
     * @param {Collection} collection - A reference to the collection to work against
     * @param {string} name - The name of this dynamic view
     * @param {object} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.
     */
    function DynamicView(collection, name, options) {
      this.collection = collection;
      this.name = name;
      this.rebuildPending = false;
      this.options = options || {};

      if (!this.options.hasOwnProperty('persistent')) {
        this.options.persistent = false;
      }

      // 'persistentSortPriority':
      // 'passive' will defer the sort phase until they call data(). (most efficient overall)
      // 'active' will sort async whenever next idle. (prioritizes read speeds)
      if (!this.options.hasOwnProperty('sortPriority')) {
        this.options.sortPriority = 'passive';
      }

      this.resultset = new Resultset(collection);
      this.resultdata = [];
      this.resultsdirty = false;

      this.cachedresultset = null;

      // keep ordered filter pipeline
      this.filterPipeline = [];

      // sorting member variables
      // we only support one active search, applied using applySort() or applySimpleSort()
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortDirty = false;

      // for now just have 1 event for when we finally rebuilt lazy view
      // once we refactor transactions, i will tie in certain transactional events

      this.events = {
        'rebuild': []
      };
    }

    DynamicView.prototype = new LokiEventEmitter();


    /**
     * rematerialize() - intended for use immediately after deserialization (loading)
     *    This will clear out and reapply filterPipeline ops, recreating the view.
     *    Since where filters do not persist correctly, this method allows
     *    restoring the view to state where user can re-apply those where filters.
     *
     * @param {Object} options - (Optional) allows specification of 'removeWhereFilters' option
     * @returns {DynamicView} This dynamic view for further chained ops.
     */
    DynamicView.prototype.rematerialize = function (options) {
      var fpl,
        fpi,
        idx;

      options = options || {};

      this.resultdata = [];
      this.resultsdirty = true;
      this.resultset = new Resultset(this.collection);

      if (this.sortFunction || this.sortCriteria) {
        this.sortDirty = true;
      }

      if (options.hasOwnProperty('removeWhereFilters')) {
        // for each view see if it had any where filters applied... since they don't
        // serialize those functions lets remove those invalid filters
        fpl = this.filterPipeline.length;
        fpi = fpl;
        while (fpi--) {
          if (this.filterPipeline[fpi].type === 'where') {
            if (fpi !== this.filterPipeline.length - 1) {
              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];
            }

            this.filterPipeline.length--;
          }
        }
      }

      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops
      var ofp = this.filterPipeline;
      this.filterPipeline = [];

      // now re-apply 'find' filterPipeline ops
      fpl = ofp.length;
      for (idx = 0; idx < fpl; idx++) {
        this.applyFind(ofp[idx].val);
      }

      // during creation of unit tests, i will remove this forced refresh and leave lazy
      this.data();

      // emit rebuild event in case user wants to be notified
      this.emit('rebuild', this);

      return this;
    };

    /**
     * branchResultset() - Makes a copy of the internal resultset for branched queries.
     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,
     *    so your branched query should be immediately resolved and not held for future evaluation.
     *
     * @param {string, array} : Optional name of collection transform, or an array of transform steps
     * @param {object} : optional parameters (if optional transform requires them)
     * @returns {Resultset} A copy of the internal resultset for branched queries.
     */
    DynamicView.prototype.branchResultset = function (transform, parameters) {
      var rs = this.resultset.branch();

      if (typeof transform === 'undefined') {
        return rs;
      }

      return rs.transform(transform, parameters);
    };

    /**
     * toJSON() - Override of toJSON to avoid circular references
     *
     */
    DynamicView.prototype.toJSON = function () {
      var copy = new DynamicView(this.collection, this.name, this.options);

      copy.resultset = this.resultset;
      copy.resultdata = []; // let's not save data (copy) to minimize size
      copy.resultsdirty = true;
      copy.filterPipeline = this.filterPipeline;
      copy.sortFunction = this.sortFunction;
      copy.sortCriteria = this.sortCriteria;
      copy.sortDirty = this.sortDirty;

      // avoid circular reference, reapply in db.loadJSON()
      copy.collection = null;

      return copy;
    };

    /**
     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.
     *     Existing options should be retained.
     */
    DynamicView.prototype.removeFilters = function () {
      this.rebuildPending = false;
      this.resultset = new Resultset(this.collection);
      this.resultdata = [];
      this.resultsdirty = false;

      this.cachedresultset = null;

      // keep ordered filter pipeline
      this.filterPipeline = [];

      // sorting member variables
      // we only support one active search, applied using applySort() or applySimpleSort()
      this.sortFunction = null;
      this.sortCriteria = null;
      this.sortDirty = false;
    };

    /**
     * applySort() - Used to apply a sort to the dynamic view
     *
     * @param {function} comparefun - a javascript compare function used for sorting
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.applySort = function (comparefun) {
      this.sortFunction = comparefun;
      this.sortCriteria = null;

      this.queueSortPhase();

      return this;
    };

    /**
     * applySimpleSort() - Used to specify a property used for view translation.
     *
     * @param {string} propname - Name of property by which to sort.
     * @param {boolean} isdesc - (Optional) If true, the sort will be in descending order.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.applySimpleSort = function (propname, isdesc) {

      if (typeof (isdesc) === 'undefined') {
        isdesc = false;
      }

      this.sortCriteria = [
        [propname, isdesc]
      ];
      this.sortFunction = null;

      this.queueSortPhase();

      return this;
    };

    /**
     * applySortCriteria() - Allows sorting a resultset based on multiple columns.
     *    Example : dv.applySortCriteria(['age', 'name']); to sort by age and then name (both ascending)
     *    Example : dv.applySortCriteria(['age', ['name', true]); to sort by age (ascending) and then by name (descending)
     *    Example : dv.applySortCriteria(['age', true], ['name', true]); to sort by age (descending) and then by name (descending)
     *
     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.
     */
    DynamicView.prototype.applySortCriteria = function (criteria) {
      this.sortCriteria = criteria;
      this.sortFunction = null;

      this.queueSortPhase();

      return this;
    };

    /**
     * startTransaction() - marks the beginning of a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.startTransaction = function () {
      this.cachedresultset = this.resultset.copy();

      return this;
    };

    /**
     * commit() - commits a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.commit = function () {
      this.cachedresultset = null;

      return this;
    };

    /**
     * rollback() - rolls back a transaction.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.rollback = function () {
      this.resultset = this.cachedresultset;

      if (this.options.persistent) {
        // for now just rebuild the persistent dynamic view data in this worst case scenario
        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.
        this.resultdata = this.resultset.data();

        this.emit('rebuild', this);
      }

      return this;
    };


    /**
     * Implementation detail.
     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.
     *
     * @param {string|number} uid - The unique ID of the filter.
     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.
     */
    DynamicView.prototype._indexOfFilterWithId = function (uid) {
      if (typeof uid === 'string' || typeof uid === 'number') {
        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {
          if (uid === this.filterPipeline[idx].uid) {
            return idx;
          }
        }
      }
      return -1;
    };

    /**
     * Implementation detail.
     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.
     *
     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.
     */
    DynamicView.prototype._addFilter = function (filter) {
      this.resultset[filter.type](filter.val);
      this.filterPipeline.push(filter);
    };

    /**
     * reapplyFilters() - Reapply all the filters in the current pipeline.
     *
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.reapplyFilters = function () {
      var filters = this.filterPipeline;
      var sortFunction = this.sortFunction;
      var sortCriteria = this.sortCriteria;

      this.removeFilters();

      for (var idx = 0, len = filters.length; idx < len; idx += 1) {
        this._addFilter(filters[idx]);
      }

      if (sortFunction !== null){
        this.applySort(sortFunction);
      }
      if (sortCriteria !== null) {
        this.applySortCriteria(sortCriteria);
      }

      if (this.options.persistent) {
        this.resultsdirty = true;
        this.queueSortPhase();
      }

      return this;
    };

    /**
     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline
     *
     * @param {object} filter - A filter object to add to the pipeline.
     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.applyFilter = function (filter) {
      var idx = this._indexOfFilterWithId(filter.uid);
      if (idx >= 0) {
        this.filterPipeline[idx] = filter;
        this.reapplyFilters();
        return;
      }

      this._addFilter(filter);

      if (this.sortFunction || this.sortCriteria) {
        this.sortDirty = true;
        this.queueSortPhase();
      }

      if (this.options.persistent) {
        this.resultsdirty = true;
        this.queueSortPhase();
      }

      return this;
    };

    /**
     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline
     *
     * @param {object} query - A mongo-style query object to apply to pipeline
     * @param {string|number} uid - Optional: The unique ID of this filter, to reference it in the future.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.applyFind = function (query, uid) {
      this.applyFilter({
        type: 'find',
        val: query,
        uid: uid
      });
      return this;
    };

    /**
     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline
     *
     * @param {function} fun - A javascript filter function to apply to pipeline
     * @param {string|number} uid - Optional: The unique ID of this filter, to reference it in the future.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.applyWhere = function (fun, uid) {
      this.applyFilter({
        type: 'where',
        val: fun,
        uid: uid
      });
      return this;
    };

    /**
     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline
     *
     * @param {string|number} uid - The unique ID of the filter to be removed.
     * @returns {DynamicView} this DynamicView object, for further chain ops.
     */
    DynamicView.prototype.removeFilter = function (uid) {
      var idx = this._indexOfFilterWithId(uid);
      if (idx < 0) {
        throw new Error("Dynamic view does not contain a filter with ID: " + uid);
      }

      this.filterPipeline.splice(idx, 1);
      this.reapplyFilters();
      return this;
    };


    /**
     * data() - resolves and pending filtering and sorting, then returns document array as result.
     *
     * @returns {array} An array of documents representing the current DynamicView contents.
     */
    DynamicView.prototype.data = function () {
      // Until a proper initialization phase can be implemented, let us initialize here (if needed)
      if (this.filterPipeline.length === 0) {
        this.applyFind();
      }

      // using final sort phase as 'catch all' for a few use cases which require full rebuild
      if (this.sortDirty || this.resultsdirty) {
        this.performSortPhase();
      }

      if (!this.options.persistent) {
        return this.resultset.data();
      }

      return this.resultdata;
    };

    /**
     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.
     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.
     */
    DynamicView.prototype.queueRebuildEvent = function () {
      var self = this;

      if (this.rebuildPending) {
        return;
      }

      this.rebuildPending = true;

      setTimeout(function () {
        self.rebuildPending = false;
        self.emit('rebuild', self);
      }, 1);
    };

    /**
     * queueSortPhase : If the view is sorted we will throttle sorting to either :
     *    (1) passive - when the user calls data(), or
     *    (2) active - once they stop updating and yield js thread control
     */
    DynamicView.prototype.queueSortPhase = function () {
      var self = this;

      // already queued? exit without queuing again
      if (this.sortDirty) {
        return;
      }

      this.sortDirty = true;

      if (this.options.sortPriority === "active") {
        // active sorting... once they are done and yield js thread, run async performSortPhase()
        setTimeout(function () {
          self.performSortPhase();
        }, 1);
      } else {
        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to
        // potentially notify user that data has changed.
        this.queueRebuildEvent();
      }
    };

    /**
     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)
     *
     */
    DynamicView.prototype.performSortPhase = function () {
      // async call to this may have been pre-empted by synchronous call to data before async could fire
      if (!this.sortDirty && !this.resultsdirty) {
        return;
      }

      if (this.sortFunction) {
        this.resultset.sort(this.sortFunction);
      }

      if (this.sortCriteria) {
        this.resultset.compoundsort(this.sortCriteria);
      }

      if (!this.options.persistent) {
        this.sortDirty = false;
        return;
      }

      // persistent view, rebuild local resultdata array
      this.resultdata = this.resultset.data();
      this.resultsdirty = false;
      this.sortDirty = false;

      this.emit('rebuild', this);
    };

    /**
     * evaluateDocument() - internal method for (re)evaluating document inclusion.
     *    Called by : collection.insert() and collection.update().
     *
     * @param {int} objIndex - index of document to (re)run through filter pipeline.
     */
    DynamicView.prototype.evaluateDocument = function (objIndex) {
      var ofr = this.resultset.filteredrows;
      var oldPos = ofr.indexOf(+objIndex);
      var oldlen = ofr.length;

      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;
      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)
      var evalResultset = new Resultset(this.collection);
      evalResultset.filteredrows = [objIndex];
      evalResultset.filterInitialized = true;
      for (var idx = 0; idx < this.filterPipeline.length; idx++) {
        switch (this.filterPipeline[idx].type) {
        case 'find':
          evalResultset.find(this.filterPipeline[idx].val);
          break;
        case 'where':
          evalResultset.where(this.filterPipeline[idx].val);
          break;
        }
      }

      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)
      var newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;

      // wasn't in old, shouldn't be now... do nothing
      if (oldPos == -1 && newPos == -1) return;

      // wasn't in resultset, should be now... add
      if (oldPos === -1 && newPos !== -1) {
        ofr.push(objIndex);

        if (this.options.persistent) {
          this.resultdata.push(this.collection.data[objIndex]);
        }

        // need to re-sort to sort new document
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }

      // was in resultset, shouldn't be now... delete
      if (oldPos !== -1 && newPos === -1) {
        if (oldPos < oldlen - 1) {
          // http://dvolvr.davidwaterston.com/2013/06/09/restating-the-obvious-the-fastest-way-to-truncate-an-array-in-javascript/comment-page-1/
          ofr[oldPos] = ofr[oldlen - 1];
          ofr.length = oldlen - 1;

          if (this.options.persistent) {
            this.resultdata[oldPos] = this.resultdata[oldlen - 1];
            this.resultdata.length = oldlen - 1;
          }
        } else {
          ofr.length = oldlen - 1;

          if (this.options.persistent) {
            this.resultdata.length = oldlen - 1;
          }
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }

      // was in resultset, should still be now... (update persistent only?)
      if (oldPos !== -1 && newPos !== -1) {
        if (this.options.persistent) {
          // in case document changed, replace persistent view data with the latest collection.data document
          this.resultdata[oldPos] = this.collection.data[objIndex];
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        } else {
          this.queueRebuildEvent();
        }

        return;
      }
    };

    /**
     * removeDocument() - internal function called on collection.delete()
     */
    DynamicView.prototype.removeDocument = function (objIndex) {
      var ofr = this.resultset.filteredrows;
      var oldPos = ofr.indexOf(+objIndex);
      var oldlen = ofr.length;
      var idx;

      if (oldPos !== -1) {
        // if not last row in resultdata, swap last to hole and truncate last row
        if (oldPos < oldlen - 1) {
          ofr[oldPos] = ofr[oldlen - 1];
          ofr.length = oldlen - 1;

          if (this.options.persistent) {
            this.resultdata[oldPos] = this.resultdata[oldlen - 1];
            this.resultdata.length = oldlen - 1;
          }
        }
        // last row, so just truncate last row
        else {
          ofr.length = oldlen - 1;

          if (this.options.persistent) {
            this.resultdata.length = oldlen - 1;
          }
        }

        // in case changes to data altered a sort column
        if (this.sortFunction || this.sortCriteria) {
          this.queueSortPhase();
        }
      }

      // since we are using filteredrows to store data array positions
      // if they remove a document (whether in our view or not),
      // we need to adjust array positions -1 for all document array references after that position
      oldlen = ofr.length;
      for (idx = 0; idx < oldlen; idx++) {
        if (ofr[idx] > objIndex) {
          ofr[idx]--;
        }
      }
    };

    /**
     * mapReduce() - data transformation via user supplied functions
     *
     * @param {function} mapFunction - this function accepts a single document for you to transform and return
     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
     * @returns The output of your reduceFunction
     */
    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data().map(mapFunction));
      } catch (err) {
        throw err;
      }
    };


    /**
     * @constructor
     * Collection class that handles documents of same type
     * @param {string} collection name
     * @param {array} array of property names to be indicized
     * @param {object} configuration object
     */
    function Collection(name, options) {
      // the name of the collection

      this.name = name;
      // the data held by the collection
      this.data = [];
      this.idIndex = []; // index of id
      this.binaryIndices = {}; // user defined indexes
      this.constraints = {
        unique: {},
        exact: {}
      };

      // unique contraints contain duplicate object references, so they are not persisted.
      // we will keep track of properties which have unique contraint applied here, and regenerate on load
      this.uniqueNames = [];

      // transforms will be used to store frequently used query chains as a series of steps
      // which itself can be stored along with the database.
      this.transforms = {};

      // the object type of the collection
      this.objType = name;

      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.
      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.
      // defaulting to true since this is called from addCollection and adding a collection should trigger save
      this.dirty = true;

      // private holders for cached data
      this.cachedIndex = null;
      this.cachedBinaryIndex = null;
      this.cachedData = null;
      var self = this;

      /* OPTIONS */
      options = options || {};

      // exact match and unique constraints
      if (options.hasOwnProperty('unique')) {
        if (!Array.isArray(options.unique)) {
          options.unique = [options.unique];
        }
        options.unique.forEach(function (prop) {
          self.uniqueNames.push(prop); // used to regenerate on subsequent database loads
          self.constraints.unique[prop] = new UniqueIndex(prop);
        });
      }

      if (options.hasOwnProperty('exact')) {
        options.exact.forEach(function (prop) {
          self.constraints.exact[prop] = new ExactIndex(prop);
        });
      }

      // is collection transactional
      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;

      // options to clone objects when inserting them
      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;

      // default clone method (if enabled) is parse-stringify
      this.cloneMethod = options.hasOwnProperty('clonemethod') ? options.cloneMethod : "parse-stringify";

      // option to make event listeners async, default is sync
      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;

      // disable track changes
      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;

      // option to observe objects and update them automatically, ignored if Object.observe is not supported
      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;

      // currentMaxId - change manually at your own peril!
      this.maxId = 0;

      this.DynamicViews = [];

      // events
      this.events = {
        'insert': [],
        'update': [],
        'pre-insert': [],
        'pre-update': [],
        'close': [],
        'flushbuffer': [],
        'error': [],
        'delete': [],
        'warning': []
      };

      // changes are tracked by collection and aggregated by the db
      this.changes = [];

      // initialize the id index
      this.ensureId();
      var indices = [];
      // initialize optional user-supplied indices array ['age', 'lname', 'zip']
      if (options && options.indices) {
        if (Object.prototype.toString.call(options.indices) === '[object Array]') {
          indices = options.indices;
        } else if (typeof options.indices === 'string') {
          indices = [options.indices];
        } else {
          throw new TypeError('Indices needs to be a string or an array of strings');
        }
      }

      for (var idx = 0; idx < indices.length; idx++) {
        this.ensureIndex(indices[idx]);
      }

      function observerCallback(changes) {

        var changedObjects = typeof Set === 'function' ? new Set() : [];

        if(!changedObjects.add)
          changedObjects.add = function(object) {
            if(this.indexOf(object) === -1)
              this.push(object);
            return this;
          };

        changes.forEach(function (change) {
          changedObjects.add(change.object);
        });

        changedObjects.forEach(function (object) {
          if(!object.hasOwnProperty('$loki'))
            return self.removeAutoUpdateObserver(object);
          try {
            self.update(object);
          } catch(err) {}
        });
      }

      this.observerCallback = observerCallback;

      /**
       * This method creates a clone of the current status of an object and associates operation and collection name,
       * so the parent db can aggregate and generate a changes object for the entire db
       */
      function createChange(name, op, obj) {
        self.changes.push({
          name: name,
          operation: op,
          obj: JSON.parse(JSON.stringify(obj))
        });
      }

      // clear all the changes
      function flushChanges() {
        self.changes = [];
      }

      this.getChanges = function () {
        return self.changes;
      };

      this.flushChanges = flushChanges;

      /**
       * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled
       */
      function insertMeta(obj) {
        if (!obj) {
          return;
        }
        if (!obj.meta) {
          obj.meta = {};
        }

        obj.meta.created = (new Date()).getTime();
        obj.meta.revision = 0;
      }

      function updateMeta(obj) {
        if (!obj) {
          return;
        }
        obj.meta.updated = (new Date()).getTime();
        obj.meta.revision += 1;
      }

      function createInsertChange(obj) {
        createChange(self.name, 'I', obj);
      }

      function createUpdateChange(obj) {
        createChange(self.name, 'U', obj);
      }

      function insertMetaWithChange(obj) {
        insertMeta(obj);
        createInsertChange(obj);
      }

      function updateMetaWithChange(obj) {
        updateMeta(obj);
        createUpdateChange(obj);
      }


      /* assign correct handler based on ChangesAPI flag */
      var insertHandler, updateHandler;

      function setHandlers() {
        insertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;
        updateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;
      }

      setHandlers();

      this.setChangesApi = function (enabled) {
        self.disableChangesApi = !enabled;
        setHandlers();
      };
      /**
       * built-in events
       */
      this.on('insert', function insertCallback(obj) {
        insertHandler(obj);
      });

      this.on('update', function updateCallback(obj) {
        updateHandler(obj);
      });

      this.on('delete', function deleteCallback(obj) {
        if (!self.disableChangesApi) {
          createChange(self.name, 'R', obj);
        }
      });

      this.on('warning', function (warning) {
        self.console.warn(warning);
      });
      // for de-serialization purposes
      flushChanges();
    }

    Collection.prototype = new LokiEventEmitter();

    Collection.prototype.console = {
      log: function () {},
      warn: function () {},
      error: function () {},
    };

    Collection.prototype.addAutoUpdateObserver = function (object) {

      if(!this.autoupdate || typeof Object.observe !== 'function')
        return;

      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);
    };

    Collection.prototype.removeAutoUpdateObserver = function (object) {
      if(!this.autoupdate || typeof Object.observe !== 'function')
        return;

      Object.unobserve(object, this.observerCallback);
    };

    Collection.prototype.addTransform = function (name, transform) {
      if (this.transforms.hasOwnProperty(name)) {
        throw new Error("a transform by that name already exists");
      }

      this.transforms[name] = transform;
    };

    Collection.prototype.setTransform = function (name, transform) {
      this.transforms[name] = transform;
    };

    Collection.prototype.removeTransform = function (name) {
      delete this.transforms[name];
    };

    Collection.prototype.byExample = function (template) {
      var k, obj, query;
      query = [];
      for (k in template) {
        if (!template.hasOwnProperty(k)) continue;
        query.push((
          obj = {},
          obj[k] = template[k],
          obj
        ));
      }
      return {
        '$and': query
      };
    };

    Collection.prototype.findObject = function (template) {
      return this.findOne(this.byExample(template));
    };

    Collection.prototype.findObjects = function (template) {
      return this.find(this.byExample(template));
    };

    /*----------------------------+
    | INDEXING                    |
    +----------------------------*/

    /**
     * Ensure binary index on a certain field
     */
    Collection.prototype.ensureIndex = function (property, force) {
      // optional parameter to force rebuild whether flagged as dirty or not
      if (typeof (force) === 'undefined') {
        force = false;
      }

      if (property === null || property === undefined) {
        throw new Error('Attempting to set index without an associated property');
      }

      if (this.binaryIndices.hasOwnProperty(property) && !force) {
        if (!this.binaryIndices[property].dirty) return;
      }

      this.binaryIndices[property] = {
        'name': property,
        'dirty': true,
        'values': []
      };

      var index, len = this.data.length,
        i = 0;

      index = this.binaryIndices[property];

      // initialize index values
      for (i; i < len; i += 1) {
        index.values.push(i);
      }

      var wrappedComparer =
        (function (prop, coll) {
          return function (a, b) {
            var obj1 = coll.data[a];
            var obj2 = coll.data[b];

            if (obj1[prop] === obj2[prop]) return 0;
            if (gtHelper(obj1[prop], obj2[prop])) return 1;
            if (ltHelper(obj1[prop], obj2[prop])) return -1;
          };
        })(property, this);

      index.values.sort(wrappedComparer);
      index.dirty = false;

      this.dirty = true; // for autosave scenarios
    };

    Collection.prototype.ensureUniqueIndex = function (field) {

      var index = this.constraints.unique[field];
      if (!index) {
        // keep track of new unique index for regenerate after database (re)load.
        if (this.uniqueNames.indexOf(field) == -1) {
          this.uniqueNames.push(field);
        }
        this.constraints.unique[field] = index = new UniqueIndex(field);
      }
      var self = this;
      this.data.forEach(function (obj) {
        index.set(obj);
      });
      return index;
    };

    /**
     * Ensure all binary indices
     */
    Collection.prototype.ensureAllIndexes = function (force) {
      var objKeys = Object.keys(this.binaryIndices);

      var i = objKeys.length;
      while (i--) {
        this.ensureIndex(objKeys[i], force);
      }
    };

    Collection.prototype.flagBinaryIndexesDirty = function () {
      var objKeys = Object.keys(this.binaryIndices);

      var i = objKeys.length;
      while (i--) {
        this.binaryIndices[objKeys[i]].dirty = true;
      }
    };

    Collection.prototype.flagBinaryIndexDirty = function (index) {
      if(this.binaryIndices[index])
        this.binaryIndices[index].dirty = true;
    };

    Collection.prototype.count = function (query) {
      if (!query) {
        return this.data.length;
      }

      return this.chain().find(query).filteredrows.length;
    };

    /**
     * Rebuild idIndex
     */
    Collection.prototype.ensureId = function () {

      var len = this.data.length,
        i = 0;

      this.idIndex = [];
      for (i; i < len; i += 1) {
        this.idIndex.push(this.data[i].$loki);
      }
    };

    /**
     * Rebuild idIndex async with callback - useful for background syncing with a remote server
     */
    Collection.prototype.ensureIdAsync = function (callback) {
      this.async(function () {
        this.ensureId();
      }, callback);
    };

    /**
     * Each collection maintains a list of DynamicViews associated with it
     **/

    Collection.prototype.addDynamicView = function (name, options) {
      var dv = new DynamicView(this, name, options);
      this.DynamicViews.push(dv);

      return dv;
    };

    Collection.prototype.removeDynamicView = function (name) {
      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
        if (this.DynamicViews[idx].name === name) {
          this.DynamicViews.splice(idx, 1);
        }
      }
    };

    Collection.prototype.getDynamicView = function (name) {
      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
        if (this.DynamicViews[idx].name === name) {
          return this.DynamicViews[idx];
        }
      }

      return null;
    };

    /**
     * find and update: pass a filtering function to select elements to be updated
     * and apply the updatefunctino to those elements iteratively
     */
    Collection.prototype.findAndUpdate = function (filterFunction, updateFunction) {

      var results = this.where(filterFunction),
        i = 0,
        obj;
      try {
        for (i; i < results.length; i++) {
          obj = updateFunction(results[i]);
          this.update(obj);
        }

      } catch (err) {
        this.rollback();
        this.console.error(err.message);
      }
    };

    /**
     * generate document method - ensure objects have id and objType properties
     * @param {object} the document to be inserted (or an array of objects)
     * @returns document or documents (if passed an array of objects)
     */
    Collection.prototype.insert = function (doc) {

      if (!doc) {
        var error = new Error('Object cannot be null');
        this.emit('error', error);
        throw error;
      }

      var self = this;
      // holder to the clone of the object inserted if collections is set to clone objects
      var obj;
      var docs = Array.isArray(doc) ? doc : [doc];
      var results = [];
      docs.forEach(function (d) {
        if (typeof d !== 'object') {
          throw new TypeError('Document needs to be an object');
        }

        // if configured to clone, do so now... otherwise just use same obj reference
        obj = self.cloneObjects ? clone(d, self.cloneMethod) : d;

        if (typeof obj.meta === 'undefined') {
          obj.meta = {
            revision: 0,
            created: 0
          };
        }
        self.emit('pre-insert', obj);
        if (self.add(obj)) {
          self.addAutoUpdateObserver(obj);
          self.emit('insert', obj);
          results.push(obj);
        } else {
          return undefined;
        }
      });
      return results.length === 1 ? results[0] : results;
    };

    Collection.prototype.clear = function () {
      this.data = [];
      this.idIndex = [];
      this.binaryIndices = {};
      this.cachedIndex = null;
      this.cachedData = null;
      this.maxId = 0;
      this.DynamicViews = [];
      this.dirty = true;
    };

    /**
     * Update method
     */
    Collection.prototype.update = function (doc) {
      if (Object.keys(this.binaryIndices).length > 0) {
        this.flagBinaryIndexesDirty();
      }

      if (Array.isArray(doc)) {
        var k = 0,
          len = doc.length;
        for (k; k < len; k += 1) {
          this.update(doc[k]);
        }
        return;
      }

      // verify object is a properly formed document
      if (!doc.hasOwnProperty('$loki')) {
        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');
      }
      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          obj,
          position,
          self = this;

        if (!arr) {
          throw new Error('Trying to update a document not in collection.');
        }
        this.emit('pre-update', doc);

        obj = arr[0];

        Object.keys(this.constraints.unique).forEach(function (key) {
          self.constraints.unique[key].update(obj);
        });

        // get current position in data array
        position = arr[1];

        // operate the update
        this.data[position] = doc;

        if(obj !== doc) {
          this.addAutoUpdateObserver(doc);
        }

        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].evaluateDocument(position);
        }

        this.idIndex[position] = obj.$loki;

        this.commit();
        this.dirty = true; // for autosave scenarios
        this.emit('update', doc);
        return doc;
      } catch (err) {
        this.rollback();
        this.console.error(err.message);
        this.emit('error', err);
        throw (err); // re-throw error so user does not think it succeeded
      }
    };

    /**
     * Add object to collection
     */
    Collection.prototype.add = function (obj) {
      var dvlen = this.DynamicViews.length;

      // if parameter isn't object exit with throw
      if ('object' !== typeof obj) {
        throw new TypeError('Object being added needs to be an object');
      }
      /*
       * try adding object to collection
       */

      if (Object.keys(this.binaryIndices).length > 0) {
        this.flagBinaryIndexesDirty();
      }

      // if object you are adding already has id column it is either already in the collection
      // or the object is carrying its own 'id' property.  If it also has a meta property,
      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.
      if (typeof (obj.$loki) !== "undefined") {
        throw new Error('Document is already in collection, please use update()');
      }

      try {
        this.startTransaction();
        this.maxId++;

        if (isNaN(this.maxId)) {
          this.maxId = (this.data[this.data.length - 1].$loki + 1);
        }

        obj.$loki = this.maxId;
        obj.meta.version = 0;

        var self = this;
        Object.keys(this.constraints.unique).forEach(function (key) {
          // Function set will throw error when unique constraint is not honoured
          self.constraints.unique[key].set(obj);
        });

        // add the object
        this.data.push(obj);

        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
        for (var i = 0; i < dvlen; i++) {
          this.DynamicViews[i].evaluateDocument(this.data.length - 1);
        }

        // add new obj id to idIndex
        this.idIndex.push(obj.$loki);

        this.commit();
        this.dirty = true; // for autosave scenarios

        if (this.cloneObjects) {
          return obj;
        }
        else {
          return clone(obj, this.cloneMethod);
        }
      } catch (err) {
        this.rollback();
        this.console.error(err.message);
      }
    };


    Collection.prototype.removeWhere = function (query) {
      var list;
      if (typeof query === 'function') {
        list = this.data.filter(query);
      } else {
        list = new Resultset(this, query);
      }
      this.remove(list);
    };

    Collection.prototype.removeDataOnly = function () {
      this.remove(this.data.slice());
    };

    /**
     * delete wrapped
     */
    Collection.prototype.remove = function (doc) {
      if (typeof doc === 'number') {
        doc = this.get(doc);
      }

      if ('object' !== typeof doc) {
        throw new Error('Parameter is not an object');
      }
      if (Array.isArray(doc)) {
        var k = 0,
          len = doc.length;
        for (k; k < len; k += 1) {
          this.remove(doc[k]);
        }
        return;
      }

      if (!doc.hasOwnProperty('$loki')) {
        throw new Error('Object is not a document stored in the collection');
      }

      if (Object.keys(this.binaryIndices).length > 0) {
        this.flagBinaryIndexesDirty();
      }

      try {
        this.startTransaction();
        var arr = this.get(doc.$loki, true),
          // obj = arr[0],
          position = arr[1];
        var self = this;
        Object.keys(this.constraints.unique).forEach(function (key) {
          if (doc[key] !== null && typeof doc[key] !== 'undefined') {
            self.constraints.unique[key].remove(doc[key]);
          }
        });
        // now that we can efficiently determine the data[] position of newly added document,
        // submit it for all registered DynamicViews to remove
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].removeDocument(position);
        }

        this.data.splice(position, 1);
        this.removeAutoUpdateObserver(doc);

        // remove id from idIndex
        this.idIndex.splice(position, 1);

        this.commit();
        this.dirty = true; // for autosave scenarios
        this.emit('delete', arr[0]);
        delete doc.$loki;
        delete doc.meta;
        return doc;

      } catch (err) {
        this.rollback();
        this.console.error(err.message);
        this.emit('error', err);
        return null;
      }
    };

    /*---------------------+
    | Finding methods     |
    +----------------------*/

    /**
     * Get by Id - faster than other methods because of the searching algorithm
     */
    Collection.prototype.get = function (id, returnPosition) {

      var retpos = returnPosition || false,
        data = this.idIndex,
        max = data.length - 1,
        min = 0,
        mid = Math.floor(min + (max - min) / 2);

      id = typeof id === 'number' ? id : parseInt(id, 10);

      if (isNaN(id)) {
        throw new TypeError('Passed id is not an integer');
      }

      while (data[min] < data[max]) {

        mid = Math.floor((min + max) / 2);

        if (data[mid] < id) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      if (max === min && data[min] === id) {

        if (retpos) {
          return [this.data[min], min];
        }
        return this.data[min];
      }
      return null;

    };

    Collection.prototype.by = function (field, value) {
      var self;
      if (!value) {
        self = this;
        return function (value) {
          return self.by(field, value);
        };
      }

      if (!this.cloneObjects) {
        return this.constraints.unique[field].get(value);
      }
      else {
        return clone(this.constraints.unique[field].get(value), this.cloneMethod);
      }
    };

    /**
     * Find one object by index property, by property equal to value
     */
    Collection.prototype.findOne = function (query) {
      // Instantiate Resultset and exec find op passing firstOnly = true param
      var result = new Resultset(this, query, null, true);
      if (Array.isArray(result) && result.length === 0) {
        return null;
      } else {
        if (!this.cloneObjects) {
          return result;
        }
        else {
          return clone(result, this.cloneMethod);
        }
      }
    };

    /**
     * Chain method, used for beginning a series of chained find() and/or view() operations
     * on a collection.
     *
     * @param {array} transform : Ordered array of transform step objects similar to chain
     * @param {object} parameters: Object containing properties representing parameters to substitute
     * @returns {Resultset} : (or data array if any map or join functions where called)
     */
    Collection.prototype.chain = function (transform, parameters) {
      var rs = new Resultset(this, null, null);

      if (typeof transform === 'undefined') {
        return rs;
      }

      return rs.transform(transform, parameters);
    };

    /**
     * Find method, api is similar to mongodb except for now it only supports one search parameter.
     * for more complex queries use view() and storeView()
     */
    Collection.prototype.find = function (query) {
      if (typeof (query) === 'undefined') {
        query = 'getAll';
      }

      if (!this.cloneObjects) {
        return new Resultset(this, query, null);
      }
      else {
        var results = new Resultset(this, query, null);

        return cloneObjectArray(results, this.cloneMethod);
      }
    };

    /**
     * Find object by unindexed field by property equal to value,
     * simply iterates and returns the first element matching the query
     */
    Collection.prototype.findOneUnindexed = function (prop, value) {

      var i = this.data.length,
        doc;
      while (i--) {
        if (this.data[i][prop] === value) {
          doc = this.data[i];
          return doc;
        }
      }
      return null;
    };

    /**
     * Transaction methods
     */

    /** start the transation */
    Collection.prototype.startTransaction = function () {
      if (this.transactional) {
        this.cachedData = clone(this.data, this.cloneMethod);
        this.cachedIndex = this.idIndex;
        this.cachedBinaryIndex = this.binaryIndices;

        // propagate startTransaction to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].startTransaction();
        }
      }
    };

    /** commit the transation */
    Collection.prototype.commit = function () {
      if (this.transactional) {
        this.cachedData = null;
        this.cachedIndex = null;
        this.cachedBinaryIndices = null;

        // propagate commit to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].commit();
        }
      }
    };

    /** roll back the transation */
    Collection.prototype.rollback = function () {
      if (this.transactional) {
        if (this.cachedData !== null && this.cachedIndex !== null) {
          this.data = this.cachedData;
          this.idIndex = this.cachedIndex;
          this.binaryIndices = this.cachedBinaryIndex;
        }

        // propagate rollback to dynamic views
        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
          this.DynamicViews[idx].rollback();
        }
      }
    };

    // async executor. This is only to enable callbacks at the end of the execution.
    Collection.prototype.async = function (fun, callback) {
      setTimeout(function () {
        if (typeof fun === 'function') {
          fun();
          callback();
        } else {
          throw new TypeError('Argument passed for async execution is not a function');
        }
      }, 0);
    };

    /**
     * Create view function - filter
     */
    Collection.prototype.where = function (fun) {
      if (!this.cloneObjects) {
        return new Resultset(this, null, fun);
      }
      else {
        var results = new Resultset(this, null, fun);

        return cloneObjectArray(results, this.cloneMethod);
      }
    };

    /**
     * Map Reduce
     */
    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {
      try {
        return reduceFunction(this.data.map(mapFunction));
      } catch (err) {
        throw err;
      }
    };

    /**
     * eqJoin - Join two collections on specified properties
     */
    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun) {
      // logic in Resultset class
      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);
    };

    /* ------ STAGING API -------- */
    /**
     * stages: a map of uniquely identified 'stages', which hold copies of objects to be
     * manipulated without affecting the data in the original collection
     */
    Collection.prototype.stages = {};

    /**
     * create a stage and/or retrieve it
     */
    Collection.prototype.getStage = function (name) {
      if (!this.stages[name]) {
        this.stages[name] = {};
      }
      return this.stages[name];
    };
    /**
     * a collection of objects recording the changes applied through a commmitStage
     */
    Collection.prototype.commitLog = [];

    /**
     * create a copy of an object and insert it into a stage
     */
    Collection.prototype.stage = function (stageName, obj) {
      var copy = JSON.parse(JSON.stringify(obj));
      this.getStage(stageName)[obj.$loki] = copy;
      return copy;
    };

    /**
     * re-attach all objects to the original collection, so indexes and views can be rebuilt
     * then create a message to be inserted in the commitlog
     */
    Collection.prototype.commitStage = function (stageName, message) {
      var stage = this.getStage(stageName),
        prop,
        timestamp = new Date().getTime();

      for (prop in stage) {

        this.update(stage[prop]);
        this.commitLog.push({
          timestamp: timestamp,
          message: message,
          data: JSON.parse(JSON.stringify(stage[prop]))
        });
      }
      this.stages[stageName] = {};
    };

    Collection.prototype.no_op = function () {
      return;
    };

    Collection.prototype.extract = function (field) {
      var i = 0,
        len = this.data.length,
        isDotNotation = isDeepProperty(field),
        result = [];
      for (i; i < len; i += 1) {
        result.push(deepProperty(this.data[i], field, isDotNotation));
      }
      return result;
    };

    Collection.prototype.max = function (field) {
      return Math.max.apply(null, this.extract(field));
    };

    Collection.prototype.min = function (field) {
      return Math.min.apply(null, this.extract(field));
    };

    Collection.prototype.maxRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = {
          index: 0,
          value: undefined
        },
        max;

      for (i; i < len; i += 1) {
        if (max !== undefined) {
          if (max < deepProperty(this.data[i], field, deep)) {
            max = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          max = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = max;
      return result;
    };

    Collection.prototype.minRecord = function (field) {
      var i = 0,
        len = this.data.length,
        deep = isDeepProperty(field),
        result = {
          index: 0,
          value: undefined
        },
        min;

      for (i; i < len; i += 1) {
        if (min !== undefined) {
          if (min > deepProperty(this.data[i], field, deep)) {
            min = deepProperty(this.data[i], field, deep);
            result.index = this.data[i].$loki;
          }
        } else {
          min = deepProperty(this.data[i], field, deep);
          result.index = this.data[i].$loki;
        }
      }
      result.value = min;
      return result;
    };

    Collection.prototype.extractNumerical = function (field) {
      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {
        return !(isNaN(n));
      });
    };

    Collection.prototype.avg = function (field) {
      return average(this.extractNumerical(field));
    };

    Collection.prototype.stdDev = function (field) {
      return standardDeviation(this.extractNumerical(field));
    };

    Collection.prototype.mode = function (field) {
      var dict = {},
        data = this.extract(field);
      data.forEach(function (obj) {
        if (dict[obj]) {
          dict[obj] += 1;
        } else {
          dict[obj] = 1;
        }
      });
      var max,
        prop, mode;
      for (prop in dict) {
        if (max) {
          if (max < dict[prop]) {
            mode = prop;
          }
        } else {
          mode = prop;
          max = dict[prop];
        }
      }
      return mode;
    };

    Collection.prototype.median = function (field) {
      var values = this.extractNumerical(field);
      values.sort(sub);

      var half = Math.floor(values.length / 2);

      if (values.length % 2) {
        return values[half];
      } else {
        return (values[half - 1] + values[half]) / 2.0;
      }
    };

    /**
     * General utils, including statistical functions
     */
    function isDeepProperty(field) {
      return field.indexOf('.') !== -1;
    }

    function parseBase10(num) {
      return parseFloat(num, 10);
    }

    function isNotUndefined(obj) {
      return obj !== undefined;
    }

    function add(a, b) {
      return a + b;
    }

    function sub(a, b) {
      return a - b;
    }

    function median(values) {
      values.sort(sub);
      var half = Math.floor(values.length / 2);
      return (values.length % 2) ? values[half] : ((values[half - 1] + values[half]) / 2.0);
    }

    function average(array) {
      return (array.reduce(add, 0)) / array.length;
    }

    function standardDeviation(values) {
      var avg = average(values);
      var squareDiffs = values.map(function (value) {
        var diff = value - avg;
        var sqrDiff = diff * diff;
        return sqrDiff;
      });

      var avgSquareDiff = average(squareDiffs);

      var stdDev = Math.sqrt(avgSquareDiff);
      return stdDev;
    }

    function deepProperty(obj, property, isDeep) {
      if (isDeep === false) {
        // pass without processing
        return obj[property];
      }
      var pieces = property.split('.'),
        root = obj;
      while (pieces.length > 0) {
        root = root[pieces.shift()];
      }
      return root;
    }

    function binarySearch(array, item, fun) {
      var lo = 0,
        hi = array.length,
        compared,
        mid;
      while (lo < hi) {
        mid = ((lo + hi) / 2) | 0;
        compared = fun.apply(null, [item, array[mid]]);
        if (compared === 0) {
          return {
            found: true,
            index: mid
          };
        } else if (compared < 0) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return {
        found: false,
        index: hi
      };
    }

    function BSonSort(fun) {
      return function (array, item) {
        return binarySearch(array, item, fun);
      };
    }

    function KeyValueStore() {}

    KeyValueStore.prototype = {
      keys: [],
      values: [],
      sort: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
      },
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      set: function (key, value) {
        var pos = this.bs(this.keys, key);
        if (pos.found) {
          this.values[pos.index] = value;
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, value);
        }
      },
      get: function (key) {
        return this.values[binarySearch(this.keys, key, this.sort).index];
      }
    };

    function UniqueIndex(uniqueField) {
      this.field = uniqueField;
      this.keyMap = {};
      this.lokiMap = {};
    }
    UniqueIndex.prototype.keyMap = {};
    UniqueIndex.prototype.lokiMap = {};
    UniqueIndex.prototype.set = function (obj) {
      if (obj[this.field] !== null && typeof (obj[this.field]) !== 'undefined') {
        if (this.keyMap[obj[this.field]]) {
          throw new Error('Duplicate key for property ' + this.field + ': ' + obj[this.field]);
        } else {
          this.keyMap[obj[this.field]] = obj;
          this.lokiMap[obj.$loki] = obj[this.field];
        }
      }
    };
    UniqueIndex.prototype.get = function (key) {
      return this.keyMap[key];
    };

    UniqueIndex.prototype.byId = function (id) {
      return this.keyMap[this.lokiMap[id]];
    };
    UniqueIndex.prototype.update = function (obj) {
      if (this.lokiMap[obj.$loki] !== obj[this.field]) {
        var old = this.lokiMap[obj.$loki];
        this.set(obj);
        // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)
        this.keyMap[old] = undefined;
      } else {
        this.keyMap[obj[this.field]] = obj;
      }
    };
    UniqueIndex.prototype.remove = function (key) {
      var obj = this.keyMap[key];
      if (obj !== null && typeof obj !== 'undefined') {
        this.keyMap[key] = undefined;
        this.lokiMap[obj.$loki] = undefined;
      } else {
        throw new Error('Key is not in unique index: ' + this.field);
      }
    };
    UniqueIndex.prototype.clear = function () {
      this.keyMap = {};
      this.lokiMap = {};
    };

    function ExactIndex(exactField) {
      this.index = {};
      this.field = exactField;
    }

    // add the value you want returned to the key in the index
    ExactIndex.prototype = {
      set: function add(key, val) {
        if (this.index[key]) {
          this.index[key].push(val);
        } else {
          this.index[key] = [val];
        }
      },

      // remove the value from the index, if the value was the last one, remove the key
      remove: function remove(key, val) {
        var idxSet = this.index[key];
        for (var i in idxSet) {
          if (idxSet[i] == val) {
            idxSet.splice(i, 1);
          }
        }
        if (idxSet.length < 1) {
          this.index[key] = undefined;
        }
      },

      // get the values related to the key, could be more than one
      get: function get(key) {
        return this.index[key];
      },

      // clear will zap the index
      clear: function clear(key) {
        this.index = {};
      }
    };

    function SortedIndex(sortedField) {
      this.field = sortedField;
    }

    SortedIndex.prototype = {
      keys: [],
      values: [],
      // set the default sort
      sort: function (a, b) {
        return (a < b) ? -1 : ((a > b) ? 1 : 0);
      },
      bs: function () {
        return new BSonSort(this.sort);
      },
      // and allow override of the default sort
      setSort: function (fun) {
        this.bs = new BSonSort(fun);
      },
      // add the value you want returned  to the key in the index
      set: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort);
        if (pos.found) {
          this.values[pos.index].push(value);
        } else {
          this.keys.splice(pos.index, 0, key);
          this.values.splice(pos.index, 0, [value]);
        }
      },
      // get all values which have a key == the given key
      get: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        if (bsr.found) {
          return this.values[bsr.index];
        } else {
          return [];
        }
      },
      // get all values which have a key < the given key
      getLt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos--;
        return this.getAll(key, 0, pos);
      },
      // get all values which have a key > the given key
      getGt: function (key) {
        var bsr = binarySearch(this.keys, key, this.sort);
        var pos = bsr.index;
        if (bsr.found) pos++;
        return this.getAll(key, pos, this.keys.length);
      },

      // get all vals from start to end
      getAll: function (key, start, end) {
        var results = [];
        for (var i = start; i < end; i++) {
          results = results.concat(this.values[i]);
        }
        return results;
      },
      // just in case someone wants to do something smart with ranges
      getPos: function (key) {
        return binarySearch(this.keys, key, this.sort);
      },
      // remove the value from the index, if the value was the last one, remove the key
      remove: function (key, value) {
        var pos = binarySearch(this.keys, key, this.sort).index;
        var idxSet = this.values[pos];
        for (var i in idxSet) {
          if (idxSet[i] == value) idxSet.splice(i, 1);
        }
        if (idxSet.length < 1) {
          this.keys.splice(pos, 1);
          this.values.splice(pos, 1);
        }
      },
      // clear will zap the index
      clear: function () {
        this.keys = [];
        this.values = [];
      }
    };


    Loki.Collection = Collection;
    Loki.KeyValueStore = KeyValueStore;
    return Loki;
  }());

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./loki-indexed-adapter.js":18,"fs":15}],20:[function(require,module,exports){
//! moment.js
//! version : 2.11.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             if (this.isValid() && other.isValid()) {
                 return other < this ? this : other;
             } else {
                 return valid__createInvalid();
             }
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return +this > +localInput;
        } else {
            return +localInput < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return +this < +localInput;
        } else {
            return +this.clone().endOf(units) < +localInput;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return +this === +localInput;
        } else {
            inputMs = +localInput;
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // JSON.stringify(new Date(NaN)) === 'null'
        return this.isValid() ? this.toISOString() : 'null';
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        // console.log("got", weekYear, week, weekday, "set", date.toISOString());
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = local__createLocal([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = getSet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = getSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto._months           = defaultLocaleMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto._monthsRegex      = defaultMonthsRegex;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.11.1';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],21:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],22:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Samsara"] = factory();
	else
		root["Samsara"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        Core: __webpack_require__(1),
	        DOM: __webpack_require__(32),
	        Events: __webpack_require__(39),
	        Inputs: __webpack_require__(40),
	        Layouts: __webpack_require__(50),
	        Streams: __webpack_require__(58),
	        Transitions: __webpack_require__(59)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        Engine: __webpack_require__(2),
	        LayoutNode: __webpack_require__(8),
	        SizeNode: __webpack_require__(17),
	        Timer: __webpack_require__(20),
	        Transform: __webpack_require__(21),
	        Transitionable: __webpack_require__(22),
	        View: __webpack_require__(26)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Modified work copyright © 2015 David Valdman */
	// TODO: cancel RAF when asleep
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var State = __webpack_require__(3);
	    var postTickQueue = __webpack_require__(4);
	    var preTickQueue = __webpack_require__(5);
	    var dirtyQueue = __webpack_require__(6);
	    var tickQueue = __webpack_require__(7);

	    var rafId = 0;

	    /**
	     * Engine is a singleton object that is required to run a Samsara application.
	     *  It is the "heartbeat" of the application, managing the batching of streams
	     *  and creating `RootNodes` and `Contexts` to begin render trees.
	     *
	     *  It also listens and can respond to DOM events on the HTML `<body>` tag
	     *  and `window` object. For instance the `resize` event.
	     *
	     * @class Engine
	     * @namespace Core
	     * @static
	     * @private
	     * @uses Core.EventHandler
	     */
	    var Engine = {};

	    /**
	     * Updates by a single frame of the application by looping through all function queues.
	     *  This is repeatedly called within a requestAnimationFrame loop until the application
	     *  is receiving no layout changes. At this point the requestAnimationFrame will be
	     *  canceled until the next change.
	     *
	     * @private
	     * @method step
	     */
	    Engine.step = function step() {
	        // browser events and their handlers happen before rendering begins
	        while (preTickQueue.length) (preTickQueue.shift())();

	        // tick signals base event flow coming in
	        State.set(State.STATES.UPDATE);

	        for (var i = 0; i < tickQueue.length; i++) tickQueue[i]();

	        // post tick is for resolving larger components from their incoming signals
	        while (postTickQueue.length) (postTickQueue.shift())();

	        State.set(State.STATES.END);

	        while (dirtyQueue.length) (dirtyQueue.shift())();

	        State.set(State.STATES.START);
	    };

	    /**
	     * Initiate the Engine's request animation frame loop.
	     *
	     * @method start
	     * @static
	     */
	    Engine.start = function start(){
	        Engine.step();
	        rafId = window.requestAnimationFrame(start);
	    };

	    module.exports = Engine;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var STATE = {
	        NONE : -1,
	        START : 0,
	        UPDATE : 1,
	        END : 2
	    };

	    var currentState = STATE.START;

	    /**
	     * SUE specified the global state of the application, whether it is in a
	     *  `start`, `update` or `end` state. This is necessary for coordinating
	     *  `resize` events with `start`, `update`, `end` states in stream.
	     *
	     * @class SUE
	     * @namespace Core
	     * @static
	     * @private
	     */
	    var SUE = {};

	    SUE.STATES = STATE;

	    SUE.set = function set(state){
	        currentState = state;
	    };

	    SUE.get = function get(){
	        return currentState;
	    };

	    module.exports = SUE;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    /**
	     * Queue that batches `update` events.
	     *  This queue is traversed after the `preTickQueue` but before `dirtQueue`
	     *  by the Engine.
	     *
	     *  @private
	     */

	    module.exports = [];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    /**
	     * Queue that batches `start` events.
	     *  This queue is traversed first (but after DOM events are executed) by the Engine.
	     *
	     *  @private
	     */

	    module.exports = [];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    /**
	     * Queue that batches `end` and `dirty` events.
	     *  This queue is traversed after the `postTickQueue` by the Engine.
	     *
	     *  @private
	     */

	    module.exports = [];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    /**
	     * This queue is executed before the postTickQueue and after the preTickQueue.
	     *  however, it differs in that the Engine does not clear the queue.
	     *  This must be done manually.
	     *
	     *  @private
	     */

	    module.exports = [];
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);
	    var Stream = __webpack_require__(15);
	    var Observable = __webpack_require__(16);

	    /**
	     * Encapsulates a stream of layout data (transform, origin, align, opacity).
	     *  Listens on start/update/end events, batches them, and emits them downstream
	     *  to descendant layout nodes.
	     *
	     *  @example
	     *
	     *      var context = Context();
	     *
	     *      var surface = new Surface({
	     *          size : [100,100],
	     *          properties : {background : 'red'}
	     *      });
	     *
	     *      var opacity = new Transitionable(1);
	     *
	     *      var layout = new LayoutNode({
	     *          transform : Transform.translateX(100),
	     *          opacity : opacity
	     *      });
	     *
	     *      context.add(layout).add(surface);
	     *      context.mount(document.body)
	     *
	     *      opacity.set(0, {duration : 1000});
	     *
	     * @class LayoutNode
	     * @constructor
	     * @namespace Core
	     * @private
	     * @param sources {Object}                          Object of layout sources
	     * @param [sources.transform] {Stream|Transform}    Transform source
	     * @param [sources.align] {Stream|Array}            Align source
	     * @param [sources.origin] {Stream|Array}           Origin source
	     * @param [sources.opacity] {Stream|Number}         Opacity source
	     */
	    function LayoutNode(sources) {
	        this.stream = _createStream(sources);
	        EventHandler.setOutputHandler(this, this.stream);
	    }

	    // Enumeration of types of layout properties
	    LayoutNode.KEYS = {
	        transform : 'transform',
	        origin : 'origin',
	        align : 'align',
	        opacity : 'opacity'
	    };

	    /**
	     * Introduce new data streams to the layout node in {key : value} pairs.
	     *  Here the `key` is one of "transform", "origin", "align" or "opacity".
	     *  The `value` is either a stream, or a simple type like a `Number` or `Array`.
	     *  Simple types will be wrapped in an `Observerable` to emit appropriate events.
	     *
	     * @method set
	     * @param sources {Object}      Object of data sources
	     */
	    LayoutNode.prototype.set = function(sources){
	        // TODO: be able to overwrite streams. Not only add
	        for (var key in sources){
	            var value = sources[key];

	            var source = (value instanceof SimpleStream)
	                ? value
	                : new Observable(value);

	            this.stream.addStream(key, source);
	        }
	    };

	    function _createStream(sources){
	        for (var key in sources){
	            var value = sources[key];
	            if (typeof value === 'number' || value instanceof Array){
	                var source = new Observable(value);
	                sources[key] = source;
	            }
	        }
	        return Stream.merge(sources);
	    }

	    module.exports = LayoutNode;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventEmitter = __webpack_require__(10);

	    /**
	     * EventHandler extends EventEmitter to provide subscription methods.
	     *  It also includes helper methods on the constructor for setting up Controllers and Views
	     *  with input and output emitters.
	     *
	     *  @example
	     *
	     *      var eventHandlerA = new EventHandler();
	     *      var eventHandlerB = new EventHandler();
	     *
	     *      eventHandlerB.subscribe(eventHandlerA);
	     *
	     *      eventHandlerB.on('name', function(payload){
	     *          console.log(payload) // {data : 0}
	     *      });
	     *
	     *      eventHandlerA.emit('name', {data : 0});
	     *
	     * @class EventHandler
	     * @namespace Events
	     * @extends Events.EventEmitter
	     * @constructor
	     */
	    function EventHandler() {
	        EventEmitter.apply(this, arguments);

	        this.upstream = []; // upstream event handlers
	        this.upstreamListeners = {}; // upstream listeners
	    }

	    EventHandler.prototype = Object.create(EventEmitter.prototype);
	    EventHandler.prototype.constructor = EventHandler;

	    /**
	     * Constructor helper method. Assign an event handler to receive an object's input events.
	     *  Defines `trigger`, `subscribe` and `unsubscribe` methods on the class instance.
	     *
	     * @method setInputHandler
	     * @static
	     * @param object {Object}           Class instance
	     * @param handler {EventHandler}    EventHandler representing an input source
	     */
	    EventHandler.setInputHandler = function setInputHandler(object, handler) {
	        object.trigger = handler.trigger.bind(handler);
	        object.subscribe = handler.subscribe.bind(handler);
	        object.unsubscribe = handler.unsubscribe.bind(handler);
	    };

	    /**
	     * Constructor helper method. Assign an event handler to emit an object's output events.
	     *  Defines `emit`, `on` and `off` methods on the class instance.
	     *
	     * @method setOutputHandler
	     * @static
	     * @param object {Object}           Object to provide on, off and emit methods
	     * @param handler {EventHandler}    Handler assigned event handler
	     */
	    EventHandler.setOutputHandler = function setOutputHandler(object, handler) {
	        handler.bindThis(object);
	        object.emit = handler.emit.bind(handler);
	        object.on = handler.on.bind(handler);
	        object.off = handler.off.bind(handler);
	    };

	    /**
	     * Constructor helper method. Given an events dictionary of {eventName : handler} pairs, attach them to
	     *  a provided input handler for an object.
	     *
	     * @method setInputEvents
	     * @static
	     * @private
	     * @param object {Object}           Object to provide on, off and emit methods
	     * @param handler {EventHandler}    Handler assigned event handler
	     */
	    EventHandler.setInputEvents = function setInputEvents(object, events, handlerIn){
	        for (var key in events) {
	            var handlerName = events[key];
	            var handler = (typeof handlerName === 'string')
	                ? object[handlerName]
	                : handlerName;
	            if (handler) handlerIn.on(key, handler.bind(object));
	        }
	    };

	    /**
	     * Adds a handler to the `type` channel which will be executed on `emit`.
	     *  Extends EventEmitter's `on` method.
	     *
	     * @method on
	     * @param type {String}             Event channel name
	     * @param handler {Function}        Handler
	     */
	    EventHandler.prototype.on = function on(type, handler) {
	        EventEmitter.prototype.on.apply(this, arguments);
	        if (!(type in this.upstreamListeners)) {
	            var upstreamListener = this.trigger.bind(this, type);
	            this.upstreamListeners[type] = upstreamListener;
	            for (var i = 0; i < this.upstream.length; i++) {
	                this.upstream[i].on(type, upstreamListener);
	            }
	        }
	    };

	    /**
	     * Listen for events from an an upstream source.
	     *
	     * @method subscribe
	     * @param source {EventEmitter} Event source
	     */
	    EventHandler.prototype.subscribe = function subscribe(source) {
	        var index = this.upstream.indexOf(source);
	        if (index < 0) {
	            this.upstream.push(source);
	            for (var type in this.upstreamListeners) {
	                source.on(type, this.upstreamListeners[type]);
	            }
	        }
	        return source;
	    };

	    /**
	     * Stop listening to events from an upstream source.
	     *  Undoes work of `subscribe`.
	     *
	     * @method unsubscribe
	     * @param source {EventEmitter} Event source
	     */
	    EventHandler.prototype.unsubscribe = function unsubscribe(source) {
	        var index = this.upstream.indexOf(source);
	        if (index >= 0) {
	            this.upstream.splice(index, 1);
	            for (var type in this.upstreamListeners) {
	                source.off(type, this.upstreamListeners[type]);
	            }
	        }
	        return source;
	    };

	    module.exports = EventHandler;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    /**
	     * EventEmitter represents an asynchronous channel for broadcasting and receiving events.
	     *
	     * @example
	     *
	     *      var eventEmitter = new EventEmitter();
	     *
	     *      eventEmitter.on('send', function(payload){
	     *          console.log(payload) // {data : 0}
	     *      });
	     *
	     *      // sometime later...
	     *      eventEmitter.emit('send', {data : 0});
	     *
	     * @class EventEmitter
	     * @namespace Events
	     * @constructor
	     */
	    function EventEmitter() {
	        this.listeners = {};
	        this._owner = this;
	    }

	    /**
	     * Broadcast an event on the `type` channel with an optional payload. This will call the handlers
	     *  of all EventEmitters listening on the `type` channel with the (optional) data payload
	     *  as its argument.
	     *
	     * @method emit
	     *
	     * @param type {String}     Channel name
	     * @param data {Object}     Payload
	     */
	    EventEmitter.prototype.emit = function emit(type, data) {
	        if (data === false) return; // do not propagate
	        var handlers = this.listeners[type];
	        if (handlers) {
	            for (var i = 0; i < handlers.length; i++)
	                handlers[i].call(this._owner, data);
	        }
	    };

	    /**
	     * Alias for emit.
	     *
	     * @method trigger
	     */
	    EventEmitter.prototype.trigger = EventEmitter.prototype.emit;


	    /**
	     * Adds a handler to the `type` channel which will be executed on `emit`.
	     *
	     * @method on
	     * @param type {String}         Channel name
	     * @param handler {Function}    Callback
	     */
	    EventEmitter.prototype.on = function on(type, handler) {
	        if (!(type in this.listeners)) this.listeners[type] = [];
	        this.listeners[type].push(handler);
	    };

	    /**
	     * Behaves like `EventEmitter.prototype.on`, except the handler is only executed once.
	     *
	     * @method once
	     * @param type {String}         Event type key (for example, 'click')
	     * @param handler {Function}    Callback
	     */
	    EventEmitter.prototype.once = function once(type, handler){
	        var onceHandler = function(){
	            handler.apply(this, arguments);
	            EventEmitter.prototype.off.call(this, type, onceHandler);
	        }.bind(this);
	        this.on(type, onceHandler);
	    };

	   /**
	     * Removes the `handler` from the `type` channel.
	     *   This undoes the work of `on`.
	     *
	     * @method off
	     * @param type {String}         Channel name
	     * @param handler {Function}    Callback
	     */
	    EventEmitter.prototype.off = function off(type, handler) {
	        if (!type) {
	            this.listeners = {};
	            return;
	        }

	        var listener = this.listeners[type];
	        if (listener !== undefined) {
	            if (!handler) this.listeners[type] = []; // remove all listeners of given type
	            else {
	                var index = listener.indexOf(handler);
	                if (index >= 0) listener.splice(index, 1);
	            }
	        }
	    };

	    /**
	     * A convenience method to bind the provided object to all added handlers.
	     *
	     * @method bindThis
	     * @param owner {Object}        Bound `this` context
	     */
	    EventEmitter.prototype.bindThis = function bindThis(owner) {
	        this._owner = owner;
	    };

	    module.exports = EventEmitter;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var EventMapper = __webpack_require__(12);
	    var EventFilter = __webpack_require__(13);
	    var EventSplitter = __webpack_require__(14);

	    /**
	     * A SimpleStream wraps an EventHandler and provides convenience
	     *  methods of `map`, `filter`, `split`, and `pluck` to
	     *  transform one stream into another.
	     *
	     * @example
	     *
	     * @class SimpleStream
	     * @extends Core.EventHandler
	     * @private
	     * @namespace Streams
	     * @constructor
	     */
	    function SimpleStream(){
	        EventHandler.call(this);
	    }

	    SimpleStream.prototype = Object.create(EventHandler.prototype);
	    SimpleStream.prototype.constructor = SimpleStream;

	    /**
	     * Map converts the current stream into a new stream
	     *  with a modified (mapped) data payload.
	     *
	     * @method map
	     * @param mapperFn {Function}   Function to map event payload
	     */
	    SimpleStream.prototype.map = function(mapperFn){
	        var stream = new SimpleStream();
	        var mapper = new EventMapper(mapperFn);
	        stream.subscribe(mapper).subscribe(this);
	        return stream;
	    };

	    /**
	     * Filter converts the current stream into a new stream
	     *  that only emits if the filter condition is satisfied.
	     *  The function should return a Boolean.
	     *
	     * @method filter
	     * @param filterFn {Function}   Function to filter event payload
	     */
	    SimpleStream.prototype.filter = function(filterFn){
	        var filter = new EventFilter(filterFn);
	        var filteredStream = new SimpleStream();
	        filteredStream.subscribe(filter).subscribe(this);
	        return filteredStream;
	    };

	    /**
	     * Split maps one of several streams based on custom logic.
	     *  The function should return an EventEmitter.
	     *
	     * @method split
	     * @param splitterFn {Function}  Splitter function
	     */
	    SimpleStream.prototype.split = function(splitterFn){
	        var splitter = new EventSplitter(splitterFn);
	        var splitStream = new SimpleStream();
	        splitStream.subscribe(splitter).subscribe(this);
	        return splitStream;
	    };

	    /**
	     * Pluck is an opinionated mapper. It projects a Stream
	     *  onto one of its return values.
	     *
	     *  Useful if a Stream returns an array or an object.
	     *
	     * @method pluck
	     * @param key {String|Number}   Key to project event payload onto
	     */
	    SimpleStream.prototype.pluck = function(key){
	        return this.map(function(value){
	            return value[key];
	        });
	    };

	    //TODO: can this be inherited by other streams?
	    SimpleStream.merge = function(){};

	    /**
	     * Lift is like map, except it maps several event sources,
	     *  not only one.
	     *
	     *  @example
	     *
	     *      var liftedStream = SimpleStream.lift(function(payload1, payload2){
	     *          return payload1 + payload2;
	     *      }, [stream2, stream2]);
	     *
	     *      liftedStream.on('name'), function(data){
	     *          // data = 3;
	     *      });
	     *
	     *      stream2.emit('name', 1);
	     *      stream2.emit('name', 2);
	     *
	     * @method lift
	     * @static
	     * @param map {Function}            Function to map stream payloads
	     * @param streams {Array|Object}    Stream sources
	     */
	    SimpleStream.lift = function(map, streams){
	        //TODO: fix comma separated arguments
	        var mergedStream = (streams instanceof Array)
	            ? this.merge(streams)
	            : this.merge.apply(null, Array.prototype.splice.call(arguments, 1));

	        var mappedStream = new EventMapper(function liftMap(data){
	            return map.apply(null, data);
	        });

	        var liftedStream = new SimpleStream();
	        liftedStream.subscribe(mappedStream).subscribe(mergedStream);

	        return liftedStream;
	    };

	    module.exports = SimpleStream;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);

	    /**
	     * EventMapper modifies the data payload of an event based on
	     *  a provided function.
	     *
	     *  Note: it does not modify the event's `type`.
	     *
	     *  @example
	     *
	     *      var eventMapper = new EventMapper(function(payload){
	     *          return payload.x + payload.y
	     *      });
	     *
	     *      var eventEmitter = new EventEmitter();
	     *
	     *      eventMapper.subscribe(eventEmitter);
	     *
	     *      eventMapper.on('name', function(value){
	     *          alert(value);
	     *      });
	     *
	     *      eventEmitter.emit('name', {x : 1, y : 2}); // alerts 3
	     *
	     * @class EventMapper
	     * @namespace Events
	     * @constructor
	     * @param map {Function}  Function to modify the event payload
	     */
	    function EventMapper(map) {
	        EventHandler.call(this);
	        this._mappingFunction = map;
	    }

	    EventMapper.prototype = Object.create(EventHandler.prototype);
	    EventMapper.prototype.constructor = EventMapper;

	    /**
	     * Emit mapped event.
	     *
	     * @method emit
	     * @param type {String} Channel name
	     * @param data {Object} Payload
	     */
	    EventMapper.prototype.emit = function emit(type, data) {
	        var mappedData = this._mappingFunction(data);
	        EventHandler.prototype.emit.call(this, type, mappedData);
	    };

	    /**
	     * Alias of emit.
	     *
	     * @method trigger
	     * @param type {String} Channel name
	     * @param data {Object} Payload
	     */
	    EventMapper.prototype.trigger = EventMapper.prototype.emit;

	    module.exports = EventMapper;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);

	    /**
	     * EventFilter regulates the broadcasting of events based on
	     *  a specified condition prescribed by a provided function
	     *  with the signature `(type, data) -> Boolean`
	     *
	     *  @example
	     *
	     *      var eventFilter = new EventFilter(function(type, payload){
	     *          return (payload.value == 0);
	     *      });
	     *
	     *      var eventEmitter = new EventEmitter();
	     *
	     *      eventFilter.subscribe(eventEmitter);
	     *
	     *      eventFilter.on('click', function(data){
	     *          alert('fired');
	     *      });
	     *
	     *      eventEmitter.emit('click', {value : 0}); // fired
	     *      eventEmitter.emit('click', {value : 1}); // doesn't fire
	     *
	     * @class EventFilter
	     * @namespace Events
	     * @constructor
	     * @param filter {Function}  Function returning a Boolean
	     */
	    function EventFilter(filter) {
	        EventHandler.call(this);
	        this._condition = filter;
	    }
	    EventFilter.prototype = Object.create(EventHandler.prototype);
	    EventFilter.prototype.constructor = EventFilter;

	    /**
	     * Emit event if the condition is satisfied.
	     *
	     * @method emit
	     * @param type {String} Channel name
	     * @param data {Object} Payload
	     */
	    EventFilter.prototype.emit = function emit(type, data) {
	        if (!this._condition(type, data)) return;
	        EventHandler.prototype.emit.apply(this, arguments);
	    };

	    /**
	     * Alias of emit.
	     *
	     * @method trigger
	     * @param type {String} Channel name
	     * @param data {Object} Payload
	     */
	    EventFilter.prototype.trigger = EventFilter.prototype.emit;

	    module.exports = EventFilter;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);

	    /**
	     * EventSplitter routes events to various event destinations
	     *  based on custom logic. The return of the provided splitter
	     *  function should be of type EventEmitter.
	     *
	     *  @example
	     *
	     *      var eventEmitter = new EventEmitter();
	     *      var eventEmitterX = new eventEmitter();
	     *      var eventEmitterY = new eventEmitter();
	     *
	     *      var eventSplitter = new EventSplitter(function(payload){
	     *          return (payload.x > payload.y)
	     *              ? eventEmitterX;
	     *              : eventEmitterY;
	     *      });
	     *
	     *      eventSplitter.subscribe(eventEmitter);
	     *
	     *      eventEmitterX.on('move', function(){
	     *          console.log('x is bigger')
	     *      });
	     *
	     *      eventEmitterY.on('move', function(){
	     *          console.log('y is bigger')
	     *      })
	     *
	     *      eventEmitter.emit('move', {x : 3, y : 2}); // x is bigger
	     *
	     * @class EventSplitter
	     * @namespace Events
	     * @constructor
	     * @param splitter {Function}
	     */
	    function EventSplitter(splitter) {
	        EventHandler.call(this);
	        this._splitter = splitter;
	    }
	    EventSplitter.prototype = Object.create(EventHandler.prototype);
	    EventSplitter.prototype.constructor = EventSplitter;

	    /**
	     * Emit event.
	     *
	     * @method emit
	     * @param type {String} Channel name
	     * @param data {Object} Payload
	     */
	    EventSplitter.prototype.emit = function emit(type, data) {
	        var target = this._splitter.apply(this, arguments);
	        if (target && target.emit instanceof Function)
	            target.emit(type, data);
	    };

	    /**
	     * Alias of emit.
	     *
	     * @method trigger
	     * @param type {String} Channel name
	     * @param data {Object} Payload
	     */
	    EventSplitter.prototype.trigger = EventSplitter.prototype.emit;

	    module.exports = EventSplitter;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var EventMapper = __webpack_require__(12);
	    var SimpleStream = __webpack_require__(11);

	    var preTickQueue = __webpack_require__(5);
	    var postTickQueue = __webpack_require__(4);
	    var dirtyQueue = __webpack_require__(6);
	    var State = __webpack_require__(3);

	    var EVENTS = {
	        START : 'start',
	        UPDATE : 'update',
	        END : 'end',
	        RESIZE : 'resize'
	    };

	    /**
	     * Stream listens to `resize`, `start`, `update` and `end` events and
	     *  emits `start`, `update` and `end` events. `Resize` events get
	     *  unified with `start`, `update`, and `end` events depending on
	     *  when they are fired within Samsara's engine cycle.
	     *
	     *  If listening to multiple sources, Stream emits a single event per
	     *  Engine cycle.
	     *
	     *  @example
	     *
	     *      var position = new Transitionable([0,0]);
	     *      var size = new EventEmitter();
	     *
	     *      var translationStream = Stream.lift(function(position, size){
	     *          var translation = [
	     *              position[0] + size[0],
	     *              position[1] + size[1]
	     *          ];
	     *
	     *          return Transform.translate(translation);
	     *      }, [positionStream, sizeStream]);
	     *
	     *      translationStream.on('start', function(transform){
	     *          console.log(transform);
	     *      });
	     *
	     *      translationStream.on('update', function(transform){
	     *          console.log(transform);
	     *      });
	     *
	     *      translationStream.on('end', function(transform){
	     *          console.log(transform);
	     *      });
	     *
	     *      position.set([100, 50], {duration : 500});
	     *      size.emit('resize', [100,100]);
	     *
	     * @class Stream
	     * @extends Streams.SimpleStream
	     * @namespace Streams
	     * @param [options] {Object}            Options
	     * @param [options.start] {Function}    Custom logic to map the `start` event
	     * @param [options.update] {Function}   Custom logic to map the `update` event
	     * @param [options.end] {Function}      Custom logic to map the `end` event
	     * @constructor
	     */
	    function Stream(options){
	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();
	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        var counter = 0;
	        var isUpdating = false;
	        var dirtyStart = false;
	        var dirtyEnd = false;

	        function start(data){
	            var payload = options && options.start ? options.start(data) : data;
	            if (payload !== false) this.emit(EVENTS.START, payload);
	            dirtyStart = false;
	        }

	        function update(data){
	            var payload = options && options.update ? options.update(data) : data;
	            if (payload !== false) this.emit(EVENTS.UPDATE, payload);
	        }

	        function end(data){
	            var payload = options && options.end ? options.end(data) : data;
	            if (payload !== false) this.emit(EVENTS.END, payload);
	            dirtyEnd = false;
	        }

	        this._eventInput.on(EVENTS.START, function(data){
	            counter++;
	            if (dirtyStart || isUpdating) return false;
	            dirtyStart = true;
	            preTickQueue.push(start.bind(this, data));
	        }.bind(this));

	        this._eventInput.on(EVENTS.UPDATE, function(data){
	            isUpdating = true;
	            postTickQueue.push(update.bind(this, data));
	        }.bind(this));

	        this._eventInput.on(EVENTS.END, function(data){
	            counter--;
	            if (isUpdating && counter > 0) {
	                update.call(this, data);
	                return false;
	            }
	            isUpdating = false;
	            if (dirtyEnd) return;
	            dirtyEnd = true;
	            dirtyQueue.push(end.bind(this, data));
	        }.bind(this));

	        this._eventInput.on(EVENTS.RESIZE, function(data){
	            switch (State.get()){
	                case State.STATES.START:
	                    this.trigger(EVENTS.START, data);
	                    break;
	                case State.STATES.UPDATE:
	                    this.trigger(EVENTS.UPDATE, data);
	                    break;
	                case State.STATES.END:
	                    this.trigger(EVENTS.END, data);
	                    break;
	            }
	        }.bind(this));
	    }

	    Stream.prototype = Object.create(SimpleStream.prototype);
	    Stream.prototype.constructor = Stream;

	    /**
	     * Extends SimpleStream.lift
	     *
	     * @static
	     * @return
	     */
	    Stream.lift = SimpleStream.lift;

	    /**
	     * Batches events for provided object of streams in
	     *  {key : stream} pairs. Emits one event per Engine cycle.
	     *
	     * @method merge
	     * @static
	     * @param streams {Object}  Dictionary of `resize` streams
	     */
	    Stream.merge = function(streamObj){
	        var mergedStream = new Stream();
	        var mergedData = (streamObj instanceof Array) ? [] : {};

	        mergedStream.addStream = function(key, stream){
	            var mapper = (function(key){
	                return new EventMapper(function(data){
	                    mergedData[key] = data;
	                    return mergedData;
	                });
	            })(key);

	            mergedStream.subscribe(mapper).subscribe(stream);
	        };

	        for (var key in streamObj){
	            var stream = streamObj[key];
	            mergedStream.addStream(key, stream);
	        }

	        return mergedStream;
	    };

	    module.exports = Stream;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	/* Documentation in progress. May be outdated. */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var SimpleStream = __webpack_require__(11);
	    var preTickQueue = __webpack_require__(5);
	    var dirtyQueue = __webpack_require__(6);

	    /**
	     * An Observable is a stream for events set discretely in time, as opposed to continuously.
	     *  It emits appropriate `start` and `end` events upon calling the `set` method.
	     *
	     * @class Observable
	     * @constructor
	     * @private
	     * @extends Streams.Stream
	     * @param value {Number, String, Array, Object} Value
	     */
	    function Observable(value){
	        SimpleStream.call(this);
	        this.value = value;

	        if (value !== undefined) this.set(value);
	    }

	    Observable.prototype = Object.create(SimpleStream.prototype);
	    Observable.prototype.constructor = Observable;

	    /**
	     * Getter for the provided value.
	     *
	     * @method get
	     * @return {Number, String, Array, Object}
	     */
	    Observable.prototype.get = function(){
	        return this.value;
	    };

	    /**
	     * Setter for the provided value.
	     *
	     * @method set
	     * @param value {Number, String, Array, Object} Value
	     */
	    Observable.prototype.set = function(value){
	        var self = this;
	        preTickQueue.push(function(){
	            self.value = value;
	            self.emit('start', value);

	            dirtyQueue.push(function(){
	                self.emit('end', value);
	            });
	        });
	    };

	    module.exports = Observable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);
	    var ResizeStream = __webpack_require__(18);
	    var SizeObservable = __webpack_require__(19);

	    /**
	     * Encapsulates a stream of size data (size, proportions, margins).
	     *  Listens on start/update/end events, batches them, and emits resize events downstream
	     *  to descendant size nodes.
	     *
	     *  Size can be defined with height and width given numerically, but
	     *  they can also be:
	     *
	     *  ```
	     *      `undefined` - takes the parent value
	     *      `true`      - takes the DOM calculated value
	     *      `false`     - value defined by setting an aspect ratio
	     *  ```
	     *
	     *  @example
	     *
	     *      var context = Context();
	     *
	     *      var surface = new Surface({
	     *          size : [100,100],
	     *          properties : {background : 'red'}
	     *      });
	     *
	     *      var sizeNode = new SizeNode({
	     *          size : [100, undefined],
	     *          margins : [50, 50]
	     *      });
	     *
	     *      context.add(sizeNode).add(surface);
	     *      context.mount(document.body)
	     *
	     * @class SizeNode
	     * @namespace Core
	     * @constructor
	     * @private
	     * @param sources {Object}                      Object of size sources
	     * @param [sources.size] {Stream|Array}         Size source
	     * @param [sources.margin] {Stream|Array}       Margin source
	     * @param [sources.proportions] {Stream|Array}  Proportions source
	     * @param [sources.aspectRatio] {Stream|Number} Aspect ratio source
	     */
	    function SizeNode(sources) {
	        this.stream = _createStream(sources);
	        EventHandler.setOutputHandler(this, this.stream);

	        this.stream._eventInput.on('start', function(data){
	            this.stream.trigger('resize', data);
	        }.bind(this));

	        this.stream._eventInput.on('update', function(data){
	            this.stream.trigger('resize', data);
	        }.bind(this));

	        this.stream._eventInput.on('end', function(data){
	            this.stream.trigger('resize', data);
	        }.bind(this));
	    }

	    // Enumeration of types of size properties
	    SizeNode.KEYS = {
	        size : 'size',
	        proportions : 'proportions',
	        margins : 'margins',
	        aspectRatio : 'aspectRatio'
	    };

	    /**
	     * Introduce new data streams to the size node in {key : value} pairs.
	     *  Here the `key` is one of "size", "proportions" or "marins".
	     *  The `value` is either a stream, or a simple type like a `Number` or `Array`.
	     *  Simple types will be wrapped in an `Observerable` to emit appropriate events.
	     *
	     * @method set
	     * @param obj {Object}      Object of data sources
	     */
	    SizeNode.prototype.set = function(obj){
	        // TODO: be able to overwrite streams. Not only add
	        for (var key in obj){
	            var value = obj[key];

	            var source = (value instanceof SimpleStream)
	                ? value
	                : new SizeObservable(value);

	            this.stream.addStream(key, source);
	        }
	    };

	    function _createStream(sources){
	        for (var key in sources){
	            var value = sources[key];
	            if (typeof value == 'number' || value instanceof Array){
	                var source = new SizeObservable(value);
	                sources[key] = source;
	            }
	        }
	        return ResizeStream.merge(sources);
	    }

	    module.exports = SizeNode;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var SimpleStream = __webpack_require__(11);
	    var EventMapper = __webpack_require__(12);
	    var EventHandler = __webpack_require__(9);

	    var preTickQueue = __webpack_require__(5);
	    var postTickQueue = __webpack_require__(4);
	    var dirtyQueue = __webpack_require__(6);
	    var State = __webpack_require__(3);

	    var EVENTS = {
	        RESIZE : 'resize'
	    };

	    /**
	     * ResizeStream is a stream that listens to and emits `resize` events.
	     *
	     * @class ResizeStream
	     * @private
	     * @extends Streams.Stream
	     * @namespace Streams
	     * @param [options] {Object}            Options
	     * @param [options.resize] {Function}   Custom logic to map the `resize` event
	     * @constructor
	     */
	    function ResizeStream(options){
	        var dirtyResize = false;

	        function resize(data){
	            var payload = (options && options.resize)
	                ? options.resize(data)
	                : data;
	            this.emit(EVENTS.RESIZE, payload);
	            dirtyResize = false;
	        }

	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();
	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._eventInput.on(EVENTS.RESIZE, function(data){
	            if (!dirtyResize) {
	                var queue;
	                switch (State.get()){
	                    case State.STATES.START:
	                        queue = preTickQueue;
	                        break;
	                    case State.STATES.UPDATE:
	                        queue = postTickQueue;
	                        break;
	                    case State.STATES.END:
	                        queue = dirtyQueue;
	                        break;
	                }
	                queue.push(resize.bind(this, data));
	            }
	            dirtyResize = true;
	        }.bind(this));
	    }

	    ResizeStream.prototype = Object.create(SimpleStream.prototype);
	    ResizeStream.prototype.constructor = ResizeStream;

	    /**
	     * Extends SimpleStream.lift
	     *
	     * @method lift
	     * @static
	     */
	    ResizeStream.lift = SimpleStream.lift;

	    /**
	     * Batches resize events for provided object of streams in
	     *  {key : stream} pairs. Emits one `resize` event per Engine cycle.
	     *
	     * @method merge
	     * @static
	     * @private
	     * @param streams {Object}  Dictionary of `resize` streams
	     */
	    ResizeStream.merge = function(streams){
	        var mergedStream = new ResizeStream();
	        var mergedData = (streams instanceof Array) ? [] : {};

	        mergedStream.addStream = function(key, stream){
	            var mapper = (function(key){
	                return new EventMapper(function(data){
	                    mergedData[key] = data;
	                    return mergedData;
	                });
	            })(key);

	            mergedStream.subscribe(mapper).subscribe(stream);
	        };

	        for (var key in streams){
	            var stream = streams[key];
	            mergedStream.addStream(key, stream);
	        }

	        return mergedStream;
	    };

	    module.exports = ResizeStream;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	/* Documentation in progress. May be outdated. */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var SimpleStream = __webpack_require__(11);
	    var preTickQueue = __webpack_require__(5);
	    var dirtyQueue = __webpack_require__(6);

	    /**
	     * A SizeObservable is a stream for resize events set discretely in time, as opposed to continuously.
	     *  It emits appropriate `resize` events upon calling the `set` method.
	     *
	     * @class Observable
	     * @constructor
	     * @private
	     * @extends Streams.SimpleStream
	     * @param value {Array} Size
	     */
	    function SizeObservable(value){
	        SimpleStream.call(this);
	        this.value = value;

	        if (value !== undefined) this.set(value);
	    }

	    SizeObservable.prototype = Object.create(SimpleStream.prototype);
	    SizeObservable.prototype.constructor = SizeObservable;

	    /**
	     * Getter for the provided size.
	     *
	     * @method get
	     * @return {Array}
	     */
	    SizeObservable.prototype.get = function(){
	        return this.value;
	    };

	    /**
	     * Setter for the provided size.
	     *
	     * @method set
	     * @param value {Array} Size
	     */
	    SizeObservable.prototype.set = function(value){
	        var self = this;
	        preTickQueue.push(function(){
	            self.value = value;
	            self.emit('resize', value);
	            dirtyQueue.push(function(){
	                self.emit('resize', value);
	            });
	        });
	    };

	    module.exports = SizeObservable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var tickQueue = __webpack_require__(7);

	    /**
	     * A collection of timing utilities meant to translate the familiar setInterval, setTimeout
	     *  timers to use Samsara's internal clock, which is backed by a requestAnimationFrame (RAF) loop.
	     *  It also includes other helpful methods for debouncing.
	     *
	     * @example
	     *
	     *      Timer.setTimeout(function(){
	     *          alert('I will execute after 1 second');
	     *      }, 1000);
	     *
	     *      Timer.after(function(){
	     *          alert('I will execute on the following RAF loop');
	     *      }, 1);
	     *
	     *      var debouncedResize = Timer.debounce(function(){
	     *          // this code will execute when the `resize` event
	     *          // has stopped firing (for the last 200 milliseconds)
	     *      }, 200);
	     *
	     *      Engine.on('resize', function(){
	     *          debounceResize();
	     *      });
	     *
	     * @class Timer
	     * @static
	     */
	    var Timer = {};

	    var getTime = (window.performance)
	        ? function() { return window.performance.now(); }
	        : Date.now;

	    function _addTimerFunction(fn) {
	        tickQueue.push(fn);
	        return fn;
	    }

	    function _clearTimerFunction(fn){
	        var index = tickQueue.indexOf(fn);
	        if (index === -1) return;
	        tickQueue.splice(index, 1);
	    }

	    /**
	     * Wraps a function to be invoked after a certain amount of time.
	     *  After a set duration has passed, it executes the function.
	     *
	     * @method setTimeout
	     * @static
	     * @param handler {Function}    Function to be run after a specified duration
	     * @param duration {Number}     Time to delay execution (in milliseconds)
	     * @return {Function}
	     */
	    Timer.setTimeout = function setTimeout(handler, duration) {
	        var t = getTime();
	        var callback = function() {
	            var t2 = getTime();
	            if (t2 - t >= duration) {
	                handler.apply(this, arguments);
	                Timer.clear(callback);
	            }
	        };
	        return _addTimerFunction(callback);
	    };

	    /**
	     * Wraps a function to be invoked at repeated intervals.
	     *
	     * @method setInterval
	     * @static
	     * @param handler {Function}    Function to be run at specified intervals
	     * @param interval {Number}     Time interval (in milliseconds)
	     * @return {Function}
	     */
	    Timer.setInterval = function setInterval(handler, duration) {
	        var t = getTime();
	        var callback = function() {
	            var t2 = getTime();
	            if (t2 - t >= duration) {
	                handler.apply(this, arguments);
	                t = getTime();
	            }
	        };
	        return _addTimerFunction(callback);
	    };

	    /**
	     * Wraps a function to be invoked after a specified number of Engine ticks.
	     *
	     * @method after
	     * @static
	     * @param handler {Function}    Function to be executed
	     * @param numTicks {Number}     Number of frames to delay execution
	     * @return {Function}
	     */
	    Timer.after = function after(handler, numTicks) {
	        if (numTicks === undefined) return undefined;
	        var callback = function() {
	            numTicks--;
	            if (numTicks <= 0) { //in case numTicks is fraction or negative
	                handler.apply(this, arguments);
	                Timer.clear(callback);
	            }
	        };
	        return _addTimerFunction(callback);
	    };

	    /**
	     * Wraps a function to be invoked every specified number of Engine ticks.
	     *
	     * @method every
	     * @static
	     * @param handler {Function}    Function to be executed
	     * @param numTicks {Number}     Number of frames per execution
	     * @return {Function}
	     */
	    Timer.every = function every(handler, numTicks) {
	        numTicks = numTicks || 1;
	        var initial = numTicks;
	        var callback = function() {
	            numTicks--;
	            if (numTicks <= 0) {
	                handler.apply(this, arguments);
	                numTicks = initial;
	            }
	        };
	        return _addTimerFunction(callback);
	    };

	    /**
	     * Cancel a timer.
	     *
	     * @method clear
	     * @static
	     * @param handler {Function} Handler
	     */
	    Timer.clear = function clear(handler) {
	        _clearTimerFunction(handler);
	    };

	    /**
	     * Debounces a function for specified duration.
	     *
	     * @method debounce
	     * @static
	     * @param handler {Function}  Handler
	     * @param duration {Number}   Duration
	     * @return {Function}
	     */
	    Timer.debounce = function debounce(handler, duration) {
	        var timeout;
	        return function() {
	            var args = arguments;

	            var fn = function() {
	                Timer.clear(timeout);
	                timeout = null;
	                handler.apply(this, args);
	            }.bind(this);

	            if (timeout) Timer.clear(timeout);
	            timeout = Timer.setTimeout(fn, duration);
	        };
	    };

	    /**
	     * Debounces a function for a specified number of Engine frames.
	     *
	     * @method frameDebounce
	     * @static
	     * @param handler {Function}  Handler
	     * @param numFrames {Number}  Number of frames
	     * @return {Function}
	     */
	    Timer.frameDebounce = function frameDebounce(handler, numFrames){
	        var timeout;
	        return function() {
	            var args = arguments;

	            var fn = function() {
	                timeout = null;
	                handler.apply(this, args);
	            }.bind(this);

	            if (timeout) Timer.clear(timeout);
	            timeout = Timer.after(fn, numFrames);
	        };
	    };

	    module.exports = Timer;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {

	    /**
	     * A library for creating and composing CSS3 matrix transforms.
	     *  A Transform is a 16 element float array `t = [t0, ..., t15]`
	     *  that corresponds to a 4x4 transformation matrix (in row-major order)
	     *
	     *  ```
	     *    ┌               ┐
	     *    │ t0  t1  t2  0 │
	     *    │ t4  t5  t6  0 │
	     *    │ t8  t9  t10 0 │
	     *    │ t12 t13 t14 1 │
	     *    └               ┘
	     *  ```
	     *
	     *  This matrix is a data structure encoding a combination of translation,
	     *  scale, skew and rotation components.
	     *
	     *  Note: these matrices are transposes from their mathematical counterparts.
	     *
	     *  @example
	     *
	     *      var layoutNode = var LayoutNode({
	     *          transform : Transform.translate([100,200,50])
	     *      });
	     *
	     *  @example
	     *
	     *      var transitionable = new Transitionable(0);
	     *
	     *      var transform = transitionable.map(function(value){
	     *          return Transform.scaleX(value);
	     *      });
	     *
	     *      var layoutNode = var LayoutNode({
	     *          transform : transform
	     *      });
	     *
	     *      transitionable.set(100, {duration : 500});
	     *
	     * @class Transform
	     * @static
	     */
	    var Transform = {};

	    /**
	     * Identity transform.
	     *
	     * @property identity {Array}
	     * @static
	     * @final
	     */
	    Transform.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

	    //TODO: why do inFront/behind need to translate by >1 to overcome DOM order?
	    /**
	     * Transform for moving a renderable in front of another renderable in the z-direction.
	     *
	     * @property inFront {Array}
	     * @static
	     * @final
	     */
	    Transform.inFront = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1.001, 1];

	    /**
	     * Transform for moving a renderable behind another renderable in the z-direction.
	     *
	     * @property behind {Array}
	     * @static
	     * @final
	     */
	    Transform.behind = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1.001, 1];

	    /**
	     * Compose Transform arrays via matrix multiplication.
	     *
	     * @method compose
	     * @static
	     * @param t1 {Transform} Left Transform
	     * @param t2 {Transform} Right Transform
	     * @return {Array}
	     */
	    Transform.compose = function multiply(t1, t2) {
	        if (t1 === Transform.identity) return t2.slice();
	        if (t2 === Transform.identity) return t1.slice();
	        return [
	            t1[0] * t2[0] + t1[4] * t2[1] + t1[8] * t2[2],
	            t1[1] * t2[0] + t1[5] * t2[1] + t1[9] * t2[2],
	            t1[2] * t2[0] + t1[6] * t2[1] + t1[10] * t2[2],
	            0,
	            t1[0] * t2[4] + t1[4] * t2[5] + t1[8] * t2[6],
	            t1[1] * t2[4] + t1[5] * t2[5] + t1[9] * t2[6],
	            t1[2] * t2[4] + t1[6] * t2[5] + t1[10] * t2[6],
	            0,
	            t1[0] * t2[8] + t1[4] * t2[9] + t1[8] * t2[10],
	            t1[1] * t2[8] + t1[5] * t2[9] + t1[9] * t2[10],
	            t1[2] * t2[8] + t1[6] * t2[9] + t1[10] * t2[10],
	            0,
	            t1[0] * t2[12] + t1[4] * t2[13] + t1[8] * t2[14] + t1[12],
	            t1[1] * t2[12] + t1[5] * t2[13] + t1[9] * t2[14] + t1[13],
	            t1[2] * t2[12] + t1[6] * t2[13] + t1[10] * t2[14] + t1[14],
	            1
	        ];
	    };

	    /**
	     * Convenience method to Compose several Transform arrays.
	     *
	     * @method composeMany
	     * @static
	     * @param {...Transform}    Transform arrays
	     * @return {Array}
	     */
	    Transform.composeMany = function composeMany(){
	        if (arguments.length > 2){
	            var first = arguments[0];
	            var second = arguments[1];
	            Array.prototype.shift.call(arguments);
	            arguments[0] = Transform.compose(first, second);
	            return Transform.composeMany.apply(null, arguments);
	        }
	        else return Transform.compose.apply(null, arguments);
	    };

	    /**
	     * Translate a Transform after the Transform is applied.
	     *
	     * @method thenMove
	     * @static
	     * @param t {Transform}     Transform
	     * @param v {Number[]}      Array of [x,y,z] translation components
	     * @return {Array}
	     */
	    Transform.thenMove = function thenMove(t, v) {
	        if (!v[2]) v[2] = 0;
	        return [t[0], t[1], t[2], 0, t[4], t[5], t[6], 0, t[8], t[9], t[10], 0, t[12] + v[0], t[13] + v[1], t[14] + v[2], 1];
	    };

	    /**
	     * Translate a Transform before the Transform is applied.
	     *
	     * @method moveThen
	     * @static
	     * @param v {Number[]}      Array of [x,y,z] translation components
	     * @param t {Transform}     Transform
	     * @return {Array}
	     */
	    Transform.moveThen = function moveThen(v, t) {
	        if (!v[2]) v[2] = 0;
	        var t0 = v[0] * t[0] + v[1] * t[4] + v[2] * t[8];
	        var t1 = v[0] * t[1] + v[1] * t[5] + v[2] * t[9];
	        var t2 = v[0] * t[2] + v[1] * t[6] + v[2] * t[10];
	        return Transform.thenMove(t, [t0, t1, t2]);
	    };

	    /**
	     * Return a Transform which represents translation by a translation vector.
	     *
	     * @method translate
	     * @static
	     * @param v {Number[]}      Translation vector [x,y,z]
	     * @return {Array}
	     */
	    Transform.translate = function translate(v) {
	        var x = v[0] || 0;
	        var y = v[1] || 0;
	        var z = v[2] || 0;
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
	    };

	    /**
	     * Return a Transform which represents translation in the x-direction.
	     *
	     * @method translateX
	     * @static
	     * @param x {Number}        Translation amount
	     */
	    Transform.translateX = function translateX(x) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
	    };

	    /**
	     * Return a Transform which represents translation in the y-direction.
	     *
	     * @method translateY
	     * @static
	     * @param y {Number}        Translation amount
	     */
	    Transform.translateY = function translateY(y) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
	    };

	    /**
	     * Return a Transform which represents translation in the z-direction.
	     *
	     * @method translateZ
	     * @static
	     * @param z {Number}        Translation amount
	     */
	    Transform.translateZ = function translateZ(z) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
	    };

	    /**
	     * Return a Transform which represents a scaling by specified amounts in each dimension.
	     *
	     * @method scale
	     * @static
	     * @param v {Number[]}      Scale vector [x,y,z]
	     * @return {Array}
	     */
	    Transform.scale = function scale(v) {
	        var x = (v[0] !== undefined) ? v[0] : 1;
	        var y = (v[1] !== undefined) ? v[1] : 1;
	        var z = (v[2] !== undefined) ? v[2] : 1;
	        return [x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1];
	    };

	    /**
	     * Return a Transform which represents scaling in the x-direction.
	     *
	     * @method scaleX
	     * @static
	     * @param x {Number}        Scale amount
	     */
	    Transform.scaleX = function scaleX(x) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, 0, 0, 1];
	    };

	    /**
	     * Return a Transform which represents scaling in the y-direction.
	     *
	     * @method scaleY
	     * @static
	     * @param y {Number}        Scale amount
	     */
	    Transform.scaleY = function scaleY(y) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y, 0, 1];
	    };

	    /**
	     * Return a Transform which represents scaling in the z-direction.
	     *
	     * @method scaleZ
	     * @static
	     * @param z {Number}        Scale amount
	     */
	    Transform.scaleZ = function scaleZ(z) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
	    };

	    /**
	     * Scale a Transform after the Transform is applied.
	     *
	     * @method thenScale
	     * @static
	     * @param t {Transform}     Transform
	     * @param v {Number[]}      Array of [x,y,z] scale components
	     * @return {Array}
	     */
	    Transform.thenScale = function thenScale(t, v) {
	        var x = (v[0] !== undefined) ? v[0] : 1;
	        var y = (v[1] !== undefined) ? v[1] : 1;
	        var z = (v[2] !== undefined) ? v[2] : 1;
	        return [
	            x * t[0],  y * t[1],  z * t[2],  0,
	            x * t[4],  y * t[5],  z * t[6],  0,
	            x * t[8],  y * t[9],  z * t[10], 0,
	            x * t[12], y * t[13], z * t[14], 1
	        ];
	    };

	    /**
	     * Return a Transform representing a clockwise rotation around the x-axis.
	     *
	     * @method rotateX
	     * @static
	     * @param angle {Number}    Angle in radians
	     * @return {Array}
	     */
	    Transform.rotateX = function rotateX(angle) {
	        var cosTheta = Math.cos(angle);
	        var sinTheta = Math.sin(angle);
	        return [1, 0, 0, 0, 0, cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1];
	    };

	    /**
	     * Return a Transform representing a clockwise rotation around the y-axis.
	     *
	     * @method rotateY
	     * @static
	     * @param angle {Number}    Angle in radians
	     * @return {Array}
	     */
	    Transform.rotateY = function rotateY(angle) {
	        var cosTheta = Math.cos(angle);
	        var sinTheta = Math.sin(angle);
	        return [cosTheta, 0, -sinTheta, 0, 0, 1, 0, 0, sinTheta, 0, cosTheta, 0, 0, 0, 0, 1];
	    };

	    /**
	     * Return a Transform representing a clockwise rotation around the z-axis.
	     *
	     * @method rotateX
	     * @static
	     * @param angle {Number}    Angle in radians
	     * @return {Array}
	     */
	    Transform.rotateZ = function rotateZ(theta) {
	        var cosTheta = Math.cos(theta);
	        var sinTheta = Math.sin(theta);
	        return [cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    };

	    /**
	     * Return a Transform representation of a skew in the x-direction
	     *
	     * @method skewX
	     * @static
	     * @param angle {Number}    The angle between the top and left sides
	     * @return {Array}
	     */
	    Transform.skewX = function skewX(angle) {
	        return [1, 0, 0, 0, Math.tan(angle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    };

	    /**
	     * Return a Transform representation of a skew in the y-direction
	     *
	     * @method skewY
	     * @static
	     * @param angle {Number}    The angle between the bottom and right sides
	     * @return {Array}
	     */
	    Transform.skewY = function skewY(angle) {
	        return [1, Math.tan(angle), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	    };

	    /**
	     * Return a Transform which represents an axis-angle rotation.
	     *
	     * @method rotateAxis
	     * @static
	     * @param v {Number[]}   Unit vector representing the axis to rotate about
	     * @param angle {Number} Radians to rotate clockwise about the axis
	     * @return {Array}
	     */
	    Transform.rotateAxis = function rotateAxis(v, angle) {
	        var sinTheta = Math.sin(angle);
	        var cosTheta = 1 - Math.cos(angle);
	        var verTheta = 1 - cosTheta; // versine of theta

	        var xxV = v[0] * v[0] * verTheta;
	        var xyV = v[0] * v[1] * verTheta;
	        var xzV = v[0] * v[2] * verTheta;
	        var yyV = v[1] * v[1] * verTheta;
	        var yzV = v[1] * v[2] * verTheta;
	        var zzV = v[2] * v[2] * verTheta;
	        var xs = v[0] * sinTheta;
	        var ys = v[1] * sinTheta;
	        var zs = v[2] * sinTheta;

	        return [
	            xxV + cosTheta, xyV + zs, xzV - ys, 0,
	            xyV - zs, yyV + cosTheta, yzV + xs, 0,
	            xzV + ys, yzV - xs, zzV + cosTheta, 0,
	            0, 0, 0, 1
	        ];
	    };

	    /**
	     * Return a Transform which represents a Transform applied about an origin point.
	     *  Useful for rotating and scaling relative to an origin.
	     *
	     * @method aboutOrigin
	     * @static
	     * @param v {Number[]}          Origin point [x,y,z]
	     * @param t {Transform}         Transform
	     * @return {Array}
	     */
	    Transform.aboutOrigin = function aboutOrigin(v, t) {
	        v[2] = v[2] || 0;
	        var t0 = v[0] - (v[0] * t[0] + v[1] * t[4] + v[2] * t[8]);
	        var t1 = v[1] - (v[0] * t[1] + v[1] * t[5] + v[2] * t[9]);
	        var t2 = v[2] - (v[0] * t[2] + v[1] * t[6] + v[2] * t[10]);
	        return Transform.thenMove(t, [t0, t1, t2]);
	    };

	    /**
	     * Returns a perspective Transform.
	     *
	     * @method perspective
	     * @static
	     * @param focusZ {Number}       z-depth of focal point
	     * @return {Array}
	     */
	    Transform.perspective = function perspective(focusZ) {
	        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1 / focusZ, 0, 0, 0, 1];
	    };

	    /**
	     * Return translation vector component of the given Transform.
	     *
	     * @method getTranslate
	     * @static
	     * @param t {Transform}         Transform
	     * @return {Number[]}
	     */
	    Transform.getTranslate = function getTranslate(t) {
	        return [t[12], t[13], t[14]];
	    };

	    /**
	     * Return inverse Transform for given Transform.
	     *   Note: will provide incorrect results if Transform is not invertible.
	     *
	     * @method inverse
	     * @static
	     * @param t {Transform} Transform
	     * @return {Array}
	     */
	    Transform.inverse = function inverse(t) {
	        // only need to consider 3x3 section for affine
	        var c0 = t[5] * t[10] - t[6] * t[9];
	        var c1 = t[4] * t[10] - t[6] * t[8];
	        var c2 = t[4] * t[9] - t[5] * t[8];
	        var c4 = t[1] * t[10] - t[2] * t[9];
	        var c5 = t[0] * t[10] - t[2] * t[8];
	        var c6 = t[0] * t[9] - t[1] * t[8];
	        var c8 = t[1] * t[6] - t[2] * t[5];
	        var c9 = t[0] * t[6] - t[2] * t[4];
	        var c10 = t[0] * t[5] - t[1] * t[4];
	        var detM = t[0] * c0 - t[1] * c1 + t[2] * c2;
	        var invD = 1 / detM;
	        var result = [
	            invD * c0, -invD * c4, invD * c8, 0,
	            -invD * c1, invD * c5, -invD * c9, 0,
	            invD * c2, -invD * c6, invD * c10, 0,
	            0, 0, 0, 1
	        ];
	        result[12] = -t[12] * result[0] - t[13] * result[4] - t[14] * result[8];
	        result[13] = -t[12] * result[1] - t[13] * result[5] - t[14] * result[9];
	        result[14] = -t[12] * result[2] - t[13] * result[6] - t[14] * result[10];
	        return result;
	    };

	    /**
	     * Returns the transpose of a Transform.
	     *
	     * @method transpose
	     * @static
	     * @param t {Transform}     Transform
	     * @return {Array}
	     */
	    Transform.transpose = function transpose(t) {
	        return [t[0], t[4], t[8], t[12], t[1], t[5], t[9], t[13], t[2], t[6], t[10], t[14], t[3], t[7], t[11], t[15]];
	    };

	    function _normSquared(v) {
	        return (v.length === 2)
	            ? v[0] * v[0] + v[1] * v[1]
	            : v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
	    }
	    function _norm(v) {
	        return Math.sqrt(_normSquared(v));
	    }
	    function _sign(n) {
	        return (n < 0) ? -1 : 1;
	    }

	    /**
	     * Decompose Transform into separate `translate`, `rotate`, `scale` and `skew` components.
	     *
	     * @method interpret
	     * @static
	     * @private
	     * @param t {Transform}     Transform
	     * @return {Object}
	     */
	    Transform.interpret = function interpret(t) {
	        // QR decomposition via Householder reflections
	        // FIRST ITERATION

	        //default Q1 to the identity matrix;
	        var x = [t[0], t[1], t[2]];                // first column vector
	        var sgn = _sign(x[0]);                     // sign of first component of x (for stability)
	        var xNorm = _norm(x);                      // norm of first column vector
	        var v = [x[0] + sgn * xNorm, x[1], x[2]];  // v = x + sign(x[0])|x|e1
	        var mult = 2 / _normSquared(v);            // mult = 2/v'v

	        //bail out if our Matrix is singular
	        if (mult >= Infinity) {
	            return {
	                translate: Transform.getTranslate(t),
	                rotate: [0, 0, 0],
	                scale: [0, 0, 0],
	                skew: [0, 0, 0]
	            };
	        }

	        //evaluate Q1 = I - 2vv'/v'v
	        var Q1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];

	        //diagonals
	        Q1[0]  = 1 - mult * v[0] * v[0];    // 0,0 entry
	        Q1[5]  = 1 - mult * v[1] * v[1];    // 1,1 entry
	        Q1[10] = 1 - mult * v[2] * v[2];    // 2,2 entry

	        //upper diagonal
	        Q1[1] = -mult * v[0] * v[1];        // 0,1 entry
	        Q1[2] = -mult * v[0] * v[2];        // 0,2 entry
	        Q1[6] = -mult * v[1] * v[2];        // 1,2 entry

	        //lower diagonal
	        Q1[4] = Q1[1];                      // 1,0 entry
	        Q1[8] = Q1[2];                      // 2,0 entry
	        Q1[9] = Q1[6];                      // 2,1 entry

	        //reduce first column of M
	        var MQ1 = Transform.compose(Q1, t);

	        // SECOND ITERATION on (1,1) minor
	        var x2 = [MQ1[5], MQ1[6]];
	        var sgn2 = _sign(x2[0]);                    // sign of first component of x (for stability)
	        var x2Norm = _norm(x2);                     // norm of first column vector
	        var v2 = [x2[0] + sgn2 * x2Norm, x2[1]];    // v = x + sign(x[0])|x|e1
	        var mult2 = 2 / _normSquared(v2);           // mult = 2/v'v

	        //evaluate Q2 = I - 2vv'/v'v
	        var Q2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];

	        //diagonal
	        Q2[5]  = 1 - mult2 * v2[0] * v2[0]; // 1,1 entry
	        Q2[10] = 1 - mult2 * v2[1] * v2[1]; // 2,2 entry

	        //off diagonals
	        Q2[6] = -mult2 * v2[0] * v2[1];     // 2,1 entry
	        Q2[9] = Q2[6];                      // 1,2 entry

	        //calc QR decomposition. Q = Q1*Q2, R = Q'*M
	        var Q = Transform.compose(Q2, Q1);      //note: really Q transpose
	        var R = Transform.compose(Q, t);

	        //remove negative scaling
	        var remover = Transform.scale(R[0] < 0 ? -1 : 1, R[5] < 0 ? -1 : 1, R[10] < 0 ? -1 : 1);
	        R = Transform.compose(R, remover);
	        Q = Transform.compose(remover, Q);

	        //decompose into rotate/scale/skew matrices
	        var result = {};
	        result.translate = Transform.getTranslate(t);
	        result.rotate = [Math.atan2(-Q[6], Q[10]), Math.asin(Q[2]), Math.atan2(-Q[1], Q[0])];
	        if (!result.rotate[0]) {
	            result.rotate[0] = 0;
	            result.rotate[2] = Math.atan2(Q[4], Q[5]);
	        }
	        result.scale = [R[0], R[5], R[10]];
	        result.skew = [Math.atan2(R[9], result.scale[2]), Math.atan2(R[8], result.scale[2]), Math.atan2(R[4], result.scale[0])];

	        //double rotation workaround
	        if (Math.abs(result.rotate[0]) + Math.abs(result.rotate[2]) > 1.5 * Math.PI) {
	            result.rotate[1] = Math.PI - result.rotate[1];
	            if (result.rotate[1] > Math.PI) result.rotate[1] -= 2 * Math.PI;
	            if (result.rotate[1] < -Math.PI) result.rotate[1] += 2 * Math.PI;
	            if (result.rotate[0] < 0) result.rotate[0] += Math.PI;
	            else result.rotate[0] -= Math.PI;
	            if (result.rotate[2] < 0) result.rotate[2] += Math.PI;
	            else result.rotate[2] -= Math.PI;
	        }

	        return result;
	    };

	    /**
	     * Compose .translate, .rotate, .scale and .skew components into a Transform matrix.
	     *  The "inverse" of .interpret.
	     *
	     * @method build
	     * @static
	     * @private
	     * @param spec {Object} Object with keys "translate, rotate, scale, skew" and their vector values
	     * @return {Array}
	     */
	    Transform.build = function build(spec) {
	        var scaleMatrix = Transform.scale(spec.scale[0], spec.scale[1], spec.scale[2]);
	        var skewMatrix = Transform.skew(spec.skew[0], spec.skew[1], spec.skew[2]);
	        var rotateMatrix = Transform.rotate(spec.rotate[0], spec.rotate[1], spec.rotate[2]);
	        return Transform.thenMove(
	            Transform.compose(Transform.compose(rotateMatrix, skewMatrix), scaleMatrix),
	            spec.translate
	        );
	    };

	    /**
	     * Weighted average between two matrices by averaging their
	     *  translation, rotation, scale, skew components.
	     *  f(M1,M2,t) = (1 - t) * M1 + t * M2
	     *
	     * @method average
	     * @static
	     * @param M1 {Transform}    M1 = f(M1,M2,0) Transform
	     * @param M2 {Transform}    M2 = f(M1,M2,1) Transform
	     * @param [t=1/2] {Number}
	     * @return {Array}
	     */
	    Transform.average = function average(M1, M2, t) {
	        t = (t === undefined) ? 0.5 : t;
	        var specM1 = Transform.interpret(M1);
	        var specM2 = Transform.interpret(M2);

	        var specAvg = {
	            translate: [0, 0, 0],
	            rotate: [0, 0, 0],
	            scale: [0, 0, 0],
	            skew: [0, 0, 0]
	        };

	        for (var i = 0; i < 3; i++) {
	            specAvg.translate[i] = (1 - t) * specM1.translate[i] + t * specM2.translate[i];
	            specAvg.rotate[i] = (1 - t) * specM1.rotate[i] + t * specM2.rotate[i];
	            specAvg.scale[i] = (1 - t) * specM1.scale[i] + t * specM2.scale[i];
	            specAvg.skew[i] = (1 - t) * specM1.skew[i] + t * specM2.skew[i];
	        }

	        return Transform.build(specAvg);
	    };

	    /**
	     * Determine if two Transforms are component-wise equal.
	     *
	     * @method equals
	     * @static
	     * @param a {Transform}     Transform
	     * @param b {Transform}     Transform
	     * @return {Boolean}
	     */
	    Transform.equals = function equals(a, b) {
	        return !Transform.notEquals(a, b);
	    };

	    /**
	     * Determine if two Transforms are component-wise unequal
	     *
	     * @method notEquals
	     * @static
	     * @param a {Transform}     Transform
	     * @param b {Transform}     Transform
	     * @return {Boolean}
	     */
	    Transform.notEquals = function notEquals(a, b) {
	        if (a === b) return false;

	        return !(a && b) ||
	            a[12] !== b[12] || a[13] !== b[13] || a[14] !== b[14] ||
	            a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] ||
	            a[4] !== b[4] || a[5] !== b[5] || a[6] !== b[6] ||
	            a[8] !== b[8] || a[9] !== b[9] || a[10] !== b[10];
	    };

	    module.exports = Transform;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	    var dirtyQueue = __webpack_require__(6);
	    var preTickQueue = __webpack_require__(5);
	    var tickQueue = __webpack_require__(7);
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);
	    var Stream = __webpack_require__(15);

	    var Tween = __webpack_require__(23);
	    var Spring = __webpack_require__(24);
	    var Inertia = __webpack_require__(25);

	    var transitionMethods = {
	        tween: Tween,
	        spring: Spring,
	        inertia: Inertia
	    };

	    /**
	     * A way to transition numeric values and arrays of numbers between start and end states.
	     *  Transitions are given an easing curve and a duration.
	     *  Non-numeric values are ignored.
	     *
	     *  @example
	     *
	     *      var transitionable = new Transitionable(0);
	     *
	     *      transitionable.set(100, {duration : 1000, curve : 'easeIn'});
	     *
	     *      transitionable.on('start', function(value){
	     *          console.log(value); // 0
	     *      });
	     *
	     *      transitionable.on('update', function(value){
	     *          console.log(value); // numbers between 0 and 100
	     *      });
	     *
	     *      transitionable.on('end', function(value){
	     *          console.log(value); // 100
	     *      });
	     *
	     * @class Transitionable
	     * @constructor
	     * @extends Streams.SimpleStream
	     * @param value {Number|Number[]}   Starting value
	     */
	    function Transitionable(value) {
	        this.value = value || 0;
	        this.velocity = 0;
	        this._callback = undefined;
	        this._method = null;
	        this._active = false;
	        this._currentActive = false;

	        var hasUpdated = false;
	        this.updateMethod = undefined;

	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();
	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._eventInput.on('start', function (value) {
	            this._currentActive = true;
	            if (!this._active) {
	                this.emit('start', value);
	                this._active = true;
	            }
	        }.bind(this));

	        this._eventInput.on('update', function (value) {
	            hasUpdated = true;
	            this.value = value;
	            this.velocity = this._engineInstance.getVelocity();
	            this.emit('update', value);
	        }.bind(this));

	        this._eventInput.on('end', function (value) {
	            this.value = value;
	            this._currentActive = false;

	            if (this._callback) {
	                var callback = this._callback;
	                this._callback = undefined;
	                callback();
	            }

	            if (!this._currentActive){
	                this._active = false;
	                hasUpdated = false;

	                if (this._engineInstance)
	                    this.velocity = this._engineInstance.getVelocity();

	                this._active = false;
	                this.emit('end', value);
	            }
	        }.bind(this));

	        if (value !== undefined) {
	            this.value = value;
	            preTickQueue.push(function () {
	                this.trigger('start', value);

	                dirtyQueue.push(function () {
	                    if (hasUpdated) return;
	                    this.trigger('end', value);
	                }.bind(this));
	            }.bind(this));
	        }
	    }

	    Transitionable.prototype = Object.create(SimpleStream.prototype);
	    Transitionable.prototype.constructor = Transitionable;

	    /**
	     * Constructor method. A way of registering other engines that can interpolate
	     *  between start and end values. For instance, a physics engine.
	     *
	     *  @method register
	     *  @param name {string}    Identifier for the engine
	     *  @param constructor      Constructor for the engine
	     */
	    Transitionable.register = function register(name, constructor) {
	        if (!(name in transitionMethods))
	            transitionMethods[name] = constructor;
	    };

	    /**
	     * Constructor method. Unregister an interpolating engine.
	     *  Undoes work of `register`.
	     *
	     *  @method unregister
	     *  @param name {string}    Identifier for the engine
	     */
	    Transitionable.unregister = function unregister(name) {
	        if (name in transitionMethods) {
	            delete transitionMethods[name];
	            return true;
	        }
	        else return false;
	    };

	    /**
	     * Define a new end value that will be transitioned towards with the prescribed
	     *  transition. An optional callback can fire when the transition completes.
	     *
	     * @method set
	     * @param value {Number|Number[]}           End value
	     * @param [transition] {Object}             Transition definition
	     * @param [transition.curve] {string}       Easing curve name, e.g., "easeIn"
	     * @param [transition.duration] {string}    Duration of transition
	     * @param [callback] {Function}             Callback
	     */
	    Transitionable.prototype.set = function set(value, transition, callback) {
	        if (!transition) {
	            this.value = value;
	            this.trigger('start', value);

	            dirtyQueue.push(function () {
	                this.trigger('end', value);
	            }.bind(this));
	            return;
	        }

	        if (callback) this._callback = callback;

	        var curve = transition.curve;

	        var method = (curve && transitionMethods[curve])
	            ? transitionMethods[curve]
	            : Tween;

	        if (this._method !== method) {
	            if (this._engineInstance){
	                if (this.updateMethod){
	                    var index = tickQueue.indexOf(this.updateMethod);
	                    if (index >= 0) tickQueue.splice(index, 1);
	                }
	                this.unsubscribe(this._engineInstance);
	            }

	            if (this.value instanceof Array) {
	                var dimensions = this.value.length;
	                this._engineInstance = (dimensions < method.DIMENSIONS)
	                    ? new method(this.value)
	                    : new NDTransitionable(this.value, method);
	            }
	            else this._engineInstance = new method(this.value);

	            this.subscribe(this._engineInstance);
	            this.updateMethod = this._engineInstance.update.bind(this._engineInstance);
	            tickQueue.push(this.updateMethod);

	            this._method = method;
	        }

	        if (!transition.velocity) transition.velocity = this.velocity;

	        this._engineInstance.set(value, transition);
	    };

	    /**
	     * Return the current state of the transition.
	     *
	     * @method get
	     * @return {Number|Number[]}    Current state
	     */
	    Transitionable.prototype.get = function get() {
	        return this.value;
	    };

	    /**
	     * Return the current velocity of the transition.
	     *
	     * @method getVelocity
	     * @return {Number|Number[]}    Current state
	     */
	    Transitionable.prototype.getVelocity = function getVelocity(){
	        return this.velocity;
	    };

	    /**
	     * Sets the value and velocity of the transition without firing any events.
	     *
	     * @method reset
	     * @param value {Number|Number[]}       New value
	     * @param [velocity] {Number|Number[]}  New velocity
	     */
	    Transitionable.prototype.reset = function reset(value, velocity){
	        this.value = value;
	        this.velocity = velocity || 0;
	        this._callback = null;
	        this._method = null;
	        if (this._engineInstance) this._engineInstance.reset(value, velocity);
	    };

	    /**
	     * Ends the transition in place.
	     *
	     * @method halt
	     */
	    Transitionable.prototype.halt = function () {
	        this.reset(this.get());
	        this.trigger('end', this.value);
	    };

	    /**
	     * Determine is the transition is ongoing, or has completed.
	     *
	     * @method isActive
	     * @return {Boolean}
	     */
	    Transitionable.prototype.isActive = function isActive() {
	        return this._active;
	    };

	    /**
	     * Iterate through the provided values with the provided transitions. Firing an
	     *  optional callback when the series of transitions completes.
	     *  One transition may be provided as opposed to an array when you want all the
	     *  transitions to behave the same way.
	     *
	     * @method iterate
	     * @param values {Array}                    Array of values
	     * @param transitions {Object|Object[]}     Array of transitions
	     * @param [callback] {Function}             Callback
	     */
	    Transitionable.prototype.iterate = function iterate(values, transitions, callback) {
	        if (values.length === 0) {
	            if (callback) callback();
	            return;
	        }

	        // sugar for same transition across value changes
	        var transition = (transitions instanceof Array)
	            ? transitions.shift()
	            : transitions;

	        this.set(values.shift(), transition, function () {
	            this.iterate(values, transitions, callback);
	        }.bind(this));
	    };

	    /**
	     * Combine multiple transitions to be executed sequentially. Provide the
	     *  transitions as an array of transition definitions.
	     *
	     *  @example
	     *
	     *  transitionable.setMany([
	     *      {value : 0, transition : {curve : 'easeOut', duration : 500}},
	     *      {value : 1, transition : {curve : 'spring', period : 100, damping : 0.5}}
	     *  ]);
	     *
	     * @method setMany
	     * @param transitions {Array}   Array of transitions
	     */
	    Transitionable.prototype.setMany = function (transitions) {
	        var first = transitions.shift();
	        if (transitions.length === 0) {
	            this.set(first.value, first.transition, first.callback)
	        }
	        else {
	            this.set(first.value, first.transition, function () {
	                this.setMany(transitions);
	            }.bind(this));
	        }
	    };

	    /**
	     * Loop indefinitely between values with provided transitions array.
	     *
	     *  @example
	     *
	     *  transitionable.loop([
	     *      {value : 0, transition : {curve : 'easeOut', duration : 500}},
	     *      {value : 1, transition : {curve : 'spring', period : 100, damping : 0.5}}
	     *  ]);
	     *
	     * @method loop
	     * @param transitions {Array}   Array of transitions
	     */
	    Transitionable.prototype.loop = function (transitions) {
	        var arrayClone = transitions.slice(0);
	        this.setMany(transitions, function () {
	            this.loop(arrayClone);
	        }.bind(this));
	    };

	    /**
	     * Postpone a transition, and fire it by providing it in the callback parameter.
	     *
	     * @method delay
	     * @param callback {Function}   Callback
	     * @param duration {Number}     Duration of delay (in millisecons)
	     */
	    Transitionable.prototype.delay = function delay(callback, duration) {
	        this.set(this.get(), {
	                duration: duration,
	                curve: function () {
	                    return 0;
	                }
	            },
	            callback
	        );
	    };

	    function NDTransitionable(value, method) {
	        this._eventOutput = new EventHandler();
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this.sources = [];
	        for (var i = 0; i < value.length; i++) {
	            var source = new method(value[i]);
	            this.sources.push(source);
	        }

	        this.stream = Stream.merge(this.sources);
	        this._eventOutput.subscribe(this.stream);
	    }

	    NDTransitionable.prototype.set = function (value, transition) {
	        for (var i = 0; i < value.length; i++)
	            this.sources[i].set(value[i], transition);
	    };

	    NDTransitionable.prototype.getVelocity = function () {
	        var velocity = [];
	        for (var i = 0; i < this.sources.length; i++)
	            velocity[i] = this.sources[i].getVelocity();
	        return velocity;
	    };

	    NDTransitionable.prototype.update = function () {
	        for (var i = 0; i < this.sources.length; i++)
	            this.sources[i].update();
	    };

	    module.exports = Transitionable;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);

	    var now = Date.now;
	    var eps = 1e-9; // for calculating velocity using finite difference
	    var registeredCurves = {};

	    /**
	     * A method of interpolating between start and end values with
	     *  an easing curve.
	     *
	     * @class Tween
	     * @private
	     * @namespace Transitions
	     * @constructor
	     * @param value {Number}    Initial value
	     */
	    function Tween(value) {
	        SimpleStream.call(this);

	        this.state = value || 0;
	        this.velocity = 0;
	        this._startValue = value || 0;
	        this._endValue = 0;
	        this._startTime = now();
	        this._curve = undefined;
	        this._duration = 0;
	        this._active = false;

	        this._eventOutput = new EventHandler();
	        EventHandler.setOutputHandler(this, this._eventOutput);
	    }

	    Tween.prototype = Object.create(SimpleStream.prototype);
	    Tween.prototype.constructor = Tween;

	    /**
	     * Default easing curves.
	     *
	     * @property CURVES {object}
	     * @property CURVES.linear {Function}           Linear interpolation
	     * @property CURVES.easeIn {Function}           EaseIn interpolation. Deceleration from zero velocity.
	     * @property CURVES.easeInCubic {Function}      Cubic interpolation. Acceleration from zero velocity.
	     * @property CURVES.easeOut {Function}          EaseOut interpolation. Acceleration from zero velocity.
	     * @property CURVES.easeOutCubic {Function}     Cubic interpolation. Deceleration from zero velocity.
	     * @property CURVES.easeOutWall                 Interpolation with wall boundary.
	     * @property CURVES.easeInOut {Function}        EaseInOut interpolation. Acceleration then deceleration.
	     * @property CURVES.easeInOutCubic {Function}   Cubic interpolation. Acceleration then deceleration.
	     * @static
	     */
	    Tween.CURVES = {
	        linear: function(t) {
	            return t;
	        },
	        easeIn: function(t) {
	            return t * t;
	        },
	        easeOut: function(t) {
	            return t * (2 - t);
	        },
	        easeInOut: function(t) {
	            return (t <= 0.5)
	                ?  2 * t * t
	                : -2 * t * t + 4 * t - 1;
	        },
	        easeOutBounce: function(t) {
	            return t * (3 - 2 * t);
	        },
	        easeInCubic: function (t) {
	            return t * t * t;
	        },
	        easeOutCubic: function (t) {
	            return 1 + Math.pow(t - 1, 3);
	        },
	        easeInOutCubic: function (t) {
	            t *= 2;
	            return (t < 1)
	                ? .5 * t * t * t
	                : .5 * Math.pow(t - 2, 3) + 1;
	        },
	        easeOutWall: function (t) {
	            if (t < (1 / 2.75)) {
	                return (7.5625 * t * t);
	            } else if (t < (2 / 2.75)) {
	                return (7.5625 * (t -= (1.5 / 2.75)) * t + .75);
	            } else if (t < (2.5 / 2.75)) {
	                return (7.5625 * (t -= (2.25 / 2.75)) * t + .9375);
	            } else {
	                return (7.5625 * (t -= (2.625 / 2.75)) * t + .984375);
	            }
	        }
	    };

	    Tween.DIMENSIONS = Infinity;

	    Tween.DEFAULT_OPTIONS = {
	        curve: Tween.CURVES.linear,
	        duration: 500
	    };

	    /**
	     * A way of registering custom easing curves by name.
	     *  Curves are functions that take a number between 0 and 1 and return
	     *  a number (often between 0 and 1, but can over/under shoot).
	     *
	     * @method register
	     * @static
	     * @param name {String}         Identifying name
	     * @param curve {Function}      Function defined on the domain [0,1]
	     * @return {Boolean}            False if key is taken, else true
	     */
	    Tween.register = function register(name, curve) {
	        if (!registeredCurves[name]) {
	            registeredCurves[name] = curve;
	            return true;
	        }
	        else return false;
	    };

	    /**
	     * Remove curve from internal registry. Undoes work of `register`.
	     *
	     * @method deregister
	     * @static
	     * @param name {String}     Name dictionary key
	     * @return {Boolean}        False if key doesn't exist
	     */
	    Tween.deregister = function deregister(name) {
	        if (registeredCurves[name]) {
	            delete registeredCurves[name];
	            return true;
	        }
	        else return false;
	    };

	    /**
	     * Retrieve all registered curves.
	     *
	     * @method getCurves
	     * @static
	     * @return {Object}
	     */
	    Tween.getCurves = function getCurves() {
	        return registeredCurves;
	    };

	    /**
	     * Set new value to transition to.
	     *
	     * @method set
	     * @param endValue {Number|Number[]}    End value
	     * @param [transition] {Object}         Transition object of type
	     *                                      {duration: number, curve: name}
	     */
	    Tween.prototype.set = function set(endValue, transition) {
	        this._startValue = this.get();

	        if (!this._active) {
	            this.emit('start', this._startValue);
	            this._active = true;
	        }

	        this._endValue = endValue;
	        this._startTime = now();

	        var curve = transition.curve;
	        if (!registeredCurves[curve] && Tween.CURVES[curve])
	            Tween.register(curve, Tween.CURVES[curve]);

	        this.velocity = transition.velocity;
	        this._duration = transition.duration || Tween.DEFAULT_OPTIONS.duration;
	        this._curve = curve
	            ? (curve instanceof Function) ? curve : getCurve(curve)
	            : Tween.DEFAULT_OPTIONS.curve;
	    };

	    /**
	     * Get current value.
	     *
	     * @method get
	     * @return {Number|Number[]}
	     */
	    Tween.prototype.get = function get() {
	        return this.state;
	    };

	    /**
	     * Get current velocity
	     *
	     * @method getVelocity
	     * @returns {Number|Number[]}
	     */
	    Tween.prototype.getVelocity = function getVelocity() {
	        return this.velocity;
	    };

	    /**
	     * Reset the value and velocity of the transition.
	     *
	     * @method reset
	     * @param value {Number|Number[]}       Value
	     * @param [velocity] {Number|Number[]}  Velocity
	     */
	    Tween.prototype.reset = function reset(value, velocity) {
	        this.state = value;
	        this.velocity = velocity || 0;
	    };

	    /**
	     * Halt transition at current state and erase all pending actions.
	     *
	     * @method halt
	     */
	    Tween.prototype.halt = function halt() {
	        var value = this.get();
	        this.reset(value);
	        this._active = false;
	        this.emit('end', value);
	    };

	    /**
	     * Update the transition in time.
	     *
	     * @method update
	     */
	    Tween.prototype.update = function update() {
	        if (!this._active) return;

	        var timeSinceStart = now() - this._startTime;

	        this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, 1);

	        if (timeSinceStart < this._duration) {
	            var t = timeSinceStart / this._duration;
	            this.state = _interpolate(this._startValue, this._endValue, this._curve(t));
	            this.emit('update', this.state);
	        }
	        else {
	            this.emit('update', this._endValue);

	            this.reset(this._endValue);
	            this._active = false;
	            this.emit('end', this._endValue);
	        }
	    };

	    function getCurve(curveName) {
	        var curve = registeredCurves[curveName];
	        if (curve !== undefined) return curve;
	        else throw new Error('curve not registered');
	    }

	    function _interpolate(a, b, t) {
	        var result;
	        if (a instanceof Array){
	            result = [];
	            for (var i = 0; i < a.length; i++){
	                if (typeof a[i] === 'number')
	                    result.push(_interpolate1D(a[i], b[i], t));
	                else result.push(a[i]);
	            }

	        }
	        else result = _interpolate1D(a, b, t);
	        return result;
	    }

	    function _interpolate1D(a, b, t){
	        return ((1 - t) * a) + (t * b);
	    }

	    function _calculateVelocity1D(current, start, curve, duration, t) {
	        return (current - start) * (curve(t + eps) - curve(t - eps)) / (2 * eps * duration);
	    }

	    function _calculateVelocity(current, start, curve, duration, t) {
	        var result;
	        if (current instanceof Array){
	            result = [];
	            for (var i = 0; i < current.length; i++){
	                if (typeof current[i] === 'number')
	                    result.push(_calculateVelocity1D(current[i], start[i], curve, duration, t));
	                else result.push(current[i]);
	            }
	        }
	        else result = _calculateVelocity1D(current, start, curve, duration, t);
	        return result;
	    }

	    module.exports = Tween;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);

	    var now = Date.now;
	    var eps = 1e-6; // for calculating velocity using finite difference
	    var tolerance = 1e-9; // energy minimum

	    /**
	     * A method of interpolating between start and end values with
	     *  a spring transition.
	     *
	     * @class Tween
	     * @private
	     * @namespace Transitions
	     * @constructor
	     * @param value {Number}    Initial value
	     * @param velocity {Number} Initial velocity
	     */
	    function Spring(value, velocity) {
	        SimpleStream.call(this);

	        this.value = value || 0;
	        this.velocity = velocity || 0;

	        this.target = null;
	        this.startTime = now();
	        this.curve = null;
	        this.energy = null;
	        this.energyTolerance = tolerance;
	        this._active = false;

	        this._eventOutput = new EventHandler();
	        EventHandler.setOutputHandler(this, this._eventOutput);
	    }

	    Spring.DIMENSIONS = 1;

	    Spring.DEFAULT_OPTIONS = {
	        velocity: 0,
	        damping: 0.5,
	        period : 100
	    };

	    Spring.prototype = Object.create(SimpleStream.prototype);
	    Spring.prototype.constructor = Spring;

	    /**
	     * Set new value to transition to.
	     *
	     * @method set
	     * @param value {Number}                End value
	     * @param [transition] {Object}         Transition definition
	     */
	    Spring.prototype.set = function (value, transition) {
	        var x0 = this.get();

	        if (!this._active){
	            this.emit('start', x0);
	            this._active = true;
	        }

	        var damping = transition.damping || Spring.DEFAULT_OPTIONS.damping;
	        var period = transition.period || Spring.DEFAULT_OPTIONS.period;
	        var v0 = transition.velocity || this.velocity;

	        this.curve = getCurve(damping, period, x0, value, v0);
	        this.energy = calculateEnergy(period);

	        var spread = getSpread(value, x0);
	        this.energyTolerance = tolerance * Math.pow(spread, 2);

	        this.target = value;
	        this.startTime = now();
	    };

	    /**
	     * Get current value.
	     *
	     * @method get
	     * @return {Number}
	     */
	    Spring.prototype.get = function () {
	        return this.value;
	    };

	    /**
	     * Get current velocity
	     *
	     * @method getVelocity
	     * @returns {Number}
	     */
	    Spring.prototype.getVelocity = function () {
	        return this.velocity;
	    };

	    /**
	     * Reset the value and velocity of the transition.
	     *
	     * @method reset
	     * @param value {Number}       Value
	     * @param [velocity] {Number}  Velocity
	     */
	    Spring.prototype.reset = function (value, velocity) {
	        this.value = value;
	        this.velocity = velocity || 0;
	    };

	    /**
	     * Halt transition at current state and erase all pending actions.
	     *
	     * @method halt
	     */
	    Spring.prototype.halt = function () {
	        var value = this.get();
	        this.reset(value);
	        this._active = false;
	        this.emit('end', value);
	    };

	    /**
	     * Update the transition in time.
	     *
	     * @method update
	     */
	    Spring.prototype.update = function update() {
	        if (!this._active) return;

	        var timeSinceStart = now() - this.startTime;

	        var value = this.curve(timeSinceStart);
	        var next = this.curve(timeSinceStart + eps);
	        var prev = this.curve(timeSinceStart - eps);

	        this.velocity = (next - prev) / (2 * eps);

	        var energy = this.energy(this.target, value, this.velocity);

	        if (energy >= this.energyTolerance) {
	            this.value = value;
	            this.emit('update', value);
	        }
	        else {
	            this.emit('update', this.target);

	            this.reset(this.target);
	            this._active = false;
	            this.emit('end', this.target);
	        }
	    };

	    function getSpread(x0, value){
	        return Math.max(1, Math.abs(value - x0));
	    }

	    function getCurve(damping, period, x0, value, v0){
	        if (damping < 1)
	            return createUnderDampedSpring(damping, period, x0, value, v0);
	        else if (damping === 1)
	            return createCriticallyDampedSpring(damping, period, x0, value, v0);
	        else
	            return createOverDampedSpring(damping, period, x0, value, v0);
	    }

	    function calculateEnergy(period){
	        var omega = 2 * Math.PI / period;

	        return function(origin, position, velocity){
	            var distance = origin - position;
	            var potentialEnergy = omega * omega * distance * distance;
	            var kineticEnergy = velocity * velocity;
	            return kineticEnergy + potentialEnergy;
	        }
	    }

	    function createUnderDampedSpring(damping, period, x0, x1, v0) {
	        var w_d =  Math.sqrt(1 - damping * damping) / period; // damped frequency
	        var A = x0 - x1;
	        var B = (damping / period * A + v0) / (w_d);

	        return function (t) {
	            return x1 + Math.exp(-damping * t / period) *
	                (A * Math.cos(w_d * t) + B * Math.sin(w_d * t));
	        }
	    }

	    function createCriticallyDampedSpring(damping, period, x0, x1, v0) {
	        var A = x0 - x1;
	        var B = v0 + A / period;

	        return function (t) {
	            return x1 + Math.exp(-damping * t / period) * (A + B * t);
	        }
	    }

	    function createOverDampedSpring(damping, period, x0, x1, v0) {
	        var w_d = Math.sqrt(damping * damping - 1) / period; // damped frequency
	        var r1 = -damping / period + w_d;
	        var r2 = -damping / period - w_d;
	        var L = x0 - x1;
	        var const1 = (r1 * L - v0) / (r2 - r1);
	        var A = L + const1;
	        var B = -const1;

	        return function (t) {
	            return x1 + A * Math.exp(r1 * t) + B * Math.exp(r2 * t);
	        }
	    }

	    module.exports = Spring;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);

	    var now = Date.now;
	    var tolerance = 1e-2; // energy minimum

	    /**
	     * Defines an inertial transition, which decreases
	     *
	     * @class Tween
	     * @private
	     * @namespace Transitions
	     * @constructor
	     * @param value {Number}    Initial value
	     * @param velocity {Number} Initial velocity
	     */
	    function Inertia(value, velocity) {
	        SimpleStream.call(this);

	        this.value = value || 0;
	        this.velocity = velocity || 0;
	        this.damping = 0;

	        this.energy = null;
	        this._active = false;
	        this._previousTime = now();

	        this._eventOutput = new EventHandler();
	        EventHandler.setOutputHandler(this, this._eventOutput);
	    }

	    Inertia.DIMENSIONS = 1;

	    Inertia.DEFAULT_OPTIONS = {
	        velocity: 0,
	        damping: 0.1
	    };

	    Inertia.prototype = Object.create(SimpleStream.prototype);
	    Inertia.prototype.constructor = Inertia;

	    /**
	     * Set new value to transition to, with a transition definition.
	     *
	     * @method set
	     * @param value {Number}                Starting value
	     * @param [transition] {Object}         Transition definition
	     */
	    Inertia.prototype.set = function (value, transition) {
	        if (!this._active) {
	            this.emit('start', value);
	            this._active = true;
	        }

	        this.value = value;

	        this.damping = (transition.damping == undefined)
	            ? Inertia.DEFAULT_OPTIONS.damping
	            : Math.pow(Math.min(transition.damping, 1), 3);

	        this.velocity = transition.velocity || this.velocity;
	    };

	    /**
	     * Get current value.
	     *
	     * @method get
	     * @return {Number}
	     */
	    Inertia.prototype.get = function () {
	        return this.value;
	    };

	    /**
	     * Get current velocity
	     *
	     * @method getVelocity
	     * @returns {Number}
	     */
	    Inertia.prototype.getVelocity = function () {
	        return this.velocity;
	    };

	    /**
	     * Reset the value and velocity of the transition.
	     *
	     * @method reset
	     * @param value {Number}       Value
	     * @param [velocity] {Number}  Velocity
	     */
	    Inertia.prototype.reset = function (value, velocity) {
	        this.value = value;
	        //this.velocity = velocity || 0;
	    };

	    /**
	     * Halt transition at current state and erase all pending actions.
	     *
	     * @method halt
	     */
	    Inertia.prototype.halt = function () {
	        var value = this.get();
	        this.reset(value);
	        this._active = false;
	        this.emit('end', value);
	    };

	    /**
	     * Update the transition in time.
	     *
	     * @method update
	     */
	    Inertia.prototype.update = function update() {
	        if (!this._active) return;

	        var currentTime = now();
	        var dt = currentTime - this._previousTime;
	        this._previousTime = currentTime;

	        this.velocity *= (1 - this.damping);
	        this.value += dt * this.velocity;

	        var energy = 0.5 * this.velocity * this.velocity;

	        if (energy >= tolerance) {
	            this.emit('update', this.value);
	        }
	        else {
	            this.emit('update', this.value);

	            this.reset(this.value);
	            this._active = false;
	            this.emit('end', this.value);
	        }
	    };

	    module.exports = Inertia;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var RenderTreeNode = __webpack_require__(27);
	    var Controller = __webpack_require__(30);
	    var SizeNode = __webpack_require__(17);
	    var LayoutNode = __webpack_require__(8);
	    var Transitionable = __webpack_require__(22);
	    var EventHandler = __webpack_require__(9);
	    var Stream = __webpack_require__(15);
	    var ResizeStream = __webpack_require__(18);
	    var SizeObservable = __webpack_require__(19);
	    var layoutAlgebra = __webpack_require__(28);
	    var sizeAlgebra = __webpack_require__(29);

	    /**
	     * A View provides encapsulation for a subtree of the render tree. You can build
	     *  complicated visual components and add them to a render tree as you would a `Surface`.
	     *
	     *  Custom `Views` are created by calling `extend` on the `View` constructor.
	     *
	     *  In addition to what a `Controller` provides, a View provides:
	     *
	     *      Render Tree method: `.add`
	     *      Size methods: `setSize`, `setProportions`
	     *      Layout methods: `setOpacity`, `setOrigin`
	     *
	     *  @example
	     *
	     *      var MyView = View.extend({
	     *          defaults : {
	     *              defaultOption1 : '',
	     *              defaultOption2 : 42
	     *          },
	     *          initialize : function(options){
	     *              // this method called on instantiation
	     *              // options are passed in after being patched by the specified defaults
	     *
	     *              var surface = new Surface({
	     *                  content : options.defaultOption1,
	     *                  size : [options.defaultOption2,100],
	     *                  properties : {background : 'red'}
	     *              });
	     *
	     *              this.add(surface);
	     *          }
	     *      });
	     *
	     *      var myView = new myView({defaultOption1 : 'hello'});
	     *
	     *      var context = Context();
	     *      context.add(myView);
	     *
	     *      context.mount(document.body);
	     *
	     * @class View
	     * @constructor
	     * @extends Core.Controller
	     * @uses Core.SizeNode
	     * @uses Core.LayoutNode
	     * @uses Core.SimpleStream
	     */
	    var View = Controller.extend({
	        _isView : true,
	        defaults : {
	            size : null,
	            origin : null,
	            opacity : 1
	        },
	        events : {
	            change : setOptions
	        },
	        constructor : function View(options){
	            this._size = new EventHandler();
	            this._layout = new EventHandler();

	            this._sizeNode = new SizeNode();
	            this._layoutNode = new LayoutNode();

	            this._node = new RenderTreeNode();
	            this._node.tempRoot = this._node;

	            this.size = ResizeStream.lift(
	                function ViewSizeAlgebra (sizeSpec, parentSize){
	                    if (!parentSize) return false;
	                    return (sizeSpec)
	                        ? sizeAlgebra(sizeSpec, parentSize)
	                        : parentSize;
	                },
	                [this._sizeNode, this._size]
	            );

	            this._cachedSize = [0,0];
	            this.size.on('resize', function(size){
	                this._cachedSize = size;
	            }.bind(this));

	            var layout = Stream.lift(
	                function ViewLayoutAlgebra (parentSpec, objectSpec, size){
	                    if (!parentSpec || !size) return false;
	                    return (objectSpec)
	                        ? layoutAlgebra(objectSpec, parentSpec, size)
	                        : parentSpec;
	                }.bind(this),
	                [this._layout, this._layoutNode, this.size]
	            );

	            this._node._size.subscribe(this.size);
	            this._node._layout.subscribe(layout);

	            Controller.apply(this, arguments);
	            if (this.options) setOptions.call(this, this.options);
	        },
	        /**
	         * Extends the render tree subtree with a new node.
	         *
	         * @method add
	         * @param object {SizeNode|LayoutNode|Surface} Node
	         * @return {RenderTreeNode}
	         */
	        add : function add(){
	            return RenderTreeNode.prototype.add.apply(this._node, arguments);
	        },
	        /**
	         * Getter for size.
	         *
	         * @method getSize
	         * @return size {Number[]}
	         */
	        getSize : function(){
	            return this._cachedSize;
	        },
	        /**
	         * Setter for size.
	         *
	         * @method setSize
	         * @param size {Number[]|Stream} Size as [width, height] in pixels, or a stream.
	         */
	        setSize : function setSize(size){
	            this._sizeNode.set({size : size});
	        },
	        /**
	         * Setter for proportions.
	         *
	         * @method setProportions
	         * @param proportions {Number[]|Stream} Proportions as [x,y], or a stream.
	         */
	        setProportions : function setProportions(proportions){
	            this._sizeNode.set({proportions : proportions});
	        },
	        /**
	         * Setter for origin.
	         *
	         * @method setOrigin
	         * @param origin {Number[]|Stream} Origin as [x,y], or a stream.
	         */
	        setOrigin : function setOrigin(origin){
	            this._layoutNode.set({origin : origin});
	        },
	        /**
	         * Setter for opacity.
	         *
	         * @method setOpacity
	         * @param opacity {Number|Stream} Opacity
	         */
	        setOpacity : function setOpacity(opacity){
	            this._layoutNode.set({opacity : opacity});
	        }
	    });

	    function setOptions(options){
	        for (var key in options){
	            var value = options[key];
	            switch (key){
	                case 'size':
	                    this.setSize(value);
	                    break;
	                case 'proportions':
	                    this.setProportions(value);
	                    break;
	                case 'origin':
	                    this.setOrigin(value);
	                    break;
	                case 'opacity':
	                    this.setOpacity(value);
	                    break;
	            }
	        }
	    }

	    module.exports = View;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var Stream = __webpack_require__(15);
	    var ResizeStream = __webpack_require__(18);
	    var SizeNode = __webpack_require__(17);
	    var LayoutNode = __webpack_require__(8);
	    var layoutAlgebra = __webpack_require__(28);
	    var sizeAlgebra = __webpack_require__(29);

	    var SIZE_KEYS = SizeNode.KEYS;
	    var LAYOUT_KEYS = LayoutNode.KEYS;

	    /**
	     * A node in the render tree. As such, it wraps a layout or size node,
	     *  providing them with an `add` method. By adding nodes, the render tree
	     *  is constructed, the leaves of which are `Surfaces`.
	     *
	     *  @constructor
	     *  @class RenderTreeNode
	     *  @private
	     *  @param object {Object|SizeNode|LayoutNode|Surface|View}
	     */
	    function RenderTreeNode(object) {
	        // layout and size inputs
	        this._layout = new EventHandler();
	        this._size = new EventHandler();

	        // layout and size streams
	        this.size = null;
	        this.layout = null;

	        this.root = null;

	        if (object) _set.call(this, object);
	    }

	    /**
	     * Extends the render tree with a new node. Similar to how a tree data structure
	     *  is created, but instead of a node with an array of children, children subscribe
	     *  to notifications from the parent.
	     *
	     *  Nodes can be instances of `LayoutNode`, `SizeNode`, or Object literals with
	     *  size and layout properties, in which case, appropriate nodes will be created.
	     *
	     *  This method also takes `Views` (subtrees) and `Surfaces` (leaves).
	     *
	     * @method add
	     * @chainable
	     * @param node {Object|SizeNode|LayoutNode|Surface|View} Node
	     * @return {RenderTreeNode}
	     */
	    RenderTreeNode.prototype.add = function add(node) {
	        var childNode;

	        if (node.constructor === Object){
	            // Object literal case
	            return _createNodeFromObjectLiteral.call(this, node);
	        }
	        else if (node._isView){
	            // View case
	            if (this.root)
	                node._node.root = this.root;
	            else if (this.tempRoot)
	                node._node.tempRoot = this.tempRoot;
	            childNode = node;
	        }
	        else {
	            // Node case
	            childNode = new RenderTreeNode(node);
	            if (this.tempRoot)
	                childNode.tempRoot = this.tempRoot;
	            else childNode.root = _getRootNode.call(this);
	        }

	        childNode._layout.subscribe(this.layout || this._layout);
	        childNode._size.subscribe(this.size || this._size);

	        return childNode;
	    };

	    function _createNodeFromObjectLiteral(object){
	        var sizeKeys = {};
	        var layoutKeys = {};

	        for (var key in object){
	            if (SIZE_KEYS[key]) sizeKeys[key] = object[key];
	            else if (LAYOUT_KEYS[key]) layoutKeys[key] = object[key];
	        }

	        var node = this;
	        var needsSize = Object.keys(sizeKeys).length > 0;
	        var needsLayout = Object.keys(layoutKeys).length > 0;

	        // create extra align node if needed
	        if (needsSize && layoutKeys.align){
	            var alignNode = new LayoutNode({
	                align : layoutKeys.align
	            });
	            delete layoutKeys.align;
	            node = node.add(alignNode);
	        }

	        // create size node first if needed
	        if (needsSize)
	            node = node.add(new SizeNode(sizeKeys));

	        // create layout node if needed
	        if (needsLayout)
	            node = node.add(new LayoutNode(layoutKeys));

	        return node;
	    }

	    function _getRootNode(){
	        if (this.root) return this.root;
	        if (this.tempRoot) return _getRootNode.call(this.tempRoot);
	        return this;
	    }

	    function _set(object) {
	        if (object instanceof SizeNode){
	            this.size = ResizeStream.lift(
	                function SGSizeAlgebra (objectSpec, parentSize){
	                    if (!parentSize) return false;
	                    return (objectSpec)
	                        ? sizeAlgebra(objectSpec, parentSize)
	                        : parentSize;
	                },
	                [object, this._size]
	            );
	            return;
	        }
	        else if (object instanceof LayoutNode){
	            this.layout = Stream.lift(
	                function SGLayoutAlgebra (objectSpec, parentSpec, size){
	                    if (!parentSpec || !size) return false;
	                    return (objectSpec)
	                        ? layoutAlgebra(objectSpec, parentSpec, size)
	                        : parentSpec;
	                },
	                [object, this._layout, this._size]
	            );
	            return;
	        }

	        // object is a leaf node
	        object._size.subscribe(this._size);
	        object._layout.subscribe(this._layout);
	        object._getRoot = _getRootNode.bind(this);
	    }

	    module.exports = RenderTreeNode;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Transform = __webpack_require__(21);

	    var DEFAULT = {
	        OPACITY : 1,
	        TRANSFORM : Transform.identity,
	        ORIGIN : null,
	        ALIGN : null
	    };

	    /**
	     * Defines the rules for composing layout specs: transform, align, origin and opacity.
	     *  Transform is multiplied by the parent's transform (matrix multiplication).
	     *  Align is a proportional offset relative to the parent size.
	     *  Origin is a proportional offset relative to the current size.
	     *  Opacity is multiplied by the parent's opacity.
	     *
	     * @method compose
	     * @private
	     * @param spec {object}           Object layout spec
	     * @param parentSpec {object}     Parent layout spec
	     * @param size {Array}            Object size
	     * @return {object}               The composed layout spec
	     */

	    function compose(spec, parentSpec, size){
	        var parentOpacity = (parentSpec.opacity !== undefined) ? parentSpec.opacity : DEFAULT.OPACITY;
	        var parentTransform = parentSpec.transform || DEFAULT.TRANSFORM;

	        var origin = spec.origin || DEFAULT.ORIGIN;
	        var align = spec.align || DEFAULT.ALIGN;

	        var opacity = (spec.opacity !== undefined)
	            ? parentOpacity * spec.opacity
	            : parentOpacity;

	        var transform = (spec.transform)
	            ? Transform.compose(parentTransform, spec.transform)
	            : parentTransform;

	        var nextSizeTransform = (spec.origin)
	            ? parentTransform
	            : parentSpec.nextSizeTransform || parentTransform;

	        if (spec.size)
	            nextSizeTransform = parentTransform;

	        if (origin && (origin[0] || origin[1])){
	            //TODO: allow origin to propogate when size is non-numeric
	            var tx =  (typeof size[0] === 'number') ? -origin[0] * size[0] : 0;
	            var ty =  (typeof size[1] === 'number') ? -origin[1] * size[1] : 0;
	            transform = Transform.moveThen([tx, ty, 0], transform);
	            origin = null;
	        }

	        if (size && align && (align[0] || align[1])) {
	            var shift = _vecInContext([align[0] * size[0], align[1] * size[1], 0], nextSizeTransform);
	            transform = Transform.thenMove(transform, shift);
	            align = null;
	        }

	        return {
	            transform : transform,
	            opacity : opacity,
	            origin : origin,
	            align : align,
	            nextSizeTransform : nextSizeTransform
	        };
	    }

	    function _vecInContext(v, m) {
	        return [
	            v[0] * m[0] + v[1] * m[4] + v[2] * m[8],
	            v[0] * m[1] + v[1] * m[5] + v[2] * m[9],
	            v[0] * m[2] + v[1] * m[6] + v[2] * m[10]
	        ];
	    }

	    module.exports = compose;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {

	    /**
	     * Defines the rules for composing size specs (size, margin, proportions) into a new size.
	     *  A margin array reduces the parent size by an amount specified in pixels.
	     *  A proportions array scales the parent size by a provided ratio.
	     *  A size array [width, height] can take `true`, `undefined`, or numeric values.
	     *      `undefined` takes the parent value
	     *      `true` takes the value defined by the DOM
	     *      numeric values override parent values
	     *
	     * @method compose
	     * @private
	     * @param spec {object}           Object size spec
	     * @param parentSize {object}     Parent size
	     * @return size {object}          Composed size
	     */

	    function compose(spec, parentSize){
	        if (!spec) return parentSize;

	        var size = new Array(2);

	        if (spec.size) {
	            // inheritance
	            if (spec.size[0] === undefined) size[0] = parentSize[0];
	            if (spec.size[1] === undefined) size[1] = parentSize[1];

	            // override
	            if (typeof spec.size[0] === 'number') size[0] = spec.size[0];
	            if (typeof spec.size[1] === 'number') size[1] = spec.size[1];

	            if (spec.size[0] === true) size[0] = true;
	            if (spec.size[1] === true) size[1] = true;
	        }

	        //TODO: what is parentSize isn't numeric? Compose margin/proportions?
	        if (spec.margins){
	            size[0] = parentSize[0] - (2 * spec.margins[0]);
	            size[1] = parentSize[1] - (2 * spec.margins[1]);
	        }

	        if (spec.proportions) {
	            if (typeof spec.proportions[0] === 'number') size[0] = spec.proportions[0] * parentSize[0];
	            if (typeof spec.proportions[1] === 'number') size[1] = spec.proportions[1] * parentSize[1];
	        }

	        if (spec.aspectRatio) {
	            if (typeof size[0] === 'number') size[1] = spec.aspectRatio * size[0];
	            else if (typeof size[1] === 'number') size[0] = spec.aspectRatio * size[1];
	        }

	        if (size[0] === undefined) size[0] = parentSize[0];
	        if (size[1] === undefined) size[1] = parentSize[1];

	        return size;
	    }

	    module.exports = compose;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * copyright © 2015 David Valdman
	 */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var OptionsManager = __webpack_require__(31);
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);

	    /**
	     * A utility class which can be extended by custom classes. These classes will then
	     *  include event input and output streams, a optionsManager for handling optional
	     *  parameters with defaults, and take an event dictionary.
	     *
	     *  Specifically, instantiations will have an `options` dictionary property,
	     *  `input`, `output` stream properties, and
	     *  `on`, `off`, `emit`, `trigger`, `subscribe`, `unsubscribe` methods.
	     *
	     *  @example
	     *
	     *      var MyClass = Controller.extend({
	     *          defaults : {
	     *              defaultOption1 : value1,
	     *              defaultOption2 : value2
	     *          },
	     *          events : {
	     *              'change' : myUpdateOptionsFunction
	     *          },
	     *          initialize : function(options){
	     *              // this method called on instantiation
	     *              // options are passed in after being patched by the specified defaults
	     *
	     *              this.input.on('test', function(){
	     *                  console.log('test fired');
	     *              });
	     *          }
	     *      });
	     *
	     *      var myInstance = new MyClass({
	     *          defaultOption1 : value3
	     *      });
	     *
	     *      // myInstance.options = {
	     *      //     defaultOption1 : value3,
	     *      //     defaultOption2 : value2
	     *      // }
	     *
	     *      myInstance.subscribe(anotherStream);
	     *
	     *      anotherStream.emit('test'); // "test fired" in console
	     *
	     * @class Controller
	     * @constructor
	     * @namespace Core
	     * @uses Core.OptionsManager
	     * @param options {Object} Instance options
	     */
	    function Controller(options) {
	        this.options = _clone(this.constructor.DEFAULT_OPTIONS || Controller.DEFAULT_OPTIONS);
	        this._optionsManager = new OptionsManager(this.options);
	        if (options) this.setOptions(options);

	        this.input = new SimpleStream();
	        this.output = new SimpleStream();
	        EventHandler.setInputHandler(this, this.input);
	        EventHandler.setOutputHandler(this, this.output);
	        EventHandler.setInputEvents(this, this.constructor.EVENTS || Controller.EVENTS, this.input);

	        this.input.bindThis(this);
	        this.input.subscribe(this._optionsManager);

	        if (this.initialize) this.initialize(this.options);
	    }

	    /**
	     * Overwrite the DEFAULT_OPTIONS dictionary on the constructor of the class you wish to extend
	     *  with the Controller to patch any options that are not prescribed on instantiation.
	     *
	     * @attribute DEFAULT_OPTIONS
	     * @readOnly
	     */
	    Controller.DEFAULT_OPTIONS = {};

	    /**
	     * Overwrite the EVENTS dictionary on the constructor of the class you wish to extend
	     *  with the Controller to include events in {key : value} pairs where the keys are
	     *  event channel names and the values are functions to be executed.
	     *
	     * @attribute EVENTS
	     * @readOnly
	     */
	    Controller.EVENTS = {};

	    /**
	     * Options getter.
	     *
	     * @method getOptions
	     * @param key {string}      Key
	     * @return object {Object}  Options value for the key
	     */
	    Controller.prototype.getOptions = function getOptions(key) {
	        return OptionsManager.prototype.getOptions.apply(this._optionsManager, arguments);
	    };

	    /**
	     *  Options setter.
	     *
	     *  @method setOptions
	     *  @param options {Object} Options
	     */
	    Controller.prototype.setOptions = function setOptions() {
	        OptionsManager.prototype.setOptions.apply(this._optionsManager, arguments);
	    };

	    var RESERVED_KEYS = {
	        DEFAULTS : 'defaults',
	        EVENTS : 'events'
	    };

	    function _clone(obj) {
	        var copy;
	        if (typeof obj === 'object') {
	            copy = (obj instanceof Array) ? [] : {};
	            for (var key in obj) {
	                var value = obj[key];
	                if (typeof value === 'object' && value !== null) {
	                    if (value instanceof Array) {
	                        copy[key] = [];
	                        for (var i = 0; i < value.length; i++)
	                            copy[key][i] = _clone(value[i]);
	                    }
	                    else copy[key] = _clone(value);
	                }
	                else copy[key] = value;
	            }
	        }
	        else copy = obj;

	        return copy;
	    }

	    function extend(protoObj, constants){
	        var parent = this;

	        var child = (protoObj.hasOwnProperty('constructor'))
	            ? function(){ protoObj.constructor.apply(this, arguments); }
	            : function(){ parent.apply(this, arguments); };

	        child.extend = extend;
	        child.prototype = Object.create(parent.prototype);
	        child.prototype.constructor = child;

	        for (var key in protoObj){
	            var value = protoObj[key];
	            switch (key) {
	                case RESERVED_KEYS.DEFAULTS:
	                    child.DEFAULT_OPTIONS = value;
	                    break;
	                case RESERVED_KEYS.EVENTS:
	                    if (!child.EVENTS) child.EVENTS = value;
	                    else
	                        for (var key in value)
	                            child.EVENTS[key] = value[key];
	                    break;
	                default:
	                    child.prototype[key] = value;
	            }
	        }


	        for (var key in constants)
	            child[key] = constants[key];

	        return child;
	    }

	    /**
	     * Allows a class to extend Controller.
	     *  Note: this is a method defined on the Controller constructor
	     *
	     * @method extend
	     * @param protoObj {Object}     Prototype properties of the extended class
	     * @param constants {Object}    Constants to be added to the extended class's constructor
	     */
	    Controller.extend = extend;

	    module.exports = Controller;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);

	    /**
	     *  A utility for setting options in a class that enables patching options
	     *   with prescribed defaults and emitting `change` events when options are changed.
	     *   Recursively defined for nested options objects.
	     *
	     *   Note: only JSONable objects are allowed, so no functions.
	     *
	     * @class OptionsManager
	     * @namespace Core
	     * @constructor
	     * @private
	     * @uses Core.EventHandler
	     * @param value {Object} Options object literal
	     */
	    function OptionsManager(value) {
	        this._value = value;
	        this._eventHandler = null;
	    }

	    /**
	     * Constructor method. Create OptionsManager from source dictionary with arguments overriden by patch dictionary.
	     *
	     * @method OptionsManager.patch
	     * @param options {Object}          Options to be patched
	     * @param patch {...Object}         Options to overwrite
	     * @return source {Object}
	     */
	    OptionsManager.patch = function patch(options, patch) {
	        var manager = new OptionsManager(options);
	        for (var i = 1; i < arguments.length; i++) manager.patch(arguments[i]);
	        return options;
	    };

	    /**
	     * Constructor method. Convenience method to set options with defaults on an object instance.
	     *
	     * @method OptionsManager.patch
	     * @param options {Object}          Options to be patched
	     * @param overrides {...Object}     Options to overwrite
	     * @return source {Object}
	     */
	    OptionsManager.setOptions = function(instance, options, defaults){
	        defaults = defaults || _clone(instance.constructor.DEFAULT_OPTIONS) || {};
	        var optionsManager = new OptionsManager(defaults);
	        instance.setOptions = OptionsManager.prototype.setOptions.bind(optionsManager);
	        instance.getOptions = OptionsManager.prototype.getOptions.bind(optionsManager);
	        if (options) instance.setOptions(options);
	        return optionsManager.get();
	    };

	    function _createEventHandler() {
	        if (!this._eventHandler) this._eventHandler = new EventHandler();
	    }

	    /**
	     * Patch options with provided patches. Triggers `change` event on the object.
	     *
	     * @method patch
	     * @param options {Object}          Patch options
	     * @return this {OptionsManager}
	     */
	    OptionsManager.prototype.patch = function patch(options, clone) {
	        var myState = this._value;
	        for (var k in options) {
	            if ((k in myState) && (options[k] && options[k].constructor === Object) && (myState[k] && myState[k].constructor === Object)) {
	                if (!myState.hasOwnProperty(k)) myState[k] = Object.create(myState[k]);
	                this.key(k).patch(options[k]);
	                if (this._eventHandler) this._eventHandler.emit('change', {key: k, value: this.key(k).value()});
	            }
	            else this.set(k, options[k]);
	        }
	        return this;
	    };

	    /**
	     * Alias for patch
	     *
	     * @method setOptions
	     */
	    OptionsManager.prototype.setOptions = OptionsManager.prototype.patch;

	    /**
	     * Return OptionsManager based on sub-object retrieved by `key`.
	     *
	     * @method key
	     * @param key {string}      Key
	     * @return {OptionsManager} Value
	     */
	    OptionsManager.prototype.key = function key(key) {
	        var result = new OptionsManager(this._value[key]);
	        if (!(result._value instanceof Object) || result._value instanceof Array) result._value = {};
	        return result;
	    };

	    /**
	     * Look up options value by key or get the full options hash.
	     *
	     * @method get
	     * @param key {string}  Key
	     * @return {Object}     Associated object or full options hash
	     */
	    OptionsManager.prototype.get = function get(key) {
	        return key ? this._value[key] : this._value;
	    };

	    /**
	     * Alias for get
	     *
	     * @method getOptions
	     */
	    OptionsManager.prototype.getOptions = OptionsManager.prototype.get;

	    /**
	     * Set key to value. Outputs `change` event if a value is overwritten.
	     *
	     * @method set
	     * @param key {string}          Key
	     * @param value {Object}        Value
	     * @return {OptionsManager}     Updated OptionsManager
	     */
	    OptionsManager.prototype.set = function set(key, value) {
	        var originalValue = this.get(key);
	        this._value[key] = value;
	        if (this._eventHandler && value !== originalValue) this._eventHandler.emit('change', {key: key, value: value});
	        return this;
	    };

	    /**
	     * Adds a handler to the `type` channel which will be executed on `emit`.
	     *
	     * @method "on"
	     * @param type {String}         Channel name
	     * @param handler {Function}    Callback
	     */
	    OptionsManager.prototype.on = function on(type, handler) {
	        _createEventHandler.call(this);
	        EventHandler.prototype.on.apply(this._eventHandler, arguments);
	    };

	    /**
	     * Removes the `handler` from the `type` channel.
	     *   This undoes the work of `on`.
	     *
	     * @method off
	     * @param type {String}         Channel name
	     * @param handler {Function}    Callback
	     */
	    OptionsManager.prototype.off = function off(type, handler) {
	        _createEventHandler.call(this);
	        EventHandler.prototype.off.apply(this._eventHandler, arguments);
	    };

	    function _clone(obj) {
	        var copy;
	        if (typeof obj === 'object') {
	            copy = (obj instanceof Array) ? [] : {};
	            for (var key in obj) {
	                var value = obj[key];
	                if (typeof value === 'object' && value !== null) {
	                    if (value instanceof Array) {
	                        copy[key] = [];
	                        for (var i = 0; i < value.length; i++)
	                            copy[key][i] = _clone(value[i]);
	                    }
	                    else copy[key] = _clone(value);
	                }
	                else copy[key] = value;
	            }
	        }
	        else copy = obj;

	        return copy;
	    }

	    module.exports = OptionsManager;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        Surface: __webpack_require__(33),
	        ContainerSurface: __webpack_require__(35),
	        Context: __webpack_require__(36)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Samsara Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var ElementOutput = __webpack_require__(34);
	    var dirtyQueue = __webpack_require__(6);

	    var isTouchEnabled = "ontouchstart" in window;

	    /**
	     * Surface is a wrapper for a DOM element animated by Samsara.
	     *  Samsara will commit opacity, size and CSS3 `transform` properties into the Surface.
	     *  CSS classes, properties and DOM attributes can also be added and dynamically changed.
	     *  Surfaces also act as sources for DOM events such as `click`.
	     *
	     * @example
	     *
	     *      var context = new Context()
	     *
	     *      var surface = new Surface({
	     *          content : 'Hello world!',
	     *          size : [true,100],
	     *          opacity : .5,
	     *          classes : ['myClass1', 'myClass2'],
	     *          properties : {background : 'red'}
	     *      });
	     *
	     *      context.add(surface);
	     *
	     *      context.mount(document.body);
	     *
	     *  @example
	     *
	     *      // same as above but create an image instead
	     *      var surface = new Surface({
	     *          attributes : {
	     *              src : 'cat.jpg'
	     *          },
	     *          size : [100,100],
	     *          tagName : 'img'
	     *      });
	     *
	     * @class Surface
	     * @namespace DOM
	     * @constructor
	     * @extends Core.ElementOutput
	     * @param [options] {Object}                Options
	     * @param [options.size] {Number[]}         Size (width, height) in pixels. These can also be `true` or `undefined`.
	     * @param [options.classes] {String[]}      CSS classes
	     * @param [options.properties] {Object}     Dictionary of CSS properties
	     * @param [options.attributes] {Object}     Dictionary of HTML attributes
	     * @param [options.content] Sstring}        InnerHTML content
	     * @param [options.origin] {Number[]}       Origin (x,y), with values between 0 and 1
	     * @param [options.margins] {Number[]}      Margins (x,y) in pixels
	     * @param [options.proportions] {Number[]}  Proportions (x,y) with values between 0 and 1
	     * @param [options.aspectRatio] {Number}    Aspect ratio
	     * @param [options.opacity=1] {Number}      Opacity
	     * @param [options.tagName="div"] {String}  HTML tagName
	     * @param [options.enableScroll] {Boolean}  Allows a Surface to support native scroll behavior
	     */
	    function Surface(options) {
	        this.properties = {};
	        this.attributes = {};
	        this.content = '';
	        this.classList = [];

	        this._contentDirty = true;
	        this._dirtyClasses = [];
	        this._classesDirty = true;
	        this._stylesDirty = true;
	        this._attributesDirty = true;
	        this._dirty = false;
	        this._cachedSize = null;

	        if (options) {
	            // default to DOM size for provided elements
	            if (options.el && !options.size){
	                this._contentDirty = false;
	                options.size = [true, true];
	            }

	            ElementOutput.call(this, options.el);
	            this.setOptions(options);
	        }
	        else ElementOutput.call(this);
	    }

	    Surface.prototype = Object.create(ElementOutput.prototype);
	    Surface.prototype.constructor = Surface;
	    Surface.prototype.elementType = 'div'; // Default tagName. Can be overridden in options.
	    Surface.prototype.elementClass = 'samsara-surface';

	    function _setDirty(){
	        if (this._dirty || !this._currentTarget) return;

	        dirtyQueue.push(function(){
	            var target = this._currentTarget;

	            if (this._classesDirty) {
	                _removeClasses.call(this, target);
	                _applyClasses.call(this, target);
	            }

	            if (this._stylesDirty) _applyProperties.call(this, target);

	            if (this._attributesDirty) _applyAttributes.call(this, target);

	            if (this._contentDirty) this.deploy(target);

	            this._dirty = false;
	        }.bind(this))
	    }

	    function _applyClasses(target) {
	        for (var i = 0; i < this.classList.length; i++)
	            target.classList.add(this.classList[i]);
	        this._classesDirty = false;
	    }

	    function _applyProperties(target) {
	        for (var key in this.properties)
	            target.style[key] = this.properties[key];
	        this._stylesDirty = false;
	    }

	    function _applyAttributes(target) {
	        for (var key in this.attributes)
	            target.setAttribute(key, this.attributes[key]);
	        this._attributesDirty = false;
	    }

	    function _removeClasses(target) {
	        for (var i = 0; i < this._dirtyClasses.length; i++) target.classList.remove(this._dirtyClasses[i]);
	        this._dirtyClasses = [];
	    }

	    function _removeProperties(target) {
	        for (var key in this.properties)
	            target.style[key] = '';
	    }

	    function _removeAttributes(target) {
	        for (var key in this.attributes)
	            target.removeAttribute(key);
	    }

	    function preventDrag(){
	        if (this._currentTarget){
	            this._currentTarget.addEventListener('touchmove', function (event) {
	                event.preventDefault();
	            }, false);
	        }
	        else {
	            this.on('deploy', function (target) {
	                target.addEventListener('touchmove', function (event) {
	                    event.preventDefault();
	                }, false);
	            }.bind(this));
	        }
	    }

	    function enableScroll(){
	        this.addClass('samsara-scrollable');
	    }
	    
	    /**
	     * Setter for HTML attributes.
	     *
	     * @method setAttributes
	     * @chainable
	     * @param attributes {Object}   HTML Attributes
	     */
	    Surface.prototype.setAttributes = function setAttributes(attributes) {
	        for (var key in attributes) {
	            var value = attributes[key];
	            if (value != undefined) this.attributes[key] = attributes[key];
	        }
	        this._attributesDirty = true;
	        _setDirty.call(this);
	        return this;
	    };

	    /**
	     * Getter for HTML attributes.
	     *
	     * @method getAttributes
	     * @return {Object}
	     */
	    Surface.prototype.getAttributes = function getAttributes() {
	        return this.attributes;
	    };

	    /**
	     * Setter for CSS properties.
	     *  Note: properties are camelCased, not hyphenated.
	     *
	     * @method setProperties
	     * @chainable
	     * @param properties {Object}   CSS properties
	     */
	    Surface.prototype.setProperties = function setProperties(properties) {
	        for (var key in properties)
	            this.properties[key] = properties[key];
	        this._stylesDirty = true;
	        _setDirty.call(this);
	        return this;
	    };

	    /**
	     * Getter for CSS properties.
	     *
	     * @method getProperties
	     * @return {Object}             Dictionary of this Surface's properties.
	     */
	    Surface.prototype.getProperties = function getProperties() {
	        return this.properties;
	    };

	    /**
	     * Add CSS class to the list of classes on this Surface.
	     *
	     * @method addClass
	     * @chainable
	     * @param className {String}    Class name
	     */
	    Surface.prototype.addClass = function addClass(className) {
	        if (this.classList.indexOf(className) < 0) {
	            this.classList.push(className);
	            this._classesDirty = true;
	            _setDirty.call(this);
	        }
	        return this;
	    };

	    /**
	     * Remove CSS class from the list of classes on this Surface.
	     *
	     * @method removeClass
	     * @param className {string}    Class name
	     */
	    Surface.prototype.removeClass = function removeClass(className) {
	        var i = this.classList.indexOf(className);
	        if (i >= 0) {
	            this._dirtyClasses.push(this.classList.splice(i, 1)[0]);
	            this._classesDirty = true;
	            _setDirty.call(this);
	        }
	    };

	    /**
	     * Toggle CSS class for this Surface.
	     *
	     * @method toggleClass
	     * @param  className {String}   Class name
	     */
	    Surface.prototype.toggleClass = function toggleClass(className) {
	        var i = this.classList.indexOf(className);
	        (i == -1)
	            ? this.addClass(className)
	            : this.removeClass(className);
	    };

	    /**
	     * Reset classlist.
	     *
	     * @method setClasses
	     * @chainable
	     * @param classlist {String[]}  ClassList
	     */
	    Surface.prototype.setClasses = function setClasses(classList) {
	        var removal = [];
	        for (var i = 0; i < this.classList.length; i++) {
	            if (classList.indexOf(this.classList[i]) < 0) removal.push(this.classList[i]);
	        }
	        for (i = 0; i < removal.length; i++) this.removeClass(removal[i]);
	        // duplicates are already checked by addClass()
	        for (i = 0; i < classList.length; i++) this.addClass(classList[i]);
	        _setDirty.call(this);
	        return this;
	    };

	    /**
	     * Get array of CSS classes attached to this Surface.
	     *
	     * @method getClasslist
	     * @return {String[]}
	     */
	    Surface.prototype.getClassList = function getClassList() {
	        return this.classList;
	    };

	    /**
	     * Set or overwrite innerHTML content of this Surface.
	     *
	     * @method setContent
	     * @chainable
	     * @param content {String|DocumentFragment} HTML content
	     */
	    Surface.prototype.setContent = function setContent(content) {
	        if (this.content !== content) {
	            this.content = content;
	            this._contentDirty = true;
	            _setDirty.call(this);
	        }
	        return this;
	    };

	    /**
	     * Return innerHTML content of this Surface.
	     *
	     * @method getContent
	     * @return {String}
	     */
	    Surface.prototype.getContent = function getContent() {
	        return this.content;
	    };

	    /**
	     * Set options for this surface
	     *
	     * @method setOptions
	     * @param options {Object} Overrides for default options. See constructor.
	     */
	    Surface.prototype.setOptions = function setOptions(options) {
	        if (options.tagName !== undefined) this.elementType = options.tagName;
	        if (options.opacity !== undefined) this.setOpacity(options.opacity);
	        if (options.size !== undefined) this.setSize(options.size);
	        if (options.origin !== undefined) this.setOrigin(options.origin);
	        if (options.proportions !== undefined) this.setProportions(options.proportions);
	        if (options.margins !== undefined) this.setMargins(options.margins);
	        if (options.classes !== undefined) this.setClasses(options.classes);
	        if (options.properties !== undefined) this.setProperties(options.properties);
	        if (options.attributes !== undefined) this.setAttributes(options.attributes);
	        if (options.content !== undefined) this.setContent(options.content);
	        if (options.aspectRatio !== undefined) this.setAspectRatio(options.aspectRatio);
	        if (options.enableScroll) enableScroll.call(this);
	        else if (isTouchEnabled) preventDrag.call(this);
	    };

	    /**
	     * Allocates the element-type associated with the Surface, adds its given
	     *  element classes, and prepares it for future committing.
	     *
	     *  This method is called upon the first `start` or `resize`
	     *  event the Surface gets.
	     *
	     * @private
	     * @method setup
	     * @param allocator {ElementAllocator} Allocator
	     */
	    Surface.prototype.setup = function setup(allocator) {
	        // create element of specific type
	        var target = allocator.allocate(this.elementType);

	        // add any element classes
	        if (this.elementClass) {
	            if (this.elementClass instanceof Array)
	                for (var i = 0; i < this.elementClass.length; i++)
	                    this.addClass(this.elementClass[i]);
	            else this.addClass(this.elementClass);
	        }

	        // set the currentTarget and any bound listeners
	        this.attach(target);

	        _applyClasses.call(this, target);
	        _applyProperties.call(this, target);
	        _applyAttributes.call(this, target);
	        this.deploy(target);
	    };

	    /**
	     * Remove all Samsara-relevant data from the Surface.
	     *
	     * @private
	     * @method remove
	     * @param allocator {ElementAllocator} Allocator
	     */
	    Surface.prototype.remove = function remove(allocator) {
	        var target = this._currentTarget;

	        // cache the target's contents for later deployment
	        this.recall(target);

	        // hide the element
	        target.style.display = 'none';
	        target.style.opacity = '';
	        target.style.width = '';
	        target.style.height = '';

	        // clear all styles, classes and attributes
	        _removeProperties.call(this, target);
	        _removeAttributes.call(this, target);
	        _removeClasses.call(this, target);

	        // garbage collect current target and remove bound event listeners
	        this.detach();

	        // store allocated node in cache for recycling
	        allocator.deallocate(target);
	    };

	    /**
	     * Insert the Surface's content into the currentTarget.
	     *
	     * @private
	     * @method deploy
	     * @param target {Node} DOM element to set content into
	     */
	    Surface.prototype.deploy = function deploy(target) {
	        //TODO: make sure target.tagName is of correct type! Tag pools must be implemented.
	        if (!target) return;
	        var content = this.getContent();
	        if (content instanceof Node) {
	            while (target.hasChildNodes()) target.removeChild(target.firstChild);
	            target.appendChild(content);
	        }
	        else target.innerHTML = content;

	        this._contentDirty = false;
	        this._eventOutput.emit('deploy', target);
	    };

	    /**
	     * Cache the content of the Surface in a document fragment for future deployment.
	     *
	     * @private
	     * @method recall
	     * @param target {Node}
	     */
	    Surface.prototype.recall = function recall(target) {
	        this._eventOutput.emit('recall');
	        var df = document.createDocumentFragment();
	        while (target.hasChildNodes()) df.appendChild(target.firstChild);
	        this.setContent(df);
	    };

	    /**
	     * Getter for size.
	     *
	     * @method getSize
	     * @return {Number[]}
	     */
	    Surface.prototype.getSize = function getSize() {
	        // TODO: remove cachedSize
	        return this._cachedSpec.size || this._cachedSize;
	    };

	    /**
	     * Setter for size.
	     *
	     * @method setSize
	     * @param size {Number[]|Stream} Size as [width, height] in pixels, or a stream.
	     */
	    Surface.prototype.setSize = function setSize(size) {
	        this._cachedSize = size;
	        this._sizeNode.set({size : size});
	        _setDirty.call(this);
	    };

	    /**
	     * Setter for proportions.
	     *
	     * @method setProportions
	     * @param proportions {Number[]|Stream} Proportions as [x,y], or a stream.
	     */
	    Surface.prototype.setProportions = function setProportions(proportions) {
	        this._sizeNode.set({proportions : proportions});
	        _setDirty.call(this);
	    };

	    /**
	     * Setter for margins.
	     *
	     * @method setMargins
	     * @param margins {Number[]|Stream} Margins as [width, height] in pixels, or a stream.
	     */
	    Surface.prototype.setMargins = function setMargins(margins) {
	        this._sizeNode.set({margins : margins});
	        _setDirty.call(this);
	    };

	    /**
	     * Setter for aspect ratio. If only one of width or height is specified,
	     *  the aspect ratio will replace the unspecified dimension by scaling
	     *  the specified dimension by the value provided.
	     *
	     * @method setAspectRatio
	     * @param aspectRatio {Number|Stream} Aspect ratio.
	     */
	    Surface.prototype.setAspectRatio = function setAspectRatio(aspectRatio) {
	        this._sizeNode.set({aspectRatio : aspectRatio});
	        _setDirty.call(this);
	    };

	    /**
	     * Setter for origin.
	     *
	     * @method setOrigin
	     * @param origin {Number[]|Stream} Origin as [x,y], or a stream.
	     */
	    Surface.prototype.setOrigin = function setOrigin(origin){
	        this._layoutNode.set({origin : origin});
	        this._originDirty = true;
	        _setDirty.call(this);
	    };

	    /**
	     * Setter for opacity.
	     *
	     * @method setOpacity
	     * @param opacity {Number} Opacity
	     */
	    Surface.prototype.setOpacity = function setOpacity(opacity){
	        this._layoutNode.set({opacity : opacity});
	        this._opacityDirty = true;
	        _setDirty.call(this);
	    };

	    module.exports = Surface;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var Transform = __webpack_require__(21);
	    var Stream = __webpack_require__(15);
	    var ResizeStream = __webpack_require__(18);
	    var SizeNode = __webpack_require__(17);
	    var LayoutNode = __webpack_require__(8);
	    var sizeAlgebra = __webpack_require__(29);
	    var layoutAlgebra = __webpack_require__(28);

	    var usePrefix = !('transform' in document.documentElement.style);
	    var devicePixelRatio = window.devicePixelRatio || 1;
	    var invDevicePixelRatio = 1 / devicePixelRatio;
	    var MIN_OPACITY = 0.0001;
	    var MAX_OPACITY = 0.9999;
	    var EPSILON = 1e-5;
	    var _zeroZero = [0,0];

	    /**
	     * Responsible for committing CSS3 properties to the DOM and providing DOM event hooks
	     *  from a provided DOM element. Where Surface's API handles inputs from the developer
	     *  from within Samsara, ElementOutput handles the DOM interaction layer.
	     *
	     *
	     * @class ElementOutput
	     * @constructor
	     * @namespace Core
	     * @uses Core.LayoutNode
	     * @uses Core.SizeNode
	     * @private
	     * @param {Node} element document parent of this container
	     */
	    function ElementOutput(element) {
	        this._currentTarget = null;

	        this._cachedSpec = {
	            transform : null,
	            opacity : 1,
	            origin : null,
	            size : null
	        };

	        this._eventOutput = new EventHandler();
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._eventForwarder = function _eventForwarder(event) {
	            this._eventOutput.emit(event.type, event);
	        }.bind(this);

	        this._sizeNode = new SizeNode();
	        this._layoutNode = new LayoutNode();

	        this._size = new EventHandler();
	        this._layout = new EventHandler();

	        this.size = ResizeStream.lift(function elementSizeLift(sizeSpec, parentSize){
	            if (!parentSize) return false; // occurs when surface is never added
	            return sizeAlgebra(sizeSpec, parentSize);
	        }, [this._sizeNode, this._size]);

	        this.layout = Stream.lift(function(parentSpec, objectSpec, size){
	            if (!parentSpec || !size) return false;
	            return (objectSpec)
	                ? layoutAlgebra(objectSpec, parentSpec, size)
	                : parentSpec;
	        }, [this._layout, this._layoutNode, this.size]);

	        this.layout.on('start', function(){
	            if (!this._currentTarget){
	                var root = this._getRoot();
	                this.setup(root.allocator);
	            }
	        }.bind(this));

	        this.layout.on('update', commitLayout.bind(this));
	        this.layout.on('end', commitLayout.bind(this));

	        this.size.on('resize', function(size){
	            if (!this._currentTarget){
	                var root = this._getRoot();
	                this.setup(root.allocator);
	            }
	            commitSize.call(this, size);
	        }.bind(this));

	        this._currentTarget = null;

	        this._opacityDirty = true;
	        this._originDirty = true;
	        this._transformDirty = true;
	        this._isVisible = true;

	        if (element) this.attach(element);
	    }

	    function _addEventListeners(target) {
	        for (var i in this._eventOutput.listeners)
	            target.addEventListener(i, this._eventForwarder);
	    }

	    function _removeEventListeners(target) {
	        for (var i in this._eventOutput.listeners)
	            target.removeEventListener(i, this._eventForwarder);
	    }

	    function _formatCSSTransform(transform) {
	        var result = 'matrix3d(';
	        for (var i = 0; i < 15; i++) {
	            if (Math.abs(transform[i]) < EPSILON) transform[i] = 0;
	            result += (i === 12 || i === 13)
	                ? Math.round(transform[i] * devicePixelRatio) * invDevicePixelRatio + ','
	                : transform[i] + ',';
	        }
	        return result + transform[15] + ')';
	    }

	    function _formatCSSOrigin(origin) {
	        return (100 * origin[0]) + '% ' + (100 * origin[1]) + '%';
	    }

	    function _xyNotEquals(a, b) {
	        return (a && b) ? (a[0] !== b[0] || a[1] !== b[1]) : a !== b;
	    }

	    var _setOrigin = usePrefix
	        ? function _setOrigin(element, origin) {
	        element.style.webkitTransformOrigin = _formatCSSOrigin(origin);
	    }
	        : function _setOrigin(element, origin) {
	        element.style.transformOrigin = _formatCSSOrigin(origin);
	    };

	    var _setTransform = (usePrefix)
	        ? function _setTransform(element, transform) {
	        element.style.webkitTransform = _formatCSSTransform(transform);
	    }
	        : function _setTransform(element, matrix) {
	        element.style.transform = _formatCSSTransform(matrix);
	    };

	    var _setSize = function _setSize(target, size){
	        if (size[0] === true) size[0] = target.offsetWidth;
	        else target.style.width = Math.ceil(size[0] * devicePixelRatio) * invDevicePixelRatio + 'px';

	        if (size[1] === true) size[1] = target.offsetHeight;
	        else target.style.height = Math.ceil(size[1] * devicePixelRatio) * invDevicePixelRatio + 'px';
	    };

	    // {Visibility : hidden} allows for DOM events to pass through the element
	    // TODO: use pointerEvents instead. However, there is a bug in Chrome for Android
	    // ticket here: https://code.google.com/p/chromium/issues/detail?id=569654
	    var _setOpacity = function _setOpacity(element, opacity) {
	        if (!this._isVisible && opacity > MIN_OPACITY) {
	            //element.style.pointerEvents = 'auto';
	            element.style.visibility = 'visible';
	            this._isVisible = true;
	        }

	        if (opacity > MAX_OPACITY) opacity = MAX_OPACITY;
	        else if (opacity < MIN_OPACITY) {
	            opacity = MIN_OPACITY;
	            if (this._isVisible) {
	                //element.style.pointerEvents = 'none';
	                element.style.visibility = 'hidden';
	                this._isVisible = false;
	            }
	        }

	        if (this._isVisible) element.style.opacity = opacity;
	    };

	    /**
	     * Adds a handler to the `type` channel which will be executed on `emit`.
	     *
	     * @method on
	     *
	     * @param type {String}         DOM event channel name, e.g., "click", "touchmove"
	     * @param handler {Function}    Handler. It's only argument will be an emitted data payload.
	     */
	    ElementOutput.prototype.on = function on(type, handler) {
	        if (this._currentTarget)
	            this._currentTarget.addEventListener(type, this._eventForwarder);
	        EventHandler.prototype.on.apply(this._eventOutput, arguments);
	    };

	    /**
	     * Removes a previously added handler to the `type` channel.
	     *  Undoes the work of `on`.
	     *
	     * @method removeListener
	     * @param type {String}         DOM event channel name e.g., "click", "touchmove"
	     * @param handler {Function}    Handler
	     */
	    ElementOutput.prototype.off = function off(type, handler) {
	        EventHandler.prototype.off.apply(this._eventOutput, arguments);
	    };

	    /**
	     * Emit an event with optional data payload. This will execute all listening
	     *  to the channel name with the payload as only argument.
	     *
	     * @method emit
	     * @param type {string}         Event channel name
	     * @param [payload] {Object}    User defined data payload
	     */
	    ElementOutput.prototype.emit = function emit(type, payload) {
	        EventHandler.prototype.emit.apply(this._eventOutput, arguments);
	    };

	    /**
	     * Assigns the DOM element for committing and to and attaches event listeners.
	     *
	     * @private
	     * @method attach
	     * @param {Node} target document parent of this container
	     */
	    ElementOutput.prototype.attach = function attach(target) {
	        this._currentTarget = target;
	        _addEventListeners.call(this, target);
	    };

	    /**
	     * Removes the associated DOM element in memory and detached event listeners.
	     *
	     * @private
	     * @method detach
	     */
	    ElementOutput.prototype.detach = function detach() {
	        var target = this._currentTarget;
	        if (target) {
	            _removeEventListeners.call(this, target);
	            target.style.display = '';
	        }
	        this._currentTarget = null;
	    };

	    function commitLayout(layout) {
	        var target = this._currentTarget;
	        if (!target) return;

	        var cache = this._cachedSpec;

	        var transform = layout.transform || Transform.identity;
	        var opacity = (layout.opacity === undefined) ? 1 : layout.opacity;
	        var origin = layout.origin || _zeroZero;

	        this._transformDirty = Transform.notEquals(cache.transform, transform);
	        this._opacityDirty = this._opacityDirty || (cache.opacity !== opacity);
	        this._originDirty = this._originDirty || (origin && _xyNotEquals(cache.origin, origin));

	        if (this._opacityDirty) {
	            cache.opacity = opacity;
	            _setOpacity.call(this, target, opacity);
	        }

	        if (this._originDirty){
	            cache.origin = origin;
	            _setOrigin(target, origin);
	        }

	        if (this._transformDirty) {
	            cache.transform = transform;
	            _setTransform(target, transform);
	        }

	        this._originDirty = false;
	        this._transformDirty = false;
	        this._opacityDirty = false;
	    }

	    function commitSize(size){
	        var target = this._currentTarget;
	        if (!target) return;

	        if (_xyNotEquals(this._cachedSpec.size, size)){
	            this._cachedSpec.size = size;
	            _setSize(target, size);
	            this.emit('resize', size);
	        }
	    }

	    module.exports = ElementOutput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Surface = __webpack_require__(33);
	    var Context = __webpack_require__(36);

	    /**
	     * ContainerSurface enables nesting of DOM. A ContainerSurface manages
	     *  its own render tree that it inserts inside a DOM node. Typically
	     *  this is used for clipping by settings `{overflow : hidden}` as a CSS
	     *  property.
	     *
	     *  @example
	     *
	     *      var myContainer = new ContainerSurface({
	     *          size : [100,100],
	     *          properties : {overflow : hidden}
	     *      });
	     *
	     *      var surface = new Surface({
	     *          size : [200,200],
	     *          properties : {background : 'red'}
	     *      });
	     *
	     *      myContainer.add(surface);
	     *
	     *      context.add(myContainer);
	     *
	     * @class ContainerSurface
	     * @extends DOM.Surface
	     * @namespace DOM
	     * @uses DOM.Context
	     * @constructor
	     *
	     * @param [options] {Object}                Options
	     * @param [options.size] {Number[]}         Size (width, height) in pixels. These can also be `true` or `undefined`.
	     * @param [options.classes] {String[]}      CSS classes
	     * @param [options.properties] {Object}     Dictionary of CSS properties
	     * @param [options.attributes] {Object}     Dictionary of HTML attributes
	     * @param [options.content] {String}        InnerHTML content
	     * @param [options.origin] {Number[]}       Origin (x,y), with values between 0 and 1
	     * @param [options.proportions] {Number[]}  Proportions (x,y) with values between 0 and 1
	     * @param [options.margins] {Number[]}      Margins (x,y) in pixels
	     * @param [options.opacity] {Number}        Opacity
	     */
	    function ContainerSurface(options) {
	        Surface.call(this, options);
	        this.context = new Context();
	        this.context._size.subscribe(this.size);

	        this.on('deploy', function(){
	            this.context.mount(this._currentTarget, true);
	        }.bind(this));
	    }

	    ContainerSurface.prototype = Object.create(Surface.prototype);
	    ContainerSurface.prototype.constructor = ContainerSurface;
	    ContainerSurface.prototype.elementType = 'div';
	    ContainerSurface.prototype.elementClass = ['samsara-surface', 'samsara-container'];

	    /**
	     * Get current perspective in pixels.
	     *
	     * @method getPerspective
	     * @return {Number} Perspective in pixels
	     */
	    ContainerSurface.prototype.getPerspective = function getPerspective() {
	        return Context.prototype.getPerspective.apply(this.context, arguments);
	    };

	    /**
	     * Set current perspective in pixels.
	     *
	     * @method setPerspective
	     * @param perspective {Number}  Perspective in pixels
	     * @param [transition] {Object} Transition definition
	     * @param [callback] {Function} Callback executed on completion of transition
	     */
	    ContainerSurface.prototype.setPerspective = function setPerspective(){
	        Context.prototype.setPerspective.apply(this.context, arguments);
	    };

	    /**
	     * Extends the render tree with a provided node.
	     *
	     * @method add
	     * @param node {Object}     Node, Surface, or View
	     * @return {RenderTreeNode}
	     */
	    ContainerSurface.prototype.add = function add() {
	        return Context.prototype.add.apply(this.context, arguments);
	    };

	    module.exports = ContainerSurface;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Modified work copyright © 2015 David Valdman */
	// TODO: Enable CSS properties on Context
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Engine = __webpack_require__(2);
	    var RootNode = __webpack_require__(37);
	    var Transform = __webpack_require__(21);
	    var ElementAllocator = __webpack_require__(38);
	    var Transitionable = __webpack_require__(22);
	    var SimpleStream = __webpack_require__(11);
	    var EventHandler = __webpack_require__(9);
	    var preTickQueue = __webpack_require__(5);
	    var dirtyQueue = __webpack_require__(6);

	    var elementType = 'div';
	    var elementClass = 'samsara-context';
	    var rafStarted = false;

	    var layoutSpec = {
	        transform : Transform.identity,
	        opacity : 1,
	        origin : null,
	        align : null,
	        nextSizeTransform : Transform.identity
	    };

	    /**
	     * A Context defines a top-level DOM element inside which other nodes (like Surfaces) are rendered.
	     *
	     *  The CSS class `samsara-context` is applied, which provides the minimal CSS necessary
	     *  to create a performant 3D context (specifically `preserve-3d`).
	     *
	     *  The Context must be mounted to a DOM node via the `mount` method. If no node is specified
	     *  it is mounted to `document.body`.
	     *
	     *  @example
	     *
	     *      var context = Context();
	     *
	     *      var surface = new Surface({
	     *          size : [100,100],
	     *          properties : {background : 'red'}
	     *      });
	     *
	     *      context.add(surface);
	     *      context.mount(document.body)
	     *
	     * @class Context
	     * @constructor
	     * @namespace DOM
	     * @uses Core.RootNode
	     */
	    function Context() {
	        this._node = new RootNode();

	        this._size = new SimpleStream();
	        this._layout = new SimpleStream();

	        this.size = this._size.map(function(){
	            var size = [this.container.clientWidth, this.container.clientHeight];
	            this.emit('resize', size);
	            return size;
	        }.bind(this));

	        this._node._size.subscribe(this.size);
	        this._node._layout.subscribe(this._layout);

	        this._perspective = new Transitionable();

	        this._perspective.on('update', function(perspective){
	            setPerspective(this.container, perspective);
	        }.bind(this));

	        this._perspective.on('end', function(perspective){
	            setPerspective(this.container, perspective);
	        }.bind(this));

	        this._eventOutput = new EventHandler();
	        this._eventForwarder = function _eventForwarder(event) {
	            this._eventOutput.emit(event.type, event);
	        }.bind(this);
	    }

	    /**
	     * Extends the render tree beginning with the Context's RootNode with a new node.
	     *  Delegates to RootNode's `add` method.
	     *
	     * @method add
	     *
	     * @param {Object}          Renderable
	     * @return {RenderTreeNode} Wrapped node
	     */
	    Context.prototype.add = function add() {
	        return RootNode.prototype.add.apply(this._node, arguments);
	    };

	    /**
	     * Get current perspective of this Context in pixels.
	     *
	     * @method getPerspective
	     * @return {Number} Perspective in pixels
	     */
	    Context.prototype.getPerspective = function getPerspective() {
	        return this._perspective.get();
	    };

	    /**
	     * Set current perspective of the `context` in pixels.
	     *
	     * @method setPerspective
	     * @param perspective {Number}  Perspective in pixels
	     * @param [transition] {Object} Transition definition
	     * @param [callback] {Function} Callback executed on completion of transition
	     */
	    Context.prototype.setPerspective = function setPerspective(perspective, transition, callback) {
	        this._perspective.set(perspective, transition, callback);
	    };

	    /**
	     * Allocate contents of the `context` to a DOM node.
	     *
	     * @method mount
	     * @param node {Node}  DOM element
	     */
	    Context.prototype.mount = function mount(node, resizeListenFlag){
	        this.container = node || document.createElement(elementType);
	        this.container.classList.add(elementClass);

	        var allocator = new ElementAllocator(this.container);
	        this._node.setAllocator(allocator);

	        this.emit('deploy', this.container);

	        if (!node)
	            document.body.appendChild(this.container);

	        if (!resizeListenFlag)
	            window.addEventListener('resize', handleResize.bind(this), false);

	        preTickQueue.push(function (){
	            handleResize.call(this);
	            this._layout.trigger('start', layoutSpec);
	            dirtyQueue.push(function(){
	                this._layout.trigger('end', layoutSpec);
	            }.bind(this));
	        }.bind(this));

	        if (!rafStarted) {
	            rafStarted = true;
	            Engine.start();
	        }
	    };

	    /**
	     * Adds a handler to the `type` channel which will be executed on `emit`.
	     *  These events should be DOM events that occur on the DOM node the
	     *  context has been mounted to.
	     *
	     * @method on
	     * @param type {String}         Channel name
	     * @param handler {Function}    Callback
	     */
	    Context.prototype.on = function on(type, handler){
	        if (this.container)
	            this.container.addEventListener(type, this._eventForwarder);
	        else {
	            this._eventOutput.on('deploy', function(target){
	                target.addEventListener(type, this._eventForwarder);
	            }.bind(this));
	        }
	        EventHandler.prototype.on.apply(this._eventOutput, arguments);
	    };

	    /**
	     * Removes the `handler` from the `type`.
	     *  Undoes the work of `on`.
	     *
	     * @method on
	     * @param type {String}         Channel name
	     * @param handler {Function}    Callback
	     */
	    Context.prototype.off = function off(type, handler) {
	        EventHandler.prototype.off.apply(this._eventOutput, arguments);
	    };

	    /**
	     * Used internally when context is subscribed to.
	     *
	     * @method emit
	     * @private
	     * @param type {String}     Channel name
	     * @param data {Object}     Payload
	     */
	    Context.prototype.emit = function emit(type, payload) {
	        EventHandler.prototype.emit.apply(this._eventOutput, arguments);
	    };

	    var usePrefix = !('perspective' in document.documentElement.style);

	    var setPerspective = usePrefix
	        ? function setPerspective(element, perspective) {
	            element.style.webkitPerspective = perspective ? (perspective | 0) + 'px' : '0px';
	        }
	        : function setPerspective(element, perspective) {
	            element.style.perspective = perspective ? (perspective | 0) + 'px' : '0px';
	        };

	    function handleResize() {
	        this._size.emit('resize');
	        dirtyQueue.push(function(){
	            this._size.emit('resize');
	        }.bind(this));
	    }

	    module.exports = Context;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var RenderTreeNode = __webpack_require__(27);

	    /**
	     * A RootNode is a first node in the Render Tree. It is like any other
	     *  RenderTreeNode but with the additional responsibility of defining
	     *  an allocating DOM node to render to.
	     *
	     * @class RootNode
	     * @constructor
	     * @private
	     * @extends Core.RenderTreeNode
	     * @param [allocator] {ElementAllocator} ElementAllocator
	     */
	    function RootNode(allocator) {
	        RenderTreeNode.call(this);
	        this.root = this;
	        if (allocator) this.setAllocator(allocator);
	    }

	    RootNode.prototype = Object.create(RenderTreeNode.prototype);
	    RootNode.prototype.constructor = RootNode;

	    /**
	     * Define an allocator
	     *
	     * @method setAllocator
	     * @param allocator {Allocator} Allocator
	     */
	    RootNode.prototype.setAllocator = function setAllocator(allocator){
	        this.allocator = allocator;
	    };

	    module.exports = RootNode;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {

	    /**
	     * Handles creating, allocating and removing DOM elements within a provided DOM element.
	     *  Manages a pool of nodes based on DOM tagName for DOM node reuse.
	     *  When a Surface is deallocated, its element is cleared and put back in the pool.
	     *  When a Surface is allocated, an existing cleared element of the same tagName is
	     *  looked for. If it is not found, a new DOM element is created.
	     *
	     * @class ElementAllocator
	     * @constructor
	     * @namespace Core
	     * @private
	     * @param container {Node} DOM element
	     */
	    function ElementAllocator(container) {
	        if (!container) container = document.createDocumentFragment();
	        this.container = container;
	        this.detachedNodes = {};
	    }

	    /**
	     * Move the DOM elements from their original container to a new one.
	     *
	     * @method migrate
	     * @param container {Node} DOM element
	     */
	    ElementAllocator.prototype.migrate = function migrate(container) {
	        var oldContainer = this.container;
	        if (container === oldContainer) return;

	        if (oldContainer instanceof DocumentFragment)
	            container.appendChild(oldContainer);
	        else {
	            while (oldContainer.hasChildNodes())
	                container.appendChild(oldContainer.firstChild);
	        }
	        this.container = container;
	    };

	    /**
	     * Allocate an element of specified type from the pool.
	     *
	     * @method allocate
	     * @param type {string} DOM tagName, e.g., "div"
	     * @return {Node}
	     */
	    ElementAllocator.prototype.allocate = function allocate(type) {
	        type = type.toLowerCase();
	        if (!(type in this.detachedNodes)) this.detachedNodes[type] = [];
	        var nodeStore = this.detachedNodes[type];
	        var result;
	        if (nodeStore.length === 0){
	            result = document.createElement(type);
	            this.container.appendChild(result);
	        }
	        else result = nodeStore.pop();
	        return result;
	    };

	    /**
	     * De-allocate an element of specified type to the pool for recycling.
	     *
	     * @method deallocate
	     * @param element {Node} DOM element
	     */
	    ElementAllocator.prototype.deallocate = function deallocate(element) {
	        var nodeType = element.nodeName.toLowerCase();
	        var nodeStore = this.detachedNodes[nodeType];
	        nodeStore.push(element);
	    };

	    module.exports = ElementAllocator;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        EventEmitter: __webpack_require__(10),
	        EventHandler: __webpack_require__(9),
	        EventMapper: __webpack_require__(12),
	        EventFilter: __webpack_require__(13),
	        EventSplitter: __webpack_require__(14)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        GenericInput: __webpack_require__(41),
	        MouseInput: __webpack_require__(42),
	        TouchInput: __webpack_require__(43),
	        ScrollInput: __webpack_require__(45),
	        ScaleInput: __webpack_require__(46),
	        RotateInput: __webpack_require__(48),
	        PinchInput: __webpack_require__(49)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);

	    // Global registry of input constructors. Append only.
	    var registry = {};

	    /**
	     * Combines multiple inputs (e.g., mouse, touch, scroll) into one unified input.
	     *  Inputs must first be registered on the constructor by a unique identifier,
	     *  then they can be accessed on instantiation.
	     *
	     *      @example
	     *
	     *      // In main.js
	     *      GenericInput.register({
	     *          "mouse" : MouseInput,
	     *          "touch" : TouchInput
	     *      });
	     *
	     *      // in myFile.js
	     *      var input = new GenericInput(['mouse', 'touch'], options);
	     *
	     * @class GenericInput
	     * @constructor
	     * @namespace Inputs
	     * @extends Streams.SimpleStream
	     * @param inputs {Object|String[]}  Dictionary with {identifier : option} pairs
	     *                                  or an array of identifier strings
	     * @param [options] {Object} Options for all inputs
	     */
	    function GenericInput(inputs, options) {
	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();

	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._inputs = {};
	        if (inputs) this.addInput(inputs);
	        if (options) this.setOptions(options);
	    }

	    GenericInput.prototype = Object.create(SimpleStream.prototype);
	    GenericInput.prototype.constructor = GenericInput;

	    /**
	     * Constrain the input along a specific axis.
	     *
	     * @property DIRECTION {Object}
	     * @property DIRECTION.X {Number}   x-axis
	     * @property DIRECTION.Y {Number}   y-axis
	     * @static
	     */
	    GenericInput.DIRECTION = {
	        X : 0,
	        Y : 1
	    };

	    /**
	     * Register a global input class with an identifying key
	     *
	     * @method register
	     * @static
	     * @param inputObject {Object} an object of {input key : input options} fields
	     */
	    GenericInput.register = function register(inputObject) {
	        for (var key in inputObject){
	            if (registry[key]){
	                if (registry[key] === inputObject[key]) return; // redundant registration
	                else throw new Error('this key is registered to a different input class');
	            }
	            else registry[key] = inputObject[key];
	        }
	    };

	    /**
	     * Helper to set options on all input instances
	     *
	     * @method setOptions
	     * @param options {Object} options object
	     */
	    GenericInput.prototype.setOptions = function(options) {
	        for (var key in this._inputs)
	            this._inputs[key].setOptions(options);
	    };

	    /**
	     * Subscribe events from an input class
	     *
	     * @method subscribeInput
	     * @param key {String} identifier for input class
	     */
	    GenericInput.prototype.subscribeInput = function subscribeInput(key) {
	        var input = this._inputs[key];
	        input.subscribe(this._eventInput);
	        this._eventOutput.subscribe(input);
	    };

	    /**
	     * Unsubscribe events from an input class
	     *
	     * @method unsubscribeInput
	     * @param key {String} identifier for input class
	     */
	    GenericInput.prototype.unsubscribeInput = function unsubscribeInput(key) {
	        var input = this._inputs[key];
	        input.unsubscribe(this._eventInput);
	        this._eventOutput.unsubscribe(input);
	    };

	    function _addSingleInput(key, options) {
	        if (!registry[key]) return;
	        this._inputs[key] = new (registry[key])(options);
	        this.subscribeInput(key);
	    }

	    /**
	     * Add an input class to from the registered classes
	     *
	     * @method addInput
	     * @param inputs {Object|Array.String} an array of registered input keys
	     *    or an object with fields {input key : input options}
	     */
	    GenericInput.prototype.addInput = function addInput(inputs) {
	        if (inputs instanceof Array)
	            for (var i = 0; i < inputs.length; i++)
	                _addSingleInput.call(this, inputs[i]);
	        else if (inputs instanceof Object)
	            for (var key in inputs)
	                _addSingleInput.call(this, key, inputs[key]);
	    };

	    module.exports = GenericInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var OptionsManager = __webpack_require__(31);
	    var SimpleStream = __webpack_require__(11);

	    var MINIMUM_TICK_TIME = 8;
	    var _now = Date.now;

	    /**
	     * Wrapper for DOM mouse events. Converts
	     *
	     *      `mousedown` -> `start`
	     *      `mousemove` -> `update`
	     *      `mouseup`   -> `end`
	     *
	     * MouseInput emits these events with the following payload data:
	     *
	     *      `value`     - Displacement in pixels from `mousedown`
	     *      `delta`     - Differential in pixels between successive mouse positions
	     *      `velocity`  - Velocity of mouse movement in pixels per second
	     *      `clientX`   - DOM event clientX property
	     *      `clientY`   - DOM event clientY property
	     *      `offsetX`   - DOM event offsetX property
	     *      `offsetY`   - DOM event offsetY property
	     *
	     * @example
	     *
	     *      var surface = new Surface({
	     *          size : [100,100],
	     *          properties : {background : 'red'}
	     *      });
	     *
	     *      var mouseInput = new MouseInput({
	     *          direction : MouseInput.DIRECTION.X
	     *      });
	     *
	     *      mouseInput.subscribe(surface);
	     *
	     *      mouseInput.on('start', function(payload){
	     *          // fired on mouse down
	     *          console.log('start', payload);
	     *      });
	     *
	     *      mouseInput.on('update', function(payload){
	     *          // fired on mouse move
	     *          console.log('update', payload);
	     *      });
	     *
	     *      mouseInput.on('end', function(payload){
	     *          // fired on mouse up
	     *          console.log('end', payload);
	     *      });
	     *
	     * @class MouseInput
	     * @constructor
	     * @extend SimpleStream
	     * @param [options] {Object}                Options
	     * @param [options.direction] {Number}      Direction to project movement onto.
	     *                                          Options found in MouseInput.DIRECTION.
	     * @param [options.scale=1] {Number}        Scale the response to the mouse
	     */
	    function MouseInput(options) {
	        this.options = OptionsManager.setOptions(this, options);

	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();

	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._eventInput.on('mousedown',    handleStart.bind(this));
	        this._eventInput.on('mousemove',    handleMove.bind(this));
	        this._eventInput.on('mouseup',      handleEnd.bind(this));
	        this._eventInput.on('mouseleave',   handleLeave.bind(this));

	        this._payload = {
	            delta    : null,
	            value    : null,
	            velocity : null,
	            clientX  : 0,
	            clientY  : 0,
	            offsetX  : 0,
	            offsetY  : 0
	        };

	        this._position = null;      // to be deprecated
	        this._prevCoord = undefined;
	        this._prevTime = undefined;
	        this._down = false;
	        this._move = false;
	    }

	    MouseInput.prototype = Object.create(SimpleStream.prototype);
	    MouseInput.prototype.constructor = MouseInput;

	    MouseInput.DEFAULT_OPTIONS = {
	        direction: undefined,
	        scale: 1
	    };

	    /**
	     * Constrain the input along a specific axis.
	     *
	     * @property DIRECTION {Object}
	     * @property DIRECTION.X {Number}   x-axis
	     * @property DIRECTION.Y {Number}   y-axis
	     * @static
	     */
	    MouseInput.DIRECTION = {
	        X : 0,
	        Y : 1
	    };

	    function handleStart(event) {
	        var delta;
	        var velocity;

	        event.preventDefault(); // prevent drag

	        var x = event.clientX;
	        var y = event.clientY;

	        this._prevCoord = [x, y];
	        this._prevTime = _now();
	        this._down = true;
	        this._move = false;

	        if (this.options.direction !== undefined){
	            this._position = 0;
	            delta = 0;
	            velocity = 0;
	        }
	        else {
	            this._position = [0, 0];
	            delta = [0, 0];
	            velocity = [0, 0];
	        }

	        var payload = this._payload;
	        payload.delta = delta;
	        payload.value = this._position;
	        payload.velocity = velocity;
	        payload.clientX = x;
	        payload.clientY = y;
	        payload.offsetX = event.offsetX;
	        payload.offsetY = event.offsetY;

	        this._eventOutput.emit('start', payload);
	    }

	    function handleMove(event) {
	        if (!this._down) return false;

	        var scale = this.options.scale;

	        var prevCoord = this._prevCoord;
	        var prevTime = this._prevTime;

	        var x = event.clientX;
	        var y = event.clientY;

	        var currTime = _now();

	        var diffX = scale * (x - prevCoord[0]);
	        var diffY = scale * (y - prevCoord[1]);

	        var dt = Math.max(currTime - prevTime, MINIMUM_TICK_TIME); // minimum tick time
	        var inv_dt = 1 / dt;

	        var velX = diffX * inv_dt;
	        var velY = diffY * inv_dt;

	        var nextVel;
	        var nextDelta;

	        if (this.options.direction === MouseInput.DIRECTION.X) {
	            nextDelta = diffX;
	            nextVel = velX;
	            this._position += nextDelta;
	        }
	        else if (this.options.direction === MouseInput.DIRECTION.Y) {
	            nextDelta = diffY;
	            nextVel = velY;
	            this._position += nextDelta;
	        }
	        else {
	            nextDelta = [diffX, diffY];
	            nextVel = [velX, velY];
	            this._position[0] += nextDelta[0];
	            this._position[1] += nextDelta[1];
	        }

	        var payload      = this._payload;
	        payload.delta    = nextDelta;
	        payload.value    = this._position;
	        payload.velocity = nextVel;
	        payload.clientX  = x;
	        payload.clientY  = y;
	        payload.offsetX  = event.offsetX;
	        payload.offsetY  = event.offsetY;

	        this._eventOutput.emit('update', payload);

	        this._prevCoord = [x, y];
	        this._prevTime = currTime;
	        this._move = true;
	    }

	    function handleEnd() {
	        if (!this._down) return false;

	        this._eventOutput.emit('end', this._payload);
	        this._prevCoord = undefined;
	        this._prevTime = undefined;
	        this._down = false;
	        this._move = false;
	    }

	    function handleLeave(event) {
	        if (!this._down || !this._move) return;

	        var boundMove = handleMove.bind(this);
	        var boundEnd = function(event) {
	            handleEnd.call(this, event);
	            document.removeEventListener('mousemove', boundMove);
	            document.removeEventListener('mouseup', boundEnd);
	        }.bind(this, event);

	        document.addEventListener('mousemove', boundMove);
	        document.addEventListener('mouseup', boundEnd);
	    }

	    module.exports = MouseInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var TouchTracker = __webpack_require__(44);
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);
	    var OptionsManager = __webpack_require__(31);

	    var MINIMUM_TICK_TIME = 8;

	    /**
	     * Wrapper for DOM touch events. Converts
	     *
	     *      `touchstart` -> `start`
	     *      `touchmove`  -> `update`
	     *      `touchend`   -> `end`
	     *
	     * TouchInput emits these events with the following payload data:
	     *
	     *      `value`     - Displacement in pixels from `touchstart`
	     *      `delta`     - Differential in pixels between successive mouse positions
	     *      `velocity`  - Velocity of mouse movement in pixels per second
	     *      `clientX`   - DOM event clientX property
	     *      `clientY`   - DOM event clientY property
	     *      `count`     - DOM event for number of simultaneous touches
	     *      `touch`     - DOM touch event identifier
	     *
	     * @example
	     *
	     *      var touchInput = new TouchInput({
	     *          direction : TouchInput.DIRECTION.Y
	     *      });
	     *
	     *      touchInput.subscribe(Engine);
	     *
	     *      touchInput.on('start', function(payload){
	     *          // fired on mouse down
	     *          console.log('start', payload);
	     *      });
	     *
	     *      touchInput.on('update', function(payload){
	     *          // fired on mouse move
	     *          console.log('update', payload);
	     *      });
	     *
	     *      touchInput.on('end', function(payload){
	     *          // fired on mouse up
	     *          console.log('end', payload);
	     *      });
	     *
	     * @class TouchInput
	     * @constructor
	     * @extends Streams.SimpleStream
	     * @uses Inputs.TouchTracker
	     * @uses Core.OptionsManager
	     * @param [options] {Object}                Options
	     * @param [options.direction] {Number}      Direction to project movement onto.
	     *                                          Options found in TouchInput.DIRECTION.
	     * @param [options.scale=1] {Number}        Scale the response to the mouse
	     */
	    function TouchInput(options) {
	        this.options = OptionsManager.setOptions(this, options);

	        this._eventOutput = new EventHandler();
	        this._touchTracker = new TouchTracker();

	        EventHandler.setOutputHandler(this, this._eventOutput);
	        EventHandler.setInputHandler(this, this._touchTracker);

	        this._touchTracker.on('trackstart', handleStart.bind(this));
	        this._touchTracker.on('trackmove', handleMove.bind(this));
	        this._touchTracker.on('trackend', handleEnd.bind(this));

	        this._payload = {
	            delta    : null,
	            value    : null,
	            velocity : null,
	            clientX  : undefined,
	            clientY  : undefined,
	            count    : 0,
	            touch    : undefined
	        };

	        this._position = null;
	    }

	    TouchInput.prototype = Object.create(SimpleStream.prototype);
	    TouchInput.prototype.constructor = TouchInput;

	    TouchInput.DEFAULT_OPTIONS = {
	        direction: undefined,
	        scale: 1
	    };

	    /**
	     * Constrain the input along a specific axis.
	     *
	     * @property DIRECTION {Object}
	     * @property DIRECTION.X {Number}   x-axis
	     * @property DIRECTION.Y {Number}   y-axis
	     * @static
	     */
	    TouchInput.DIRECTION = {
	        X : 0,
	        Y : 1
	    };

	    function handleStart(data) {
	        var velocity;
	        var delta;
	        if (this.options.direction !== undefined){
	            this._position = 0;
	            velocity = 0;
	            delta = 0;
	        }
	        else {
	            this._position = [0, 0];
	            velocity = [0, 0];
	            delta = [0, 0];
	        }

	        var payload = this._payload;
	        payload.delta = delta;
	        payload.value = this._position;
	        payload.velocity = velocity;
	        payload.clientX = data.x;
	        payload.clientY = data.y;
	        payload.count = data.count;
	        payload.touch = data.identifier;

	        this._eventOutput.emit('start', payload);
	    }

	    function handleMove(data) {
	        var scale = this.options.scale;
	        var history = data.history;

	        var currHistory = history[history.length - 1];
	        var prevHistory = history[history.length - 2];

	        var prevTime = prevHistory.timestamp;
	        var currTime = currHistory.timestamp;

	        var diffX = scale * (currHistory.x - prevHistory.x);
	        var diffY = scale * (currHistory.y - prevHistory.y);

	        var dt = Math.max(currTime - prevTime, MINIMUM_TICK_TIME);
	        var inv_dt = 1 / dt;

	        var velX = diffX * inv_dt;
	        var velY = diffY * inv_dt;

	        var nextVel;
	        var nextDelta;
	        if (this.options.direction === TouchInput.DIRECTION.X) {
	            nextDelta = diffX;
	            nextVel = velX;
	            this._position += diffX;
	        }
	        else if (this.options.direction === TouchInput.DIRECTION.Y) {
	            nextDelta = diffY;
	            nextVel = velY;
	            this._position += nextDelta;
	        }
	        else {
	            nextDelta = [diffX, diffY];
	            nextVel = [velX, velY];
	            this._position[0] += nextDelta[0];
	            this._position[1] += nextDelta[1];
	        }

	        var payload = this._payload;
	        payload.delta      = nextDelta;
	        payload.velocity   = nextVel;
	        payload.value      = this._position;
	        payload.clientX    = data.x;
	        payload.clientY    = data.y;
	        payload.count      = data.count;
	        payload.touch      = data.identifier;

	        this._eventOutput.emit('update', payload);
	    }

	    function handleEnd(data) {
	        this._payload.count = data.count;
	        this._eventOutput.emit('end', this._payload);
	    }

	    module.exports = TouchInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	//TODO: deprecate in favor of generic history stream

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var OptionsManager = __webpack_require__(31);
	    var EventHandler = __webpack_require__(9);

	    var _now = Date.now;

	    /**
	     * Catalogues a history of touch events. Useful for creating more complex
	     *  touch recognition for gestures. Currently only used by TouchInput to
	     *  track previous touches to compute velocity.
	     *
	     * TouchTracker emits these events with the following payload data:
	     *
	     *      `x`             - Displacement in x-direction
	     *      `y`             - Displacement in y-direction
	     *      `identifier`    - DOM event touch identifier
	     *      `timestamp`     - Timestamp
	     *      `count`         - DOM event for number of simultaneous touches
	     *      `history`       - History of touches for the gesture
	     *
	     * @class TouchTracker
	     * @constructor
	     * @private
	     * @uses Core.OptionsManager
	     * @param [options] {Object}                Options
	     * @param [options.limit] {Number}          Number of touches to record
	     */

	    function TouchTracker(options) {
	        this.options = OptionsManager.setOptions(this, options);

	        this.touchHistory = {};
	        this._isTouched = false;

	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();

	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._eventInput.on('touchstart', _handleStart.bind(this));
	        this._eventInput.on('touchmove', _handleMove.bind(this));
	        this._eventInput.on('touchend', _handleEnd.bind(this));
	        this._eventInput.on('touchcancel', _handleEnd.bind(this));
	    }

	    TouchTracker.DEFAULT_OPTIONS = {
	        limit : 1 // number of simultaneous touches
	    };

	    /**
	     * Record touch data, if selective is false.
	     * @private
	     * @method track
	     * @param {Object} data touch data
	     */
	    TouchTracker.prototype.track = function track(data) {
	        this.touchHistory[data.identifier] = [data];
	    };

	    function _timestampTouch(touch, event, history) {
	        return {
	            x: touch.clientX,
	            y: touch.clientY,
	            identifier : touch.identifier,
	            timestamp: _now(),
	            count: event.touches.length,
	            history: history
	        };
	    }

	    function _handleStart(event) {
	        if (event.touches.length > this.options.limit) return;
	        this._isTouched = true;

	        for (var i = 0; i < event.changedTouches.length; i++) {
	            var touch = event.changedTouches[i];
	            var data = _timestampTouch(touch, event, null);
	            this._eventOutput.emit('trackstart', data);
	            if (!this.touchHistory[touch.identifier]) this.track(data);
	        }
	    }

	    function _handleMove(event) {
	        for (var i = 0; i < event.changedTouches.length; i++) {
	            var touch = event.changedTouches[i];
	            var history = this.touchHistory[touch.identifier];
	            if (history) {
	                var data = _timestampTouch(touch, event, history);
	                this.touchHistory[touch.identifier].push(data);
	                this._eventOutput.emit('trackmove', data);
	            }
	        }
	    }

	    function _handleEnd(event) {
	        if (!this._isTouched) return;

	        for (var i = 0; i < event.changedTouches.length; i++) {
	            var touch = event.changedTouches[i];
	            var history = this.touchHistory[touch.identifier];
	            if (history) {
	                var data = _timestampTouch(touch, event, history);
	                this._eventOutput.emit('trackend', data);
	                delete this.touchHistory[touch.identifier];
	            }
	        }

	        this._isTouched = false;
	    }

	    module.exports = TouchTracker;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	/* Documentation in progress. May be outdated. */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var OptionsManager = __webpack_require__(31);
	    var SimpleStream = __webpack_require__(11);
	    var Timer = __webpack_require__(20);

	    var MINIMUM_TICK_TIME = 8;

	    /**
	     * Wrapper for DOM wheel/mousewheel events. Converts `scroll` events
	     *  to `start`, `update` and `end` events and emits them with the payload:
	     *
	     *      `value`     - Scroll displacement in pixels from start
	     *      `delta`     - Scroll differential in pixels between subsequent events
	     *      `velocity`  - Velocity of scroll
	     *
	     * @example
	     *
	     *      var scrollInput = new ScrollInput();
	     *
	     *      scrollInput.subscribe(Engine) // listens on `window` events
	     *
	     *      scrollInput.on('start', function(payload){
	     *          console.log('start', payload);
	     *      });
	     *
	     *      scrollInput.on('update', function(payload){
	     *          console.log('update', payload);
	     *      });
	     *
	     *      scrollInput.on('end', function(payload){
	     *          console.log('end', payload);
	     *      });
	     *
	     * @class ScrollInput
	     * @constructor
	     * @extends Streams.SimpleStream
	     * @uses Inputs.TouchTracker
	     * @uses Core.OptionsManager
	     * @param [options] {Object}                Options
	     * @param [options.direction] {Number}      Direction to project movement onto.
	     *                                          Options found in TouchInput.DIRECTION.
	     * @param [options.scale=1] {Number}        Scale the response to the mouse
	     */
	    function ScrollInput(options) {
	        this.options = OptionsManager.setOptions(this, options);

	        this._payload = {
	            delta    : null,
	            value    : null,
	            velocity : null
	        };

	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();

	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this._eventInput.on('mousewheel', handleMove.bind(this));
	        this._eventInput.on('wheel', handleMove.bind(this));

	        this._value = (this.options.direction === undefined) ? [0,0] : 0;
	        this._prevTime = undefined;
	        this._inProgress = false;

	        var self = this;
	        this._scrollEnd = Timer.debounce(function(){
	            self._inProgress = false;
	            self._eventOutput.emit('end', self._payload);
	        }, 100);
	    }

	    ScrollInput.prototype = Object.create(SimpleStream.prototype);
	    ScrollInput.prototype.constructor = ScrollInput;

	    ScrollInput.DEFAULT_OPTIONS = {
	        direction: undefined,
	        scale: 1
	    };

	    /**
	     * Constrain the input along a specific axis.
	     *
	     * @property DIRECTION {Object}
	     * @property DIRECTION.X {Number}   x-axis
	     * @property DIRECTION.Y {Number}   y-axis
	     * @static
	     */
	    ScrollInput.DIRECTION = {
	        X : 0,
	        Y : 1
	    };

	    var _now = Date.now;

	    function handleMove(event) {
	        // prevent scrolling of page simultaneously
	        event.preventDefault();

	        if (!this._inProgress) {
	            this._value = (this.options.direction === undefined) ? [0,0] : 0;
	            payload = this._payload;
	            payload.value = this._value;
	            payload.clientX = event.clientX;
	            payload.clientY = event.clientY;
	            payload.offsetX = event.offsetX;
	            payload.offsetY = event.offsetY;

	            this._eventOutput.emit('start', payload);
	            this._inProgress = true;
	            return;
	        }

	        var currTime = _now();
	        var prevTime = this._prevTime || currTime;

	        var diffX = (event.wheelDeltaX !== undefined) ? event.wheelDeltaX : -event.deltaX;
	        var diffY = (event.wheelDeltaY !== undefined) ? event.wheelDeltaY : -event.deltaY;

	        var invDeltaT = 1 / Math.max(currTime - prevTime, MINIMUM_TICK_TIME); // minimum tick time
	        this._prevTime = currTime;

	        var velX = diffX * invDeltaT;
	        var velY = diffY * invDeltaT;

	        var scale = this.options.scale;
	        var nextVel;
	        var nextDelta;

	        if (this.options.direction === ScrollInput.DIRECTION.X) {
	            nextDelta = scale * diffX;
	            nextVel = scale * velX;
	            this._value += nextDelta;
	        }
	        else if (this.options.direction === ScrollInput.DIRECTION.Y) {
	            nextDelta = scale * diffY;
	            nextVel = scale * velY;
	            this._value += nextDelta;
	        }
	        else {
	            nextDelta = [scale * diffX, scale * diffY];
	            nextVel = [scale * velX, scale * velY];
	            this._value[0] += nextDelta[0];
	            this._value[1] += nextDelta[1];
	        }

	        var payload = this._payload;
	        payload.delta    = nextDelta;
	        payload.velocity = nextVel;
	        payload.value = this._value;

	        this._eventOutput.emit('update', payload);

	        // debounce `end` event
	        this._scrollEnd();
	    }

	    module.exports = ScrollInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var TwoFingerInput = __webpack_require__(47);
	    var OptionsManager = __webpack_require__(31);

	    /**
	     * Detects two-finger pinching motion and emits `start`, `update` and
	     *  `end` events with the payload data:
	     *
	     *      `value`         - Distance between the two touches
	     *      `delta`         - Differential in successive distances
	     *      `velocity`      - Relative velocity between two touches
	     *      `displacement`  - Total accumulated displacement
	     *      `center`        - Midpoint between the two touches
	     *      `touches`       - Array of DOM event touch identifiers
	     *
	     *  Note: Unlike PinchInput, which produces pixel values of displacement
	     *  between two touches, ScaleInput produces dimensionless values corresponding
	     *  to scaling of the initial distance between the touches. For example, if two
	     *  touches begin at 100 px apart, and move to 200 px apart, ScaleInput will emit
	     *  a value of 2 (for 2x magnification), while PinchInput will emit a value of 100.
	     *
	     * @example
	     *
	     *      var scaleInput = new ScaleInput();
	     *
	     *      scaleInput.subscribe(Engine) // listens on `window` events
	     *
	     *      scaleInput.on('start', function(payload){
	     *          console.log('start', payload);
	     *      });
	     *
	     *      scaleInput.on('update', function(payload){
	     *          console.log('update', payload);
	     *      });
	     *
	     *      scaleInput.on('end', function(payload){
	     *          console.log('end', payload);
	     *      });
	     *
	     * @class ScaleInput
	     * @extends Inputs.TwoFingerInput
	     * @uses Core.OptionsManager
	     * @constructor
	     * @param options {Object}              Options
	     * @param [options.scale=1] {Number}    Scale the response to pinch
	     */
	    function ScaleInput(options) {
	        TwoFingerInput.call(this);

	        this.options = OptionsManager.setOptions(this, options);

	        this._startDist = 0;
	        this._scaleFactor = 1;
	    }

	    ScaleInput.prototype = Object.create(TwoFingerInput.prototype);
	    ScaleInput.prototype.constructor = ScaleInput;

	    ScaleInput.DEFAULT_OPTIONS = {
	        scale : 1
	    };

	    // handles initial touch of two fingers
	    ScaleInput.prototype._startUpdate = function _startUpdate(event) {
	        this._startDist = TwoFingerInput.calculateDistance(this.posA, this.posB);
	        var center = TwoFingerInput.calculateCenter(this.posA, this.posB);

	        this._eventOutput.emit('start', {
	            count: event.touches.length,
	            touches: [this.touchAId, this.touchBId],
	            distance: this._startDist,
	            center: center
	        });
	    };

	    // handles movement of two fingers
	    ScaleInput.prototype._moveUpdate = function _moveUpdate(diffTime) {
	        var scale = this.options.scale;

	        var currDist = TwoFingerInput.calculateDistance(this.posA, this.posB);
	        var center = TwoFingerInput.calculateCenter(this.posA, this.posB);

	        var delta = (currDist - this._startDist) / this._startDist;
	        var newScaleFactor = Math.max(1 + scale * delta, 0);
	        var veloScale = (newScaleFactor - this._scaleFactor) / diffTime;

	        this._eventOutput.emit('update', {
	            delta : delta,
	            scale: newScaleFactor,
	            velocity: veloScale,
	            distance: currDist,
	            center : center,
	            touches: [this.touchAId, this.touchBId]
	        });

	        this._scaleFactor = newScaleFactor;
	    };

	    module.exports = ScaleInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	// TODO: emit start, update, end events instead
	// of calling protected _startUpdate etc methods

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var EventHandler = __webpack_require__(9);
	    var SimpleStream = __webpack_require__(11);

	    var _now = Date.now;

	    /**
	     * Generalizes handling of two-finger touch events.
	     *  Helper to PinchInput, RotateInput, and ScaleInput.
	     *  This class is meant to be overridden and not used directly.
	     *
	     * @class TwoFingerInput
	     * @extends Streams.SimpleStream
	     * @private
	     * @constructor
	     */
	    function TwoFingerInput() {
	        this._eventInput = new EventHandler();
	        this._eventOutput = new EventHandler();

	        EventHandler.setInputHandler(this, this._eventInput);
	        EventHandler.setOutputHandler(this, this._eventOutput);

	        this.touchAEnabled = false;
	        this.touchAId = 0;
	        this.posA = null;
	        this.timestampA = 0;
	        this.touchBEnabled = false;
	        this.touchBId = 0;
	        this.posB = null;
	        this.timestampB = 0;

	        this._eventInput.on('touchstart', this.handleStart.bind(this));
	        this._eventInput.on('touchmove', this.handleMove.bind(this));
	        this._eventInput.on('touchend', this.handleEnd.bind(this));
	        this._eventInput.on('touchcancel', this.handleEnd.bind(this));
	    }

	    TwoFingerInput.prototype = Object.create(SimpleStream.prototype);
	    TwoFingerInput.prototype.constructor = TwoFingerInput;

	    /**
	     * Calculates the angle between two touches relative to [0,1].
	     *
	     * @method calculateAngle
	     * @static
	     * @param posA {Array}  First touch location (x,y)
	     * @param posB {Array}  Second touch location (x,y)
	     * @return {Number}
	     */
	    TwoFingerInput.calculateAngle = function(posA, posB) {
	        var diffX = posB[0] - posA[0];
	        var diffY = posB[1] - posA[1];
	        return Math.atan2(diffY, diffX);
	    };

	    /**
	     * Calculates the distance between two touches.
	     *
	     * @method calculateDistance
	     * @static
	     * @param posA {Array}  First touch location (x,y)
	     * @param posB {Array}  Second touch location (x,y)
	     * @return {Number}
	     */
	    TwoFingerInput.calculateDistance = function(posA, posB) {
	        var diffX = posB[0] - posA[0];
	        var diffY = posB[1] - posA[1];
	        return Math.sqrt(diffX * diffX + diffY * diffY);
	    };

	    /**
	     * Calculates the midpoint between two touches.
	     *
	     * @method calculateCenter
	     * @static
	     * @param posA {Array}  First touch location (x,y)
	     * @param posB {Array}  Second touch location (x,y)
	     * @return {Array}
	     */
	    TwoFingerInput.calculateCenter = function(posA, posB) {
	        return [(posA[0] + posB[0]) / 2.0, (posA[1] + posB[1]) / 2.0];
	    };

	    // private
	    TwoFingerInput.prototype.handleStart = function handleStart(event) {
	        for (var i = 0; i < event.changedTouches.length; i++) {
	            var touch = event.changedTouches[i];
	            if (!this.touchAEnabled) {
	                this.touchAId = touch.identifier;
	                this.touchAEnabled = true;
	                this.posA = [touch.pageX, touch.pageY];
	                this.timestampA = _now();
	            }
	            else if (!this.touchBEnabled) {
	                this.touchBId = touch.identifier;
	                this.touchBEnabled = true;
	                this.posB = [touch.pageX, touch.pageY];
	                this.timestampB = _now();
	                this._startUpdate(event);
	            }
	        }
	    };

	    // private
	    TwoFingerInput.prototype.handleMove = function handleMove(event) {
	        if (!(this.touchAEnabled && this.touchBEnabled)) return;
	        var prevTimeA = this.timestampA;
	        var prevTimeB = this.timestampB;
	        var diffTime;
	        for (var i = 0; i < event.changedTouches.length; i++) {
	            var touch = event.changedTouches[i];
	            if (touch.identifier === this.touchAId) {
	                this.posA = [touch.pageX, touch.pageY];
	                this.timestampA = _now();
	                diffTime = this.timestampA - prevTimeA;
	            }
	            else if (touch.identifier === this.touchBId) {
	                this.posB = [touch.pageX, touch.pageY];
	                this.timestampB = _now();
	                diffTime = this.timestampB - prevTimeB;
	            }
	        }
	        if (diffTime) this._moveUpdate(diffTime);
	    };

	    // private
	    TwoFingerInput.prototype.handleEnd = function handleEnd(event) {
	        for (var i = 0; i < event.changedTouches.length; i++) {
	            var touch = event.changedTouches[i];
	            if (touch.identifier === this.touchAId || touch.identifier === this.touchBId) {
	                if (this.touchAEnabled && this.touchBEnabled) {
	                    this._eventOutput.emit('end', {
	                        touches : [this.touchAId, this.touchBId],
	                        angle   : this._angle
	                    });
	                }
	                this.touchAEnabled = false;
	                this.touchAId = 0;
	                this.touchBEnabled = false;
	                this.touchBId = 0;
	            }
	        }
	    };

	    module.exports = TwoFingerInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var TwoFingerInput = __webpack_require__(47);
	    var OptionsManager = __webpack_require__(31);

	    /**
	     * Detects two-finger rotational motion and emits `start`, `update` and
	     *  `end` events with the payload data:
	     *
	     *      `value`         - Angle of rotation
	     *      `delta`         - Differential of successive angles
	     *      `velocity`      - Velocity of rotation
	     *      `center`        - Midpoint between the two touches
	     *      `touches`       - Array of DOM event touch identifiers
	     *
	     * @example
	     *
	     *      var rotateInput = new RotateInput();
	     *
	     *      rotateInput.subscribe(Engine) // listens on `window` events
	     *
	     *      rotateInput.on('start', function(payload){
	     *          console.log('start', payload);
	     *      });
	     *
	     *      rotateInput.on('update', function(payload){
	     *          console.log('update', payload);
	     *      });
	     *
	     *      rotateInput.on('end', function(payload){
	     *          console.log('end', payload);
	     *      });
	     *
	     * @class RotateInput
	     * @extends Inputs.TwoFingerInput
	     * @uses Core.OptionsManager
	     * @constructor
	     * @param options {Object}              Options
	     * @param [options.scale=1] {Number}    Scale the response to pinch
	     */
	    function RotateInput(options) {
	        TwoFingerInput.call(this);

	        this.options = OptionsManager.setOptions(this, options);

	        this._angle = 0;
	        this._previousAngle = 0;
	    }

	    RotateInput.prototype = Object.create(TwoFingerInput.prototype);
	    RotateInput.prototype.constructor = RotateInput;

	    RotateInput.DEFAULT_OPTIONS = {
	        scale : 1
	    };

	    RotateInput.prototype._startUpdate = function _startUpdate(event) {
	        this._previousAngle = TwoFingerInput.calculateAngle(this.posA, this.posB);
	        var center = TwoFingerInput.calculateCenter(this.posA, this.posB);

	        this._angle = 0;

	        this._eventOutput.emit('start', {
	            count: event.touches.length,
	            value: this._angle,
	            center: center,
	            touches: [this.touchAId, this.touchBId]
	        });
	    };

	    RotateInput.prototype._moveUpdate = function _moveUpdate(diffTime) {
	        var scale = this.options.scale;

	        var currAngle = TwoFingerInput.calculateAngle(this.posA, this.posB);
	        var center = TwoFingerInput.calculateCenter(this.posA, this.posB);

	        var diffTheta = scale * (currAngle - this._previousAngle);
	        var velTheta = diffTheta / diffTime;

	        this._angle += diffTheta;

	        this._eventOutput.emit('update', {
	            delta : diffTheta,
	            velocity: velTheta,
	            value: this._angle,
	            center: center,
	            touches: [this.touchAId, this.touchBId]
	        });

	        this._previousAngle = currAngle;
	    };

	    module.exports = RotateInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */

	/* Modified work copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var TwoFingerInput = __webpack_require__(47);
	    var OptionsManager = __webpack_require__(31);

	    /**
	     * Detects two-finger pinching motion and emits `start`, `update` and
	     *  `end` events with the payload data:
	     *
	     *      `value`         - Distance between the two touches
	     *      `delta`         - Differential in successive distances
	     *      `velocity`      - Relative velocity between two touches
	     *      `displacement`  - Total accumulated displacement
	     *      `center`        - Midpoint between the two touches
	     *      `touches`       - Array of DOM event touch identifiers
	     *
	     * @example
	     *
	     *      var pinchInput = new PinchInput();
	     *
	     *      pinchInput.subscribe(Engine) // listens on `window` events
	     *
	     *      pinchInput.on('start', function(payload){
	     *          console.log('start', payload);
	     *      });
	     *
	     *      pinchInput.on('update', function(payload){
	     *          console.log('update', payload);
	     *      });
	     *
	     *      pinchInput.on('end', function(payload){
	     *          console.log('end', payload);
	     *      });
	     *
	     * @class PinchInput
	     * @extends Inputs.TwoFingerInput
	     * @uses Core.OptionsManager
	     * @constructor
	     * @param options {Object}              Options
	     * @param [options.scale=1] {Number}    Scale the response to pinch
	     */
	    function PinchInput(options) {
	        TwoFingerInput.call(this);

	        this.options = OptionsManager.setOptions(this, options);

	        this._displacement = 0;
	        this._previousDistance = 0;
	    }

	    PinchInput.prototype = Object.create(TwoFingerInput.prototype);
	    PinchInput.prototype.constructor = PinchInput;

	    PinchInput.DEFAULT_OPTIONS = {
	        scale : 1
	    };

	    PinchInput.prototype._startUpdate = function _startUpdate(event) {
	        var center = TwoFingerInput.calculateCenter(this.posA, this.posB);
	        this._previousDistance = TwoFingerInput.calculateDistance(this.posA, this.posB);

	        this._displacement = 0;

	        this._eventOutput.emit('start', {
	            count: event.touches.length,
	            touches: [this.touchAId, this.touchBId],
	            value: this._previousDistance,
	            center: center
	        });
	    };

	    PinchInput.prototype._moveUpdate = function _moveUpdate(diffTime) {
	        var currDist = TwoFingerInput.calculateDistance(this.posA, this.posB);
	        var center = TwoFingerInput.calculateCenter(this.posA, this.posB);

	        var scale = this.options.scale;
	        var delta = scale * (currDist - this._previousDistance);
	        var velocity = delta / diffTime;

	        this._displacement += delta;

	        this._eventOutput.emit('update', {
	            delta : delta,
	            velocity: velocity,
	            value: currDist,
	            displacement: this._displacement,
	            center: center,
	            touches: [this.touchAId, this.touchBId]
	        });

	        this._previousDistance = currDist;
	    };

	    module.exports = PinchInput;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        DrawerLayout: __webpack_require__(51),
	        FlexibleLayout: __webpack_require__(54),
	        GridLayout: __webpack_require__(55),
	        SequentialLayout: __webpack_require__(56),
	        Scrollview: __webpack_require__(57)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Transform = __webpack_require__(21);
	    var Transitionable = __webpack_require__(22);
	    var View = __webpack_require__(26);
	    var LayoutNode = __webpack_require__(8);
	    var Stream = __webpack_require__(15);
	    var Differential = __webpack_require__(52);
	    var Accumulator = __webpack_require__(53);
	    var EventMapper = __webpack_require__(12);

	    var CONSTANTS = {
	        DIRECTION : {
	            X : 0,
	            Y : 1
	        },
	        SIDE : {
	            LEFT : 0,
	            TOP : 1,
	            RIGHT : 2,
	            BOTTOM : 3
	        },
	        ORIENTATION : {
	            POSITIVE :  1,
	            NEGATIVE : -1
	        }
	    };

	    /**
	     * A layout composed of two sections: content and drawer.
	     *
	     *  The drawer is initially hidden behind the content, until it is moved
	     *  by a call to setPosition. The source of the movement can be by subscribing
	     *  the layout to user input (like a Mouse/Touch/Scroll input), or by manually
	     *  calling setPosition with a transition.
	     *
	     *  The layout emits a `start`, `update` and `end` Stream with payload
	     *
	     *      `progress` - Number between 0 and 1 indicating how open the drawer is
	     *      `value` - Pixel displacement in how open the drawer is
	     *
	     *  It also emits `close` and `open` events.
	     *
	     *  The drawer can be revealed from any side of the content (top, left, bottom, right),
	     *  by specifying a side option.
	     *
	     *  @class DrawerLayout
	     *  @constructor
	     *  @namespace Layouts
	     *  @extends Core.View
	     *  @param [options] {Object}                       Options
	     *  @param [options.side] {Number}                  Side to reveal the drawer from. Defined in DrawerLayout.SIDES
	     *  @param [options.revealLength] {Number}          The maximum length to reveal the drawer
	     *  @param [options.velocityThreshold] {Number}     The velocity needed to complete the drawer transition
	     *  @param [options.positionThreshold] {Number}     The displacement needed to complete the drawer transition
	     *  @param [options.transitionClose] {Object}       A transition definition for closing the drawer
	     *  @param [options.transitionOpen] {Object}        A transition definition for opening the drawer
	     */
	    var DrawerLayout = View.extend({
	        defaults : {
	            side : CONSTANTS.SIDE.LEFT,
	            revealLength : undefined,
	            velocityThreshold : Infinity,
	            positionThreshold : 0,
	            transitionOpen : true,
	            transitionClose : true
	        },
	        events : {
	            change : _updateState
	        },
	        initialize : function initialize(options){
	            // DERIVED STATE

	            // vertical or horizontal movement
	            this.direction = _getDirectionFromSide(options.side);

	            // positive or negative movement along the direction
	            this.orientation = _getOrientationFromSide(options.side);

	            // scale the revealLength by the parity of the direction
	            this.options.revealLength *= this.orientation;

	            // open state (needed for toggling)
	            this.isOpen = false;

	            // STREAMS
	            
	            // responsible for manually moving the content without user input
	            this.transitionStream = new Transitionable(0);

	            // responsible for moving the content from user input
	            var gestureDelta = new Stream({
	                start : function (){
	                    this.transitionStream.halt();
	                    return 0;
	                }.bind(this),
	                update : function (data){
	                    // modify the delta from user input to be constrained
	                    // by the revealLength
	                    var delta = data.delta;
	                    var newDelta = delta;
	                    var revealLength = options.revealLength;

	                    var currentPosition = this.position.get();
	                    var newPosition = currentPosition + delta;

	                    var MIN_LENGTH = 0;
	                    var MAX_LENGTH = 0;

	                    if (this.orientation === CONSTANTS.ORIENTATION.POSITIVE)
	                        MAX_LENGTH = revealLength;
	                    else
	                        MIN_LENGTH = revealLength;

	                    if (newPosition >= MAX_LENGTH || newPosition <= MIN_LENGTH){
	                        if (newPosition > MAX_LENGTH && newPosition > MIN_LENGTH && currentPosition !== MAX_LENGTH)
	                            newDelta = MAX_LENGTH - currentPosition;
	                        else if (newPosition < MIN_LENGTH && currentPosition !== MIN_LENGTH)
	                            newDelta = MIN_LENGTH - currentPosition;
	                        else
	                            newDelta = 0;
	                    }

	                    return newDelta;
	                }.bind(this),
	                end : function (data){
	                    var velocity = data.velocity;

	                    var orientation = this.orientation;
	                    var position = this.position.get();

	                    var length = options.revealLength;
	                    var MAX_LENGTH = orientation * length;
	                    var positionThreshold = options.positionThreshold || MAX_LENGTH / 2;
	                    var velocityThreshold = options.velocityThreshold;

	                    if (position === 0) {
	                        this.isOpen = false;
	                        return false;
	                    }

	                    if (position === MAX_LENGTH) {
	                        this.isOpen = true;
	                        return false;
	                    }

	                    var shouldOpen =
	                        (position >= positionThreshold) && ((velocity > -velocityThreshold) || (velocity > velocityThreshold)) ||
	                        (position <  positionThreshold) && ((velocity >  velocityThreshold));

	                    if (shouldOpen){
	                        this.options.transitionOpen.velocity = velocity;
	                        this.open(this.options.transitionOpen, function(){
	                            this.options.transitionOpen.velocity = 0;
	                        }.bind(this));
	                    }
	                    else {
	                        this.options.transitionClose.velocity = velocity;
	                        this.close(this.options.transitionClose, function(){
	                            this.options.transitionClose.velocity = 0;
	                        }.bind(this));
	                    }
	                }.bind(this)
	            });

	            gestureDelta.subscribe(this.input);

	            var transitionDelta = new Differential();
	            transitionDelta.subscribe(this.transitionStream);

	            this.position = new Accumulator(0);
	            this.position.subscribe(gestureDelta);
	            this.position.subscribe(transitionDelta);

	            var outputMapper = new EventMapper(function(position){
	                return {
	                    value : position,
	                    progress : position / this.options.revealLength
	                }
	            }.bind(this));

	            this.output.subscribe(outputMapper).subscribe(this.position);
	        },
	        /**
	         * Set the drawer component with a Surface of View.
	         *
	         * @method addDrawer
	         * @param drawer {Surface|View}
	         */
	        addDrawer : function addDrawer(drawer){
	            if (this.options.revealLength == undefined)
	                this.options.revealLength = drawer.getSize()[this.direction];

	            this.drawer = drawer;
	            var layout = new LayoutNode({transform : Transform.behind});
	            this.add(layout).add(this.drawer);
	        },
	        /**
	         * Set the content component with a Surface or View.
	         *
	         * @method addContent
	         * @param content {Surface|View}
	         */
	        addContent : function addContent(content){
	            var transform = this.position.map(function(position){
	                return (this.direction === CONSTANTS.DIRECTION.X)
	                    ? Transform.translateX(position)
	                    : Transform.translateY(position)
	            }.bind(this));

	            var layout = new LayoutNode({transform : transform});

	            this.add(layout).add(content);
	        },
	        /**
	         * Reveals the drawer with a transition.
	         *   Emits an `open` event when an opening transition has been committed to.
	         *
	         * @method open
	         * @param [transition] {Boolean|Object} transition definition
	         * @param [callback] {Function}         callback
	         */
	        open : function open(transition, callback){
	            if (transition === undefined) transition = this.options.transitionOpen;
	            this.setPosition(this.options.revealLength, transition, callback);
	            if (!this.isOpen) {
	                this.isOpen = true;
	                this.emit('open');
	            }
	        },
	        /**
	         * Conceals the drawer with a transition.
	         *   Emits a `close` event when an closing transition has been committed to.
	         *
	         * @method close
	         * @param [transition] {Boolean|Object} transition definition
	         * @param [callback] {Function}         callback
	         */
	        close : function close(transition, callback){
	            if (transition === undefined) transition = this.options.transitionClose;
	            this.setPosition(0, transition, callback);
	            if (this.isOpen){
	                this.isOpen = false;
	                this.emit('close');
	            }
	        },
	        /**
	         * Toggles between open and closed states.
	         *
	         * @method toggle
	         * @param [transition] {Boolean|Object} transition definition
	         */
	        toggle : function toggle(transition){
	            if (this.isOpen) this.close(transition);
	            else this.open(transition);
	        },
	        /**
	         * Sets the position in pixels for the content's displacement.
	         *
	         * @method setPosition
	         * @param position {Number}             position
	         * @param [transition] {Boolean|Object} transition definition
	         * @param [callback] {Function}         callback
	         */
	        setPosition : function setPosition(position, transition, callback) {
	            this.transitionStream.reset(this.position.get());
	            this.transitionStream.set(position, transition, callback);
	        },
	        /**
	         * Resets to last state of being open or closed
	         *
	         * @method reset
	         * @param [transition] {Boolean|Object} transition definition
	         */
	        reset : function reset(transition) {
	            if (this.isOpen) this.open(transition);
	            else this.close(transition);
	        }
	    }, CONSTANTS);

	    function _getDirectionFromSide(side) {
	        var SIDE = CONSTANTS.SIDE;
	        var DIRECTION = CONSTANTS.DIRECTION;
	        return (side === SIDE.LEFT || side === SIDE.RIGHT)
	            ? DIRECTION.X
	            : DIRECTION.Y;
	    }

	    function _getOrientationFromSide(side) {
	        var SIDES = CONSTANTS.SIDE;
	        return (side === SIDES.LEFT || side === SIDES.TOP)
	            ? CONSTANTS.ORIENTATION.POSITIVE
	            : CONSTANTS.ORIENTATION.NEGATIVE;
	    }

	    function _updateState(data){
	        var key = data.key;
	        var value = data.value;
	        if (key !== 'side') {
	            this.direction = _getDirectionFromSide(value);
	            this.orientation = _getOrientationFromSide(value);
	        }
	        this.options.revealLength *= this.direction;
	    }

	    module.exports = DrawerLayout;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module){
	    var Stream = __webpack_require__(15);
	    var OptionsManager = __webpack_require__(31);

	    /**
	     * Differential is a Stream that emits differentials of consecutive
	     *  input values.
	     *
	     *  It emits `start`, `update` and `end` events.
	     *
	     *  @example
	     *
	     *      var differential = new Differential();
	     *      // this gives differentials of mouse input
	     *      differential.subscribe(mouseInput.pluck('value'));
	     *
	     *
	     * @class Differential
	     * @extends Streams.Stream
	     * @uses Core.OptionsManager
	     * @namespace Streams
	     * @constructor
	     * @param [options] {Object}        Options
	     * @param [options.scale] {Number}  Scale to apply to differential
	     */
	    function Differential(options){
	        this.options = OptionsManager.setOptions(this, options);

	        var previous = undefined;
	        var delta = undefined;

	        Stream.call(this, {
	            update: function () { return delta; }
	        });

	        this._eventInput.on('start', function(value){ previous = value; });
	        this._eventInput.on('update', function(value){
	            var scale = this.options.scale;
	            if (previous instanceof Array) {
	                delta = [];
	                for (var i = 0; i < previous.length; i++)
	                    delta[i] = scale * (value[i] - previous[i]);
	            }
	            else delta = scale * (value - previous);
	            previous = value;
	        }.bind(this));
	    }

	    Differential.DEFAULT_OPTIONS = {
	        scale : 1
	    };

	    Differential.prototype = Object.create(Stream.prototype);
	    Differential.prototype.constructor = Differential;

	    module.exports = Differential;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module){
	    var OptionsManager = __webpack_require__(31);
	    var Stream = __webpack_require__(15);
	    var preTickQueue = __webpack_require__(5);
	    var dirtyQueue = __webpack_require__(6);

	    /**
	     * Accumulator is a Stream that accumulates a value given by a
	     *  number or array of numbers.
	     *
	     *  It emits `start`, `update` and `end` events.
	     *
	     *  @example
	     *
	     *      var accumulator = new Accumulator(0);
	     *
	     *      // this gives the total displacement of mouse input
	     *      accumulator.subscribe(mouseInput.pluck('delta'));
	     *
	     *
	     * @class Accumulator
	     * @extends Streams.Stream
	     * @namespace Streams
	     * @constructor
	     * @param [sum] {Number|Array}    Initial value
	     * @param [options] {Object}      Options
	     * @param [options.min] {Number}  Set a minimum value
	     * @param [options.max] {Number}  Set a maximum value
	     */
	    function Accumulator(sum, options){
	        this.options = OptionsManager.setOptions(this, options);

	        // TODO: is this state necessary?
	        this.sum = undefined;

	        if (sum !== undefined) this.set(sum);

	        Stream.call(this, {
	            start : function(){ return this.sum || 0; }.bind(this),
	            update : function(){ return this.sum; }.bind(this),
	            end : function(){ return this.sum || 0; }.bind(this)
	        });

	        // TODO: is `start` event necessary?
	        this._eventInput.on('start', function(value){
	            if (this.sum !== undefined) return;
	            if (value instanceof Array) {
	                this.sum = [];
	                for (var i = 0; i < value.length; i++)
	                    this.sum[i] = clamp(value[i], this.options.min, this.options.max);
	            }
	            else this.sum = clamp(value, this.options.min, this.options.max);
	        }.bind(this));

	        this._eventInput.on('update', function(delta){
	            if (delta instanceof Array){
	                for (var i = 0; i < delta.length; i++){
	                    this.sum[i] += delta[i];
	                    this.sum[i] = clamp(this.sum[i], this.options.min, this.options.max);
	                }
	            }
	            else {
	                this.sum += delta;
	                this.sum = clamp(this.sum, this.options.min, this.options.max);
	            }
	        }.bind(this));
	    }

	    Accumulator.prototype = Object.create(Stream.prototype);
	    Accumulator.prototype.constructor = Accumulator;

	    Accumulator.DEFAULT_OPTIONS = {
	        min : -Infinity,
	        max :  Infinity
	    };

	    function clamp(value, min, max){
	        return Math.min(Math.max(value, min), max);
	    }

	    /**
	     * Set accumulated value.
	     *
	     * @method set
	     * @param sum {Number}              Current value
	     * @param [silent=false] {Boolean}  Flag to suppress events
	     */
	    Accumulator.prototype.set = function(sum, silent){
	        this.sum = sum;
	        if (silent === true) return;
	        var self = this;
	        preTickQueue.push(function(){
	            self.trigger('start', sum);
	            dirtyQueue.push(function(){
	                self.trigger('end', sum);
	            });
	        })
	    };

	    /**
	     * Returns current accumulated value.
	     *
	     * @method get
	     * @return {Number}
	     */
	    Accumulator.prototype.get = function(){
	        return this.sum;
	    };

	    module.exports = Accumulator;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Transform = __webpack_require__(21);
	    var Transitionable = __webpack_require__(22);
	    var View = __webpack_require__(26);
	    var Stream = __webpack_require__(15);
	    var LayoutNode = __webpack_require__(8);
	    var SizeNode = __webpack_require__(17);

	    var CONSTANTS = {
	        DIRECTION : {
	            X : 0,
	            Y : 1
	        }
	    };

	    /**
	     * A layout which arranges items vertically or horizontally and
	     *  with sizes prescribed by ratios of a containing size. These
	     *  ratios can be animated.
	     *
	     * @class FlexibleLayout
	     * @constructor
	     * @namespace Layouts
	     * @extends Core.View
	     * @param [options] {Object}                        Options
	     * @param [options.direction]{Number}               Direction to lay out items
	     * @param [options.ratios] {Transitionable|Array}   The proportions
	     */
	    var FlexibleLayout = View.extend({
	        defaults : {
	            direction : CONSTANTS.DIRECTION.X,
	            ratios : []
	        },
	        initialize : function initialize(options){
	            var ratios = (options.ratios instanceof Transitionable)
	                ? options.ratios
	                : new Transitionable(options.ratios);

	            this.nodes = [];

	            var stateStream = Stream.lift(function(ratios, parentSize){
	                var direction = options.direction;

	                // calculate remaining size after true-sized nodes are accounted for
	                var flexLength = parentSize[direction];
	                var ratioSum = 0;
	                for (var i = 0; i < ratios.length; i++) {
	                    var ratio = ratios[i];
	                    var node = this.nodes[i];

	                    (typeof ratio !== 'number')
	                        ? flexLength -= node.getSize()[direction] || 0
	                        : ratioSum += ratio;
	                }

	                // calculate sizes and displacements of nodes
	                var displacement = 0;
	                var transforms = [];
	                var sizes = [];
	                for (var i = 0; i < ratios.length; i++) {
	                    node = this.nodes[i];
	                    ratio = ratios[i];

	                    var nodeLength = (typeof ratio === 'number')
	                        ? flexLength * ratio / ratioSum
	                        : node.getSize()[direction];

	                    var transform = (direction == CONSTANTS.DIRECTION.X)
	                        ? Transform.translateX(displacement)
	                        : Transform.translateY(displacement);

	                    var size = (direction == CONSTANTS.DIRECTION.X)
	                        ? [nodeLength, undefined]
	                        : [undefined, nodeLength];

	                    sizes.push(size);
	                    transforms.push(transform);

	                    displacement += nodeLength;
	                }

	                return {
	                    transforms : transforms,
	                    sizes : sizes
	                };

	            }.bind(this), [ratios, this.size]);

	            this.transforms = stateStream.pluck('transforms');
	            this.sizes = stateStream.pluck('sizes');
	        },
	        /**
	         * Add content as an array of Views or Surfaces.
	         *
	         * @method addItems
	         * @param items {Array}  An array of Views or Surfaces
	         */
	        addItems : function addItems(items){
	            this.nodes = items;

	            for (var i = 0; i < this.nodes.length; i++){
	                var node = this.nodes[i];

	                var layoutNode = new LayoutNode({
	                    transform : this.transforms.pluck(i)
	                });

	                var sizeNode = new SizeNode({
	                    size : this.sizes.pluck(i)
	                });

	                this.add(layoutNode).add(sizeNode).add(node);
	            }
	        }
	    }, CONSTANTS);

	    module.exports = FlexibleLayout;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Transform = __webpack_require__(21);
	    var View = __webpack_require__(26);
	    var Stream = __webpack_require__(15);
	    var LayoutNode = __webpack_require__(8);
	    var SizeNode = __webpack_require__(17);
	    var Transitionable = __webpack_require__(22);

	    /**
	     * A layout that arranges items in a grid and can rearrange the grid responsively.
	     *
	     *  The user provides the number of items per row in an array or a dictionary
	     *  with keys that are pixel values. The items will be sized to fill the available space.
	     *
	     *  Let itemsPerRow be a dictionary if you want the grid to rearrange responsively. The
	     *  keys should be pixel values. The row arrangement will be one of the entries of
	     *  the dictionary whose key value is closest to the parent width without exceeding it.
	     *
	     *  @class GridLayout
	     *  @constructor
	     *  @extends Core.View
	     *  @param [options] {Object}                           Options
	     *  @param options.itemsByRow {Array|Object}            Number of items per row, or an object of {width : itemsByRow} pairs
	     *  @param [options.gutter=0] {Transitionable|Number}   Gap space between successive items
	     */
	    var GridLayout = View.extend({
	        defaults : {
	            itemsPerRow : [],
	            gutter : 0
	        },
	        events : {},
	        initialize : function initialize(options){
	            var gutter = (options.gutter instanceof Transitionable)
	                ? options.gutter
	                : new Transitionable(options.gutter);

	            this.stream = Stream.lift(function(size, gutter){
	                if (!size) return false; // TODO: fix bug

	                var width = size[0];
	                var height = size[1];

	                var rows = ((options.itemsPerRow instanceof Array))
	                    ? options.itemsPerRow
	                    : selectRows(options.itemsPerRow, width);

	                var numRows = rows.length;
	                var rowHeight = (height - ((numRows - 1) * gutter)) / numRows;

	                var sizes = [];
	                var positions = [];

	                var y = 0;
	                for (var row = 0; row < numRows; row++){
	                    var numCols = rows[row];
	                    var colWidth = (width - ((numCols - 1) * gutter)) / numCols;

	                    var x = 0;
	                    for (var col = 0; col < numCols; col++){
	                        var size = [colWidth, rowHeight];
	                        sizes.push(size);
	                        positions.push([x,y]);
	                        x += colWidth + gutter;
	                    }

	                    y += rowHeight + gutter;
	                }

	                return {
	                    sizes : sizes,
	                    positions : positions
	                };
	            }, [this.size, gutter])
	        },
	        /**
	         * Add items to the layout.
	         *
	         * @method addItems
	         * @param [items] {Array}   Array of Surfaces or Views
	         */
	        addItems : function addItems(items){
	            var sizes = this.stream.pluck('sizes');
	            var positions = this.stream.pluck('positions');

	            for (var i = 0; i < items.length; i++){
	                var node = items[i];

	                var size = sizes.pluck(i);
	                var position = positions.pluck(i);

	                var transform = position.map(function(position){
	                    return Transform.translate(position);
	                });

	                var size = new SizeNode({size : size});
	                var layout = new LayoutNode({transform : transform});

	                this.add(size).add(layout).add(node);
	            }
	        }
	    });

	    function selectRows(rows, width){
	        for (var cutoff in rows) {
	            if (width <= parseInt(cutoff))
	                break;
	        }
	        return rows[cutoff];
	    }

	    module.exports = GridLayout;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Transform = __webpack_require__(21);
	    var View = __webpack_require__(26);
	    var ResizeStream = __webpack_require__(18);
	    var LayoutNode = __webpack_require__(8);

	    var CONSTANTS = {
	        DIRECTION : {
	            X : 0,
	            Y : 1
	        }
	    };

	    /**
	     * A layout which arranges items in series based on their size.
	     *  Items can be arranged vertically or horizontally.
	     *
	     * @class SequentialLayout
	     * @constructor
	     * @namespace Layouts
	     * @extends Core.View
	     * @param [options] {Object}                        Options
	     * @param [options.direction]{Number}               Direction to lay out items
	     * @param [options.spacing] {Transitionable|Array}  Gutter spacing between items
	     */
	    var SequentialLayout = View.extend({
	        defaults : {
	            direction : CONSTANTS.DIRECTION.X,
	            spacing : 0
	        },
	        initialize : function initialize(){},
	        /**
	         * Add content as an array of Views or Surfaces.
	         *
	         * @method addItems
	         * @param items {Array}  An array of Views or Surfaces
	         */
	        addItems : function addItems(items){
	            var sizes = [];
	            for (var i = 0; i < items.length; i++)
	                sizes.push(items[i].size);

	            var stream = ResizeStream.lift(function(){
	                var sizes = arguments;
	                var direction = this.options.direction;
	                var transforms = [];

	                var length = 0;
	                for (var i = 0; i < sizes.length; i++){
	                    var size = sizes[i];

	                    var transform = direction === CONSTANTS.DIRECTION.X
	                        ? Transform.translateX(length)
	                        : Transform.translateY(length);

	                    transforms.push(transform);

	                    length += size[direction] + this.options.spacing;
	                }

	                return {
	                    transforms : transforms,
	                    length: length
	                };
	            }.bind(this), sizes);

	            var transforms = stream.pluck('transforms');
	            var length = stream.pluck('length');

	            this.output.subscribe(length);

	            for (var i = 0; i < items.length; i++){
	                var node = items[i];
	                var transform = transforms.pluck(i);
	                var layout = new LayoutNode({transform : transform});
	                this.add(layout).add(node);
	            }
	        }
	    }, CONSTANTS);

	    module.exports = SequentialLayout;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Copyright © 2015 David Valdman */

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    var Transform = __webpack_require__(21);
	    var Transitionable = __webpack_require__(22);
	    var View = __webpack_require__(26);
	    var LayoutNode = __webpack_require__(8);
	    var Stream = __webpack_require__(15);
	    var ResizeStream = __webpack_require__(18);
	    var Accumulator = __webpack_require__(53);
	    var Differential = __webpack_require__(52);

	    var SequentialLayout = __webpack_require__(56);
	    var ContainerSurface = __webpack_require__(35);

	    var GenericInput = __webpack_require__(41);
	    var ScrollInput = __webpack_require__(45);
	    var TouchInput = __webpack_require__(43);

	    GenericInput.register({
	        touch : TouchInput,
	        scroll : ScrollInput
	    });

	    var CONSTANTS = {
	        DIRECTION : {
	            X : 0,
	            Y : 1
	        }
	    };

	    var Scrollview = View.extend({
	        defaults : {
	            direction : CONSTANTS.DIRECTION.Y,
	            pageTransition : false
	        },
	        initialize : function(options){
	            this._currentIndex = 0;
	            this._previousIndex = 0;
	            this.itemOffset = 0;
	            this.items = [];
	            this.layout = new SequentialLayout({
	                direction : options.direction
	            });

	            var genericInput = new GenericInput(['touch', 'scroll'], {
	                direction : options.direction
	            });

	            var position = new Accumulator(0);

	            this.drag = new Transitionable(0);
	            this.spring = new Transitionable(0);

	            var dragDifferential = new Differential();
	            var springDifferential = new Differential();
	            var gestureDifferential = genericInput.pluck('delta');

	            dragDifferential.subscribe(this.drag);
	            springDifferential.subscribe(this.spring);

	            position.subscribe(gestureDifferential);
	            position.subscribe(dragDifferential);
	            //position.subscribe(springDifferential);

	            if (options.pageTransition){
	                genericInput.on('end', function(data){
	                    if (!shouldBounce) return;
	                    this.drag.reset(0);
	                    this.spring.reset(0);
	                    options.pageTransition.velocity = data.velocity + this.drag.getVelocity();
	                    this.drag.set(0, options.pageTransition);
	                }.bind(this));

	                genericInput.on('start', function(){
	                    this.drag.halt();
	                    this.spring.halt();
	                }.bind(this));

	                this.spring.on('start', function () {
	                    this.drag.velocity = 0;
	                }.bind(this));

	                this.spring.on('end', function(){
	                    changePage.call(this, this._currentIndex);
	                }.bind(this));
	            }

	            this.drag.on('end', function(data){
	                this.spring.set(this.itemOffset, {
	                    curve: 'spring',
	                    period: 70,
	                    damping: 0.7,
	                    velocity : data.velocity
	                })
	            }.bind(this));

	            var overflowStream = ResizeStream.lift(function(contentLength, viewportSize){
	                if (!contentLength) return false;
	                return viewportSize[options.direction] - contentLength;
	            }, [this.layout, this.size]);


	            var shouldBounce = true;
	            this.offset = Stream.lift(function(top, overflow){
	                shouldBounce = true;
	                if (!overflow) return false;

	                if (this.drag.isActive() || this.spring.isActive())
	                    return Math.round(top);

	                if (top <= overflow) {
	                    shouldBounce = false;
	                    position.set(overflow, true);
	                    changePage.call(this, this._currentIndex);
	                    return overflow;
	                }
	                else if(top >= 0){
	                    shouldBounce = false;
	                    position.set(0, true);
	                    changePage.call(this, this._currentIndex);
	                    return 0;
	                }
	                else
	                    return Math.round(top);
	            }.bind(this), [position, overflowStream]);

	            var displacementNode = new LayoutNode({
	                transform : this.offset.map(function(position){
	                    return options.direction == CONSTANTS.DIRECTION.Y
	                        ? Transform.translateY(position)
	                        : Transform.translateX(position);
	                })
	            });

	            var container = new ContainerSurface({
	                properties : {
	                    overflow : 'hidden'
	                }
	            });

	            genericInput.subscribe(container);

	            container.add(displacementNode).add(this.layout);
	            this.add(container);
	        },
	        goto : function(index, transition, callback){
	            transition = transition || this.options.transition;
	            var position = this.itemOffset;
	            if (index > this._currentIndex){
	                for (var i = this._currentIndex; i < index; i++)
	                    position -= this.items[i].getSize()[this.options.direction];
	            }
	            else if (index < this._currentIndex){
	                for (var i = this._currentIndex; i > index; i--)
	                    position += this.items[i].getSize()[this.options.direction];
	            }
	            else return;

	            this.spring.set(0);
	            this.spring.set(Math.ceil(position), transition, callback);
	        },
	        addItems : function(items){
	            this.layout.addItems(items);
	            this.items = items;

	            var args = [this.offset];
	            for (var i = 0; i < items.length; i++){
	                args.push(items[i].size);
	            }

	            var accumLength = 0;
	            var itemOffsetStream = Stream.lift(function(){
	                if (arguments[1] === undefined) return false;

	                var offset = arguments[0];
	                var direction = this.options.direction;
	                var index = this._currentIndex;
	                var currentSize = arguments[index + 1];

	                if (!currentSize) return false;

	                var progress = 0;
	                var itemOffset = -offset - accumLength;
	                var currentLength = currentSize[direction];

	                if (itemOffset >= currentLength){
	                    // pass currentNode forwards
	                    this._currentIndex++;
	                    progress = 0;
	                    accumLength += currentLength;
	                }
	                else if (itemOffset < 0){
	                    // pass currentNode backwards
	                    if (this._currentIndex == 0) return false;
	                    this._currentIndex--;
	                    progress = 1;
	                    currentLength = arguments[this._currentIndex + 1][direction];
	                    accumLength -= currentLength;
	                }
	                else {
	                    progress = itemOffset / currentLength;
	                }

	                this.itemOffset = (itemOffset < currentLength / 2)
	                    ? itemOffset
	                    : itemOffset - currentLength;

	                return {
	                    index : this._currentIndex,
	                    progress : progress
	                };
	            }.bind(this), args);

	            this.output.subscribe(itemOffsetStream);

	            itemOffsetStream.on('start', function(value){
	            }.bind(this));

	            itemOffsetStream.on('update', function(value){
	            }.bind(this));

	            itemOffsetStream.on('end', function(value){
	            }.bind(this));
	        }
	    });

	    function changePage(index){
	        console.log(index, this._previousIndex)
	        if (index == this._previousIndex) return;
	        this.output.emit('page', index);
	        this._previousIndex = index;
	    }

	    module.exports = Scrollview;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        Accumulator: __webpack_require__(53),
	        Differential: __webpack_require__(52),
	        SimpleStream: __webpack_require__(11),
	        Stream: __webpack_require__(15),
	        Observable: __webpack_require__(16),
	        SizeObservable: __webpack_require__(19)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {
	    module.exports = {
	        Tween: __webpack_require__(23),
	        Spring: __webpack_require__(24),
	        Inertia: __webpack_require__(25)
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }
/******/ ])
});
;
},{}],23:[function(require,module,exports){
/*!
 * vue-router v0.7.10
 * (c) 2016 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  global.VueRouter = factory();
}(this, function () { 'use strict';

  var babelHelpers = {};

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  function Target(path, matcher, delegate) {
    this.path = path;
    this.matcher = matcher;
    this.delegate = delegate;
  }

  Target.prototype = {
    to: function to(target, callback) {
      var delegate = this.delegate;

      if (delegate && delegate.willAddRoute) {
        target = delegate.willAddRoute(this.matcher.target, target);
      }

      this.matcher.add(this.path, target);

      if (callback) {
        if (callback.length === 0) {
          throw new Error("You must have an argument in the function passed to `to`");
        }
        this.matcher.addChild(this.path, target, callback, this.delegate);
      }
      return this;
    }
  };

  function Matcher(target) {
    this.routes = {};
    this.children = {};
    this.target = target;
  }

  Matcher.prototype = {
    add: function add(path, handler) {
      this.routes[path] = handler;
    },

    addChild: function addChild(path, target, callback, delegate) {
      var matcher = new Matcher(target);
      this.children[path] = matcher;

      var match = generateMatch(path, matcher, delegate);

      if (delegate && delegate.contextEntered) {
        delegate.contextEntered(target, match);
      }

      callback(match);
    }
  };

  function generateMatch(startingPath, matcher, delegate) {
    return function (path, nestedCallback) {
      var fullPath = startingPath + path;

      if (nestedCallback) {
        nestedCallback(generateMatch(fullPath, matcher, delegate));
      } else {
        return new Target(startingPath + path, matcher, delegate);
      }
    };
  }

  function addRoute(routeArray, path, handler) {
    var len = 0;
    for (var i = 0, l = routeArray.length; i < l; i++) {
      len += routeArray[i].path.length;
    }

    path = path.substr(len);
    var route = { path: path, handler: handler };
    routeArray.push(route);
  }

  function eachRoute(baseRoute, matcher, callback, binding) {
    var routes = matcher.routes;

    for (var path in routes) {
      if (routes.hasOwnProperty(path)) {
        var routeArray = baseRoute.slice();
        addRoute(routeArray, path, routes[path]);

        if (matcher.children[path]) {
          eachRoute(routeArray, matcher.children[path], callback, binding);
        } else {
          callback.call(binding, routeArray);
        }
      }
    }
  }

  function map (callback, addRouteCallback) {
    var matcher = new Matcher();

    callback(generateMatch("", matcher, this.delegate));

    eachRoute([], matcher, function (route) {
      if (addRouteCallback) {
        addRouteCallback(this, route);
      } else {
        this.add(route);
      }
    }, this);
  }

  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];

  var escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');

  function isArray(test) {
    return Object.prototype.toString.call(test) === "[object Array]";
  }

  // A Segment represents a segment in the original route description.
  // Each Segment type provides an `eachChar` and `regex` method.
  //
  // The `eachChar` method invokes the callback with one or more character
  // specifications. A character specification consumes one or more input
  // characters.
  //
  // The `regex` method returns a regex fragment for the segment. If the
  // segment is a dynamic of star segment, the regex fragment also includes
  // a capture.
  //
  // A character specification contains:
  //
  // * `validChars`: a String with a list of all valid characters, or
  // * `invalidChars`: a String with a list of all invalid characters
  // * `repeat`: true if the character specification can repeat

  function StaticSegment(string) {
    this.string = string;
  }
  StaticSegment.prototype = {
    eachChar: function eachChar(callback) {
      var string = this.string,
          ch;

      for (var i = 0, l = string.length; i < l; i++) {
        ch = string.charAt(i);
        callback({ validChars: ch });
      }
    },

    regex: function regex() {
      return this.string.replace(escapeRegex, '\\$1');
    },

    generate: function generate() {
      return this.string;
    }
  };

  function DynamicSegment(name) {
    this.name = name;
  }
  DynamicSegment.prototype = {
    eachChar: function eachChar(callback) {
      callback({ invalidChars: "/", repeat: true });
    },

    regex: function regex() {
      return "([^/]+)";
    },

    generate: function generate(params) {
      var val = params[this.name];
      return val == null ? ":" + this.name : val;
    }
  };

  function StarSegment(name) {
    this.name = name;
  }
  StarSegment.prototype = {
    eachChar: function eachChar(callback) {
      callback({ invalidChars: "", repeat: true });
    },

    regex: function regex() {
      return "(.+)";
    },

    generate: function generate(params) {
      var val = params[this.name];
      return val == null ? ":" + this.name : val;
    }
  };

  function EpsilonSegment() {}
  EpsilonSegment.prototype = {
    eachChar: function eachChar() {},
    regex: function regex() {
      return "";
    },
    generate: function generate() {
      return "";
    }
  };

  function parse(route, names, specificity) {
    // normalize route as not starting with a "/". Recognition will
    // also normalize.
    if (route.charAt(0) === "/") {
      route = route.substr(1);
    }

    var segments = route.split("/"),
        results = [];

    // A routes has specificity determined by the order that its different segments
    // appear in. This system mirrors how the magnitude of numbers written as strings
    // works.
    // Consider a number written as: "abc". An example would be "200". Any other number written
    // "xyz" will be smaller than "abc" so long as `a > z`. For instance, "199" is smaller
    // then "200", even though "y" and "z" (which are both 9) are larger than "0" (the value
    // of (`b` and `c`). This is because the leading symbol, "2", is larger than the other
    // leading symbol, "1".
    // The rule is that symbols to the left carry more weight than symbols to the right
    // when a number is written out as a string. In the above strings, the leading digit
    // represents how many 100's are in the number, and it carries more weight than the middle
    // number which represents how many 10's are in the number.
    // This system of number magnitude works well for route specificity, too. A route written as
    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than
    // `x`, irrespective of the other parts.
    // Because of this similarity, we assign each type of segment a number value written as a
    // string. We can find the specificity of compound routes by concatenating these strings
    // together, from left to right. After we have looped through all of the segments,
    // we convert the string to a number.
    specificity.val = '';

    for (var i = 0, l = segments.length; i < l; i++) {
      var segment = segments[i],
          match;

      if (match = segment.match(/^:([^\/]+)$/)) {
        results.push(new DynamicSegment(match[1]));
        names.push(match[1]);
        specificity.val += '3';
      } else if (match = segment.match(/^\*([^\/]+)$/)) {
        results.push(new StarSegment(match[1]));
        specificity.val += '2';
        names.push(match[1]);
      } else if (segment === "") {
        results.push(new EpsilonSegment());
        specificity.val += '1';
      } else {
        results.push(new StaticSegment(segment));
        specificity.val += '4';
      }
    }

    specificity.val = +specificity.val;

    return results;
  }

  // A State has a character specification and (`charSpec`) and a list of possible
  // subsequent states (`nextStates`).
  //
  // If a State is an accepting state, it will also have several additional
  // properties:
  //
  // * `regex`: A regular expression that is used to extract parameters from paths
  //   that reached this accepting state.
  // * `handlers`: Information on how to convert the list of captures into calls
  //   to registered handlers with the specified parameters
  // * `types`: How many static, dynamic or star segments in this route. Used to
  //   decide which route to use if multiple registered routes match a path.
  //
  // Currently, State is implemented naively by looping over `nextStates` and
  // comparing a character specification against a character. A more efficient
  // implementation would use a hash of keys pointing at one or more next states.

  function State(charSpec) {
    this.charSpec = charSpec;
    this.nextStates = [];
  }

  State.prototype = {
    get: function get(charSpec) {
      var nextStates = this.nextStates;

      for (var i = 0, l = nextStates.length; i < l; i++) {
        var child = nextStates[i];

        var isEqual = child.charSpec.validChars === charSpec.validChars;
        isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;

        if (isEqual) {
          return child;
        }
      }
    },

    put: function put(charSpec) {
      var state;

      // If the character specification already exists in a child of the current
      // state, just return that state.
      if (state = this.get(charSpec)) {
        return state;
      }

      // Make a new state for the character spec
      state = new State(charSpec);

      // Insert the new state as a child of the current state
      this.nextStates.push(state);

      // If this character specification repeats, insert the new state as a child
      // of itself. Note that this will not trigger an infinite loop because each
      // transition during recognition consumes a character.
      if (charSpec.repeat) {
        state.nextStates.push(state);
      }

      // Return the new state
      return state;
    },

    // Find a list of child states matching the next character
    match: function match(ch) {
      // DEBUG "Processing `" + ch + "`:"
      var nextStates = this.nextStates,
          child,
          charSpec,
          chars;

      // DEBUG "  " + debugState(this)
      var returned = [];

      for (var i = 0, l = nextStates.length; i < l; i++) {
        child = nextStates[i];

        charSpec = child.charSpec;

        if (typeof (chars = charSpec.validChars) !== 'undefined') {
          if (chars.indexOf(ch) !== -1) {
            returned.push(child);
          }
        } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {
          if (chars.indexOf(ch) === -1) {
            returned.push(child);
          }
        }
      }

      return returned;
    }

    /** IF DEBUG
    , debug: function() {
      var charSpec = this.charSpec,
          debug = "[",
          chars = charSpec.validChars || charSpec.invalidChars;
       if (charSpec.invalidChars) { debug += "^"; }
      debug += chars;
      debug += "]";
       if (charSpec.repeat) { debug += "+"; }
       return debug;
    }
    END IF **/
  };

  /** IF DEBUG
  function debug(log) {
    console.log(log);
  }

  function debugState(state) {
    return state.nextStates.map(function(n) {
      if (n.nextStates.length === 0) { return "( " + n.debug() + " [accepting] )"; }
      return "( " + n.debug() + " <then> " + n.nextStates.map(function(s) { return s.debug() }).join(" or ") + " )";
    }).join(", ")
  }
  END IF **/

  // Sort the routes by specificity
  function sortSolutions(states) {
    return states.sort(function (a, b) {
      return b.specificity.val - a.specificity.val;
    });
  }

  function recognizeChar(states, ch) {
    var nextStates = [];

    for (var i = 0, l = states.length; i < l; i++) {
      var state = states[i];

      nextStates = nextStates.concat(state.match(ch));
    }

    return nextStates;
  }

  var oCreate = Object.create || function (proto) {
    function F() {}
    F.prototype = proto;
    return new F();
  };

  function RecognizeResults(queryParams) {
    this.queryParams = queryParams || {};
  }
  RecognizeResults.prototype = oCreate({
    splice: Array.prototype.splice,
    slice: Array.prototype.slice,
    push: Array.prototype.push,
    length: 0,
    queryParams: null
  });

  function findHandler(state, path, queryParams) {
    var handlers = state.handlers,
        regex = state.regex;
    var captures = path.match(regex),
        currentCapture = 1;
    var result = new RecognizeResults(queryParams);

    for (var i = 0, l = handlers.length; i < l; i++) {
      var handler = handlers[i],
          names = handler.names,
          params = {};

      for (var j = 0, m = names.length; j < m; j++) {
        params[names[j]] = captures[currentCapture++];
      }

      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });
    }

    return result;
  }

  function addSegment(currentState, segment) {
    segment.eachChar(function (ch) {
      var state;

      currentState = currentState.put(ch);
    });

    return currentState;
  }

  function decodeQueryParamPart(part) {
    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1
    part = part.replace(/\+/gm, '%20');
    return decodeURIComponent(part);
  }

  // The main interface

  var RouteRecognizer = function RouteRecognizer() {
    this.rootState = new State();
    this.names = {};
  };

  RouteRecognizer.prototype = {
    add: function add(routes, options) {
      var currentState = this.rootState,
          regex = "^",
          specificity = {},
          handlers = [],
          allSegments = [],
          name;

      var isEmpty = true;

      for (var i = 0, l = routes.length; i < l; i++) {
        var route = routes[i],
            names = [];

        var segments = parse(route.path, names, specificity);

        allSegments = allSegments.concat(segments);

        for (var j = 0, m = segments.length; j < m; j++) {
          var segment = segments[j];

          if (segment instanceof EpsilonSegment) {
            continue;
          }

          isEmpty = false;

          // Add a "/" for the new segment
          currentState = currentState.put({ validChars: "/" });
          regex += "/";

          // Add a representation of the segment to the NFA and regex
          currentState = addSegment(currentState, segment);
          regex += segment.regex();
        }

        var handler = { handler: route.handler, names: names };
        handlers.push(handler);
      }

      if (isEmpty) {
        currentState = currentState.put({ validChars: "/" });
        regex += "/";
      }

      currentState.handlers = handlers;
      currentState.regex = new RegExp(regex + "$");
      currentState.specificity = specificity;

      if (name = options && options.as) {
        this.names[name] = {
          segments: allSegments,
          handlers: handlers
        };
      }
    },

    handlersFor: function handlersFor(name) {
      var route = this.names[name],
          result = [];
      if (!route) {
        throw new Error("There is no route named " + name);
      }

      for (var i = 0, l = route.handlers.length; i < l; i++) {
        result.push(route.handlers[i]);
      }

      return result;
    },

    hasRoute: function hasRoute(name) {
      return !!this.names[name];
    },

    generate: function generate(name, params) {
      var route = this.names[name],
          output = "";
      if (!route) {
        throw new Error("There is no route named " + name);
      }

      var segments = route.segments;

      for (var i = 0, l = segments.length; i < l; i++) {
        var segment = segments[i];

        if (segment instanceof EpsilonSegment) {
          continue;
        }

        output += "/";
        output += segment.generate(params);
      }

      if (output.charAt(0) !== '/') {
        output = '/' + output;
      }

      if (params && params.queryParams) {
        output += this.generateQueryString(params.queryParams);
      }

      return output;
    },

    generateQueryString: function generateQueryString(params) {
      var pairs = [];
      var keys = [];
      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          keys.push(key);
        }
      }
      keys.sort();
      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        var value = params[key];
        if (value == null) {
          continue;
        }
        var pair = encodeURIComponent(key);
        if (isArray(value)) {
          for (var j = 0, l = value.length; j < l; j++) {
            var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);
            pairs.push(arrayPair);
          }
        } else {
          pair += "=" + encodeURIComponent(value);
          pairs.push(pair);
        }
      }

      if (pairs.length === 0) {
        return '';
      }

      return "?" + pairs.join("&");
    },

    parseQueryString: function parseQueryString(queryString) {
      var pairs = queryString.split("&"),
          queryParams = {};
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i].split('='),
            key = decodeQueryParamPart(pair[0]),
            keyLength = key.length,
            isArray = false,
            value;
        if (pair.length === 1) {
          value = 'true';
        } else {
          //Handle arrays
          if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {
            isArray = true;
            key = key.slice(0, keyLength - 2);
            if (!queryParams[key]) {
              queryParams[key] = [];
            }
          }
          value = pair[1] ? decodeQueryParamPart(pair[1]) : '';
        }
        if (isArray) {
          queryParams[key].push(value);
        } else {
          queryParams[key] = value;
        }
      }
      return queryParams;
    },

    recognize: function recognize(path) {
      var states = [this.rootState],
          pathLen,
          i,
          l,
          queryStart,
          queryParams = {},
          isSlashDropped = false;

      queryStart = path.indexOf('?');
      if (queryStart !== -1) {
        var queryString = path.substr(queryStart + 1, path.length);
        path = path.substr(0, queryStart);
        queryParams = this.parseQueryString(queryString);
      }

      path = decodeURI(path);

      // DEBUG GROUP path

      if (path.charAt(0) !== "/") {
        path = "/" + path;
      }

      pathLen = path.length;
      if (pathLen > 1 && path.charAt(pathLen - 1) === "/") {
        path = path.substr(0, pathLen - 1);
        isSlashDropped = true;
      }

      for (i = 0, l = path.length; i < l; i++) {
        states = recognizeChar(states, path.charAt(i));
        if (!states.length) {
          break;
        }
      }

      // END DEBUG GROUP

      var solutions = [];
      for (i = 0, l = states.length; i < l; i++) {
        if (states[i].handlers) {
          solutions.push(states[i]);
        }
      }

      states = sortSolutions(solutions);

      var state = solutions[0];

      if (state && state.handlers) {
        // if a trailing slash was dropped and a star segment is the last segment
        // specified, put the trailing slash back
        if (isSlashDropped && state.regex.source.slice(-5) === "(.+)$") {
          path = path + "/";
        }
        return findHandler(state, path, queryParams);
      }
    }
  };

  RouteRecognizer.prototype.map = map;

  RouteRecognizer.VERSION = '0.1.9';

  var genQuery = RouteRecognizer.prototype.generateQueryString;

  // export default for holding the Vue reference
  var exports$1 = {};
  /**
   * Warn stuff.
   *
   * @param {String} msg
   */

  function warn(msg) {
    /* istanbul ignore next */
    if (window.console) {
      console.warn('[vue-router] ' + msg);
      if (!exports$1.Vue || exports$1.Vue.config.debug) {
        console.warn(new Error('warning stack trace:').stack);
      }
    }
  }

  /**
   * Resolve a relative path.
   *
   * @param {String} base
   * @param {String} relative
   * @param {Boolean} append
   * @return {String}
   */

  function resolvePath(base, relative, append) {
    var query = base.match(/(\?.*)$/);
    if (query) {
      query = query[1];
      base = base.slice(0, -query.length);
    }
    // a query!
    if (relative.charAt(0) === '?') {
      return base + relative;
    }
    var stack = base.split('/');
    // remove trailing segment if:
    // - not appending
    // - appending to trailing slash (last segment is empty)
    if (!append || !stack[stack.length - 1]) {
      stack.pop();
    }
    // resolve relative path
    var segments = relative.replace(/^\//, '').split('/');
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment === '.') {
        continue;
      } else if (segment === '..') {
        stack.pop();
      } else {
        stack.push(segment);
      }
    }
    // ensure leading slash
    if (stack[0] !== '') {
      stack.unshift('');
    }
    return stack.join('/');
  }

  /**
   * Forgiving check for a promise
   *
   * @param {Object} p
   * @return {Boolean}
   */

  function isPromise(p) {
    return p && typeof p.then === 'function';
  }

  /**
   * Retrive a route config field from a component instance
   * OR a component contructor.
   *
   * @param {Function|Vue} component
   * @param {String} name
   * @return {*}
   */

  function getRouteConfig(component, name) {
    var options = component && (component.$options || component.options);
    return options && options.route && options.route[name];
  }

  /**
   * Resolve an async component factory. Have to do a dirty
   * mock here because of Vue core's internal API depends on
   * an ID check.
   *
   * @param {Object} handler
   * @param {Function} cb
   */

  var resolver = undefined;

  function resolveAsyncComponent(handler, cb) {
    if (!resolver) {
      resolver = {
        resolve: exports$1.Vue.prototype._resolveComponent,
        $options: {
          components: {
            _: handler.component
          }
        }
      };
    } else {
      resolver.$options.components._ = handler.component;
    }
    resolver.resolve('_', function (Component) {
      handler.component = Component;
      cb(Component);
    });
  }

  /**
   * Map the dynamic segments in a path to params.
   *
   * @param {String} path
   * @param {Object} params
   * @param {Object} query
   */

  function mapParams(path, params, query) {
    if (params === undefined) params = {};

    path = path.replace(/:([^\/]+)/g, function (_, key) {
      var val = params[key];
      /* istanbul ignore if */
      if (!val) {
        warn('param "' + key + '" not found when generating ' + 'path for "' + path + '" with params ' + JSON.stringify(params));
      }
      return val || '';
    });
    if (query) {
      path += genQuery(query);
    }
    return path;
  }

  var hashRE = /#.*$/;

  var HTML5History = (function () {
    function HTML5History(_ref) {
      var root = _ref.root;
      var onChange = _ref.onChange;
      babelHelpers.classCallCheck(this, HTML5History);

      if (root) {
        // make sure there's the starting slash
        if (root.charAt(0) !== '/') {
          root = '/' + root;
        }
        // remove trailing slash
        this.root = root.replace(/\/$/, '');
        this.rootRE = new RegExp('^\\' + this.root);
      } else {
        this.root = null;
      }
      this.onChange = onChange;
      // check base tag
      var baseEl = document.querySelector('base');
      this.base = baseEl && baseEl.getAttribute('href');
    }

    HTML5History.prototype.start = function start() {
      var _this = this;

      this.listener = function (e) {
        var url = decodeURI(location.pathname + location.search);
        if (_this.root) {
          url = url.replace(_this.rootRE, '');
        }
        _this.onChange(url, e && e.state, location.hash);
      };
      window.addEventListener('popstate', this.listener);
      this.listener();
    };

    HTML5History.prototype.stop = function stop() {
      window.removeEventListener('popstate', this.listener);
    };

    HTML5History.prototype.go = function go(path, replace, append) {
      var url = this.formatPath(path, append);
      if (replace) {
        history.replaceState({}, '', url);
      } else {
        // record scroll position by replacing current state
        history.replaceState({
          pos: {
            x: window.pageXOffset,
            y: window.pageYOffset
          }
        }, '');
        // then push new state
        history.pushState({}, '', url);
      }
      var hashMatch = path.match(hashRE);
      var hash = hashMatch && hashMatch[0];
      path = url
      // strip hash so it doesn't mess up params
      .replace(hashRE, '')
      // remove root before matching
      .replace(this.rootRE, '');
      this.onChange(path, null, hash);
    };

    HTML5History.prototype.formatPath = function formatPath(path, append) {
      return path.charAt(0) === '/'
      // absolute path
      ? this.root ? this.root + '/' + path.replace(/^\//, '') : path : resolvePath(this.base || location.pathname, path, append);
    };

    return HTML5History;
  })();

  var HashHistory = (function () {
    function HashHistory(_ref) {
      var hashbang = _ref.hashbang;
      var onChange = _ref.onChange;
      babelHelpers.classCallCheck(this, HashHistory);

      this.hashbang = hashbang;
      this.onChange = onChange;
    }

    HashHistory.prototype.start = function start() {
      var self = this;
      this.listener = function () {
        var path = location.hash;
        var raw = path.replace(/^#!?/, '');
        // always
        if (raw.charAt(0) !== '/') {
          raw = '/' + raw;
        }
        var formattedPath = self.formatPath(raw);
        if (formattedPath !== path) {
          location.replace(formattedPath);
          return;
        }
        // determine query
        // note it's possible to have queries in both the actual URL
        // and the hash fragment itself.
        var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;
        self.onChange(decodeURI(path.replace(/^#!?/, '') + query));
      };
      window.addEventListener('hashchange', this.listener);
      this.listener();
    };

    HashHistory.prototype.stop = function stop() {
      window.removeEventListener('hashchange', this.listener);
    };

    HashHistory.prototype.go = function go(path, replace, append) {
      path = this.formatPath(path, append);
      if (replace) {
        location.replace(path);
      } else {
        location.hash = path;
      }
    };

    HashHistory.prototype.formatPath = function formatPath(path, append) {
      var isAbsoloute = path.charAt(0) === '/';
      var prefix = '#' + (this.hashbang ? '!' : '');
      return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);
    };

    return HashHistory;
  })();

  var AbstractHistory = (function () {
    function AbstractHistory(_ref) {
      var onChange = _ref.onChange;
      babelHelpers.classCallCheck(this, AbstractHistory);

      this.onChange = onChange;
      this.currentPath = '/';
    }

    AbstractHistory.prototype.start = function start() {
      this.onChange('/');
    };

    AbstractHistory.prototype.stop = function stop() {
      // noop
    };

    AbstractHistory.prototype.go = function go(path, replace, append) {
      path = this.currentPath = this.formatPath(path, append);
      this.onChange(path);
    };

    AbstractHistory.prototype.formatPath = function formatPath(path, append) {
      return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);
    };

    return AbstractHistory;
  })();

  /**
   * Determine the reusability of an existing router view.
   *
   * @param {Directive} view
   * @param {Object} handler
   * @param {Transition} transition
   */

  function canReuse(view, handler, transition) {
    var component = view.childVM;
    if (!component || !handler) {
      return false;
    }
    // important: check view.Component here because it may
    // have been changed in activate hook
    if (view.Component !== handler.component) {
      return false;
    }
    var canReuseFn = getRouteConfig(component, 'canReuse');
    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {
      to: transition.to,
      from: transition.from
    }) : true; // defaults to true
  }

  /**
   * Check if a component can deactivate.
   *
   * @param {Directive} view
   * @param {Transition} transition
   * @param {Function} next
   */

  function canDeactivate(view, transition, next) {
    var fromComponent = view.childVM;
    var hook = getRouteConfig(fromComponent, 'canDeactivate');
    if (!hook) {
      next();
    } else {
      transition.callHook(hook, fromComponent, next, {
        expectBoolean: true
      });
    }
  }

  /**
   * Check if a component can activate.
   *
   * @param {Object} handler
   * @param {Transition} transition
   * @param {Function} next
   */

  function canActivate(handler, transition, next) {
    resolveAsyncComponent(handler, function (Component) {
      // have to check due to async-ness
      if (transition.aborted) {
        return;
      }
      // determine if this component can be activated
      var hook = getRouteConfig(Component, 'canActivate');
      if (!hook) {
        next();
      } else {
        transition.callHook(hook, null, next, {
          expectBoolean: true
        });
      }
    });
  }

  /**
   * Call deactivate hooks for existing router-views.
   *
   * @param {Directive} view
   * @param {Transition} transition
   * @param {Function} next
   */

  function deactivate(view, transition, next) {
    var component = view.childVM;
    var hook = getRouteConfig(component, 'deactivate');
    if (!hook) {
      next();
    } else {
      transition.callHooks(hook, component, next);
    }
  }

  /**
   * Activate / switch component for a router-view.
   *
   * @param {Directive} view
   * @param {Transition} transition
   * @param {Number} depth
   * @param {Function} [cb]
   */

  function activate(view, transition, depth, cb, reuse) {
    var handler = transition.activateQueue[depth];
    if (!handler) {
      saveChildView(view);
      if (view._bound) {
        view.setComponent(null);
      }
      cb && cb();
      return;
    }

    var Component = view.Component = handler.component;
    var activateHook = getRouteConfig(Component, 'activate');
    var dataHook = getRouteConfig(Component, 'data');
    var waitForData = getRouteConfig(Component, 'waitForData');

    view.depth = depth;
    view.activated = false;

    var component = undefined;
    var loading = !!(dataHook && !waitForData);

    // "reuse" is a flag passed down when the parent view is
    // either reused via keep-alive or as a child of a kept-alive view.
    // of course we can only reuse if the current kept-alive instance
    // is of the correct type.
    reuse = reuse && view.childVM && view.childVM.constructor === Component;

    if (reuse) {
      // just reuse
      component = view.childVM;
      component.$loadingRouteData = loading;
    } else {
      saveChildView(view);

      // unbuild current component. this step also destroys
      // and removes all nested child views.
      view.unbuild(true);

      // build the new component. this will also create the
      // direct child view of the current one. it will register
      // itself as view.childView.
      component = view.build({
        _meta: {
          $loadingRouteData: loading
        },
        created: function created() {
          this._routerView = view;
        }
      });

      // handle keep-alive.
      // when a kept-alive child vm is restored, we need to
      // add its cached child views into the router's view list,
      // and also properly update current view's child view.
      if (view.keepAlive) {
        component.$loadingRouteData = loading;
        var cachedChildView = component._keepAliveRouterView;
        if (cachedChildView) {
          view.childView = cachedChildView;
          component._keepAliveRouterView = null;
        }
      }
    }

    // cleanup the component in case the transition is aborted
    // before the component is ever inserted.
    var cleanup = function cleanup() {
      component.$destroy();
    };

    // actually insert the component and trigger transition
    var insert = function insert() {
      if (reuse) {
        cb && cb();
        return;
      }
      var router = transition.router;
      if (router._rendered || router._transitionOnLoad) {
        view.transition(component);
      } else {
        // no transition on first render, manual transition
        /* istanbul ignore if */
        if (view.setCurrent) {
          // 0.12 compat
          view.setCurrent(component);
        } else {
          // 1.0
          view.childVM = component;
        }
        component.$before(view.anchor, null, false);
      }
      cb && cb();
    };

    var afterData = function afterData() {
      // activate the child view
      if (view.childView) {
        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);
      }
      insert();
    };

    // called after activation hook is resolved
    var afterActivate = function afterActivate() {
      view.activated = true;
      if (dataHook && waitForData) {
        // wait until data loaded to insert
        loadData(component, transition, dataHook, afterData, cleanup);
      } else {
        // load data and insert at the same time
        if (dataHook) {
          loadData(component, transition, dataHook);
        }
        afterData();
      }
    };

    if (activateHook) {
      transition.callHooks(activateHook, component, afterActivate, { cleanup: cleanup });
    } else {
      afterActivate();
    }
  }

  /**
   * Reuse a view, just reload data if necessary.
   *
   * @param {Directive} view
   * @param {Transition} transition
   */

  function reuse(view, transition) {
    var component = view.childVM;
    var dataHook = getRouteConfig(component, 'data');
    if (dataHook) {
      loadData(component, transition, dataHook);
    }
  }

  /**
   * Asynchronously load and apply data to component.
   *
   * @param {Vue} component
   * @param {Transition} transition
   * @param {Function} hook
   * @param {Function} cb
   * @param {Function} cleanup
   */

  function loadData(component, transition, hook, cb, cleanup) {
    component.$loadingRouteData = true;
    transition.callHooks(hook, component, function (data, onError) {
      // merge data from multiple data hooks
      if (Array.isArray(data) && data._needMerge) {
        data = data.reduce(function (res, obj) {
          if (isPlainObject(obj)) {
            Object.keys(obj).forEach(function (key) {
              res[key] = obj[key];
            });
          }
          return res;
        }, Object.create(null));
      }
      // handle promise sugar syntax
      var promises = [];
      if (isPlainObject(data)) {
        Object.keys(data).forEach(function (key) {
          var val = data[key];
          if (isPromise(val)) {
            promises.push(val.then(function (resolvedVal) {
              component.$set(key, resolvedVal);
            }));
          } else {
            component.$set(key, val);
          }
        });
      }
      if (!promises.length) {
        component.$loadingRouteData = false;
        component.$emit('route-data-loaded', component);
        cb && cb();
      } else {
        promises[0].constructor.all(promises).then(function () {
          component.$loadingRouteData = false;
          component.$emit('route-data-loaded', component);
          cb && cb();
        }, onError);
      }
    }, {
      cleanup: cleanup,
      expectData: true
    });
  }

  /**
   * Save the child view for a kept-alive view so that
   * we can restore it when it is switched back to.
   *
   * @param {Directive} view
   */

  function saveChildView(view) {
    if (view.keepAlive && view.childVM && view.childView) {
      view.childVM._keepAliveRouterView = view.childView;
    }
    view.childView = null;
  }

  /**
   * Check plain object.
   *
   * @param {*} val
   */

  function isPlainObject(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  }

  /**
   * A RouteTransition object manages the pipeline of a
   * router-view switching process. This is also the object
   * passed into user route hooks.
   *
   * @param {Router} router
   * @param {Route} to
   * @param {Route} from
   */

  var RouteTransition = (function () {
    function RouteTransition(router, to, from) {
      babelHelpers.classCallCheck(this, RouteTransition);

      this.router = router;
      this.to = to;
      this.from = from;
      this.next = null;
      this.aborted = false;
      this.done = false;
    }

    /**
     * Abort current transition and return to previous location.
     */

    RouteTransition.prototype.abort = function abort() {
      if (!this.aborted) {
        this.aborted = true;
        // if the root path throws an error during validation
        // on initial load, it gets caught in an infinite loop.
        var abortingOnLoad = !this.from.path && this.to.path === '/';
        if (!abortingOnLoad) {
          this.router.replace(this.from.path || '/');
        }
      }
    };

    /**
     * Abort current transition and redirect to a new location.
     *
     * @param {String} path
     */

    RouteTransition.prototype.redirect = function redirect(path) {
      if (!this.aborted) {
        this.aborted = true;
        if (typeof path === 'string') {
          path = mapParams(path, this.to.params, this.to.query);
        } else {
          path.params = path.params || this.to.params;
          path.query = path.query || this.to.query;
        }
        this.router.replace(path);
      }
    };

    /**
     * A router view transition's pipeline can be described as
     * follows, assuming we are transitioning from an existing
     * <router-view> chain [Component A, Component B] to a new
     * chain [Component A, Component C]:
     *
     *  A    A
     *  | => |
     *  B    C
     *
     * 1. Reusablity phase:
     *   -> canReuse(A, A)
     *   -> canReuse(B, C)
     *   -> determine new queues:
     *      - deactivation: [B]
     *      - activation: [C]
     *
     * 2. Validation phase:
     *   -> canDeactivate(B)
     *   -> canActivate(C)
     *
     * 3. Activation phase:
     *   -> deactivate(B)
     *   -> activate(C)
     *
     * Each of these steps can be asynchronous, and any
     * step can potentially abort the transition.
     *
     * @param {Function} cb
     */

    RouteTransition.prototype.start = function start(cb) {
      var transition = this;

      // determine the queue of views to deactivate
      var deactivateQueue = [];
      var view = this.router._rootView;
      while (view) {
        deactivateQueue.unshift(view);
        view = view.childView;
      }
      var reverseDeactivateQueue = deactivateQueue.slice().reverse();

      // determine the queue of route handlers to activate
      var activateQueue = this.activateQueue = toArray(this.to.matched).map(function (match) {
        return match.handler;
      });

      // 1. Reusability phase
      var i = undefined,
          reuseQueue = undefined;
      for (i = 0; i < reverseDeactivateQueue.length; i++) {
        if (!canReuse(reverseDeactivateQueue[i], activateQueue[i], transition)) {
          break;
        }
      }
      if (i > 0) {
        reuseQueue = reverseDeactivateQueue.slice(0, i);
        deactivateQueue = reverseDeactivateQueue.slice(i).reverse();
        activateQueue = activateQueue.slice(i);
      }

      // 2. Validation phase
      transition.runQueue(deactivateQueue, canDeactivate, function () {
        transition.runQueue(activateQueue, canActivate, function () {
          transition.runQueue(deactivateQueue, deactivate, function () {
            // 3. Activation phase

            // Update router current route
            transition.router._onTransitionValidated(transition);

            // trigger reuse for all reused views
            reuseQueue && reuseQueue.forEach(function (view) {
              return reuse(view, transition);
            });

            // the root of the chain that needs to be replaced
            // is the top-most non-reusable view.
            if (deactivateQueue.length) {
              var _view = deactivateQueue[deactivateQueue.length - 1];
              var depth = reuseQueue ? reuseQueue.length : 0;
              activate(_view, transition, depth, cb);
            } else {
              cb();
            }
          });
        });
      });
    };

    /**
     * Asynchronously and sequentially apply a function to a
     * queue.
     *
     * @param {Array} queue
     * @param {Function} fn
     * @param {Function} cb
     */

    RouteTransition.prototype.runQueue = function runQueue(queue, fn, cb) {
      var transition = this;
      step(0);
      function step(index) {
        if (index >= queue.length) {
          cb();
        } else {
          fn(queue[index], transition, function () {
            step(index + 1);
          });
        }
      }
    };

    /**
     * Call a user provided route transition hook and handle
     * the response (e.g. if the user returns a promise).
     *
     * If the user neither expects an argument nor returns a
     * promise, the hook is assumed to be synchronous.
     *
     * @param {Function} hook
     * @param {*} [context]
     * @param {Function} [cb]
     * @param {Object} [options]
     *                 - {Boolean} expectBoolean
     *                 - {Boolean} expectData
     *                 - {Function} cleanup
     */

    RouteTransition.prototype.callHook = function callHook(hook, context, cb) {
      var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

      var _ref$expectBoolean = _ref.expectBoolean;
      var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;
      var _ref$expectData = _ref.expectData;
      var expectData = _ref$expectData === undefined ? false : _ref$expectData;
      var cleanup = _ref.cleanup;

      var transition = this;
      var nextCalled = false;

      // abort the transition
      var abort = function abort() {
        cleanup && cleanup();
        transition.abort();
      };

      // handle errors
      var onError = function onError(err) {
        // cleanup indicates an after-activation hook,
        // so instead of aborting we just let the transition
        // finish.
        cleanup ? next() : abort();
        if (err && !transition.router._suppress) {
          warn('Uncaught error during transition: ');
          throw err instanceof Error ? err : new Error(err);
        }
      };

      // advance the transition to the next step
      var next = function next(data) {
        if (nextCalled) {
          warn('transition.next() should be called only once.');
          return;
        }
        nextCalled = true;
        if (transition.aborted) {
          cleanup && cleanup();
          return;
        }
        cb && cb(data, onError);
      };

      // expose a clone of the transition object, so that each
      // hook gets a clean copy and prevent the user from
      // messing with the internals.
      var exposed = {
        to: transition.to,
        from: transition.from,
        abort: abort,
        next: next,
        redirect: function redirect() {
          transition.redirect.apply(transition, arguments);
        }
      };

      // actually call the hook
      var res = undefined;
      try {
        res = hook.call(context, exposed);
      } catch (err) {
        return onError(err);
      }

      // handle boolean/promise return values
      var resIsPromise = isPromise(res);
      if (expectBoolean) {
        if (typeof res === 'boolean') {
          res ? next() : abort();
        } else if (resIsPromise) {
          res.then(function (ok) {
            ok ? next() : abort();
          }, onError);
        } else if (!hook.length) {
          next(res);
        }
      } else if (resIsPromise) {
        res.then(next, onError);
      } else if (expectData && isPlainOjbect(res) || !hook.length) {
        next(res);
      }
    };

    /**
     * Call a single hook or an array of async hooks in series.
     *
     * @param {Array} hooks
     * @param {*} context
     * @param {Function} cb
     * @param {Object} [options]
     */

    RouteTransition.prototype.callHooks = function callHooks(hooks, context, cb, options) {
      var _this = this;

      if (Array.isArray(hooks)) {
        (function () {
          var res = [];
          res._needMerge = true;
          var onError = undefined;
          _this.runQueue(hooks, function (hook, _, next) {
            if (!_this.aborted) {
              _this.callHook(hook, context, function (r, onError) {
                if (r) res.push(r);
                onError = onError;
                next();
              }, options);
            }
          }, function () {
            cb(res, onError);
          });
        })();
      } else {
        this.callHook(hooks, context, cb, options);
      }
    };

    return RouteTransition;
  })();

  function isPlainOjbect(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  }

  function toArray(val) {
    return val ? Array.prototype.slice.call(val) : [];
  }

  var internalKeysRE = /^(component|subRoutes)$/;

  /**
   * Route Context Object
   *
   * @param {String} path
   * @param {Router} router
   */

  var Route = function Route(path, router) {
    var _this = this;

    babelHelpers.classCallCheck(this, Route);

    var matched = router._recognizer.recognize(path);
    if (matched) {
      // copy all custom fields from route configs
      [].forEach.call(matched, function (match) {
        for (var key in match.handler) {
          if (!internalKeysRE.test(key)) {
            _this[key] = match.handler[key];
          }
        }
      });
      // set query and params
      this.query = matched.queryParams;
      this.params = [].reduce.call(matched, function (prev, cur) {
        if (cur.params) {
          for (var key in cur.params) {
            prev[key] = cur.params[key];
          }
        }
        return prev;
      }, {});
    }
    // expose path and router
    this.path = path;
    this.router = router;
    // for internal use
    this.matched = matched || router._notFoundHandler;
    // Important: freeze self to prevent observation
    Object.freeze(this);
  };

  function applyOverride (Vue) {
    var _Vue$util = Vue.util;
    var extend = _Vue$util.extend;
    var isArray = _Vue$util.isArray;
    var defineReactive = _Vue$util.defineReactive;

    // override Vue's init and destroy process to keep track of router instances
    var init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      options = options || {};
      var root = options._parent || options.parent || this;
      var router = root.$router;
      var route = root.$route;
      if (router) {
        // expose router
        this.$router = router;
        router._children.push(this);
        /* istanbul ignore if */
        if (this._defineMeta) {
          // 0.12
          this._defineMeta('$route', route);
        } else {
          // 1.0
          defineReactive(this, '$route', route);
        }
      }
      init.call(this, options);
    };

    var destroy = Vue.prototype._destroy;
    Vue.prototype._destroy = function () {
      if (!this._isBeingDestroyed && this.$router) {
        this.$router._children.$remove(this);
      }
      destroy.apply(this, arguments);
    };

    // 1.0 only: enable route mixins
    var strats = Vue.config.optionMergeStrategies;
    var hooksToMergeRE = /^(data|activate|deactivate)$/;

    if (strats) {
      strats.route = function (parentVal, childVal) {
        if (!childVal) return parentVal;
        if (!parentVal) return childVal;
        var ret = {};
        extend(ret, parentVal);
        for (var key in childVal) {
          var a = ret[key];
          var b = childVal[key];
          // for data, activate and deactivate, we need to merge them into
          // arrays similar to lifecycle hooks.
          if (a && hooksToMergeRE.test(key)) {
            ret[key] = (isArray(a) ? a : [a]).concat(b);
          } else {
            ret[key] = b;
          }
        }
        return ret;
      };
    }
  }

  function View (Vue) {

    var _ = Vue.util;
    var componentDef =
    // 0.12
    Vue.directive('_component') ||
    // 1.0
    Vue.internalDirectives.component;
    // <router-view> extends the internal component directive
    var viewDef = _.extend({}, componentDef);

    // with some overrides
    _.extend(viewDef, {

      _isRouterView: true,

      bind: function bind() {
        var route = this.vm.$route;
        /* istanbul ignore if */
        if (!route) {
          warn('<router-view> can only be used inside a ' + 'router-enabled app.');
          return;
        }
        // force dynamic directive so v-component doesn't
        // attempt to build right now
        this._isDynamicLiteral = true;
        // finally, init by delegating to v-component
        componentDef.bind.call(this);

        // locate the parent view
        var parentView = undefined;
        var parent = this.vm;
        while (parent) {
          if (parent._routerView) {
            parentView = parent._routerView;
            break;
          }
          parent = parent.$parent;
        }
        if (parentView) {
          // register self as a child of the parent view,
          // instead of activating now. This is so that the
          // child's activate hook is called after the
          // parent's has resolved.
          this.parentView = parentView;
          parentView.childView = this;
        } else {
          // this is the root view!
          var router = route.router;
          router._rootView = this;
        }

        // handle late-rendered view
        // two possibilities:
        // 1. root view rendered after transition has been
        //    validated;
        // 2. child view rendered after parent view has been
        //    activated.
        var transition = route.router._currentTransition;
        if (!parentView && transition.done || parentView && parentView.activated) {
          var depth = parentView ? parentView.depth + 1 : 0;
          activate(this, transition, depth);
        }
      },

      unbind: function unbind() {
        if (this.parentView) {
          this.parentView.childView = null;
        }
        componentDef.unbind.call(this);
      }
    });

    Vue.elementDirective('router-view', viewDef);
  }

  var trailingSlashRE = /\/$/;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
  var queryStringRE = /\?.*$/;

  // install v-link, which provides navigation support for
  // HTML5 history mode
  function Link (Vue) {
    var _Vue$util = Vue.util;
    var _bind = _Vue$util.bind;
    var isObject = _Vue$util.isObject;
    var addClass = _Vue$util.addClass;
    var removeClass = _Vue$util.removeClass;

    Vue.directive('link-active', {
      priority: 1001,
      bind: function bind() {
        this.el.__v_link_active = true;
      }
    });

    Vue.directive('link', {
      priority: 1000,

      bind: function bind() {
        var vm = this.vm;
        /* istanbul ignore if */
        if (!vm.$route) {
          warn('v-link can only be used inside a router-enabled app.');
          return;
        }
        this.router = vm.$route.router;
        // update things when the route changes
        this.unwatch = vm.$watch('$route', _bind(this.onRouteUpdate, this));
        // check if active classes should be applied to a different element
        this.activeEl = this.el;
        var parent = this.el.parentNode;
        while (parent) {
          if (parent.__v_link_active) {
            this.activeEl = parent;
            break;
          }
          parent = parent.parentNode;
        }
        // no need to handle click if link expects to be opened
        // in a new window/tab.
        /* istanbul ignore if */
        if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {
          return;
        }
        // handle click
        this.el.addEventListener('click', _bind(this.onClick, this));
      },

      update: function update(target) {
        this.target = target;
        if (isObject(target)) {
          this.append = target.append;
          this.exact = target.exact;
          this.prevActiveClass = this.activeClass;
          this.activeClass = target.activeClass;
        }
        this.onRouteUpdate(this.vm.$route);
      },

      onClick: function onClick(e) {
        // don't redirect with control keys
        /* istanbul ignore if */
        if (e.metaKey || e.ctrlKey || e.shiftKey) return;
        // don't redirect when preventDefault called
        /* istanbul ignore if */
        if (e.defaultPrevented) return;
        // don't redirect on right click
        /* istanbul ignore if */
        if (e.button !== 0) return;

        var target = this.target;
        if (target) {
          // v-link with expression, just go
          e.preventDefault();
          this.router.go(target);
        } else {
          // no expression, delegate for an <a> inside
          var el = e.target;
          while (el.tagName !== 'A' && el !== this.el) {
            el = el.parentNode;
          }
          if (el.tagName === 'A' && sameOrigin(el)) {
            e.preventDefault();
            this.router.go({
              path: el.pathname,
              replace: target && target.replace,
              append: target && target.append
            });
          }
        }
      },

      onRouteUpdate: function onRouteUpdate(route) {
        // router._stringifyPath is dependent on current route
        // and needs to be called again whenver route changes.
        var newPath = this.router._stringifyPath(this.target);
        if (this.path !== newPath) {
          this.path = newPath;
          this.updateActiveMatch();
          this.updateHref();
        }
        this.updateClasses(route.path);
      },

      updateActiveMatch: function updateActiveMatch() {
        this.activeRE = this.path && !this.exact ? new RegExp('^' + this.path.replace(/\/$/, '').replace(queryStringRE, '').replace(regexEscapeRE, '\\$&') + '(\\/|$)') : null;
      },

      updateHref: function updateHref() {
        if (this.el.tagName !== 'A') {
          return;
        }
        var path = this.path;
        var router = this.router;
        var isAbsolute = path.charAt(0) === '/';
        // do not format non-hash relative paths
        var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, this.append) : path;
        if (href) {
          this.el.href = href;
        } else {
          this.el.removeAttribute('href');
        }
      },

      updateClasses: function updateClasses(path) {
        var el = this.activeEl;
        var activeClass = this.activeClass || this.router._linkActiveClass;
        // clear old class
        if (this.prevActiveClass !== activeClass) {
          removeClass(el, this.prevActiveClass);
        }
        // remove query string before matching
        var dest = this.path.replace(queryStringRE, '');
        path = path.replace(queryStringRE, '');
        // add new class
        if (this.exact) {
          if (dest === path ||
          // also allow additional trailing slash
          dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {
            addClass(el, activeClass);
          } else {
            removeClass(el, activeClass);
          }
        } else {
          if (this.activeRE && this.activeRE.test(path)) {
            addClass(el, activeClass);
          } else {
            removeClass(el, activeClass);
          }
        }
      },

      unbind: function unbind() {
        this.el.removeEventListener('click', this.handler);
        this.unwatch && this.unwatch();
      }
    });

    function sameOrigin(link) {
      return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;
    }
  }

  var historyBackends = {
    abstract: AbstractHistory,
    hash: HashHistory,
    html5: HTML5History
  };

  // late bind during install
  var Vue = undefined;

  /**
   * Router constructor
   *
   * @param {Object} [options]
   */

  var Router = (function () {
    function Router() {
      var _this = this;

      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var _ref$hashbang = _ref.hashbang;
      var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;
      var _ref$abstract = _ref.abstract;
      var abstract = _ref$abstract === undefined ? false : _ref$abstract;
      var _ref$history = _ref.history;
      var history = _ref$history === undefined ? false : _ref$history;
      var _ref$saveScrollPosition = _ref.saveScrollPosition;
      var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;
      var _ref$transitionOnLoad = _ref.transitionOnLoad;
      var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;
      var _ref$suppressTransitionError = _ref.suppressTransitionError;
      var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;
      var _ref$root = _ref.root;
      var root = _ref$root === undefined ? null : _ref$root;
      var _ref$linkActiveClass = _ref.linkActiveClass;
      var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;
      babelHelpers.classCallCheck(this, Router);

      /* istanbul ignore if */
      if (!Router.installed) {
        throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');
      }

      // Vue instances
      this.app = null;
      this._children = [];

      // route recognizer
      this._recognizer = new RouteRecognizer();
      this._guardRecognizer = new RouteRecognizer();

      // state
      this._started = false;
      this._startCb = null;
      this._currentRoute = {};
      this._currentTransition = null;
      this._previousTransition = null;
      this._notFoundHandler = null;
      this._notFoundRedirect = null;
      this._beforeEachHooks = [];
      this._afterEachHooks = [];

      // trigger transition on initial render?
      this._rendered = false;
      this._transitionOnLoad = transitionOnLoad;

      // history mode
      this._root = root;
      this._abstract = abstract;
      this._hashbang = hashbang;

      // check if HTML5 history is available
      var hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;
      this._history = history && hasPushState;
      this._historyFallback = history && !hasPushState;

      // create history object
      var inBrowser = Vue.util.inBrowser;
      this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';

      var History = historyBackends[this.mode];
      this.history = new History({
        root: root,
        hashbang: this._hashbang,
        onChange: function onChange(path, state, anchor) {
          _this._match(path, state, anchor);
        }
      });

      // other options
      this._saveScrollPosition = saveScrollPosition;
      this._linkActiveClass = linkActiveClass;
      this._suppress = suppressTransitionError;
    }

    /**
     * Allow directly passing components to a route
     * definition.
     *
     * @param {String} path
     * @param {Object} handler
     */

    // API ===================================================

    /**
    * Register a map of top-level paths.
    *
    * @param {Object} map
    */

    Router.prototype.map = function map(_map) {
      for (var route in _map) {
        this.on(route, _map[route]);
      }
      return this;
    };

    /**
     * Register a single root-level path
     *
     * @param {String} rootPath
     * @param {Object} handler
     *                 - {String} component
     *                 - {Object} [subRoutes]
     *                 - {Boolean} [forceRefresh]
     *                 - {Function} [before]
     *                 - {Function} [after]
     */

    Router.prototype.on = function on(rootPath, handler) {
      if (rootPath === '*') {
        this._notFound(handler);
      } else {
        this._addRoute(rootPath, handler, []);
      }
      return this;
    };

    /**
     * Set redirects.
     *
     * @param {Object} map
     */

    Router.prototype.redirect = function redirect(map) {
      for (var path in map) {
        this._addRedirect(path, map[path]);
      }
      return this;
    };

    /**
     * Set aliases.
     *
     * @param {Object} map
     */

    Router.prototype.alias = function alias(map) {
      for (var path in map) {
        this._addAlias(path, map[path]);
      }
      return this;
    };

    /**
     * Set global before hook.
     *
     * @param {Function} fn
     */

    Router.prototype.beforeEach = function beforeEach(fn) {
      this._beforeEachHooks.push(fn);
      return this;
    };

    /**
     * Set global after hook.
     *
     * @param {Function} fn
     */

    Router.prototype.afterEach = function afterEach(fn) {
      this._afterEachHooks.push(fn);
      return this;
    };

    /**
     * Navigate to a given path.
     * The path can be an object describing a named path in
     * the format of { name: '...', params: {}, query: {}}
     * The path is assumed to be already decoded, and will
     * be resolved against root (if provided)
     *
     * @param {String|Object} path
     * @param {Boolean} [replace]
     */

    Router.prototype.go = function go(path) {
      var replace = false;
      var append = false;
      if (Vue.util.isObject(path)) {
        replace = path.replace;
        append = path.append;
      }
      path = this._stringifyPath(path);
      if (path) {
        this.history.go(path, replace, append);
      }
    };

    /**
     * Short hand for replacing current path
     *
     * @param {String} path
     */

    Router.prototype.replace = function replace(path) {
      if (typeof path === 'string') {
        path = { path: path };
      }
      path.replace = true;
      this.go(path);
    };

    /**
     * Start the router.
     *
     * @param {VueConstructor} App
     * @param {String|Element} container
     * @param {Function} [cb]
     */

    Router.prototype.start = function start(App, container, cb) {
      /* istanbul ignore if */
      if (this._started) {
        warn('already started.');
        return;
      }
      this._started = true;
      this._startCb = cb;
      if (!this.app) {
        /* istanbul ignore if */
        if (!App || !container) {
          throw new Error('Must start vue-router with a component and a ' + 'root container.');
        }
        /* istanbul ignore if */
        if (App instanceof Vue) {
          throw new Error('Must start vue-router with a component, not a ' + 'Vue instance.');
        }
        this._appContainer = container;
        var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);
        // give it a name for better debugging
        Ctor.options.name = Ctor.options.name || 'RouterApp';
      }

      // handle history fallback in browsers that do not
      // support HTML5 history API
      if (this._historyFallback) {
        var _location = window.location;
        var _history = new HTML5History({ root: this._root });
        var path = _history.root ? _location.pathname.replace(_history.rootRE, '') : _location.pathname;
        if (path && path !== '/') {
          _location.assign((_history.root || '') + '/' + this.history.formatPath(path) + _location.search);
          return;
        }
      }

      this.history.start();
    };

    /**
     * Stop listening to route changes.
     */

    Router.prototype.stop = function stop() {
      this.history.stop();
      this._started = false;
    };

    // Internal methods ======================================

    /**
    * Add a route containing a list of segments to the internal
    * route recognizer. Will be called recursively to add all
    * possible sub-routes.
    *
    * @param {String} path
    * @param {Object} handler
    * @param {Array} segments
    */

    Router.prototype._addRoute = function _addRoute(path, handler, segments) {
      guardComponent(path, handler);
      handler.path = path;
      handler.fullPath = (segments.reduce(function (path, segment) {
        return path + segment.path;
      }, '') + path).replace('//', '/');
      segments.push({
        path: path,
        handler: handler
      });
      this._recognizer.add(segments, {
        as: handler.name
      });
      // add sub routes
      if (handler.subRoutes) {
        for (var subPath in handler.subRoutes) {
          // recursively walk all sub routes
          this._addRoute(subPath, handler.subRoutes[subPath],
          // pass a copy in recursion to avoid mutating
          // across branches
          segments.slice());
        }
      }
    };

    /**
     * Set the notFound route handler.
     *
     * @param {Object} handler
     */

    Router.prototype._notFound = function _notFound(handler) {
      guardComponent('*', handler);
      this._notFoundHandler = [{ handler: handler }];
    };

    /**
     * Add a redirect record.
     *
     * @param {String} path
     * @param {String} redirectPath
     */

    Router.prototype._addRedirect = function _addRedirect(path, redirectPath) {
      if (path === '*') {
        this._notFoundRedirect = redirectPath;
      } else {
        this._addGuard(path, redirectPath, this.replace);
      }
    };

    /**
     * Add an alias record.
     *
     * @param {String} path
     * @param {String} aliasPath
     */

    Router.prototype._addAlias = function _addAlias(path, aliasPath) {
      this._addGuard(path, aliasPath, this._match);
    };

    /**
     * Add a path guard.
     *
     * @param {String} path
     * @param {String} mappedPath
     * @param {Function} handler
     */

    Router.prototype._addGuard = function _addGuard(path, mappedPath, _handler) {
      var _this2 = this;

      this._guardRecognizer.add([{
        path: path,
        handler: function handler(match, query) {
          var realPath = mapParams(mappedPath, match.params, query);
          _handler.call(_this2, realPath);
        }
      }]);
    };

    /**
     * Check if a path matches any redirect records.
     *
     * @param {String} path
     * @return {Boolean} - if true, will skip normal match.
     */

    Router.prototype._checkGuard = function _checkGuard(path) {
      var matched = this._guardRecognizer.recognize(path);
      if (matched) {
        matched[0].handler(matched[0], matched.queryParams);
        return true;
      } else if (this._notFoundRedirect) {
        matched = this._recognizer.recognize(path);
        if (!matched) {
          this.replace(this._notFoundRedirect);
          return true;
        }
      }
    };

    /**
     * Match a URL path and set the route context on vm,
     * triggering view updates.
     *
     * @param {String} path
     * @param {Object} [state]
     * @param {String} [anchor]
     */

    Router.prototype._match = function _match(path, state, anchor) {
      var _this3 = this;

      if (this._checkGuard(path)) {
        return;
      }

      var currentRoute = this._currentRoute;
      var currentTransition = this._currentTransition;

      if (currentTransition) {
        if (currentTransition.to.path === path) {
          // do nothing if we have an active transition going to the same path
          return;
        } else if (currentRoute.path === path) {
          // We are going to the same path, but we also have an ongoing but
          // not-yet-validated transition. Abort that transition and reset to
          // prev transition.
          currentTransition.aborted = true;
          this._currentTransition = this._prevTransition;
          return;
        } else {
          // going to a totally different path. abort ongoing transition.
          currentTransition.aborted = true;
        }
      }

      // construct new route and transition context
      var route = new Route(path, this);
      var transition = new RouteTransition(this, route, currentRoute);

      // current transition is updated right now.
      // however, current route will only be updated after the transition has
      // been validated.
      this._prevTransition = currentTransition;
      this._currentTransition = transition;

      if (!this.app) {
        (function () {
          // initial render
          var router = _this3;
          _this3.app = new _this3._appConstructor({
            el: _this3._appContainer,
            created: function created() {
              this.$router = router;
            },
            _meta: {
              $route: route
            }
          });
        })();
      }

      // check global before hook
      var beforeHooks = this._beforeEachHooks;
      var startTransition = function startTransition() {
        transition.start(function () {
          _this3._postTransition(route, state, anchor);
        });
      };

      if (beforeHooks.length) {
        transition.runQueue(beforeHooks, function (hook, _, next) {
          if (transition === _this3._currentTransition) {
            transition.callHook(hook, null, next, {
              expectBoolean: true
            });
          }
        }, startTransition);
      } else {
        startTransition();
      }

      if (!this._rendered && this._startCb) {
        this._startCb.call(null);
      }

      // HACK:
      // set rendered to true after the transition start, so
      // that components that are acitvated synchronously know
      // whether it is the initial render.
      this._rendered = true;
    };

    /**
     * Set current to the new transition.
     * This is called by the transition object when the
     * validation of a route has succeeded.
     *
     * @param {Transition} transition
     */

    Router.prototype._onTransitionValidated = function _onTransitionValidated(transition) {
      // set current route
      var route = this._currentRoute = transition.to;
      // update route context for all children
      if (this.app.$route !== route) {
        this.app.$route = route;
        this._children.forEach(function (child) {
          child.$route = route;
        });
      }
      // call global after hook
      if (this._afterEachHooks.length) {
        this._afterEachHooks.forEach(function (hook) {
          return hook.call(null, {
            to: transition.to,
            from: transition.from
          });
        });
      }
      this._currentTransition.done = true;
    };

    /**
     * Handle stuff after the transition.
     *
     * @param {Route} route
     * @param {Object} [state]
     * @param {String} [anchor]
     */

    Router.prototype._postTransition = function _postTransition(route, state, anchor) {
      // handle scroll positions
      // saved scroll positions take priority
      // then we check if the path has an anchor
      var pos = state && state.pos;
      if (pos && this._saveScrollPosition) {
        Vue.nextTick(function () {
          window.scrollTo(pos.x, pos.y);
        });
      } else if (anchor) {
        Vue.nextTick(function () {
          var el = document.getElementById(anchor.slice(1));
          if (el) {
            window.scrollTo(window.scrollX, el.offsetTop);
          }
        });
      }
    };

    /**
     * Normalize named route object / string paths into
     * a string.
     *
     * @param {Object|String|Number} path
     * @return {String}
     */

    Router.prototype._stringifyPath = function _stringifyPath(path) {
      var fullPath = '';
      if (path && typeof path === 'object') {
        if (path.name) {
          var extend = Vue.util.extend;
          var currentParams = this._currentTransition && this._currentTransition.to.params;
          var targetParams = path.params || {};
          var params = currentParams ? extend(extend({}, currentParams), targetParams) : targetParams;
          if (path.query) {
            params.queryParams = path.query;
          }
          fullPath = this._recognizer.generate(path.name, params);
        } else if (path.path) {
          fullPath = path.path;
          if (path.query) {
            var query = this._recognizer.generateQueryString(path.query);
            if (fullPath.indexOf('?') > -1) {
              fullPath += '&' + query.slice(1);
            } else {
              fullPath += query;
            }
          }
        }
      } else {
        fullPath = path ? path + '' : '';
      }
      return encodeURI(fullPath);
    };

    return Router;
  })();

  function guardComponent(path, handler) {
    var comp = handler.component;
    if (Vue.util.isPlainObject(comp)) {
      comp = handler.component = Vue.extend(comp);
    }
    /* istanbul ignore if */
    if (typeof comp !== 'function') {
      handler.component = null;
      warn('invalid component for route "' + path + '".');
    }
  }

  /* Installation */

  Router.installed = false;

  /**
   * Installation interface.
   * Install the necessary directives.
   */

  Router.install = function (externalVue) {
    /* istanbul ignore if */
    if (Router.installed) {
      warn('already installed.');
      return;
    }
    Vue = externalVue;
    applyOverride(Vue);
    View(Vue);
    Link(Vue);
    exports$1.Vue = Vue;
    Router.installed = true;
  };

  // auto install
  /* istanbul ignore if */
  if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(Router);
  }

  return Router;

}));
},{}],24:[function(require,module,exports){
;(function () {

  var vueTouch = {}
  var Hammer = typeof require === 'function'
    ? require('hammerjs')
    : window.Hammer
  var gestures = ['tap', 'pan', 'pinch', 'press', 'rotate', 'swipe']
  var customeEvents = {}

  vueTouch.install = function (Vue) {

    Vue.directive('touch', {

      isFn: true,
      acceptStatement: true,

      bind: function () {
        if (!this.el.hammer) {
          this.el.hammer = new Hammer.Manager(this.el)
        }
        var mc = this.mc = this.el.hammer
        // determine event type
        var event = this.arg
        var recognizerType, recognizer

        if (customeEvents[event]) { // custom event

          var custom = customeEvents[event]
          recognizerType = custom.type
          recognizer = new Hammer[capitalize(recognizerType)](custom)
          recognizer.recognizeWith(mc.recognizers)
          mc.add(recognizer)

        } else { // built-in event

          for (var i = 0; i < gestures.length; i++) {
            if (event.indexOf(gestures[i]) === 0) {
              recognizerType = gestures[i]
              break
            }
          }
          if (!recognizerType) {
            console.warn('Invalid v-touch event: ' + event)
            return
          }
          recognizer = mc.get(recognizerType)
          if (!recognizer) {
            // add recognizer
            recognizer = new Hammer[capitalize(recognizerType)]()
            // make sure multiple recognizers work together...
            recognizer.recognizeWith(mc.recognizers)
            mc.add(recognizer)
          }

        }
      },

      update: function (fn) {
        var mc = this.mc
        var vm = this.vm
        var event = this.arg
        // teardown old handler
        if (this.handler) {
          mc.off(event, this.handler)
        }
        // define new handler
        this.handler = function (e) {
          e.targetVM = vm
          fn.call(vm, e)
        }
        mc.on(event, this.handler)
      },

      unbind: function () {
        this.mc.off(this.arg, this.handler)
        if (!Object.keys(this.mc.handlers).length) {
          this.mc.destroy()
          this.el.hammer = null
        }
      }

    })
  }

  /**
   * Register a custom event.
   *
   * @param {String} event
   * @param {Object} options - a Hammer.js recognizer option object.
   *                           required fields:
   *                           - type: the base recognizer to use for this event
   */

  vueTouch.registerCustomEvent = function (event, options) {
    options.event = event
    customeEvents[event] = options
  }

  function capitalize (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  }

  if (typeof exports == "object") {
    module.exports = vueTouch
  } else if (typeof define == "function" && define.amd) {
    define([], function(){ return vueTouch })
  } else if (window.Vue) {
    window.VueTouch = vueTouch
    Vue.use(vueTouch)
  }

})()
},{"hammerjs":17}],25:[function(require,module,exports){
(function (process){
/*!
 * Vue.js v1.0.15
 * (c) 2016 Evan You
 * Released under the MIT License.
 */
'use strict';

function set(obj, key, val) {
  if (hasOwn(obj, key)) {
    obj[key] = val;
    return;
  }
  if (obj._isVue) {
    set(obj._data, key, val);
    return;
  }
  var ob = obj.__ob__;
  if (!ob) {
    obj[key] = val;
    return;
  }
  ob.convert(key, val);
  ob.dep.notify();
  if (ob.vms) {
    var i = ob.vms.length;
    while (i--) {
      var vm = ob.vms[i];
      vm._proxy(key);
      vm._digest();
    }
  }
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 *
 * @param {Object} obj
 * @param {String} key
 */

function del(obj, key) {
  if (!hasOwn(obj, key)) {
    return;
  }
  delete obj[key];
  var ob = obj.__ob__;
  if (!ob) {
    return;
  }
  ob.dep.notify();
  if (ob.vms) {
    var i = ob.vms.length;
    while (i--) {
      var vm = ob.vms[i];
      vm._unproxy(key);
      vm._digest();
    }
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Check whether the object has the property.
 *
 * @param {Object} obj
 * @param {String} key
 * @return {Boolean}
 */

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Check if an expression is a literal value.
 *
 * @param {String} exp
 * @return {Boolean}
 */

var literalValueRE = /^\s?(true|false|[\d\.]+|'[^']*'|"[^"]*")\s?$/;

function isLiteral(exp) {
  return literalValueRE.test(exp);
}

/**
 * Check if a string starts with $ or _
 *
 * @param {String} str
 * @return {Boolean}
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Guard text output, make sure undefined outputs
 * empty string
 *
 * @param {*} value
 * @return {String}
 */

function _toString(value) {
  return value == null ? '' : value.toString();
}

/**
 * Check and convert possible numeric strings to numbers
 * before setting back to data
 *
 * @param {*} value
 * @return {*|Number}
 */

function toNumber(value) {
  if (typeof value !== 'string') {
    return value;
  } else {
    var parsed = Number(value);
    return isNaN(parsed) ? value : parsed;
  }
}

/**
 * Convert string boolean literals into real booleans.
 *
 * @param {*} value
 * @return {*|Boolean}
 */

function toBoolean(value) {
  return value === 'true' ? true : value === 'false' ? false : value;
}

/**
 * Strip quotes from a string
 *
 * @param {String} str
 * @return {String | false}
 */

function stripQuotes(str) {
  var a = str.charCodeAt(0);
  var b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
}

/**
 * Camelize a hyphen-delmited string.
 *
 * @param {String} str
 * @return {String}
 */

var camelizeRE = /-(\w)/g;

function camelize(str) {
  return str.replace(camelizeRE, toUpper);
}

function toUpper(_, c) {
  return c ? c.toUpperCase() : '';
}

/**
 * Hyphenate a camelCase string.
 *
 * @param {String} str
 * @return {String}
 */

var hyphenateRE = /([a-z\d])([A-Z])/g;

function hyphenate(str) {
  return str.replace(hyphenateRE, '$1-$2').toLowerCase();
}

/**
 * Converts hyphen/underscore/slash delimitered names into
 * camelized classNames.
 *
 * e.g. my-component => MyComponent
 *      some_else    => SomeElse
 *      some/comp    => SomeComp
 *
 * @param {String} str
 * @return {String}
 */

var classifyRE = /(?:^|[-_\/])(\w)/g;

function classify(str) {
  return str.replace(classifyRE, toUpper);
}

/**
 * Simple bind, faster than native
 *
 * @param {Function} fn
 * @param {Object} ctx
 * @return {Function}
 */

function bind$1(fn, ctx) {
  return function (a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  };
}

/**
 * Convert an Array-like object to a real Array.
 *
 * @param {Array-like} list
 * @param {Number} [start] - start index
 * @return {Array}
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 *
 * @param {Object} to
 * @param {Object} from
 */

function extend(to, from) {
  var keys = Object.keys(from);
  var i = keys.length;
  while (i--) {
    to[keys[i]] = from[keys[i]];
  }
  return to;
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 *
 * @param {*} obj
 * @return {Boolean}
 */

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 *
 * @param {*} obj
 * @return {Boolean}
 */

var toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';

function isPlainObject(obj) {
  return toString.call(obj) === OBJECT_STRING;
}

/**
 * Array type check.
 *
 * @param {*} obj
 * @return {Boolean}
 */

var isArray = Array.isArray;

/**
 * Define a non-enumerable property
 *
 * @param {Object} obj
 * @param {String} key
 * @param {*} val
 * @param {Boolean} [enumerable]
 */

function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Debounce a function so it only gets called after the
 * input stops arriving after the given wait period.
 *
 * @param {Function} func
 * @param {Number} wait
 * @return {Function} - the debounced function
 */

function _debounce(func, wait) {
  var timeout, args, context, timestamp, result;
  var later = function later() {
    var last = Date.now() - timestamp;
    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    }
  };
  return function () {
    context = this;
    args = arguments;
    timestamp = Date.now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
    }
    return result;
  };
}

/**
 * Manual indexOf because it's slightly faster than
 * native.
 *
 * @param {Array} arr
 * @param {*} obj
 */

function indexOf(arr, obj) {
  var i = arr.length;
  while (i--) {
    if (arr[i] === obj) return i;
  }
  return -1;
}

/**
 * Make a cancellable version of an async callback.
 *
 * @param {Function} fn
 * @return {Function}
 */

function cancellable(fn) {
  var cb = function cb() {
    if (!cb.cancelled) {
      return fn.apply(this, arguments);
    }
  };
  cb.cancel = function () {
    cb.cancelled = true;
  };
  return cb;
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 *
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 */

function looseEqual(a, b) {
  /* eslint-disable eqeqeq */
  return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
  /* eslint-enable eqeqeq */
}

var hasProto = ('__proto__' in {});

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';

var isIE9 = inBrowser && navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0;

var isAndroid = inBrowser && navigator.userAgent.toLowerCase().indexOf('android') > 0;

var transitionProp = undefined;
var transitionEndEvent = undefined;
var animationProp = undefined;
var animationEndEvent = undefined;

// Transition property/event sniffing
if (inBrowser && !isIE9) {
  var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
  var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
  transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
  transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
  animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
  animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
}

/**
 * Defer a task to execute it asynchronously. Ideally this
 * should be executed as a microtask, so we leverage
 * MutationObserver if it's available, and fallback to
 * setTimeout(0).
 *
 * @param {Function} cb
 * @param {Object} ctx
 */

var nextTick = (function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;
  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks = [];
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }
  /* istanbul ignore if */
  if (typeof MutationObserver !== 'undefined') {
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(counter);
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = counter;
    };
  } else {
    timerFunc = setTimeout;
  }
  return function (cb, ctx) {
    var func = ctx ? function () {
      cb.call(ctx);
    } : cb;
    callbacks.push(func);
    if (pending) return;
    pending = true;
    timerFunc(nextTickHandler, 0);
  };
})();

function Cache(limit) {
  this.size = 0;
  this.limit = limit;
  this.head = this.tail = undefined;
  this._keymap = Object.create(null);
}

var p = Cache.prototype;

/**
 * Put <value> into the cache associated with <key>.
 * Returns the entry which was removed to make room for
 * the new entry. Otherwise undefined is returned.
 * (i.e. if there was enough room already).
 *
 * @param {String} key
 * @param {*} value
 * @return {Entry|undefined}
 */

p.put = function (key, value) {
  var removed;
  if (this.size === this.limit) {
    removed = this.shift();
  }

  var entry = this.get(key, true);
  if (!entry) {
    entry = {
      key: key
    };
    this._keymap[key] = entry;
    if (this.tail) {
      this.tail.newer = entry;
      entry.older = this.tail;
    } else {
      this.head = entry;
    }
    this.tail = entry;
    this.size++;
  }
  entry.value = value;

  return removed;
};

/**
 * Purge the least recently used (oldest) entry from the
 * cache. Returns the removed entry or undefined if the
 * cache was empty.
 */

p.shift = function () {
  var entry = this.head;
  if (entry) {
    this.head = this.head.newer;
    this.head.older = undefined;
    entry.newer = entry.older = undefined;
    this._keymap[entry.key] = undefined;
    this.size--;
  }
  return entry;
};

/**
 * Get and register recent use of <key>. Returns the value
 * associated with <key> or undefined if not in cache.
 *
 * @param {String} key
 * @param {Boolean} returnEntry
 * @return {Entry|*}
 */

p.get = function (key, returnEntry) {
  var entry = this._keymap[key];
  if (entry === undefined) return;
  if (entry === this.tail) {
    return returnEntry ? entry : entry.value;
  }
  // HEAD--------------TAIL
  //   <.older   .newer>
  //  <--- add direction --
  //   A  B  C  <D>  E
  if (entry.newer) {
    if (entry === this.head) {
      this.head = entry.newer;
    }
    entry.newer.older = entry.older; // C <-- E.
  }
  if (entry.older) {
    entry.older.newer = entry.newer; // C. --> E
  }
  entry.newer = undefined; // D --x
  entry.older = this.tail; // D. --> E
  if (this.tail) {
    this.tail.newer = entry; // E. <-- D
  }
  this.tail = entry;
  return returnEntry ? entry : entry.value;
};

var cache$1 = new Cache(1000);
var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
var reservedArgRE = /^in$|^-?\d+/;

/**
 * Parser state
 */

var str;
var dir;
var c;
var prev;
var i;
var l;
var lastFilterIndex;
var inSingle;
var inDouble;
var curly;
var square;
var paren;
/**
 * Push a filter to the current directive object
 */

function pushFilter() {
  var exp = str.slice(lastFilterIndex, i).trim();
  var filter;
  if (exp) {
    filter = {};
    var tokens = exp.match(filterTokenRE);
    filter.name = tokens[0];
    if (tokens.length > 1) {
      filter.args = tokens.slice(1).map(processFilterArg);
    }
  }
  if (filter) {
    (dir.filters = dir.filters || []).push(filter);
  }
  lastFilterIndex = i + 1;
}

/**
 * Check if an argument is dynamic and strip quotes.
 *
 * @param {String} arg
 * @return {Object}
 */

function processFilterArg(arg) {
  if (reservedArgRE.test(arg)) {
    return {
      value: toNumber(arg),
      dynamic: false
    };
  } else {
    var stripped = stripQuotes(arg);
    var dynamic = stripped === arg;
    return {
      value: dynamic ? arg : stripped,
      dynamic: dynamic
    };
  }
}

/**
 * Parse a directive value and extract the expression
 * and its filters into a descriptor.
 *
 * Example:
 *
 * "a + 1 | uppercase" will yield:
 * {
 *   expression: 'a + 1',
 *   filters: [
 *     { name: 'uppercase', args: null }
 *   ]
 * }
 *
 * @param {String} str
 * @return {Object}
 */

function parseDirective(s) {

  var hit = cache$1.get(s);
  if (hit) {
    return hit;
  }

  // reset parser state
  str = s;
  inSingle = inDouble = false;
  curly = square = paren = 0;
  lastFilterIndex = 0;
  dir = {};

  for (i = 0, l = str.length; i < l; i++) {
    prev = c;
    c = str.charCodeAt(i);
    if (inSingle) {
      // check single quote
      if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
    } else if (inDouble) {
      // check double quote
      if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
    } else if (c === 0x7C && // pipe
    str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
      if (dir.expression == null) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        dir.expression = str.slice(0, i).trim();
      } else {
        // already has filter
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
    }
  }

  if (dir.expression == null) {
    dir.expression = str.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  cache$1.put(s, dir);
  return dir;
}

var directive = Object.freeze({
  parseDirective: parseDirective
});

var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var cache = undefined;
var tagRE = undefined;
var htmlRE = undefined;
/**
 * Escape a string so it can be used in a RegExp
 * constructor.
 *
 * @param {String} str
 */

function escapeRegex(str) {
  return str.replace(regexEscapeRE, '\\$&');
}

function compileRegex() {
  var open = escapeRegex(config.delimiters[0]);
  var close = escapeRegex(config.delimiters[1]);
  var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
  var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
  tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');
  htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
  // reset cache
  cache = new Cache(1000);
}

/**
 * Parse a template text string into an array of tokens.
 *
 * @param {String} text
 * @return {Array<Object> | null}
 *               - {String} type
 *               - {String} value
 *               - {Boolean} [html]
 *               - {Boolean} [oneTime]
 */

function parseText(text) {
  if (!cache) {
    compileRegex();
  }
  var hit = cache.get(text);
  if (hit) {
    return hit;
  }
  text = text.replace(/\n/g, '');
  if (!tagRE.test(text)) {
    return null;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, html, value, first, oneTime;
  /* eslint-disable no-cond-assign */
  while (match = tagRE.exec(text)) {
    /* eslint-enable no-cond-assign */
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push({
        value: text.slice(lastIndex, index)
      });
    }
    // tag token
    html = htmlRE.test(match[0]);
    value = html ? match[1] : match[2];
    first = value.charCodeAt(0);
    oneTime = first === 42; // *
    value = oneTime ? value.slice(1) : value;
    tokens.push({
      tag: true,
      value: value.trim(),
      html: html,
      oneTime: oneTime
    });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push({
      value: text.slice(lastIndex)
    });
  }
  cache.put(text, tokens);
  return tokens;
}

/**
 * Format a list of tokens into an expression.
 * e.g. tokens parsed from 'a {{b}} c' can be serialized
 * into one single expression as '"a " + b + " c"'.
 *
 * @param {Array} tokens
 * @param {Vue} [vm]
 * @return {String}
 */

function tokensToExp(tokens, vm) {
  if (tokens.length > 1) {
    return tokens.map(function (token) {
      return formatToken(token, vm);
    }).join('+');
  } else {
    return formatToken(tokens[0], vm, true);
  }
}

/**
 * Format a single token.
 *
 * @param {Object} token
 * @param {Vue} [vm]
 * @param {Boolean} [single]
 * @return {String}
 */

function formatToken(token, vm, single) {
  return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
}

/**
 * For an attribute with multiple interpolation tags,
 * e.g. attr="some-{{thing | filter}}", in order to combine
 * the whole thing into a single watchable expression, we
 * have to inline those filters. This function does exactly
 * that. This is a bit hacky but it avoids heavy changes
 * to directive parser and watcher mechanism.
 *
 * @param {String} exp
 * @param {Boolean} single
 * @return {String}
 */

var filterRE$1 = /[^|]\|[^|]/;
function inlineFilters(exp, single) {
  if (!filterRE$1.test(exp)) {
    return single ? exp : '(' + exp + ')';
  } else {
    var dir = parseDirective(exp);
    if (!dir.filters) {
      return '(' + exp + ')';
    } else {
      return 'this._applyFilters(' + dir.expression + // value
      ',null,' + // oldValue (null for read)
      JSON.stringify(dir.filters) + // filter descriptors
      ',false)'; // write?
    }
  }
}

var text$1 = Object.freeze({
  compileRegex: compileRegex,
  parseText: parseText,
  tokensToExp: tokensToExp
});

var delimiters = ['{{', '}}'];
var unsafeDelimiters = ['{{{', '}}}'];

var config = Object.defineProperties({

  /**
   * Whether to print debug messages.
   * Also enables stack trace for warnings.
   *
   * @type {Boolean}
   */

  debug: false,

  /**
   * Whether to suppress warnings.
   *
   * @type {Boolean}
   */

  silent: false,

  /**
   * Whether to use async rendering.
   */

  async: true,

  /**
   * Whether to warn against errors caught when evaluating
   * expressions.
   */

  warnExpressionErrors: true,

  /**
   * Whether or not to handle fully object properties which
   * are already backed by getters and seters. Depending on
   * use case and environment, this might introduce non-neglible
   * performance penalties.
   */
  convertAllProperties: false,

  /**
   * Internal flag to indicate the delimiters have been
   * changed.
   *
   * @type {Boolean}
   */

  _delimitersChanged: true,

  /**
   * List of asset types that a component can own.
   *
   * @type {Array}
   */

  _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],

  /**
   * prop binding modes
   */

  _propBindingModes: {
    ONE_WAY: 0,
    TWO_WAY: 1,
    ONE_TIME: 2
  },

  /**
   * Max circular updates allowed in a batcher flush cycle.
   */

  _maxUpdateCount: 100

}, {
  delimiters: { /**
                 * Interpolation delimiters. Changing these would trigger
                 * the text parser to re-compile the regular expressions.
                 *
                 * @type {Array<String>}
                 */

    get: function get() {
      return delimiters;
    },
    set: function set(val) {
      delimiters = val;
      compileRegex();
    },
    configurable: true,
    enumerable: true
  },
  unsafeDelimiters: {
    get: function get() {
      return unsafeDelimiters;
    },
    set: function set(val) {
      unsafeDelimiters = val;
      compileRegex();
    },
    configurable: true,
    enumerable: true
  }
});

var warn = undefined;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var hasConsole = typeof console !== 'undefined';
    warn = function (msg, e) {
      if (hasConsole && (!config.silent || config.debug)) {
        console.warn('[Vue warn]: ' + msg);
        /* istanbul ignore if */
        if (config.debug) {
          if (e) {
            throw e;
          } else {
            console.warn(new Error('Warning Stack Trace').stack);
          }
        }
      }
    };
  })();
}

/**
 * Append with transition.
 *
 * @param {Element} el
 * @param {Element} target
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function appendWithTransition(el, target, vm, cb) {
  applyTransition(el, 1, function () {
    target.appendChild(el);
  }, vm, cb);
}

/**
 * InsertBefore with transition.
 *
 * @param {Element} el
 * @param {Element} target
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function beforeWithTransition(el, target, vm, cb) {
  applyTransition(el, 1, function () {
    before(el, target);
  }, vm, cb);
}

/**
 * Remove with transition.
 *
 * @param {Element} el
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function removeWithTransition(el, vm, cb) {
  applyTransition(el, -1, function () {
    remove(el);
  }, vm, cb);
}

/**
 * Apply transitions with an operation callback.
 *
 * @param {Element} el
 * @param {Number} direction
 *                  1: enter
 *                 -1: leave
 * @param {Function} op - the actual DOM operation
 * @param {Vue} vm
 * @param {Function} [cb]
 */

function applyTransition(el, direction, op, vm, cb) {
  var transition = el.__v_trans;
  if (!transition ||
  // skip if there are no js hooks and CSS transition is
  // not supported
  !transition.hooks && !transitionEndEvent ||
  // skip transitions for initial compile
  !vm._isCompiled ||
  // if the vm is being manipulated by a parent directive
  // during the parent's compilation phase, skip the
  // animation.
  vm.$parent && !vm.$parent._isCompiled) {
    op();
    if (cb) cb();
    return;
  }
  var action = direction > 0 ? 'enter' : 'leave';
  transition[action](op, cb);
}

/**
 * Query an element selector if it's not an element already.
 *
 * @param {String|Element} el
 * @return {Element}
 */

function query(el) {
  if (typeof el === 'string') {
    var selector = el;
    el = document.querySelector(el);
    if (!el) {
      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
    }
  }
  return el;
}

/**
 * Check if a node is in the document.
 * Note: document.documentElement.contains should work here
 * but always returns false for comment nodes in phantomjs,
 * making unit tests difficult. This is fixed by doing the
 * contains() check on the node's parentNode instead of
 * the node itself.
 *
 * @param {Node} node
 * @return {Boolean}
 */

function inDoc(node) {
  var doc = document.documentElement;
  var parent = node && node.parentNode;
  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
}

/**
 * Get and remove an attribute from a node.
 *
 * @param {Node} node
 * @param {String} _attr
 */

function getAttr(node, _attr) {
  var val = node.getAttribute(_attr);
  if (val !== null) {
    node.removeAttribute(_attr);
  }
  return val;
}

/**
 * Get an attribute with colon or v-bind: prefix.
 *
 * @param {Node} node
 * @param {String} name
 * @return {String|null}
 */

function getBindAttr(node, name) {
  var val = getAttr(node, ':' + name);
  if (val === null) {
    val = getAttr(node, 'v-bind:' + name);
  }
  return val;
}

/**
 * Check the presence of a bind attribute.
 *
 * @param {Node} node
 * @param {String} name
 * @return {Boolean}
 */

function hasBindAttr(node, name) {
  return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
}

/**
 * Insert el before target
 *
 * @param {Element} el
 * @param {Element} target
 */

function before(el, target) {
  target.parentNode.insertBefore(el, target);
}

/**
 * Insert el after target
 *
 * @param {Element} el
 * @param {Element} target
 */

function after(el, target) {
  if (target.nextSibling) {
    before(el, target.nextSibling);
  } else {
    target.parentNode.appendChild(el);
  }
}

/**
 * Remove el from DOM
 *
 * @param {Element} el
 */

function remove(el) {
  el.parentNode.removeChild(el);
}

/**
 * Prepend el to target
 *
 * @param {Element} el
 * @param {Element} target
 */

function prepend(el, target) {
  if (target.firstChild) {
    before(el, target.firstChild);
  } else {
    target.appendChild(el);
  }
}

/**
 * Replace target with el
 *
 * @param {Element} target
 * @param {Element} el
 */

function replace(target, el) {
  var parent = target.parentNode;
  if (parent) {
    parent.replaceChild(el, target);
  }
}

/**
 * Add event listener shorthand.
 *
 * @param {Element} el
 * @param {String} event
 * @param {Function} cb
 */

function on$1(el, event, cb) {
  el.addEventListener(event, cb);
}

/**
 * Remove event listener shorthand.
 *
 * @param {Element} el
 * @param {String} event
 * @param {Function} cb
 */

function off(el, event, cb) {
  el.removeEventListener(event, cb);
}

/**
 * In IE9, setAttribute('class') will result in empty class
 * if the element also has the :class attribute; However in
 * PhantomJS, setting `className` does not work on SVG elements...
 * So we have to do a conditional check here.
 *
 * @param {Element} el
 * @param {String} cls
 */

function setClass(el, cls) {
  /* istanbul ignore if */
  if (isIE9 && !(el instanceof SVGElement)) {
    el.className = cls;
  } else {
    el.setAttribute('class', cls);
  }
}

/**
 * Add class with compatibility for IE & SVG
 *
 * @param {Element} el
 * @param {String} cls
 */

function addClass(el, cls) {
  if (el.classList) {
    el.classList.add(cls);
  } else {
    var cur = ' ' + (el.getAttribute('class') || '') + ' ';
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      setClass(el, (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for IE & SVG
 *
 * @param {Element} el
 * @param {String} cls
 */

function removeClass(el, cls) {
  if (el.classList) {
    el.classList.remove(cls);
  } else {
    var cur = ' ' + (el.getAttribute('class') || '') + ' ';
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    setClass(el, cur.trim());
  }
  if (!el.className) {
    el.removeAttribute('class');
  }
}

/**
 * Extract raw content inside an element into a temporary
 * container div
 *
 * @param {Element} el
 * @param {Boolean} asFragment
 * @return {Element}
 */

function extractContent(el, asFragment) {
  var child;
  var rawContent;
  /* istanbul ignore if */
  if (isTemplate(el) && el.content instanceof DocumentFragment) {
    el = el.content;
  }
  if (el.hasChildNodes()) {
    trimNode(el);
    rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
    /* eslint-disable no-cond-assign */
    while (child = el.firstChild) {
      /* eslint-enable no-cond-assign */
      rawContent.appendChild(child);
    }
  }
  return rawContent;
}

/**
 * Trim possible empty head/tail textNodes inside a parent.
 *
 * @param {Node} node
 */

function trimNode(node) {
  trim(node, node.firstChild);
  trim(node, node.lastChild);
}

function trim(parent, node) {
  if (node && node.nodeType === 3 && !node.data.trim()) {
    parent.removeChild(node);
  }
}

/**
 * Check if an element is a template tag.
 * Note if the template appears inside an SVG its tagName
 * will be in lowercase.
 *
 * @param {Element} el
 */

function isTemplate(el) {
  return el.tagName && el.tagName.toLowerCase() === 'template';
}

/**
 * Create an "anchor" for performing dom insertion/removals.
 * This is used in a number of scenarios:
 * - fragment instance
 * - v-html
 * - v-if
 * - v-for
 * - component
 *
 * @param {String} content
 * @param {Boolean} persist - IE trashes empty textNodes on
 *                            cloneNode(true), so in certain
 *                            cases the anchor needs to be
 *                            non-empty to be persisted in
 *                            templates.
 * @return {Comment|Text}
 */

function createAnchor(content, persist) {
  var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
  anchor.__vue_anchor = true;
  return anchor;
}

/**
 * Find a component ref attribute that starts with $.
 *
 * @param {Element} node
 * @return {String|undefined}
 */

var refRE = /^v-ref:/;

function findRef(node) {
  if (node.hasAttributes()) {
    var attrs = node.attributes;
    for (var i = 0, l = attrs.length; i < l; i++) {
      var name = attrs[i].name;
      if (refRE.test(name)) {
        return camelize(name.replace(refRE, ''));
      }
    }
  }
}

/**
 * Map a function to a range of nodes .
 *
 * @param {Node} node
 * @param {Node} end
 * @param {Function} op
 */

function mapNodeRange(node, end, op) {
  var next;
  while (node !== end) {
    next = node.nextSibling;
    op(node);
    node = next;
  }
  op(end);
}

/**
 * Remove a range of nodes with transition, store
 * the nodes in a fragment with correct ordering,
 * and call callback when done.
 *
 * @param {Node} start
 * @param {Node} end
 * @param {Vue} vm
 * @param {DocumentFragment} frag
 * @param {Function} cb
 */

function removeNodeRange(start, end, vm, frag, cb) {
  var done = false;
  var removed = 0;
  var nodes = [];
  mapNodeRange(start, end, function (node) {
    if (node === end) done = true;
    nodes.push(node);
    removeWithTransition(node, vm, onRemoved);
  });
  function onRemoved() {
    removed++;
    if (done && removed >= nodes.length) {
      for (var i = 0; i < nodes.length; i++) {
        frag.appendChild(nodes[i]);
      }
      cb && cb();
    }
  }
}

var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/;
var reservedTagRE = /^(slot|partial|component)$/;

/**
 * Check if an element is a component, if yes return its
 * component id.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Object|undefined}
 */

function checkComponentAttr(el, options) {
  var tag = el.tagName.toLowerCase();
  var hasAttrs = el.hasAttributes();
  if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
    if (resolveAsset(options, 'components', tag)) {
      return { id: tag };
    } else {
      var is = hasAttrs && getIsBinding(el);
      if (is) {
        return is;
      } else if (process.env.NODE_ENV !== 'production') {
        if (tag.indexOf('-') > -1 || /HTMLUnknownElement/.test(el.toString()) &&
        // Chrome returns unknown for several HTML5 elements.
        // https://code.google.com/p/chromium/issues/detail?id=540526
        !/^(data|time|rtc|rb)$/.test(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly?');
        }
      }
    }
  } else if (hasAttrs) {
    return getIsBinding(el);
  }
}

/**
 * Get "is" binding from an element.
 *
 * @param {Element} el
 * @return {Object|undefined}
 */

function getIsBinding(el) {
  // dynamic syntax
  var exp = getAttr(el, 'is');
  if (exp != null) {
    return { id: exp };
  } else {
    exp = getBindAttr(el, 'is');
    if (exp != null) {
      return { id: exp, dynamic: true };
    }
  }
}

/**
 * Set a prop's initial value on a vm and its data object.
 *
 * @param {Vue} vm
 * @param {Object} prop
 * @param {*} value
 */

function initProp(vm, prop, value) {
  var key = prop.path;
  value = coerceProp(prop, value);
  vm[key] = vm._data[key] = assertProp(prop, value) ? value : undefined;
}

/**
 * Assert whether a prop is valid.
 *
 * @param {Object} prop
 * @param {*} value
 */

function assertProp(prop, value) {
  // if a prop is not provided and is not required,
  // skip the check.
  if (prop.raw === null && !prop.required) {
    return true;
  }
  var options = prop.options;
  var type = options.type;
  var valid = true;
  var expectedType;
  if (type) {
    if (type === String) {
      expectedType = 'string';
      valid = typeof value === expectedType;
    } else if (type === Number) {
      expectedType = 'number';
      valid = typeof value === 'number';
    } else if (type === Boolean) {
      expectedType = 'boolean';
      valid = typeof value === 'boolean';
    } else if (type === Function) {
      expectedType = 'function';
      valid = typeof value === 'function';
    } else if (type === Object) {
      expectedType = 'object';
      valid = isPlainObject(value);
    } else if (type === Array) {
      expectedType = 'array';
      valid = isArray(value);
    } else {
      valid = value instanceof type;
    }
  }
  if (!valid) {
    process.env.NODE_ENV !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '="' + prop.raw + '".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');
    return false;
  }
  var validator = options.validator;
  if (validator) {
    if (!validator.call(null, value)) {
      process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '="' + prop.raw + '"');
      return false;
    }
  }
  return true;
}

/**
 * Force parsing value with coerce option.
 *
 * @param {*} value
 * @param {Object} options
 * @return {*}
 */

function coerceProp(prop, value) {
  var coerce = prop.options.coerce;
  if (!coerce) {
    return value;
  }
  // coerce is a function
  return coerce(value);
}

function formatType(val) {
  return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';
}

function formatValue(val) {
  return Object.prototype.toString.call(val).slice(8, -1);
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 *
 * All strategy functions follow the same signature:
 *
 * @param {*} parentVal
 * @param {*} childVal
 * @param {Vue} [vm]
 */

var strats = config.optionMergeStrategies = Object.create(null);

/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  var key, toVal, fromVal;
  for (key in from) {
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isObject(toVal) && isObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * El
 */

strats.el = function (parentVal, childVal, vm) {
  if (!vm && childVal && typeof childVal !== 'function') {
    process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
    return;
  }
  var ret = childVal || parentVal;
  // invoke the element factory if this is instance merge
  return vm && typeof ret === 'function' ? ret.call(vm) : ret;
};

/**
 * Hooks and param attributes are merged as arrays.
 */

strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = function (parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
};

/**
 * 0.11 deprecation warning
 */

strats.paramAttributes = function () {
  /* istanbul ignore next */
  process.env.NODE_ENV !== 'production' && warn('"paramAttributes" option has been deprecated in 0.12. ' + 'Use "props" instead.');
};

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal);
  return childVal ? extend(res, guardArrayAssets(childVal)) : res;
}

config._assetTypes.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Events & Watchers.
 *
 * Events & watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = strats.events = function (parentVal, childVal) {
  if (!childVal) return parentVal;
  if (!parentVal) return childVal;
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */

strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) return parentVal;
  if (!parentVal) return childVal;
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */

var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Make sure component options get converted to actual
 * constructors.
 *
 * @param {Object} options
 */

function guardComponents(options) {
  if (options.components) {
    var components = options.components = guardArrayAssets(options.components);
    var def;
    var ids = Object.keys(components);
    for (var i = 0, l = ids.length; i < l; i++) {
      var key = ids[i];
      if (commonTagRE.test(key) || reservedTagRE.test(key)) {
        process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
        continue;
      }
      def = components[key];
      if (isPlainObject(def)) {
        components[key] = Vue.extend(def);
      }
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 *
 * @param {Object} options
 */

function guardProps(options) {
  var props = options.props;
  var i, val;
  if (isArray(props)) {
    options.props = {};
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        options.props[val] = null;
      } else if (val.name) {
        options.props[val.name] = val;
      }
    }
  } else if (isPlainObject(props)) {
    var keys = Object.keys(props);
    i = keys.length;
    while (i--) {
      val = props[keys[i]];
      if (typeof val === 'function') {
        props[keys[i]] = { type: val };
      }
    }
  }
}

/**
 * Guard an Array-format assets option and converted it
 * into the key-value Object format.
 *
 * @param {Object|Array} assets
 * @return {Object}
 */

function guardArrayAssets(assets) {
  if (isArray(assets)) {
    var res = {};
    var i = assets.length;
    var asset;
    while (i--) {
      asset = assets[i];
      var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
      if (!id) {
        process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
      } else {
        res[id] = asset;
      }
    }
    return res;
  }
  return assets;
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 *
 * @param {Object} parent
 * @param {Object} child
 * @param {Vue} [vm] - if vm is present, indicates this is
 *                     an instantiation merge.
 */

function mergeOptions(parent, child, vm) {
  guardComponents(child);
  guardProps(child);
  var options = {};
  var key;
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 *
 * @param {Object} options
 * @param {String} type
 * @param {String} id
 * @return {Object|Function}
 */

function resolveAsset(options, type, id) {
  var assets = options[type];
  var camelizedId;
  return assets[id] ||
  // camelCase ID
  assets[camelizedId = camelize(id)] ||
  // Pascal Case ID
  assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
}

/**
 * Assert asset exists
 */

function assertAsset(val, type, id) {
  if (!val) {
    process.env.NODE_ENV !== 'production' && warn('Failed to resolve ' + type + ': ' + id);
  }
}

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto)

/**
 * Intercept mutating methods and emit events
 */

;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // notify change
    ob.dep.notify();
    return result;
  });
});

/**
 * Swap the element at the given index with a new value
 * and emits corresponding event.
 *
 * @param {Number} index
 * @param {*} val
 * @return {*} - replaced element
 */

def(arrayProto, '$set', function $set(index, val) {
  if (index >= this.length) {
    this.length = Number(index) + 1;
  }
  return this.splice(index, 1, val)[0];
});

/**
 * Convenience method to remove the element at given index.
 *
 * @param {Number} index
 * @param {*} val
 */

def(arrayProto, '$remove', function $remove(item) {
  /* istanbul ignore if */
  if (!this.length) return;
  var index = indexOf(this, item);
  if (index > -1) {
    return this.splice(index, 1);
  }
});

var uid$3 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 *
 * @constructor
 */
function Dep() {
  this.id = uid$3++;
  this.subs = [];
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;

/**
 * Add a directive subscriber.
 *
 * @param {Directive} sub
 */

Dep.prototype.addSub = function (sub) {
  this.subs.push(sub);
};

/**
 * Remove a directive subscriber.
 *
 * @param {Directive} sub
 */

Dep.prototype.removeSub = function (sub) {
  this.subs.$remove(sub);
};

/**
 * Add self as a dependency to the target watcher.
 */

Dep.prototype.depend = function () {
  Dep.target.addDep(this);
};

/**
 * Notify all subscribers of a new value.
 */

Dep.prototype.notify = function () {
  // stablize the subscriber list first
  var subs = toArray(this.subs);
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 *
 * @param {Array|Object} value
 * @constructor
 */

function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  def(value, '__ob__', this);
  if (isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
}

// Instance methods

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 *
 * @param {Object} obj
 */

Observer.prototype.walk = function (obj) {
  var keys = Object.keys(obj);
  for (var i = 0, l = keys.length; i < l; i++) {
    this.convert(keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 *
 * @param {Array} items
 */

Observer.prototype.observeArray = function (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

/**
 * Convert a property into getter/setter so we can emit
 * the events when the property is accessed/changed.
 *
 * @param {String} key
 * @param {*} val
 */

Observer.prototype.convert = function (key, val) {
  defineReactive(this.value, key, val);
};

/**
 * Add an owner vm, so that when $set/$delete mutations
 * happen we can notify owner vms to proxy the keys and
 * digest the watchers. This is only called when the object
 * is observed as an instance's root $data.
 *
 * @param {Vue} vm
 */

Observer.prototype.addVm = function (vm) {
  (this.vms || (this.vms = [])).push(vm);
};

/**
 * Remove an owner vm. This is called when the object is
 * swapped out as an instance's $data object.
 *
 * @param {Vue} vm
 */

Observer.prototype.removeVm = function (vm) {
  this.vms.$remove(vm);
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 *
 * @param {Object|Array} target
 * @param {Object} proto
 */

function protoAugment(target, src) {
  target.__proto__ = src;
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 *
 * @param {Object|Array} target
 * @param {Object} proto
 */

function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 *
 * @param {*} value
 * @param {Vue} [vm]
 * @return {Observer|undefined}
 * @static
 */

function observe(value, vm) {
  if (!value || typeof value !== 'object') {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if ((isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (ob && vm) {
    ob.addVm(vm);
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {*} val
 */

function defineReactive(obj, key, val) {
  var dep = new Dep();

  // cater for pre-defined getter/setters
  var getter, setter;
  if (config.convertAllProperties) {
    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }
    getter = property && property.get;
    setter = property && property.set;
  }

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (isArray(value)) {
          for (var e, i = 0, l = value.length; i < l; i++) {
            e = value[i];
            e && e.__ob__ && e.__ob__.dep.depend();
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      if (newVal === value) {
        return;
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

var util = Object.freeze({
	defineReactive: defineReactive,
	set: set,
	del: del,
	hasOwn: hasOwn,
	isLiteral: isLiteral,
	isReserved: isReserved,
	_toString: _toString,
	toNumber: toNumber,
	toBoolean: toBoolean,
	stripQuotes: stripQuotes,
	camelize: camelize,
	hyphenate: hyphenate,
	classify: classify,
	bind: bind$1,
	toArray: toArray,
	extend: extend,
	isObject: isObject,
	isPlainObject: isPlainObject,
	def: def,
	debounce: _debounce,
	indexOf: indexOf,
	cancellable: cancellable,
	looseEqual: looseEqual,
	isArray: isArray,
	hasProto: hasProto,
	inBrowser: inBrowser,
	isIE9: isIE9,
	isAndroid: isAndroid,
	get transitionProp () { return transitionProp; },
	get transitionEndEvent () { return transitionEndEvent; },
	get animationProp () { return animationProp; },
	get animationEndEvent () { return animationEndEvent; },
	nextTick: nextTick,
	query: query,
	inDoc: inDoc,
	getAttr: getAttr,
	getBindAttr: getBindAttr,
	hasBindAttr: hasBindAttr,
	before: before,
	after: after,
	remove: remove,
	prepend: prepend,
	replace: replace,
	on: on$1,
	off: off,
	setClass: setClass,
	addClass: addClass,
	removeClass: removeClass,
	extractContent: extractContent,
	trimNode: trimNode,
	isTemplate: isTemplate,
	createAnchor: createAnchor,
	findRef: findRef,
	mapNodeRange: mapNodeRange,
	removeNodeRange: removeNodeRange,
	mergeOptions: mergeOptions,
	resolveAsset: resolveAsset,
	assertAsset: assertAsset,
	checkComponentAttr: checkComponentAttr,
	initProp: initProp,
	assertProp: assertProp,
	coerceProp: coerceProp,
	commonTagRE: commonTagRE,
	reservedTagRE: reservedTagRE,
	get warn () { return warn; }
});

var uid = 0;

function initMixin (Vue) {

  /**
   * The main init sequence. This is called for every
   * instance, including ones that are created from extended
   * constructors.
   *
   * @param {Object} options - this options object should be
   *                           the result of merging class
   *                           options and the options passed
   *                           in to the constructor.
   */

  Vue.prototype._init = function (options) {

    options = options || {};

    this.$el = null;
    this.$parent = options.parent;
    this.$root = this.$parent ? this.$parent.$root : this;
    this.$children = [];
    this.$refs = {}; // child vm references
    this.$els = {}; // element references
    this._watchers = []; // all watchers as an array
    this._directives = []; // all directives

    // a uid
    this._uid = uid++;

    // a flag to avoid this being observed
    this._isVue = true;

    // events bookkeeping
    this._events = {}; // registered callbacks
    this._eventsCount = {}; // for $broadcast optimization

    // fragment instance properties
    this._isFragment = false;
    this._fragment = // @type {DocumentFragment}
    this._fragmentStart = // @type {Text|Comment}
    this._fragmentEnd = null; // @type {Text|Comment}

    // lifecycle state
    this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = false;
    this._unlinkFn = null;

    // context:
    // if this is a transcluded component, context
    // will be the common parent vm of this instance
    // and its host.
    this._context = options._context || this.$parent;

    // scope:
    // if this is inside an inline v-for, the scope
    // will be the intermediate scope created for this
    // repeat fragment. this is used for linking props
    // and container directives.
    this._scope = options._scope;

    // fragment:
    // if this instance is compiled inside a Fragment, it
    // needs to reigster itself as a child of that fragment
    // for attach/detach to work properly.
    this._frag = options._frag;
    if (this._frag) {
      this._frag.children.push(this);
    }

    // push self into parent / transclusion host
    if (this.$parent) {
      this.$parent.$children.push(this);
    }

    // merge options.
    options = this.$options = mergeOptions(this.constructor.options, options, this);

    // set ref
    this._updateRef();

    // initialize data as empty object.
    // it will be filled up in _initScope().
    this._data = {};

    // call init hook
    this._callHook('init');

    // initialize data observation and scope inheritance.
    this._initState();

    // setup event system and option events.
    this._initEvents();

    // call created hook
    this._callHook('created');

    // if `el` option is passed, start compilation.
    if (options.el) {
      this.$mount(options.el);
    }
  };
}

var pathCache = new Cache(1000);

// actions
var APPEND = 0;
var PUSH = 1;
var INC_SUB_PATH_DEPTH = 2;
var PUSH_SUB_PATH = 3;

// states
var BEFORE_PATH = 0;
var IN_PATH = 1;
var BEFORE_IDENT = 2;
var IN_IDENT = 3;
var IN_SUB_PATH = 4;
var IN_SINGLE_QUOTE = 5;
var IN_DOUBLE_QUOTE = 6;
var AFTER_PATH = 7;
var ERROR = 8;

var pathStateMachine = [];

pathStateMachine[BEFORE_PATH] = {
  'ws': [BEFORE_PATH],
  'ident': [IN_IDENT, APPEND],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[IN_PATH] = {
  'ws': [IN_PATH],
  '.': [BEFORE_IDENT],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[BEFORE_IDENT] = {
  'ws': [BEFORE_IDENT],
  'ident': [IN_IDENT, APPEND]
};

pathStateMachine[IN_IDENT] = {
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND],
  'ws': [IN_PATH, PUSH],
  '.': [BEFORE_IDENT, PUSH],
  '[': [IN_SUB_PATH, PUSH],
  'eof': [AFTER_PATH, PUSH]
};

pathStateMachine[IN_SUB_PATH] = {
  "'": [IN_SINGLE_QUOTE, APPEND],
  '"': [IN_DOUBLE_QUOTE, APPEND],
  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  ']': [IN_PATH, PUSH_SUB_PATH],
  'eof': ERROR,
  'else': [IN_SUB_PATH, APPEND]
};

pathStateMachine[IN_SINGLE_QUOTE] = {
  "'": [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_SINGLE_QUOTE, APPEND]
};

pathStateMachine[IN_DOUBLE_QUOTE] = {
  '"': [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_DOUBLE_QUOTE, APPEND]
};

/**
 * Determine the type of a character in a keypath.
 *
 * @param {Char} ch
 * @return {String} type
 */

function getPathCharType(ch) {
  if (ch === undefined) {
    return 'eof';
  }

  var code = ch.charCodeAt(0);

  switch (code) {
    case 0x5B: // [
    case 0x5D: // ]
    case 0x2E: // .
    case 0x22: // "
    case 0x27: // '
    case 0x30:
      // 0
      return ch;

    case 0x5F: // _
    case 0x24:
      // $
      return 'ident';

    case 0x20: // Space
    case 0x09: // Tab
    case 0x0A: // Newline
    case 0x0D: // Return
    case 0xA0: // No-break space
    case 0xFEFF: // Byte Order Mark
    case 0x2028: // Line Separator
    case 0x2029:
      // Paragraph Separator
      return 'ws';
  }

  // a-z, A-Z
  if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
    return 'ident';
  }

  // 1-9
  if (code >= 0x31 && code <= 0x39) {
    return 'number';
  }

  return 'else';
}

/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 *
 * @param {String} path
 * @return {String}
 */

function formatSubPath(path) {
  var trimmed = path.trim();
  // invalid leading 0
  if (path.charAt(0) === '0' && isNaN(path)) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
}

/**
 * Parse a string path into an array of segments
 *
 * @param {String} path
 * @return {Array|undefined}
 */

function parse(path) {
  var keys = [];
  var index = -1;
  var mode = BEFORE_PATH;
  var subPathDepth = 0;
  var c, newChar, key, type, transition, action, typeMap;

  var actions = [];

  actions[PUSH] = function () {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[APPEND] = function () {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[INC_SUB_PATH_DEPTH] = function () {
    actions[APPEND]();
    subPathDepth++;
  };

  actions[PUSH_SUB_PATH] = function () {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = IN_SUB_PATH;
      actions[APPEND]();
    } else {
      subPathDepth = 0;
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[PUSH]();
      }
    }
  };

  function maybeUnescapeQuote() {
    var nextChar = path[index + 1];
    if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
      index++;
      newChar = '\\' + nextChar;
      actions[APPEND]();
      return true;
    }
  }

  while (mode != null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue;
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap['else'] || ERROR;

    if (transition === ERROR) {
      return; // parse error
    }

    mode = transition[0];
    action = actions[transition[1]];
    if (action) {
      newChar = transition[2];
      newChar = newChar === undefined ? c : newChar;
      if (action() === false) {
        return;
      }
    }

    if (mode === AFTER_PATH) {
      keys.raw = path;
      return keys;
    }
  }
}

/**
 * External parse that check for a cache hit first
 *
 * @param {String} path
 * @return {Array|undefined}
 */

function parsePath(path) {
  var hit = pathCache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      pathCache.put(path, hit);
    }
  }
  return hit;
}

/**
 * Get from an object from a path string
 *
 * @param {Object} obj
 * @param {String} path
 */

function getPath(obj, path) {
  return parseExpression(path).get(obj);
}

/**
 * Warn against setting non-existent root path on a vm.
 */

var warnNonExistent;
if (process.env.NODE_ENV !== 'production') {
  warnNonExistent = function (path) {
    warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.');
  };
}

/**
 * Set on an object from a path
 *
 * @param {Object} obj
 * @param {String | Array} path
 * @param {*} val
 */

function setPath(obj, path, val) {
  var original = obj;
  if (typeof path === 'string') {
    path = parse(path);
  }
  if (!path || !isObject(obj)) {
    return false;
  }
  var last, key;
  for (var i = 0, l = path.length; i < l; i++) {
    last = obj;
    key = path[i];
    if (key.charAt(0) === '*') {
      key = parseExpression(key.slice(1)).get.call(original, original);
    }
    if (i < l - 1) {
      obj = obj[key];
      if (!isObject(obj)) {
        obj = {};
        if (process.env.NODE_ENV !== 'production' && last._isVue) {
          warnNonExistent(path);
        }
        set(last, key, obj);
      }
    } else {
      if (isArray(obj)) {
        obj.$set(key, val);
      } else if (key in obj) {
        obj[key] = val;
      } else {
        if (process.env.NODE_ENV !== 'production' && obj._isVue) {
          warnNonExistent(path);
        }
        set(obj, key, val);
      }
    }
  }
  return true;
}

var path = Object.freeze({
  parsePath: parsePath,
  getPath: getPath,
  setPath: setPath
});

var expressionCache = new Cache(1000);

var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');

// keywords that don't make sense inside expressions
var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'proctected,static,interface,private,public';
var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');

var wsRE = /\s/g;
var newlineRE = /\n/g;
var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")|new |typeof |void /g;
var restoreRE = /"(\d+)"/g;
var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
var booleanLiteralRE = /^(?:true|false)$/;

/**
 * Save / Rewrite / Restore
 *
 * When rewriting paths found in an expression, it is
 * possible for the same letter sequences to be found in
 * strings and Object literal property keys. Therefore we
 * remove and store these parts in a temporary array, and
 * restore them after the path rewrite.
 */

var saved = [];

/**
 * Save replacer
 *
 * The save regex can match two possible cases:
 * 1. An opening object literal
 * 2. A string
 * If matched as a plain string, we need to escape its
 * newlines, since the string needs to be preserved when
 * generating the function body.
 *
 * @param {String} str
 * @param {String} isString - str if matched as a string
 * @return {String} - placeholder with index
 */

function save(str, isString) {
  var i = saved.length;
  saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
  return '"' + i + '"';
}

/**
 * Path rewrite replacer
 *
 * @param {String} raw
 * @return {String}
 */

function rewrite(raw) {
  var c = raw.charAt(0);
  var path = raw.slice(1);
  if (allowedKeywordsRE.test(path)) {
    return raw;
  } else {
    path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
    return c + 'scope.' + path;
  }
}

/**
 * Restore replacer
 *
 * @param {String} str
 * @param {String} i - matched save index
 * @return {String}
 */

function restore(str, i) {
  return saved[i];
}

/**
 * Rewrite an expression, prefixing all path accessors with
 * `scope.` and generate getter/setter functions.
 *
 * @param {String} exp
 * @return {Function}
 */

function compileGetter(exp) {
  if (improperKeywordsRE.test(exp)) {
    process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
  }
  // reset state
  saved.length = 0;
  // save strings and object literal keys
  var body = exp.replace(saveRE, save).replace(wsRE, '');
  // rewrite all paths
  // pad 1 space here becaue the regex matches 1 extra char
  body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
  return makeGetterFn(body);
}

/**
 * Build a getter function. Requires eval.
 *
 * We isolate the try/catch so it doesn't affect the
 * optimization of the parse function when it is not called.
 *
 * @param {String} body
 * @return {Function|undefined}
 */

function makeGetterFn(body) {
  try {
    return new Function('scope', 'return ' + body + ';');
  } catch (e) {
    process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
  }
}

/**
 * Compile a setter function for the expression.
 *
 * @param {String} exp
 * @return {Function|undefined}
 */

function compileSetter(exp) {
  var path = parsePath(exp);
  if (path) {
    return function (scope, val) {
      setPath(scope, path, val);
    };
  } else {
    process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
  }
}

/**
 * Parse an expression into re-written getter/setters.
 *
 * @param {String} exp
 * @param {Boolean} needSet
 * @return {Function}
 */

function parseExpression(exp, needSet) {
  exp = exp.trim();
  // try cache
  var hit = expressionCache.get(exp);
  if (hit) {
    if (needSet && !hit.set) {
      hit.set = compileSetter(hit.exp);
    }
    return hit;
  }
  var res = { exp: exp };
  res.get = isSimplePath(exp) && exp.indexOf('[') < 0
  // optimized super simple getter
  ? makeGetterFn('scope.' + exp)
  // dynamic getter
  : compileGetter(exp);
  if (needSet) {
    res.set = compileSetter(exp);
  }
  expressionCache.put(exp, res);
  return res;
}

/**
 * Check if an expression is a simple path.
 *
 * @param {String} exp
 * @return {Boolean}
 */

function isSimplePath(exp) {
  return pathTestRE.test(exp) &&
  // don't treat true/false as paths
  !booleanLiteralRE.test(exp) &&
  // Math constants e.g. Math.PI, Math.E etc.
  exp.slice(0, 5) !== 'Math.';
}

var expression = Object.freeze({
  parseExpression: parseExpression,
  isSimplePath: isSimplePath
});

// we have two separate queues: one for directive updates
// and one for user watcher registered via $watch().
// we want to guarantee directive updates to be called
// before user watchers so that when user watchers are
// triggered, the DOM would have already been in updated
// state.
var queue = [];
var userQueue = [];
var has = {};
var circular = {};
var waiting = false;
var internalQueueDepleted = false;

/**
 * Reset the batcher's state.
 */

function resetBatcherState() {
  queue = [];
  userQueue = [];
  has = {};
  circular = {};
  waiting = internalQueueDepleted = false;
}

/**
 * Flush both queues and run the watchers.
 */

function flushBatcherQueue() {
  runBatcherQueue(queue);
  internalQueueDepleted = true;
  runBatcherQueue(userQueue);
  // dev tool hook
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production') {
    if (inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
      window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');
    }
  }
  resetBatcherState();
}

/**
 * Run the watchers in a single queue.
 *
 * @param {Array} queue
 */

function runBatcherQueue(queue) {
  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (var i = 0; i < queue.length; i++) {
    var watcher = queue[i];
    var id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > config._maxUpdateCount) {
        queue.splice(has[id], 1);
        warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);
      }
    }
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 *
 * @param {Watcher} watcher
 *   properties:
 *   - {Number} id
 *   - {Function} run
 */

function pushWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    // if an internal watcher is pushed, but the internal
    // queue is already depleted, we run it immediately.
    if (internalQueueDepleted && !watcher.user) {
      watcher.run();
      return;
    }
    // push watcher into appropriate queue
    var q = watcher.user ? userQueue : queue;
    has[id] = q.length;
    q.push(watcher);
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushBatcherQueue);
    }
  }
}

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 *
 * @param {Vue} vm
 * @param {String} expression
 * @param {Function} cb
 * @param {Object} options
 *                 - {Array} filters
 *                 - {Boolean} twoWay
 *                 - {Boolean} deep
 *                 - {Boolean} user
 *                 - {Boolean} sync
 *                 - {Boolean} lazy
 *                 - {Function} [preProcess]
 *                 - {Function} [postProcess]
 * @constructor
 */
function Watcher(vm, expOrFn, cb, options) {
  // mix in options
  if (options) {
    extend(this, options);
  }
  var isFn = typeof expOrFn === 'function';
  this.vm = vm;
  vm._watchers.push(this);
  this.expression = isFn ? expOrFn.toString() : expOrFn;
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = Object.create(null);
  this.newDeps = null;
  this.prevError = null; // for async error stacks
  // parse expression for getter/setter
  if (isFn) {
    this.getter = expOrFn;
    this.setter = undefined;
  } else {
    var res = parseExpression(expOrFn, this.twoWay);
    this.getter = res.get;
    this.setter = res.set;
  }
  this.value = this.lazy ? undefined : this.get();
  // state for avoiding false triggers for deep and Array
  // watchers during vm._digest()
  this.queued = this.shallow = false;
}

/**
 * Add a dependency to this directive.
 *
 * @param {Dep} dep
 */

Watcher.prototype.addDep = function (dep) {
  var id = dep.id;
  if (!this.newDeps[id]) {
    this.newDeps[id] = dep;
    if (!this.deps[id]) {
      this.deps[id] = dep;
      dep.addSub(this);
    }
  }
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */

Watcher.prototype.get = function () {
  this.beforeGet();
  var scope = this.scope || this.vm;
  var value;
  try {
    value = this.getter.call(scope, scope);
  } catch (e) {
    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
      warn('Error when evaluating expression "' + this.expression + '". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);
    }
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  if (this.preProcess) {
    value = this.preProcess(value);
  }
  if (this.filters) {
    value = scope._applyFilters(value, null, this.filters, false);
  }
  if (this.postProcess) {
    value = this.postProcess(value);
  }
  this.afterGet();
  return value;
};

/**
 * Set the corresponding value with the setter.
 *
 * @param {*} value
 */

Watcher.prototype.set = function (value) {
  var scope = this.scope || this.vm;
  if (this.filters) {
    value = scope._applyFilters(value, this.value, this.filters, true);
  }
  try {
    this.setter.call(scope, scope, value);
  } catch (e) {
    if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
      warn('Error when evaluating setter "' + this.expression + '"', e);
    }
  }
  // two-way sync for v-for alias
  var forContext = scope.$forContext;
  if (forContext && forContext.alias === this.expression) {
    if (forContext.filters) {
      process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');
      return;
    }
    forContext._withLock(function () {
      if (scope.$key) {
        // original is an object
        forContext.rawValue[scope.$key] = value;
      } else {
        forContext.rawValue.$set(scope.$index, value);
      }
    });
  }
};

/**
 * Prepare for dependency collection.
 */

Watcher.prototype.beforeGet = function () {
  Dep.target = this;
  this.newDeps = Object.create(null);
};

/**
 * Clean up for dependency collection.
 */

Watcher.prototype.afterGet = function () {
  Dep.target = null;
  var ids = Object.keys(this.deps);
  var i = ids.length;
  while (i--) {
    var id = ids[i];
    if (!this.newDeps[id]) {
      this.deps[id].removeSub(this);
    }
  }
  this.deps = this.newDeps;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 *
 * @param {Boolean} shallow
 */

Watcher.prototype.update = function (shallow) {
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync || !config.async) {
    this.run();
  } else {
    // if queued, only overwrite shallow with non-shallow,
    // but not the other way around.
    this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
    this.queued = true;
    // record before-push error stack in debug mode
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.debug) {
      this.prevError = new Error('[vue] async stack trace');
    }
    pushWatcher(this);
  }
};

/**
 * Batcher job interface.
 * Will be called by the batcher.
 */

Watcher.prototype.run = function () {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated; but only do so if this is a
    // non-shallow update (caused by a vm digest).
    (isObject(value) || this.deep) && !this.shallow) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      // in debug + async mode, when a watcher callbacks
      // throws, we also throw the saved before-push error
      // so the full cross-tick stack trace is available.
      var prevError = this.prevError;
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
        this.prevError = null;
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          nextTick(function () {
            throw prevError;
          }, 0);
          throw e;
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
    this.queued = this.shallow = false;
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */

Watcher.prototype.evaluate = function () {
  // avoid overwriting another watcher that is being
  // collected.
  var current = Dep.target;
  this.value = this.get();
  this.dirty = false;
  Dep.target = current;
};

/**
 * Depend on all deps collected by this watcher.
 */

Watcher.prototype.depend = function () {
  var depIds = Object.keys(this.deps);
  var i = depIds.length;
  while (i--) {
    this.deps[depIds[i]].depend();
  }
};

/**
 * Remove self from all dependencies' subcriber list.
 */

Watcher.prototype.teardown = function () {
  if (this.active) {
    // remove self from vm's watcher list
    // we can skip this if the vm if being destroyed
    // which can improve teardown performance.
    if (!this.vm._isBeingDestroyed) {
      this.vm._watchers.$remove(this);
    }
    var depIds = Object.keys(this.deps);
    var i = depIds.length;
    while (i--) {
      this.deps[depIds[i]].removeSub(this);
    }
    this.active = false;
    this.vm = this.cb = this.value = null;
  }
};

/**
 * Recrusively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 *
 * @param {*} val
 */

function traverse(val) {
  var i, keys;
  if (isArray(val)) {
    i = val.length;
    while (i--) traverse(val[i]);
  } else if (isObject(val)) {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) traverse(val[keys[i]]);
  }
}

var cloak = {
  bind: function bind() {
    var el = this.el;
    this.vm.$once('pre-hook:compiled', function () {
      el.removeAttribute('v-cloak');
    });
  }
};

var ref = {
  bind: function bind() {
    process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');
  }
};

var ON = 700;
var MODEL = 800;
var BIND = 850;
var TRANSITION = 1100;
var EL = 1500;
var COMPONENT = 1500;
var PARTIAL = 1750;
var FOR = 2000;
var IF = 2000;
var SLOT = 2100;

var el = {

  priority: EL,

  bind: function bind() {
    /* istanbul ignore if */
    if (!this.arg) {
      return;
    }
    var id = this.id = camelize(this.arg);
    var refs = (this._scope || this.vm).$els;
    if (hasOwn(refs, id)) {
      refs[id] = this.el;
    } else {
      defineReactive(refs, id, this.el);
    }
  },

  unbind: function unbind() {
    var refs = (this._scope || this.vm).$els;
    if (refs[this.id] === this.el) {
      refs[this.id] = null;
    }
  }
};

var prefixes = ['-webkit-', '-moz-', '-ms-'];
var camelPrefixes = ['Webkit', 'Moz', 'ms'];
var importantRE = /!important;?$/;
var propCache = Object.create(null);

var testEl = null;

var style = {

  deep: true,

  update: function update(value) {
    if (typeof value === 'string') {
      this.el.style.cssText = value;
    } else if (isArray(value)) {
      this.handleObject(value.reduce(extend, {}));
    } else {
      this.handleObject(value || {});
    }
  },

  handleObject: function handleObject(value) {
    // cache object styles so that only changed props
    // are actually updated.
    var cache = this.cache || (this.cache = {});
    var name, val;
    for (name in cache) {
      if (!(name in value)) {
        this.handleSingle(name, null);
        delete cache[name];
      }
    }
    for (name in value) {
      val = value[name];
      if (val !== cache[name]) {
        cache[name] = val;
        this.handleSingle(name, val);
      }
    }
  },

  handleSingle: function handleSingle(prop, value) {
    prop = normalize(prop);
    if (!prop) return; // unsupported prop
    // cast possible numbers/booleans into strings
    if (value != null) value += '';
    if (value) {
      var isImportant = importantRE.test(value) ? 'important' : '';
      if (isImportant) {
        value = value.replace(importantRE, '').trim();
      }
      this.el.style.setProperty(prop, value, isImportant);
    } else {
      this.el.style.removeProperty(prop);
    }
  }

};

/**
 * Normalize a CSS property name.
 * - cache result
 * - auto prefix
 * - camelCase -> dash-case
 *
 * @param {String} prop
 * @return {String}
 */

function normalize(prop) {
  if (propCache[prop]) {
    return propCache[prop];
  }
  var res = prefix(prop);
  propCache[prop] = propCache[res] = res;
  return res;
}

/**
 * Auto detect the appropriate prefix for a CSS property.
 * https://gist.github.com/paulirish/523692
 *
 * @param {String} prop
 * @return {String}
 */

function prefix(prop) {
  prop = hyphenate(prop);
  var camel = camelize(prop);
  var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
  if (!testEl) {
    testEl = document.createElement('div');
  }
  if (camel in testEl.style) {
    return prop;
  }
  var i = prefixes.length;
  var prefixed;
  while (i--) {
    prefixed = camelPrefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixes[i] + prop;
    }
  }
}

// xlink
var xlinkNS = 'http://www.w3.org/1999/xlink';
var xlinkRE = /^xlink:/;

// check for attributes that prohibit interpolations
var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
// these attributes should also set their corresponding properties
// because they only affect the initial state of the element
var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;

// these attributes should set a hidden property for
// binding v-model to object values
var modelProps = {
  value: '_value',
  'true-value': '_trueValue',
  'false-value': '_falseValue'
};

var bind = {

  priority: BIND,

  bind: function bind() {
    var attr = this.arg;
    var tag = this.el.tagName;
    // should be deep watch on object mode
    if (!attr) {
      this.deep = true;
    }
    // handle interpolation bindings
    var descriptor = this.descriptor;
    var tokens = descriptor.interp;
    if (tokens) {
      // handle interpolations with one-time tokens
      if (descriptor.hasOneTime) {
        this.expression = tokensToExp(tokens, this._scope || this.vm);
      }

      // only allow binding on native attributes
      if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
        process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');
        this.el.removeAttribute(attr);
        this.invalid = true;
      }

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production') {
        var raw = attr + '="' + descriptor.raw + '": ';
        // warn src
        if (attr === 'src') {
          warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');
        }

        // warn style
        if (attr === 'style') {
          warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');
        }
      }
    }
  },

  update: function update(value) {
    if (this.invalid) {
      return;
    }
    var attr = this.arg;
    if (this.arg) {
      this.handleSingle(attr, value);
    } else {
      this.handleObject(value || {});
    }
  },

  // share object handler with v-bind:class
  handleObject: style.handleObject,

  handleSingle: function handleSingle(attr, value) {
    var el = this.el;
    var interp = this.descriptor.interp;
    if (!interp && attrWithPropsRE.test(attr) && attr in el) {
      el[attr] = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
      ? '' : value : value;
    }
    // set model props
    var modelProp = modelProps[attr];
    if (!interp && modelProp) {
      el[modelProp] = value;
      // update v-model if present
      var model = el.__v_model;
      if (model) {
        model.listener();
      }
    }
    // do not set value attribute for textarea
    if (attr === 'value' && el.tagName === 'TEXTAREA') {
      el.removeAttribute(attr);
      return;
    }
    // update attribute
    if (value != null && value !== false) {
      if (attr === 'class') {
        // handle edge case #1960:
        // class interpolation should not overwrite Vue transition class
        if (el.__v_trans) {
          value += ' ' + el.__v_trans.id + '-transition';
        }
        setClass(el, value);
      } else if (xlinkRE.test(attr)) {
        el.setAttributeNS(xlinkNS, attr, value);
      } else {
        el.setAttribute(attr, value);
      }
    } else {
      el.removeAttribute(attr);
    }
  }
};

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  'delete': 46,
  up: 38,
  left: 37,
  right: 39,
  down: 40
};

function keyFilter(handler, keys) {
  var codes = keys.map(function (key) {
    var charCode = key.charCodeAt(0);
    if (charCode > 47 && charCode < 58) {
      return parseInt(key, 10);
    }
    if (key.length === 1) {
      charCode = key.toUpperCase().charCodeAt(0);
      if (charCode > 64 && charCode < 91) {
        return charCode;
      }
    }
    return keyCodes[key];
  });
  return function keyHandler(e) {
    if (codes.indexOf(e.keyCode) > -1) {
      return handler.call(this, e);
    }
  };
}

function stopFilter(handler) {
  return function stopHandler(e) {
    e.stopPropagation();
    return handler.call(this, e);
  };
}

function preventFilter(handler) {
  return function preventHandler(e) {
    e.preventDefault();
    return handler.call(this, e);
  };
}

var on = {

  acceptStatement: true,
  priority: ON,

  bind: function bind() {
    // deal with iframes
    if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
      var self = this;
      this.iframeBind = function () {
        on$1(self.el.contentWindow, self.arg, self.handler);
      };
      this.on('load', this.iframeBind);
    }
  },

  update: function update(handler) {
    // stub a noop for v-on with no value,
    // e.g. @mousedown.prevent
    if (!this.descriptor.raw) {
      handler = function () {};
    }

    if (typeof handler !== 'function') {
      process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler);
      return;
    }

    // apply modifiers
    if (this.modifiers.stop) {
      handler = stopFilter(handler);
    }
    if (this.modifiers.prevent) {
      handler = preventFilter(handler);
    }
    // key filter
    var keys = Object.keys(this.modifiers).filter(function (key) {
      return key !== 'stop' && key !== 'prevent';
    });
    if (keys.length) {
      handler = keyFilter(handler, keys);
    }

    this.reset();
    this.handler = handler;

    if (this.iframeBind) {
      this.iframeBind();
    } else {
      on$1(this.el, this.arg, this.handler);
    }
  },

  reset: function reset() {
    var el = this.iframeBind ? this.el.contentWindow : this.el;
    if (this.handler) {
      off(el, this.arg, this.handler);
    }
  },

  unbind: function unbind() {
    this.reset();
  }
};

var checkbox = {

  bind: function bind() {
    var self = this;
    var el = this.el;

    this.getValue = function () {
      return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
    };

    function getBooleanValue() {
      var val = el.checked;
      if (val && el.hasOwnProperty('_trueValue')) {
        return el._trueValue;
      }
      if (!val && el.hasOwnProperty('_falseValue')) {
        return el._falseValue;
      }
      return val;
    }

    this.listener = function () {
      var model = self._watcher.value;
      if (isArray(model)) {
        var val = self.getValue();
        if (el.checked) {
          if (indexOf(model, val) < 0) {
            model.push(val);
          }
        } else {
          model.$remove(val);
        }
      } else {
        self.set(getBooleanValue());
      }
    };

    this.on('change', this.listener);
    if (el.hasAttribute('checked')) {
      this.afterBind = this.listener;
    }
  },

  update: function update(value) {
    var el = this.el;
    if (isArray(value)) {
      el.checked = indexOf(value, this.getValue()) > -1;
    } else {
      if (el.hasOwnProperty('_trueValue')) {
        el.checked = looseEqual(value, el._trueValue);
      } else {
        el.checked = !!value;
      }
    }
  }
};

var select = {

  bind: function bind() {
    var self = this;
    var el = this.el;

    // method to force update DOM using latest value.
    this.forceUpdate = function () {
      if (self._watcher) {
        self.update(self._watcher.get());
      }
    };

    // check if this is a multiple select
    var multiple = this.multiple = el.hasAttribute('multiple');

    // attach listener
    this.listener = function () {
      var value = getValue(el, multiple);
      value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
      self.set(value);
    };
    this.on('change', this.listener);

    // if has initial value, set afterBind
    var initValue = getValue(el, multiple, true);
    if (multiple && initValue.length || !multiple && initValue !== null) {
      this.afterBind = this.listener;
    }

    // All major browsers except Firefox resets
    // selectedIndex with value -1 to 0 when the element
    // is appended to a new parent, therefore we have to
    // force a DOM update whenever that happens...
    this.vm.$on('hook:attached', this.forceUpdate);
  },

  update: function update(value) {
    var el = this.el;
    el.selectedIndex = -1;
    var multi = this.multiple && isArray(value);
    var options = el.options;
    var i = options.length;
    var op, val;
    while (i--) {
      op = options[i];
      val = op.hasOwnProperty('_value') ? op._value : op.value;
      /* eslint-disable eqeqeq */
      op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
      /* eslint-enable eqeqeq */
    }
  },

  unbind: function unbind() {
    /* istanbul ignore next */
    this.vm.$off('hook:attached', this.forceUpdate);
  }
};

/**
 * Get select value
 *
 * @param {SelectElement} el
 * @param {Boolean} multi
 * @param {Boolean} init
 * @return {Array|*}
 */

function getValue(el, multi, init) {
  var res = multi ? [] : null;
  var op, val, selected;
  for (var i = 0, l = el.options.length; i < l; i++) {
    op = el.options[i];
    selected = init ? op.hasAttribute('selected') : op.selected;
    if (selected) {
      val = op.hasOwnProperty('_value') ? op._value : op.value;
      if (multi) {
        res.push(val);
      } else {
        return val;
      }
    }
  }
  return res;
}

/**
 * Native Array.indexOf uses strict equal, but in this
 * case we need to match string/numbers with custom equal.
 *
 * @param {Array} arr
 * @param {*} val
 */

function indexOf$1(arr, val) {
  var i = arr.length;
  while (i--) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

var radio = {

  bind: function bind() {
    var self = this;
    var el = this.el;

    this.getValue = function () {
      // value overwrite via v-bind:value
      if (el.hasOwnProperty('_value')) {
        return el._value;
      }
      var val = el.value;
      if (self.params.number) {
        val = toNumber(val);
      }
      return val;
    };

    this.listener = function () {
      self.set(self.getValue());
    };
    this.on('change', this.listener);

    if (el.hasAttribute('checked')) {
      this.afterBind = this.listener;
    }
  },

  update: function update(value) {
    this.el.checked = looseEqual(value, this.getValue());
  }
};

var text$2 = {

  bind: function bind() {
    var self = this;
    var el = this.el;
    var isRange = el.type === 'range';
    var lazy = this.params.lazy;
    var number = this.params.number;
    var debounce = this.params.debounce;

    // handle composition events.
    //   http://blog.evanyou.me/2014/01/03/composition-event/
    // skip this for Android because it handles composition
    // events quite differently. Android doesn't trigger
    // composition events for language input methods e.g.
    // Chinese, but instead triggers them for spelling
    // suggestions... (see Discussion/#162)
    var composing = false;
    if (!isAndroid && !isRange) {
      this.on('compositionstart', function () {
        composing = true;
      });
      this.on('compositionend', function () {
        composing = false;
        // in IE11 the "compositionend" event fires AFTER
        // the "input" event, so the input handler is blocked
        // at the end... have to call it here.
        //
        // #1327: in lazy mode this is unecessary.
        if (!lazy) {
          self.listener();
        }
      });
    }

    // prevent messing with the input when user is typing,
    // and force update on blur.
    this.focused = false;
    if (!isRange && !lazy) {
      this.on('focus', function () {
        self.focused = true;
      });
      this.on('blur', function () {
        self.focused = false;
        // do not sync value after fragment removal (#2017)
        if (!self._frag || self._frag.inserted) {
          self.rawListener();
        }
      });
    }

    // Now attach the main listener
    this.listener = this.rawListener = function () {
      if (composing || !self._bound) {
        return;
      }
      var val = number || isRange ? toNumber(el.value) : el.value;
      self.set(val);
      // force update on next tick to avoid lock & same value
      // also only update when user is not typing
      nextTick(function () {
        if (self._bound && !self.focused) {
          self.update(self._watcher.value);
        }
      });
    };

    // apply debounce
    if (debounce) {
      this.listener = _debounce(this.listener, debounce);
    }

    // Support jQuery events, since jQuery.trigger() doesn't
    // trigger native events in some cases and some plugins
    // rely on $.trigger()
    //
    // We want to make sure if a listener is attached using
    // jQuery, it is also removed with jQuery, that's why
    // we do the check for each directive instance and
    // store that check result on itself. This also allows
    // easier test coverage control by unsetting the global
    // jQuery variable in tests.
    this.hasjQuery = typeof jQuery === 'function';
    if (this.hasjQuery) {
      jQuery(el).on('change', this.listener);
      if (!lazy) {
        jQuery(el).on('input', this.listener);
      }
    } else {
      this.on('change', this.listener);
      if (!lazy) {
        this.on('input', this.listener);
      }
    }

    // IE9 doesn't fire input event on backspace/del/cut
    if (!lazy && isIE9) {
      this.on('cut', function () {
        nextTick(self.listener);
      });
      this.on('keyup', function (e) {
        if (e.keyCode === 46 || e.keyCode === 8) {
          self.listener();
        }
      });
    }

    // set initial value if present
    if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
      this.afterBind = this.listener;
    }
  },

  update: function update(value) {
    this.el.value = _toString(value);
  },

  unbind: function unbind() {
    var el = this.el;
    if (this.hasjQuery) {
      jQuery(el).off('change', this.listener);
      jQuery(el).off('input', this.listener);
    }
  }
};

var handlers = {
  text: text$2,
  radio: radio,
  select: select,
  checkbox: checkbox
};

var model = {

  priority: MODEL,
  twoWay: true,
  handlers: handlers,
  params: ['lazy', 'number', 'debounce'],

  /**
   * Possible elements:
   *   <select>
   *   <textarea>
   *   <input type="*">
   *     - text
   *     - checkbox
   *     - radio
   *     - number
   */

  bind: function bind() {
    // friendly warning...
    this.checkFilters();
    if (this.hasRead && !this.hasWrite) {
      process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');
    }
    var el = this.el;
    var tag = el.tagName;
    var handler;
    if (tag === 'INPUT') {
      handler = handlers[el.type] || handlers.text;
    } else if (tag === 'SELECT') {
      handler = handlers.select;
    } else if (tag === 'TEXTAREA') {
      handler = handlers.text;
    } else {
      process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag);
      return;
    }
    el.__v_model = this;
    handler.bind.call(this);
    this.update = handler.update;
    this._unbind = handler.unbind;
  },

  /**
   * Check read/write filter stats.
   */

  checkFilters: function checkFilters() {
    var filters = this.filters;
    if (!filters) return;
    var i = filters.length;
    while (i--) {
      var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
      if (typeof filter === 'function' || filter.read) {
        this.hasRead = true;
      }
      if (filter.write) {
        this.hasWrite = true;
      }
    }
  },

  unbind: function unbind() {
    this.el.__v_model = null;
    this._unbind && this._unbind();
  }
};

var show = {

  bind: function bind() {
    // check else block
    var next = this.el.nextElementSibling;
    if (next && getAttr(next, 'v-else') !== null) {
      this.elseEl = next;
    }
  },

  update: function update(value) {
    this.apply(this.el, value);
    if (this.elseEl) {
      this.apply(this.elseEl, !value);
    }
  },

  apply: function apply(el, value) {
    if (inDoc(el)) {
      applyTransition(el, value ? 1 : -1, toggle, this.vm);
    } else {
      toggle();
    }
    function toggle() {
      el.style.display = value ? '' : 'none';
    }
  }
};

var templateCache = new Cache(1000);
var idSelectorCache = new Cache(1000);

var map = {
  efault: [0, '', ''],
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
};

map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];

map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];

/**
 * Check if a node is a supported template node with a
 * DocumentFragment content.
 *
 * @param {Node} node
 * @return {Boolean}
 */

function isRealTemplate(node) {
  return isTemplate(node) && node.content instanceof DocumentFragment;
}

var tagRE$1 = /<([\w:]+)/;
var entityRE = /&#?\w+?;/;

/**
 * Convert a string template to a DocumentFragment.
 * Determines correct wrapping by tag types. Wrapping
 * strategy found in jQuery & component/domify.
 *
 * @param {String} templateString
 * @param {Boolean} raw
 * @return {DocumentFragment}
 */

function stringToFragment(templateString, raw) {
  // try a cache hit first
  var hit = templateCache.get(templateString);
  if (hit) {
    return hit;
  }

  var frag = document.createDocumentFragment();
  var tagMatch = templateString.match(tagRE$1);
  var entityMatch = entityRE.test(templateString);

  if (!tagMatch && !entityMatch) {
    // text only, return a single text node.
    frag.appendChild(document.createTextNode(templateString));
  } else {

    var tag = tagMatch && tagMatch[1];
    var wrap = map[tag] || map.efault;
    var depth = wrap[0];
    var prefix = wrap[1];
    var suffix = wrap[2];
    var node = document.createElement('div');

    var templateStringToUse = raw ? templateString : templateString.trim();
    node.innerHTML = prefix + templateStringToUse + suffix;
    while (depth--) {
      node = node.lastChild;
    }

    var child;
    /* eslint-disable no-cond-assign */
    while (child = node.firstChild) {
      /* eslint-enable no-cond-assign */
      frag.appendChild(child);
    }
  }

  templateCache.put(templateString, frag);
  return frag;
}

/**
 * Convert a template node to a DocumentFragment.
 *
 * @param {Node} node
 * @return {DocumentFragment}
 */

function nodeToFragment(node) {
  // if its a template tag and the browser supports it,
  // its content is already a document fragment.
  if (isRealTemplate(node)) {
    trimNode(node.content);
    return node.content;
  }
  // script template
  if (node.tagName === 'SCRIPT') {
    return stringToFragment(node.textContent);
  }
  // normal node, clone it to avoid mutating the original
  var clonedNode = cloneNode(node);
  var frag = document.createDocumentFragment();
  var child;
  /* eslint-disable no-cond-assign */
  while (child = clonedNode.firstChild) {
    /* eslint-enable no-cond-assign */
    frag.appendChild(child);
  }
  trimNode(frag);
  return frag;
}

// Test for the presence of the Safari template cloning bug
// https://bugs.webkit.org/showug.cgi?id=137755
var hasBrokenTemplate = (function () {
  /* istanbul ignore else */
  if (inBrowser) {
    var a = document.createElement('div');
    a.innerHTML = '<template>1</template>';
    return !a.cloneNode(true).firstChild.innerHTML;
  } else {
    return false;
  }
})();

// Test for IE10/11 textarea placeholder clone bug
var hasTextareaCloneBug = (function () {
  /* istanbul ignore else */
  if (inBrowser) {
    var t = document.createElement('textarea');
    t.placeholder = 't';
    return t.cloneNode(true).value === 't';
  } else {
    return false;
  }
})();

/**
 * 1. Deal with Safari cloning nested <template> bug by
 *    manually cloning all template instances.
 * 2. Deal with IE10/11 textarea placeholder bug by setting
 *    the correct value after cloning.
 *
 * @param {Element|DocumentFragment} node
 * @return {Element|DocumentFragment}
 */

function cloneNode(node) {
  if (!node.querySelectorAll) {
    return node.cloneNode();
  }
  var res = node.cloneNode(true);
  var i, original, cloned;
  /* istanbul ignore if */
  if (hasBrokenTemplate) {
    var tempClone = res;
    if (isRealTemplate(node)) {
      node = node.content;
      tempClone = res.content;
    }
    original = node.querySelectorAll('template');
    if (original.length) {
      cloned = tempClone.querySelectorAll('template');
      i = cloned.length;
      while (i--) {
        cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
      }
    }
  }
  /* istanbul ignore if */
  if (hasTextareaCloneBug) {
    if (node.tagName === 'TEXTAREA') {
      res.value = node.value;
    } else {
      original = node.querySelectorAll('textarea');
      if (original.length) {
        cloned = res.querySelectorAll('textarea');
        i = cloned.length;
        while (i--) {
          cloned[i].value = original[i].value;
        }
      }
    }
  }
  return res;
}

/**
 * Process the template option and normalizes it into a
 * a DocumentFragment that can be used as a partial or a
 * instance template.
 *
 * @param {*} template
 *        Possible values include:
 *        - DocumentFragment object
 *        - Node object of type Template
 *        - id selector: '#some-template-id'
 *        - template string: '<div><span>{{msg}}</span></div>'
 * @param {Boolean} shouldClone
 * @param {Boolean} raw
 *        inline HTML interpolation. Do not check for id
 *        selector and keep whitespace in the string.
 * @return {DocumentFragment|undefined}
 */

function parseTemplate(template, shouldClone, raw) {
  var node, frag;

  // if the template is already a document fragment,
  // do nothing
  if (template instanceof DocumentFragment) {
    trimNode(template);
    return shouldClone ? cloneNode(template) : template;
  }

  if (typeof template === 'string') {
    // id selector
    if (!raw && template.charAt(0) === '#') {
      // id selector can be cached too
      frag = idSelectorCache.get(template);
      if (!frag) {
        node = document.getElementById(template.slice(1));
        if (node) {
          frag = nodeToFragment(node);
          // save selector to cache
          idSelectorCache.put(template, frag);
        }
      }
    } else {
      // normal string template
      frag = stringToFragment(template, raw);
    }
  } else if (template.nodeType) {
    // a direct node
    frag = nodeToFragment(template);
  }

  return frag && shouldClone ? cloneNode(frag) : frag;
}

var template = Object.freeze({
  cloneNode: cloneNode,
  parseTemplate: parseTemplate
});

/**
 * Abstraction for a partially-compiled fragment.
 * Can optionally compile content with a child scope.
 *
 * @param {Function} linker
 * @param {Vue} vm
 * @param {DocumentFragment} frag
 * @param {Vue} [host]
 * @param {Object} [scope]
 */
function Fragment(linker, vm, frag, host, scope, parentFrag) {
  this.children = [];
  this.childFrags = [];
  this.vm = vm;
  this.scope = scope;
  this.inserted = false;
  this.parentFrag = parentFrag;
  if (parentFrag) {
    parentFrag.childFrags.push(this);
  }
  this.unlink = linker(vm, frag, host, scope, this);
  var single = this.single = frag.childNodes.length === 1 &&
  // do not go single mode if the only node is an anchor
  !frag.childNodes[0].__vue_anchor;
  if (single) {
    this.node = frag.childNodes[0];
    this.before = singleBefore;
    this.remove = singleRemove;
  } else {
    this.node = createAnchor('fragment-start');
    this.end = createAnchor('fragment-end');
    this.frag = frag;
    prepend(this.node, frag);
    frag.appendChild(this.end);
    this.before = multiBefore;
    this.remove = multiRemove;
  }
  this.node.__vfrag__ = this;
}

/**
 * Call attach/detach for all components contained within
 * this fragment. Also do so recursively for all child
 * fragments.
 *
 * @param {Function} hook
 */

Fragment.prototype.callHook = function (hook) {
  var i, l;
  for (i = 0, l = this.childFrags.length; i < l; i++) {
    this.childFrags[i].callHook(hook);
  }
  for (i = 0, l = this.children.length; i < l; i++) {
    hook(this.children[i]);
  }
};

/**
 * Insert fragment before target, single node version
 *
 * @param {Node} target
 * @param {Boolean} withTransition
 */

function singleBefore(target, withTransition) {
  this.inserted = true;
  var method = withTransition !== false ? beforeWithTransition : before;
  method(this.node, target, this.vm);
  if (inDoc(this.node)) {
    this.callHook(attach);
  }
}

/**
 * Remove fragment, single node version
 */

function singleRemove() {
  this.inserted = false;
  var shouldCallRemove = inDoc(this.node);
  var self = this;
  this.beforeRemove();
  removeWithTransition(this.node, this.vm, function () {
    if (shouldCallRemove) {
      self.callHook(detach);
    }
    self.destroy();
  });
}

/**
 * Insert fragment before target, multi-nodes version
 *
 * @param {Node} target
 * @param {Boolean} withTransition
 */

function multiBefore(target, withTransition) {
  this.inserted = true;
  var vm = this.vm;
  var method = withTransition !== false ? beforeWithTransition : before;
  mapNodeRange(this.node, this.end, function (node) {
    method(node, target, vm);
  });
  if (inDoc(this.node)) {
    this.callHook(attach);
  }
}

/**
 * Remove fragment, multi-nodes version
 */

function multiRemove() {
  this.inserted = false;
  var self = this;
  var shouldCallRemove = inDoc(this.node);
  this.beforeRemove();
  removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
    if (shouldCallRemove) {
      self.callHook(detach);
    }
    self.destroy();
  });
}

/**
 * Prepare the fragment for removal.
 */

Fragment.prototype.beforeRemove = function () {
  var i, l;
  for (i = 0, l = this.childFrags.length; i < l; i++) {
    // call the same method recursively on child
    // fragments, depth-first
    this.childFrags[i].beforeRemove(false);
  }
  for (i = 0, l = this.children.length; i < l; i++) {
    // Call destroy for all contained instances,
    // with remove:false and defer:true.
    // Defer is necessary because we need to
    // keep the children to call detach hooks
    // on them.
    this.children[i].$destroy(false, true);
  }
  var dirs = this.unlink.dirs;
  for (i = 0, l = dirs.length; i < l; i++) {
    // disable the watchers on all the directives
    // so that the rendered content stays the same
    // during removal.
    dirs[i]._watcher && dirs[i]._watcher.teardown();
  }
};

/**
 * Destroy the fragment.
 */

Fragment.prototype.destroy = function () {
  if (this.parentFrag) {
    this.parentFrag.childFrags.$remove(this);
  }
  this.node.__vfrag__ = null;
  this.unlink();
};

/**
 * Call attach hook for a Vue instance.
 *
 * @param {Vue} child
 */

function attach(child) {
  if (!child._isAttached) {
    child._callHook('attached');
  }
}

/**
 * Call detach hook for a Vue instance.
 *
 * @param {Vue} child
 */

function detach(child) {
  if (child._isAttached) {
    child._callHook('detached');
  }
}

var linkerCache = new Cache(5000);

/**
 * A factory that can be used to create instances of a
 * fragment. Caches the compiled linker if possible.
 *
 * @param {Vue} vm
 * @param {Element|String} el
 */
function FragmentFactory(vm, el) {
  this.vm = vm;
  var template;
  var isString = typeof el === 'string';
  if (isString || isTemplate(el)) {
    template = parseTemplate(el, true);
  } else {
    template = document.createDocumentFragment();
    template.appendChild(el);
  }
  this.template = template;
  // linker can be cached, but only for components
  var linker;
  var cid = vm.constructor.cid;
  if (cid > 0) {
    var cacheId = cid + (isString ? el : el.outerHTML);
    linker = linkerCache.get(cacheId);
    if (!linker) {
      linker = compile(template, vm.$options, true);
      linkerCache.put(cacheId, linker);
    }
  } else {
    linker = compile(template, vm.$options, true);
  }
  this.linker = linker;
}

/**
 * Create a fragment instance with given host and scope.
 *
 * @param {Vue} host
 * @param {Object} scope
 * @param {Fragment} parentFrag
 */

FragmentFactory.prototype.create = function (host, scope, parentFrag) {
  var frag = cloneNode(this.template);
  return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
};

var vIf = {

  priority: IF,

  bind: function bind() {
    var el = this.el;
    if (!el.__vue__) {
      // check else block
      var next = el.nextElementSibling;
      if (next && getAttr(next, 'v-else') !== null) {
        remove(next);
        this.elseFactory = new FragmentFactory(this.vm, next);
      }
      // check main block
      this.anchor = createAnchor('v-if');
      replace(el, this.anchor);
      this.factory = new FragmentFactory(this.vm, el);
    } else {
      process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.');
      this.invalid = true;
    }
  },

  update: function update(value) {
    if (this.invalid) return;
    if (value) {
      if (!this.frag) {
        this.insert();
      }
    } else {
      this.remove();
    }
  },

  insert: function insert() {
    if (this.elseFrag) {
      this.elseFrag.remove();
      this.elseFrag = null;
    }
    this.frag = this.factory.create(this._host, this._scope, this._frag);
    this.frag.before(this.anchor);
  },

  remove: function remove() {
    if (this.frag) {
      this.frag.remove();
      this.frag = null;
    }
    if (this.elseFactory && !this.elseFrag) {
      this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
      this.elseFrag.before(this.anchor);
    }
  },

  unbind: function unbind() {
    if (this.frag) {
      this.frag.destroy();
    }
  }
};

var uid$1 = 0;

var vFor = {

  priority: FOR,

  params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],

  bind: function bind() {
    // support "item in items" syntax
    var inMatch = this.expression.match(/(.*) in (.*)/);
    if (inMatch) {
      var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
      if (itMatch) {
        this.iterator = itMatch[1].trim();
        this.alias = itMatch[2].trim();
      } else {
        this.alias = inMatch[1].trim();
      }
      this.expression = inMatch[2];
    }

    if (!this.alias) {
      process.env.NODE_ENV !== 'production' && warn('Alias is required in v-for.');
      return;
    }

    // uid as a cache identifier
    this.id = '__v-for__' + ++uid$1;

    // check if this is an option list,
    // so that we know if we need to update the <select>'s
    // v-model when the option list has changed.
    // because v-model has a lower priority than v-for,
    // the v-model is not bound here yet, so we have to
    // retrive it in the actual updateModel() function.
    var tag = this.el.tagName;
    this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';

    // setup anchor nodes
    this.start = createAnchor('v-for-start');
    this.end = createAnchor('v-for-end');
    replace(this.el, this.end);
    before(this.start, this.end);

    // cache
    this.cache = Object.create(null);

    // fragment factory
    this.factory = new FragmentFactory(this.vm, this.el);
  },

  update: function update(data) {
    this.diff(data);
    this.updateRef();
    this.updateModel();
  },

  /**
   * Diff, based on new data and old data, determine the
   * minimum amount of DOM manipulations needed to make the
   * DOM reflect the new data Array.
   *
   * The algorithm diffs the new data Array by storing a
   * hidden reference to an owner vm instance on previously
   * seen data. This allows us to achieve O(n) which is
   * better than a levenshtein distance based algorithm,
   * which is O(m * n).
   *
   * @param {Array} data
   */

  diff: function diff(data) {
    // check if the Array was converted from an Object
    var item = data[0];
    var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');

    var trackByKey = this.params.trackBy;
    var oldFrags = this.frags;
    var frags = this.frags = new Array(data.length);
    var alias = this.alias;
    var iterator = this.iterator;
    var start = this.start;
    var end = this.end;
    var inDocument = inDoc(start);
    var init = !oldFrags;
    var i, l, frag, key, value, primitive;

    // First pass, go through the new Array and fill up
    // the new frags array. If a piece of data has a cached
    // instance for it, we reuse it. Otherwise build a new
    // instance.
    for (i = 0, l = data.length; i < l; i++) {
      item = data[i];
      key = convertedFromObject ? item.$key : null;
      value = convertedFromObject ? item.$value : item;
      primitive = !isObject(value);
      frag = !init && this.getCachedFrag(value, i, key);
      if (frag) {
        // reusable fragment
        frag.reused = true;
        // update $index
        frag.scope.$index = i;
        // update $key
        if (key) {
          frag.scope.$key = key;
        }
        // update iterator
        if (iterator) {
          frag.scope[iterator] = key !== null ? key : i;
        }
        // update data for track-by, object repeat &
        // primitive values.
        if (trackByKey || convertedFromObject || primitive) {
          frag.scope[alias] = value;
        }
      } else {
        // new isntance
        frag = this.create(value, alias, i, key);
        frag.fresh = !init;
      }
      frags[i] = frag;
      if (init) {
        frag.before(end);
      }
    }

    // we're done for the initial render.
    if (init) {
      return;
    }

    // Second pass, go through the old fragments and
    // destroy those who are not reused (and remove them
    // from cache)
    var removalIndex = 0;
    var totalRemoved = oldFrags.length - frags.length;
    for (i = 0, l = oldFrags.length; i < l; i++) {
      frag = oldFrags[i];
      if (!frag.reused) {
        this.deleteCachedFrag(frag);
        this.remove(frag, removalIndex++, totalRemoved, inDocument);
      }
    }

    // Final pass, move/insert new fragments into the
    // right place.
    var targetPrev, prevEl, currentPrev;
    var insertionIndex = 0;
    for (i = 0, l = frags.length; i < l; i++) {
      frag = frags[i];
      // this is the frag that we should be after
      targetPrev = frags[i - 1];
      prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
      if (frag.reused && !frag.staggerCb) {
        currentPrev = findPrevFrag(frag, start, this.id);
        if (currentPrev !== targetPrev && (!currentPrev ||
        // optimization for moving a single item.
        // thanks to suggestions by @livoras in #1807
        findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
          this.move(frag, prevEl);
        }
      } else {
        // new instance, or still in stagger.
        // insert with updated stagger index.
        this.insert(frag, insertionIndex++, prevEl, inDocument);
      }
      frag.reused = frag.fresh = false;
    }
  },

  /**
   * Create a new fragment instance.
   *
   * @param {*} value
   * @param {String} alias
   * @param {Number} index
   * @param {String} [key]
   * @return {Fragment}
   */

  create: function create(value, alias, index, key) {
    var host = this._host;
    // create iteration scope
    var parentScope = this._scope || this.vm;
    var scope = Object.create(parentScope);
    // ref holder for the scope
    scope.$refs = Object.create(parentScope.$refs);
    scope.$els = Object.create(parentScope.$els);
    // make sure point $parent to parent scope
    scope.$parent = parentScope;
    // for two-way binding on alias
    scope.$forContext = this;
    // define scope properties
    defineReactive(scope, alias, value);
    defineReactive(scope, '$index', index);
    if (key) {
      defineReactive(scope, '$key', key);
    } else if (scope.$key) {
      // avoid accidental fallback
      def(scope, '$key', null);
    }
    if (this.iterator) {
      defineReactive(scope, this.iterator, key !== null ? key : index);
    }
    var frag = this.factory.create(host, scope, this._frag);
    frag.forId = this.id;
    this.cacheFrag(value, frag, index, key);
    return frag;
  },

  /**
   * Update the v-ref on owner vm.
   */

  updateRef: function updateRef() {
    var ref = this.descriptor.ref;
    if (!ref) return;
    var hash = (this._scope || this.vm).$refs;
    var refs;
    if (!this.fromObject) {
      refs = this.frags.map(findVmFromFrag);
    } else {
      refs = {};
      this.frags.forEach(function (frag) {
        refs[frag.scope.$key] = findVmFromFrag(frag);
      });
    }
    hash[ref] = refs;
  },

  /**
   * For option lists, update the containing v-model on
   * parent <select>.
   */

  updateModel: function updateModel() {
    if (this.isOption) {
      var parent = this.start.parentNode;
      var model = parent && parent.__v_model;
      if (model) {
        model.forceUpdate();
      }
    }
  },

  /**
   * Insert a fragment. Handles staggering.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Node} prevEl
   * @param {Boolean} inDocument
   */

  insert: function insert(frag, index, prevEl, inDocument) {
    if (frag.staggerCb) {
      frag.staggerCb.cancel();
      frag.staggerCb = null;
    }
    var staggerAmount = this.getStagger(frag, index, null, 'enter');
    if (inDocument && staggerAmount) {
      // create an anchor and insert it synchronously,
      // so that we can resolve the correct order without
      // worrying about some elements not inserted yet
      var anchor = frag.staggerAnchor;
      if (!anchor) {
        anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
        anchor.__vfrag__ = frag;
      }
      after(anchor, prevEl);
      var op = frag.staggerCb = cancellable(function () {
        frag.staggerCb = null;
        frag.before(anchor);
        remove(anchor);
      });
      setTimeout(op, staggerAmount);
    } else {
      frag.before(prevEl.nextSibling);
    }
  },

  /**
   * Remove a fragment. Handles staggering.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Number} total
   * @param {Boolean} inDocument
   */

  remove: function remove(frag, index, total, inDocument) {
    if (frag.staggerCb) {
      frag.staggerCb.cancel();
      frag.staggerCb = null;
      // it's not possible for the same frag to be removed
      // twice, so if we have a pending stagger callback,
      // it means this frag is queued for enter but removed
      // before its transition started. Since it is already
      // destroyed, we can just leave it in detached state.
      return;
    }
    var staggerAmount = this.getStagger(frag, index, total, 'leave');
    if (inDocument && staggerAmount) {
      var op = frag.staggerCb = cancellable(function () {
        frag.staggerCb = null;
        frag.remove();
      });
      setTimeout(op, staggerAmount);
    } else {
      frag.remove();
    }
  },

  /**
   * Move a fragment to a new position.
   * Force no transition.
   *
   * @param {Fragment} frag
   * @param {Node} prevEl
   */

  move: function move(frag, prevEl) {
    // fix a common issue with Sortable:
    // if prevEl doesn't have nextSibling, this means it's
    // been dragged after the end anchor. Just re-position
    // the end anchor to the end of the container.
    /* istanbul ignore if */
    if (!prevEl.nextSibling) {
      this.end.parentNode.appendChild(this.end);
    }
    frag.before(prevEl.nextSibling, false);
  },

  /**
   * Cache a fragment using track-by or the object key.
   *
   * @param {*} value
   * @param {Fragment} frag
   * @param {Number} index
   * @param {String} [key]
   */

  cacheFrag: function cacheFrag(value, frag, index, key) {
    var trackByKey = this.params.trackBy;
    var cache = this.cache;
    var primitive = !isObject(value);
    var id;
    if (key || trackByKey || primitive) {
      id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
      if (!cache[id]) {
        cache[id] = frag;
      } else if (trackByKey !== '$index') {
        process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
      }
    } else {
      id = this.id;
      if (hasOwn(value, id)) {
        if (value[id] === null) {
          value[id] = frag;
        } else {
          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
        }
      } else {
        def(value, id, frag);
      }
    }
    frag.raw = value;
  },

  /**
   * Get a cached fragment from the value/index/key
   *
   * @param {*} value
   * @param {Number} index
   * @param {String} key
   * @return {Fragment}
   */

  getCachedFrag: function getCachedFrag(value, index, key) {
    var trackByKey = this.params.trackBy;
    var primitive = !isObject(value);
    var frag;
    if (key || trackByKey || primitive) {
      var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
      frag = this.cache[id];
    } else {
      frag = value[this.id];
    }
    if (frag && (frag.reused || frag.fresh)) {
      process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
    }
    return frag;
  },

  /**
   * Delete a fragment from cache.
   *
   * @param {Fragment} frag
   */

  deleteCachedFrag: function deleteCachedFrag(frag) {
    var value = frag.raw;
    var trackByKey = this.params.trackBy;
    var scope = frag.scope;
    var index = scope.$index;
    // fix #948: avoid accidentally fall through to
    // a parent repeater which happens to have $key.
    var key = hasOwn(scope, '$key') && scope.$key;
    var primitive = !isObject(value);
    if (trackByKey || key || primitive) {
      var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
      this.cache[id] = null;
    } else {
      value[this.id] = null;
      frag.raw = null;
    }
  },

  /**
   * Get the stagger amount for an insertion/removal.
   *
   * @param {Fragment} frag
   * @param {Number} index
   * @param {Number} total
   * @param {String} type
   */

  getStagger: function getStagger(frag, index, total, type) {
    type = type + 'Stagger';
    var trans = frag.node.__v_trans;
    var hooks = trans && trans.hooks;
    var hook = hooks && (hooks[type] || hooks.stagger);
    return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
  },

  /**
   * Pre-process the value before piping it through the
   * filters. This is passed to and called by the watcher.
   */

  _preProcess: function _preProcess(value) {
    // regardless of type, store the un-filtered raw value.
    this.rawValue = value;
    return value;
  },

  /**
   * Post-process the value after it has been piped through
   * the filters. This is passed to and called by the watcher.
   *
   * It is necessary for this to be called during the
   * wathcer's dependency collection phase because we want
   * the v-for to update when the source Object is mutated.
   */

  _postProcess: function _postProcess(value) {
    if (isArray(value)) {
      return value;
    } else if (isPlainObject(value)) {
      // convert plain object to array.
      var keys = Object.keys(value);
      var i = keys.length;
      var res = new Array(i);
      var key;
      while (i--) {
        key = keys[i];
        res[i] = {
          $key: key,
          $value: value[key]
        };
      }
      return res;
    } else {
      if (typeof value === 'number') {
        value = range(value);
      }
      return value || [];
    }
  },

  unbind: function unbind() {
    if (this.descriptor.ref) {
      (this._scope || this.vm).$refs[this.descriptor.ref] = null;
    }
    if (this.frags) {
      var i = this.frags.length;
      var frag;
      while (i--) {
        frag = this.frags[i];
        this.deleteCachedFrag(frag);
        frag.destroy();
      }
    }
  }
};

/**
 * Helper to find the previous element that is a fragment
 * anchor. This is necessary because a destroyed frag's
 * element could still be lingering in the DOM before its
 * leaving transition finishes, but its inserted flag
 * should have been set to false so we can skip them.
 *
 * If this is a block repeat, we want to make sure we only
 * return frag that is bound to this v-for. (see #929)
 *
 * @param {Fragment} frag
 * @param {Comment|Text} anchor
 * @param {String} id
 * @return {Fragment}
 */

function findPrevFrag(frag, anchor, id) {
  var el = frag.node.previousSibling;
  /* istanbul ignore if */
  if (!el) return;
  frag = el.__vfrag__;
  while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
    el = el.previousSibling;
    /* istanbul ignore if */
    if (!el) return;
    frag = el.__vfrag__;
  }
  return frag;
}

/**
 * Find a vm from a fragment.
 *
 * @param {Fragment} frag
 * @return {Vue|undefined}
 */

function findVmFromFrag(frag) {
  var node = frag.node;
  // handle multi-node frag
  if (frag.end) {
    while (!node.__vue__ && node !== frag.end && node.nextSibling) {
      node = node.nextSibling;
    }
  }
  return node.__vue__;
}

/**
 * Create a range array from given number.
 *
 * @param {Number} n
 * @return {Array}
 */

function range(n) {
  var i = -1;
  var ret = new Array(n);
  while (++i < n) {
    ret[i] = i;
  }
  return ret;
}

if (process.env.NODE_ENV !== 'production') {
  vFor.warnDuplicate = function (value) {
    warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.');
  };
}

var html = {

  bind: function bind() {
    // a comment node means this is a binding for
    // {{{ inline unescaped html }}}
    if (this.el.nodeType === 8) {
      // hold nodes
      this.nodes = [];
      // replace the placeholder with proper anchor
      this.anchor = createAnchor('v-html');
      replace(this.el, this.anchor);
    }
  },

  update: function update(value) {
    value = _toString(value);
    if (this.nodes) {
      this.swap(value);
    } else {
      this.el.innerHTML = value;
    }
  },

  swap: function swap(value) {
    // remove old nodes
    var i = this.nodes.length;
    while (i--) {
      remove(this.nodes[i]);
    }
    // convert new value to a fragment
    // do not attempt to retrieve from id selector
    var frag = parseTemplate(value, true, true);
    // save a reference to these nodes so we can remove later
    this.nodes = toArray(frag.childNodes);
    before(frag, this.anchor);
  }
};

var text = {

  bind: function bind() {
    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
  },

  update: function update(value) {
    this.el[this.attr] = _toString(value);
  }
};

// must export plain object
var publicDirectives = {
  text: text,
  html: html,
  'for': vFor,
  'if': vIf,
  show: show,
  model: model,
  on: on,
  bind: bind,
  el: el,
  ref: ref,
  cloak: cloak
};

var queue$1 = [];
var queued = false;

/**
 * Push a job into the queue.
 *
 * @param {Function} job
 */

function pushJob(job) {
  queue$1.push(job);
  if (!queued) {
    queued = true;
    nextTick(flush);
  }
}

/**
 * Flush the queue, and do one forced reflow before
 * triggering transitions.
 */

function flush() {
  // Force layout
  var f = document.documentElement.offsetHeight;
  for (var i = 0; i < queue$1.length; i++) {
    queue$1[i]();
  }
  queue$1 = [];
  queued = false;
  // dummy return, so js linters don't complain about
  // unused variable f
  return f;
}

var TYPE_TRANSITION = 'transition';
var TYPE_ANIMATION = 'animation';
var transDurationProp = transitionProp + 'Duration';
var animDurationProp = animationProp + 'Duration';

/**
 * A Transition object that encapsulates the state and logic
 * of the transition.
 *
 * @param {Element} el
 * @param {String} id
 * @param {Object} hooks
 * @param {Vue} vm
 */
function Transition(el, id, hooks, vm) {
  this.id = id;
  this.el = el;
  this.enterClass = hooks && hooks.enterClass || id + '-enter';
  this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
  this.hooks = hooks;
  this.vm = vm;
  // async state
  this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
  this.justEntered = false;
  this.entered = this.left = false;
  this.typeCache = {};
  // check css transition type
  this.type = hooks && hooks.type;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== 'production') {
    if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
      warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type);
    }
  }
  // bind
  var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
    self[m] = bind$1(self[m], self);
  });
}

var p$1 = Transition.prototype;

/**
 * Start an entering transition.
 *
 * 1. enter transition triggered
 * 2. call beforeEnter hook
 * 3. add enter class
 * 4. insert/show element
 * 5. call enter hook (with possible explicit js callback)
 * 6. reflow
 * 7. based on transition type:
 *    - transition:
 *        remove class now, wait for transitionend,
 *        then done if there's no explicit js callback.
 *    - animation:
 *        wait for animationend, remove class,
 *        then done if there's no explicit js callback.
 *    - no css transition:
 *        done now if there's no explicit js callback.
 * 8. wait for either done or js callback, then call
 *    afterEnter hook.
 *
 * @param {Function} op - insert/show the element
 * @param {Function} [cb]
 */

p$1.enter = function (op, cb) {
  this.cancelPending();
  this.callHook('beforeEnter');
  this.cb = cb;
  addClass(this.el, this.enterClass);
  op();
  this.entered = false;
  this.callHookWithCb('enter');
  if (this.entered) {
    return; // user called done synchronously.
  }
  this.cancel = this.hooks && this.hooks.enterCancelled;
  pushJob(this.enterNextTick);
};

/**
 * The "nextTick" phase of an entering transition, which is
 * to be pushed into a queue and executed after a reflow so
 * that removing the class can trigger a CSS transition.
 */

p$1.enterNextTick = function () {

  // Important hack:
  // in Chrome, if a just-entered element is applied the
  // leave class while its interpolated property still has
  // a very small value (within one frame), Chrome will
  // skip the leave transition entirely and not firing the
  // transtionend event. Therefore we need to protected
  // against such cases using a one-frame timeout.
  this.justEntered = true;
  var self = this;
  setTimeout(function () {
    self.justEntered = false;
  }, 17);

  var enterDone = this.enterDone;
  var type = this.getCssTransitionType(this.enterClass);
  if (!this.pendingJsCb) {
    if (type === TYPE_TRANSITION) {
      // trigger transition by removing enter class now
      removeClass(this.el, this.enterClass);
      this.setupCssCb(transitionEndEvent, enterDone);
    } else if (type === TYPE_ANIMATION) {
      this.setupCssCb(animationEndEvent, enterDone);
    } else {
      enterDone();
    }
  } else if (type === TYPE_TRANSITION) {
    removeClass(this.el, this.enterClass);
  }
};

/**
 * The "cleanup" phase of an entering transition.
 */

p$1.enterDone = function () {
  this.entered = true;
  this.cancel = this.pendingJsCb = null;
  removeClass(this.el, this.enterClass);
  this.callHook('afterEnter');
  if (this.cb) this.cb();
};

/**
 * Start a leaving transition.
 *
 * 1. leave transition triggered.
 * 2. call beforeLeave hook
 * 3. add leave class (trigger css transition)
 * 4. call leave hook (with possible explicit js callback)
 * 5. reflow if no explicit js callback is provided
 * 6. based on transition type:
 *    - transition or animation:
 *        wait for end event, remove class, then done if
 *        there's no explicit js callback.
 *    - no css transition:
 *        done if there's no explicit js callback.
 * 7. wait for either done or js callback, then call
 *    afterLeave hook.
 *
 * @param {Function} op - remove/hide the element
 * @param {Function} [cb]
 */

p$1.leave = function (op, cb) {
  this.cancelPending();
  this.callHook('beforeLeave');
  this.op = op;
  this.cb = cb;
  addClass(this.el, this.leaveClass);
  this.left = false;
  this.callHookWithCb('leave');
  if (this.left) {
    return; // user called done synchronously.
  }
  this.cancel = this.hooks && this.hooks.leaveCancelled;
  // only need to handle leaveDone if
  // 1. the transition is already done (synchronously called
  //    by the user, which causes this.op set to null)
  // 2. there's no explicit js callback
  if (this.op && !this.pendingJsCb) {
    // if a CSS transition leaves immediately after enter,
    // the transitionend event never fires. therefore we
    // detect such cases and end the leave immediately.
    if (this.justEntered) {
      this.leaveDone();
    } else {
      pushJob(this.leaveNextTick);
    }
  }
};

/**
 * The "nextTick" phase of a leaving transition.
 */

p$1.leaveNextTick = function () {
  var type = this.getCssTransitionType(this.leaveClass);
  if (type) {
    var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
    this.setupCssCb(event, this.leaveDone);
  } else {
    this.leaveDone();
  }
};

/**
 * The "cleanup" phase of a leaving transition.
 */

p$1.leaveDone = function () {
  this.left = true;
  this.cancel = this.pendingJsCb = null;
  this.op();
  removeClass(this.el, this.leaveClass);
  this.callHook('afterLeave');
  if (this.cb) this.cb();
  this.op = null;
};

/**
 * Cancel any pending callbacks from a previously running
 * but not finished transition.
 */

p$1.cancelPending = function () {
  this.op = this.cb = null;
  var hasPending = false;
  if (this.pendingCssCb) {
    hasPending = true;
    off(this.el, this.pendingCssEvent, this.pendingCssCb);
    this.pendingCssEvent = this.pendingCssCb = null;
  }
  if (this.pendingJsCb) {
    hasPending = true;
    this.pendingJsCb.cancel();
    this.pendingJsCb = null;
  }
  if (hasPending) {
    removeClass(this.el, this.enterClass);
    removeClass(this.el, this.leaveClass);
  }
  if (this.cancel) {
    this.cancel.call(this.vm, this.el);
    this.cancel = null;
  }
};

/**
 * Call a user-provided synchronous hook function.
 *
 * @param {String} type
 */

p$1.callHook = function (type) {
  if (this.hooks && this.hooks[type]) {
    this.hooks[type].call(this.vm, this.el);
  }
};

/**
 * Call a user-provided, potentially-async hook function.
 * We check for the length of arguments to see if the hook
 * expects a `done` callback. If true, the transition's end
 * will be determined by when the user calls that callback;
 * otherwise, the end is determined by the CSS transition or
 * animation.
 *
 * @param {String} type
 */

p$1.callHookWithCb = function (type) {
  var hook = this.hooks && this.hooks[type];
  if (hook) {
    if (hook.length > 1) {
      this.pendingJsCb = cancellable(this[type + 'Done']);
    }
    hook.call(this.vm, this.el, this.pendingJsCb);
  }
};

/**
 * Get an element's transition type based on the
 * calculated styles.
 *
 * @param {String} className
 * @return {Number}
 */

p$1.getCssTransitionType = function (className) {
  /* istanbul ignore if */
  if (!transitionEndEvent ||
  // skip CSS transitions if page is not visible -
  // this solves the issue of transitionend events not
  // firing until the page is visible again.
  // pageVisibility API is supported in IE10+, same as
  // CSS transitions.
  document.hidden ||
  // explicit js-only transition
  this.hooks && this.hooks.css === false ||
  // element is hidden
  isHidden(this.el)) {
    return;
  }
  var type = this.type || this.typeCache[className];
  if (type) return type;
  var inlineStyles = this.el.style;
  var computedStyles = window.getComputedStyle(this.el);
  var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
  if (transDuration && transDuration !== '0s') {
    type = TYPE_TRANSITION;
  } else {
    var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
    if (animDuration && animDuration !== '0s') {
      type = TYPE_ANIMATION;
    }
  }
  if (type) {
    this.typeCache[className] = type;
  }
  return type;
};

/**
 * Setup a CSS transitionend/animationend callback.
 *
 * @param {String} event
 * @param {Function} cb
 */

p$1.setupCssCb = function (event, cb) {
  this.pendingCssEvent = event;
  var self = this;
  var el = this.el;
  var onEnd = this.pendingCssCb = function (e) {
    if (e.target === el) {
      off(el, event, onEnd);
      self.pendingCssEvent = self.pendingCssCb = null;
      if (!self.pendingJsCb && cb) {
        cb();
      }
    }
  };
  on$1(el, event, onEnd);
};

/**
 * Check if an element is hidden - in that case we can just
 * skip the transition alltogether.
 *
 * @param {Element} el
 * @return {Boolean}
 */

function isHidden(el) {
  return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
}

var transition = {

  priority: TRANSITION,

  update: function update(id, oldId) {
    var el = this.el;
    // resolve on owner vm
    var hooks = resolveAsset(this.vm.$options, 'transitions', id);
    id = id || 'v';
    // apply on closest vm
    el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm);
    if (oldId) {
      removeClass(el, oldId + '-transition');
    }
    addClass(el, id + '-transition');
  }
};

var bindingModes = config._propBindingModes;

var propDef = {

  bind: function bind() {

    var child = this.vm;
    var parent = child._context;
    // passed in from compiler directly
    var prop = this.descriptor.prop;
    var childKey = prop.path;
    var parentKey = prop.parentPath;
    var twoWay = prop.mode === bindingModes.TWO_WAY;

    var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
      val = coerceProp(prop, val);
      if (assertProp(prop, val)) {
        child[childKey] = val;
      }
    }, {
      twoWay: twoWay,
      filters: prop.filters,
      // important: props need to be observed on the
      // v-for scope if present
      scope: this._scope
    });

    // set the child initial value.
    initProp(child, prop, parentWatcher.value);

    // setup two-way binding
    if (twoWay) {
      // important: defer the child watcher creation until
      // the created hook (after data observation)
      var self = this;
      child.$once('pre-hook:created', function () {
        self.childWatcher = new Watcher(child, childKey, function (val) {
          parentWatcher.set(val);
        }, {
          // ensure sync upward before parent sync down.
          // this is necessary in cases e.g. the child
          // mutates a prop array, then replaces it. (#1683)
          sync: true
        });
      });
    }
  },

  unbind: function unbind() {
    this.parentWatcher.teardown();
    if (this.childWatcher) {
      this.childWatcher.teardown();
    }
  }
};

var component = {

  priority: COMPONENT,

  params: ['keep-alive', 'transition-mode', 'inline-template'],

  /**
   * Setup. Two possible usages:
   *
   * - static:
   *   <comp> or <div v-component="comp">
   *
   * - dynamic:
   *   <component :is="view">
   */

  bind: function bind() {
    if (!this.el.__vue__) {
      // keep-alive cache
      this.keepAlive = this.params.keepAlive;
      if (this.keepAlive) {
        this.cache = {};
      }
      // check inline-template
      if (this.params.inlineTemplate) {
        // extract inline template as a DocumentFragment
        this.inlineTemplate = extractContent(this.el, true);
      }
      // component resolution related state
      this.pendingComponentCb = this.Component = null;
      // transition related state
      this.pendingRemovals = 0;
      this.pendingRemovalCb = null;
      // create a ref anchor
      this.anchor = createAnchor('v-component');
      replace(this.el, this.anchor);
      // remove is attribute.
      // this is removed during compilation, but because compilation is
      // cached, when the component is used elsewhere this attribute
      // will remain at link time.
      this.el.removeAttribute('is');
      // remove ref, same as above
      if (this.descriptor.ref) {
        this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
      }
      // if static, build right now.
      if (this.literal) {
        this.setComponent(this.expression);
      }
    } else {
      process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
    }
  },

  /**
   * Public update, called by the watcher in the dynamic
   * literal scenario, e.g. <component :is="view">
   */

  update: function update(value) {
    if (!this.literal) {
      this.setComponent(value);
    }
  },

  /**
   * Switch dynamic components. May resolve the component
   * asynchronously, and perform transition based on
   * specified transition mode. Accepts a few additional
   * arguments specifically for vue-router.
   *
   * The callback is called when the full transition is
   * finished.
   *
   * @param {String} value
   * @param {Function} [cb]
   */

  setComponent: function setComponent(value, cb) {
    this.invalidatePending();
    if (!value) {
      // just remove current
      this.unbuild(true);
      this.remove(this.childVM, cb);
      this.childVM = null;
    } else {
      var self = this;
      this.resolveComponent(value, function () {
        self.mountComponent(cb);
      });
    }
  },

  /**
   * Resolve the component constructor to use when creating
   * the child vm.
   */

  resolveComponent: function resolveComponent(id, cb) {
    var self = this;
    this.pendingComponentCb = cancellable(function (Component) {
      self.ComponentName = Component.options.name || id;
      self.Component = Component;
      cb();
    });
    this.vm._resolveComponent(id, this.pendingComponentCb);
  },

  /**
   * Create a new instance using the current constructor and
   * replace the existing instance. This method doesn't care
   * whether the new component and the old one are actually
   * the same.
   *
   * @param {Function} [cb]
   */

  mountComponent: function mountComponent(cb) {
    // actual mount
    this.unbuild(true);
    var self = this;
    var activateHook = this.Component.options.activate;
    var cached = this.getCached();
    var newComponent = this.build();
    if (activateHook && !cached) {
      this.waitingFor = newComponent;
      activateHook.call(newComponent, function () {
        if (self.waitingFor !== newComponent) {
          return;
        }
        self.waitingFor = null;
        self.transition(newComponent, cb);
      });
    } else {
      // update ref for kept-alive component
      if (cached) {
        newComponent._updateRef();
      }
      this.transition(newComponent, cb);
    }
  },

  /**
   * When the component changes or unbinds before an async
   * constructor is resolved, we need to invalidate its
   * pending callback.
   */

  invalidatePending: function invalidatePending() {
    if (this.pendingComponentCb) {
      this.pendingComponentCb.cancel();
      this.pendingComponentCb = null;
    }
  },

  /**
   * Instantiate/insert a new child vm.
   * If keep alive and has cached instance, insert that
   * instance; otherwise build a new one and cache it.
   *
   * @param {Object} [extraOptions]
   * @return {Vue} - the created instance
   */

  build: function build(extraOptions) {
    var cached = this.getCached();
    if (cached) {
      return cached;
    }
    if (this.Component) {
      // default options
      var options = {
        name: this.ComponentName,
        el: cloneNode(this.el),
        template: this.inlineTemplate,
        // make sure to add the child with correct parent
        // if this is a transcluded component, its parent
        // should be the transclusion host.
        parent: this._host || this.vm,
        // if no inline-template, then the compiled
        // linker can be cached for better performance.
        _linkerCachable: !this.inlineTemplate,
        _ref: this.descriptor.ref,
        _asComponent: true,
        _isRouterView: this._isRouterView,
        // if this is a transcluded component, context
        // will be the common parent vm of this instance
        // and its host.
        _context: this.vm,
        // if this is inside an inline v-for, the scope
        // will be the intermediate scope created for this
        // repeat fragment. this is used for linking props
        // and container directives.
        _scope: this._scope,
        // pass in the owner fragment of this component.
        // this is necessary so that the fragment can keep
        // track of its contained components in order to
        // call attach/detach hooks for them.
        _frag: this._frag
      };
      // extra options
      // in 1.0.0 this is used by vue-router only
      /* istanbul ignore if */
      if (extraOptions) {
        extend(options, extraOptions);
      }
      var child = new this.Component(options);
      if (this.keepAlive) {
        this.cache[this.Component.cid] = child;
      }
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
        warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);
      }
      return child;
    }
  },

  /**
   * Try to get a cached instance of the current component.
   *
   * @return {Vue|undefined}
   */

  getCached: function getCached() {
    return this.keepAlive && this.cache[this.Component.cid];
  },

  /**
   * Teardown the current child, but defers cleanup so
   * that we can separate the destroy and removal steps.
   *
   * @param {Boolean} defer
   */

  unbuild: function unbuild(defer) {
    if (this.waitingFor) {
      this.waitingFor.$destroy();
      this.waitingFor = null;
    }
    var child = this.childVM;
    if (!child || this.keepAlive) {
      if (child) {
        // remove ref
        child._updateRef(true);
      }
      return;
    }
    // the sole purpose of `deferCleanup` is so that we can
    // "deactivate" the vm right now and perform DOM removal
    // later.
    child.$destroy(false, defer);
  },

  /**
   * Remove current destroyed child and manually do
   * the cleanup after removal.
   *
   * @param {Function} cb
   */

  remove: function remove(child, cb) {
    var keepAlive = this.keepAlive;
    if (child) {
      // we may have a component switch when a previous
      // component is still being transitioned out.
      // we want to trigger only one lastest insertion cb
      // when the existing transition finishes. (#1119)
      this.pendingRemovals++;
      this.pendingRemovalCb = cb;
      var self = this;
      child.$remove(function () {
        self.pendingRemovals--;
        if (!keepAlive) child._cleanup();
        if (!self.pendingRemovals && self.pendingRemovalCb) {
          self.pendingRemovalCb();
          self.pendingRemovalCb = null;
        }
      });
    } else if (cb) {
      cb();
    }
  },

  /**
   * Actually swap the components, depending on the
   * transition mode. Defaults to simultaneous.
   *
   * @param {Vue} target
   * @param {Function} [cb]
   */

  transition: function transition(target, cb) {
    var self = this;
    var current = this.childVM;
    // for devtool inspection
    if (process.env.NODE_ENV !== 'production') {
      if (current) current._inactive = true;
      target._inactive = false;
    }
    this.childVM = target;
    switch (self.params.transitionMode) {
      case 'in-out':
        target.$before(self.anchor, function () {
          self.remove(current, cb);
        });
        break;
      case 'out-in':
        self.remove(current, function () {
          target.$before(self.anchor, cb);
        });
        break;
      default:
        self.remove(current);
        target.$before(self.anchor, cb);
    }
  },

  /**
   * Unbind.
   */

  unbind: function unbind() {
    this.invalidatePending();
    // Do not defer cleanup when unbinding
    this.unbuild();
    // destroy all keep-alive cached instances
    if (this.cache) {
      for (var key in this.cache) {
        this.cache[key].$destroy();
      }
      this.cache = null;
    }
  }
};

var vClass = {

  deep: true,

  update: function update(value) {
    if (value && typeof value === 'string') {
      this.handleObject(stringToObject(value));
    } else if (isPlainObject(value)) {
      this.handleObject(value);
    } else if (isArray(value)) {
      this.handleArray(value);
    } else {
      this.cleanup();
    }
  },

  handleObject: function handleObject(value) {
    this.cleanup(value);
    var keys = this.prevKeys = Object.keys(value);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      if (value[key]) {
        addClass(this.el, key);
      } else {
        removeClass(this.el, key);
      }
    }
  },

  handleArray: function handleArray(value) {
    this.cleanup(value);
    for (var i = 0, l = value.length; i < l; i++) {
      if (value[i]) {
        addClass(this.el, value[i]);
      }
    }
    this.prevKeys = value.slice();
  },

  cleanup: function cleanup(value) {
    if (this.prevKeys) {
      var i = this.prevKeys.length;
      while (i--) {
        var key = this.prevKeys[i];
        if (key && (!value || !contains$1(value, key))) {
          removeClass(this.el, key);
        }
      }
    }
  }
};

function stringToObject(value) {
  var res = {};
  var keys = value.trim().split(/\s+/);
  var i = keys.length;
  while (i--) {
    res[keys[i]] = true;
  }
  return res;
}

function contains$1(value, key) {
  return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);
}

var internalDirectives = {
  style: style,
  'class': vClass,
  component: component,
  prop: propDef,
  transition: transition
};

var propBindingModes = config._propBindingModes;
var empty = {};

// regexes
var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;

/**
 * Compile props on a root element and return
 * a props link function.
 *
 * @param {Element|DocumentFragment} el
 * @param {Array} propOptions
 * @return {Function} propsLinkFn
 */

function compileProps(el, propOptions) {
  var props = [];
  var names = Object.keys(propOptions);
  var i = names.length;
  var options, name, attr, value, path, parsed, prop;
  while (i--) {
    name = names[i];
    options = propOptions[name] || empty;

    if (process.env.NODE_ENV !== 'production' && name === '$data') {
      warn('Do not use $data as prop.');
      continue;
    }

    // props could contain dashes, which will be
    // interpreted as minus calculations by the parser
    // so we need to camelize the path here
    path = camelize(name);
    if (!identRE$1.test(path)) {
      process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.');
      continue;
    }

    prop = {
      name: name,
      path: path,
      options: options,
      mode: propBindingModes.ONE_WAY,
      raw: null
    };

    attr = hyphenate(name);
    // first check dynamic version
    if ((value = getBindAttr(el, attr)) === null) {
      if ((value = getBindAttr(el, attr + '.sync')) !== null) {
        prop.mode = propBindingModes.TWO_WAY;
      } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
        prop.mode = propBindingModes.ONE_TIME;
      }
    }
    if (value !== null) {
      // has dynamic binding!
      prop.raw = value;
      parsed = parseDirective(value);
      value = parsed.expression;
      prop.filters = parsed.filters;
      // check binding type
      if (isLiteral(value) && !parsed.filters) {
        // for expressions containing literal numbers and
        // booleans, there's no need to setup a prop binding,
        // so we can optimize them as a one-time set.
        prop.optimizedLiteral = true;
      } else {
        prop.dynamic = true;
        // check non-settable path for two-way bindings
        if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
          prop.mode = propBindingModes.ONE_WAY;
          warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);
        }
      }
      prop.parentPath = value;

      // warn required two-way
      if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
        warn('Prop "' + name + '" expects a two-way binding type.');
      }
    } else if ((value = getAttr(el, attr)) !== null) {
      // has literal binding!
      prop.raw = value;
    } else if (options.required) {
      // warn missing required
      process.env.NODE_ENV !== 'production' && warn('Missing required prop: ' + name);
    }
    // push prop
    props.push(prop);
  }
  return makePropsLinkFn(props);
}

/**
 * Build a function that applies props to a vm.
 *
 * @param {Array} props
 * @return {Function} propsLinkFn
 */

function makePropsLinkFn(props) {
  return function propsLinkFn(vm, scope) {
    // store resolved props info
    vm._props = {};
    var i = props.length;
    var prop, path, options, value, raw;
    while (i--) {
      prop = props[i];
      raw = prop.raw;
      path = prop.path;
      options = prop.options;
      vm._props[path] = prop;
      if (raw === null) {
        // initialize absent prop
        initProp(vm, prop, getDefault(vm, options));
      } else if (prop.dynamic) {
        // dynamic prop
        if (vm._context) {
          if (prop.mode === propBindingModes.ONE_TIME) {
            // one time binding
            value = (scope || vm._context).$get(prop.parentPath);
            initProp(vm, prop, value);
          } else {
            // dynamic binding
            vm._bindDir({
              name: 'prop',
              def: propDef,
              prop: prop
            }, null, null, scope); // el, host, scope
          }
        } else {
            process.env.NODE_ENV !== 'production' && warn('Cannot bind dynamic prop on a root instance' + ' with no parent: ' + prop.name + '="' + raw + '"');
          }
      } else if (prop.optimizedLiteral) {
        // optimized literal, cast it and just set once
        var stripped = stripQuotes(raw);
        value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
        initProp(vm, prop, value);
      } else {
        // string literal, but we need to cater for
        // Boolean props with no value
        value = options.type === Boolean && raw === '' ? true : raw;
        initProp(vm, prop, value);
      }
    }
  };
}

/**
 * Get the default value of a prop.
 *
 * @param {Vue} vm
 * @param {Object} options
 * @return {*}
 */

function getDefault(vm, options) {
  // no default, return undefined
  if (!hasOwn(options, 'default')) {
    // absent boolean value defaults to false
    return options.type === Boolean ? false : undefined;
  }
  var def = options['default'];
  // warn against non-factory defaults for Object & Array
  if (isObject(def)) {
    process.env.NODE_ENV !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');
  }
  // call factory function for non-Function types
  return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
}

// special binding prefixes
var bindRE = /^v-bind:|^:/;
var onRE = /^v-on:|^@/;
var argRE = /:(.*)$/;
var modifierRE = /\.[^\.]+/g;
var transitionRE = /^(v-bind:|:)?transition$/;

// terminal directives
var terminalDirectives = ['for', 'if'];

// default directive priority
var DEFAULT_PRIORITY = 1000;

/**
 * Compile a template and return a reusable composite link
 * function, which recursively contains more link functions
 * inside. This top level compile function would normally
 * be called on instance root nodes, but can also be used
 * for partial compilation if the partial argument is true.
 *
 * The returned composite link function, when called, will
 * return an unlink function that tearsdown all directives
 * created during the linking phase.
 *
 * @param {Element|DocumentFragment} el
 * @param {Object} options
 * @param {Boolean} partial
 * @return {Function}
 */

function compile(el, options, partial) {
  // link function for the node itself.
  var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
  // link function for the childNodes
  var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;

  /**
   * A composite linker function to be called on a already
   * compiled piece of DOM, which instantiates all directive
   * instances.
   *
   * @param {Vue} vm
   * @param {Element|DocumentFragment} el
   * @param {Vue} [host] - host vm of transcluded content
   * @param {Object} [scope] - v-for scope
   * @param {Fragment} [frag] - link context fragment
   * @return {Function|undefined}
   */

  return function compositeLinkFn(vm, el, host, scope, frag) {
    // cache childNodes before linking parent, fix #657
    var childNodes = toArray(el.childNodes);
    // link
    var dirs = linkAndCapture(function compositeLinkCapturer() {
      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
      if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
    }, vm);
    return makeUnlinkFn(vm, dirs);
  };
}

/**
 * Apply a linker to a vm/element pair and capture the
 * directives created during the process.
 *
 * @param {Function} linker
 * @param {Vue} vm
 */

function linkAndCapture(linker, vm) {
  var originalDirCount = vm._directives.length;
  linker();
  var dirs = vm._directives.slice(originalDirCount);
  dirs.sort(directiveComparator);
  for (var i = 0, l = dirs.length; i < l; i++) {
    dirs[i]._bind();
  }
  return dirs;
}

/**
 * Directive priority sort comparator
 *
 * @param {Object} a
 * @param {Object} b
 */

function directiveComparator(a, b) {
  a = a.descriptor.def.priority || DEFAULT_PRIORITY;
  b = b.descriptor.def.priority || DEFAULT_PRIORITY;
  return a > b ? -1 : a === b ? 0 : 1;
}

/**
 * Linker functions return an unlink function that
 * tearsdown all directives instances generated during
 * the process.
 *
 * We create unlink functions with only the necessary
 * information to avoid retaining additional closures.
 *
 * @param {Vue} vm
 * @param {Array} dirs
 * @param {Vue} [context]
 * @param {Array} [contextDirs]
 * @return {Function}
 */

function makeUnlinkFn(vm, dirs, context, contextDirs) {
  function unlink(destroying) {
    teardownDirs(vm, dirs, destroying);
    if (context && contextDirs) {
      teardownDirs(context, contextDirs);
    }
  }
  // expose linked directives
  unlink.dirs = dirs;
  return unlink;
}

/**
 * Teardown partial linked directives.
 *
 * @param {Vue} vm
 * @param {Array} dirs
 * @param {Boolean} destroying
 */

function teardownDirs(vm, dirs, destroying) {
  var i = dirs.length;
  while (i--) {
    dirs[i]._teardown();
    if (!destroying) {
      vm._directives.$remove(dirs[i]);
    }
  }
}

/**
 * Compile link props on an instance.
 *
 * @param {Vue} vm
 * @param {Element} el
 * @param {Object} props
 * @param {Object} [scope]
 * @return {Function}
 */

function compileAndLinkProps(vm, el, props, scope) {
  var propsLinkFn = compileProps(el, props);
  var propDirs = linkAndCapture(function () {
    propsLinkFn(vm, scope);
  }, vm);
  return makeUnlinkFn(vm, propDirs);
}

/**
 * Compile the root element of an instance.
 *
 * 1. attrs on context container (context scope)
 * 2. attrs on the component template root node, if
 *    replace:true (child scope)
 *
 * If this is a fragment instance, we only need to compile 1.
 *
 * @param {Vue} vm
 * @param {Element} el
 * @param {Object} options
 * @param {Object} contextOptions
 * @return {Function}
 */

function compileRoot(el, options, contextOptions) {
  var containerAttrs = options._containerAttrs;
  var replacerAttrs = options._replacerAttrs;
  var contextLinkFn, replacerLinkFn;

  // only need to compile other attributes for
  // non-fragment instances
  if (el.nodeType !== 11) {
    // for components, container and replacer need to be
    // compiled separately and linked in different scopes.
    if (options._asComponent) {
      // 2. container attributes
      if (containerAttrs && contextOptions) {
        contextLinkFn = compileDirectives(containerAttrs, contextOptions);
      }
      if (replacerAttrs) {
        // 3. replacer attributes
        replacerLinkFn = compileDirectives(replacerAttrs, options);
      }
    } else {
      // non-component, just compile as a normal element.
      replacerLinkFn = compileDirectives(el.attributes, options);
    }
  } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
    // warn container directives for fragment instances
    var names = containerAttrs.filter(function (attr) {
      // allow vue-loader/vueify scoped css attributes
      return attr.name.indexOf('_v-') < 0 &&
      // allow event listeners
      !onRE.test(attr.name) &&
      // allow slots
      attr.name !== 'slot';
    }).map(function (attr) {
      return '"' + attr.name + '"';
    });
    if (names.length) {
      var plural = names.length > 1;
      warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');
    }
  }

  options._containerAttrs = options._replacerAttrs = null;
  return function rootLinkFn(vm, el, scope) {
    // link context scope dirs
    var context = vm._context;
    var contextDirs;
    if (context && contextLinkFn) {
      contextDirs = linkAndCapture(function () {
        contextLinkFn(context, el, null, scope);
      }, context);
    }

    // link self
    var selfDirs = linkAndCapture(function () {
      if (replacerLinkFn) replacerLinkFn(vm, el);
    }, vm);

    // return the unlink function that tearsdown context
    // container directives.
    return makeUnlinkFn(vm, selfDirs, context, contextDirs);
  };
}

/**
 * Compile a node and return a nodeLinkFn based on the
 * node type.
 *
 * @param {Node} node
 * @param {Object} options
 * @return {Function|null}
 */

function compileNode(node, options) {
  var type = node.nodeType;
  if (type === 1 && node.tagName !== 'SCRIPT') {
    return compileElement(node, options);
  } else if (type === 3 && node.data.trim()) {
    return compileTextNode(node, options);
  } else {
    return null;
  }
}

/**
 * Compile an element and return a nodeLinkFn.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Function|null}
 */

function compileElement(el, options) {
  // preprocess textareas.
  // textarea treats its text content as the initial value.
  // just bind it as an attr directive for value.
  if (el.tagName === 'TEXTAREA') {
    var tokens = parseText(el.value);
    if (tokens) {
      el.setAttribute(':value', tokensToExp(tokens));
      el.value = '';
    }
  }
  var linkFn;
  var hasAttrs = el.hasAttributes();
  // check terminal directives (for & if)
  if (hasAttrs) {
    linkFn = checkTerminalDirectives(el, options);
  }
  // check element directives
  if (!linkFn) {
    linkFn = checkElementDirectives(el, options);
  }
  // check component
  if (!linkFn) {
    linkFn = checkComponent(el, options);
  }
  // normal directives
  if (!linkFn && hasAttrs) {
    linkFn = compileDirectives(el.attributes, options);
  }
  return linkFn;
}

/**
 * Compile a textNode and return a nodeLinkFn.
 *
 * @param {TextNode} node
 * @param {Object} options
 * @return {Function|null} textNodeLinkFn
 */

function compileTextNode(node, options) {
  // skip marked text nodes
  if (node._skip) {
    return removeText;
  }

  var tokens = parseText(node.wholeText);
  if (!tokens) {
    return null;
  }

  // mark adjacent text nodes as skipped,
  // because we are using node.wholeText to compile
  // all adjacent text nodes together. This fixes
  // issues in IE where sometimes it splits up a single
  // text node into multiple ones.
  var next = node.nextSibling;
  while (next && next.nodeType === 3) {
    next._skip = true;
    next = next.nextSibling;
  }

  var frag = document.createDocumentFragment();
  var el, token;
  for (var i = 0, l = tokens.length; i < l; i++) {
    token = tokens[i];
    el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
    frag.appendChild(el);
  }
  return makeTextNodeLinkFn(tokens, frag, options);
}

/**
 * Linker for an skipped text node.
 *
 * @param {Vue} vm
 * @param {Text} node
 */

function removeText(vm, node) {
  remove(node);
}

/**
 * Process a single text token.
 *
 * @param {Object} token
 * @param {Object} options
 * @return {Node}
 */

function processTextToken(token, options) {
  var el;
  if (token.oneTime) {
    el = document.createTextNode(token.value);
  } else {
    if (token.html) {
      el = document.createComment('v-html');
      setTokenType('html');
    } else {
      // IE will clean up empty textNodes during
      // frag.cloneNode(true), so we have to give it
      // something here...
      el = document.createTextNode(' ');
      setTokenType('text');
    }
  }
  function setTokenType(type) {
    if (token.descriptor) return;
    var parsed = parseDirective(token.value);
    token.descriptor = {
      name: type,
      def: publicDirectives[type],
      expression: parsed.expression,
      filters: parsed.filters
    };
  }
  return el;
}

/**
 * Build a function that processes a textNode.
 *
 * @param {Array<Object>} tokens
 * @param {DocumentFragment} frag
 */

function makeTextNodeLinkFn(tokens, frag) {
  return function textNodeLinkFn(vm, el, host, scope) {
    var fragClone = frag.cloneNode(true);
    var childNodes = toArray(fragClone.childNodes);
    var token, value, node;
    for (var i = 0, l = tokens.length; i < l; i++) {
      token = tokens[i];
      value = token.value;
      if (token.tag) {
        node = childNodes[i];
        if (token.oneTime) {
          value = (scope || vm).$eval(value);
          if (token.html) {
            replace(node, parseTemplate(value, true));
          } else {
            node.data = value;
          }
        } else {
          vm._bindDir(token.descriptor, node, host, scope);
        }
      }
    }
    replace(el, fragClone);
  };
}

/**
 * Compile a node list and return a childLinkFn.
 *
 * @param {NodeList} nodeList
 * @param {Object} options
 * @return {Function|undefined}
 */

function compileNodeList(nodeList, options) {
  var linkFns = [];
  var nodeLinkFn, childLinkFn, node;
  for (var i = 0, l = nodeList.length; i < l; i++) {
    node = nodeList[i];
    nodeLinkFn = compileNode(node, options);
    childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
    linkFns.push(nodeLinkFn, childLinkFn);
  }
  return linkFns.length ? makeChildLinkFn(linkFns) : null;
}

/**
 * Make a child link function for a node's childNodes.
 *
 * @param {Array<Function>} linkFns
 * @return {Function} childLinkFn
 */

function makeChildLinkFn(linkFns) {
  return function childLinkFn(vm, nodes, host, scope, frag) {
    var node, nodeLinkFn, childrenLinkFn;
    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
      node = nodes[n];
      nodeLinkFn = linkFns[i++];
      childrenLinkFn = linkFns[i++];
      // cache childNodes before linking parent, fix #657
      var childNodes = toArray(node.childNodes);
      if (nodeLinkFn) {
        nodeLinkFn(vm, node, host, scope, frag);
      }
      if (childrenLinkFn) {
        childrenLinkFn(vm, childNodes, host, scope, frag);
      }
    }
  };
}

/**
 * Check for element directives (custom elements that should
 * be resovled as terminal directives).
 *
 * @param {Element} el
 * @param {Object} options
 */

function checkElementDirectives(el, options) {
  var tag = el.tagName.toLowerCase();
  if (commonTagRE.test(tag)) return;
  // special case: give named slot a higher priority
  // than unnamed slots
  if (tag === 'slot' && hasBindAttr(el, 'name')) {
    tag = '_namedSlot';
  }
  var def = resolveAsset(options, 'elementDirectives', tag);
  if (def) {
    return makeTerminalNodeLinkFn(el, tag, '', options, def);
  }
}

/**
 * Check if an element is a component. If yes, return
 * a component link function.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Function|undefined}
 */

function checkComponent(el, options) {
  var component = checkComponentAttr(el, options);
  if (component) {
    var ref = findRef(el);
    var descriptor = {
      name: 'component',
      ref: ref,
      expression: component.id,
      def: internalDirectives.component,
      modifiers: {
        literal: !component.dynamic
      }
    };
    var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
      if (ref) {
        defineReactive((scope || vm).$refs, ref, null);
      }
      vm._bindDir(descriptor, el, host, scope, frag);
    };
    componentLinkFn.terminal = true;
    return componentLinkFn;
  }
}

/**
 * Check an element for terminal directives in fixed order.
 * If it finds one, return a terminal link function.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Function} terminalLinkFn
 */

function checkTerminalDirectives(el, options) {
  // skip v-pre
  if (getAttr(el, 'v-pre') !== null) {
    return skip;
  }
  // skip v-else block, but only if following v-if
  if (el.hasAttribute('v-else')) {
    var prev = el.previousElementSibling;
    if (prev && prev.hasAttribute('v-if')) {
      return skip;
    }
  }
  var value, dirName;
  for (var i = 0, l = terminalDirectives.length; i < l; i++) {
    dirName = terminalDirectives[i];
    value = el.getAttribute('v-' + dirName);
    if (value != null) {
      return makeTerminalNodeLinkFn(el, dirName, value, options);
    }
  }
}

function skip() {}
skip.terminal = true;

/**
 * Build a node link function for a terminal directive.
 * A terminal link function terminates the current
 * compilation recursion and handles compilation of the
 * subtree in the directive.
 *
 * @param {Element} el
 * @param {String} dirName
 * @param {String} value
 * @param {Object} options
 * @param {Object} [def]
 * @return {Function} terminalLinkFn
 */

function makeTerminalNodeLinkFn(el, dirName, value, options, def) {
  var parsed = parseDirective(value);
  var descriptor = {
    name: dirName,
    expression: parsed.expression,
    filters: parsed.filters,
    raw: value,
    // either an element directive, or if/for
    def: def || publicDirectives[dirName]
  };
  // check ref for v-for and router-view
  if (dirName === 'for' || dirName === 'router-view') {
    descriptor.ref = findRef(el);
  }
  var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
    if (descriptor.ref) {
      defineReactive((scope || vm).$refs, descriptor.ref, null);
    }
    vm._bindDir(descriptor, el, host, scope, frag);
  };
  fn.terminal = true;
  return fn;
}

/**
 * Compile the directives on an element and return a linker.
 *
 * @param {Array|NamedNodeMap} attrs
 * @param {Object} options
 * @return {Function}
 */

function compileDirectives(attrs, options) {
  var i = attrs.length;
  var dirs = [];
  var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens;
  while (i--) {
    attr = attrs[i];
    name = rawName = attr.name;
    value = rawValue = attr.value;
    tokens = parseText(value);
    // reset arg
    arg = null;
    // check modifiers
    modifiers = parseModifiers(name);
    name = name.replace(modifierRE, '');

    // attribute interpolations
    if (tokens) {
      value = tokensToExp(tokens);
      arg = name;
      pushDir('bind', publicDirectives.bind, tokens);
      // warn against mixing mustaches with v-bind
      if (process.env.NODE_ENV !== 'production') {
        if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
          return attr.name === ':class' || attr.name === 'v-bind:class';
        })) {
          warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.');
        }
      }
    } else

      // special attribute: transition
      if (transitionRE.test(name)) {
        modifiers.literal = !bindRE.test(name);
        pushDir('transition', internalDirectives.transition);
      } else

        // event handlers
        if (onRE.test(name)) {
          arg = name.replace(onRE, '');
          pushDir('on', publicDirectives.on);
        } else

          // attribute bindings
          if (bindRE.test(name)) {
            dirName = name.replace(bindRE, '');
            if (dirName === 'style' || dirName === 'class') {
              pushDir(dirName, internalDirectives[dirName]);
            } else {
              arg = dirName;
              pushDir('bind', publicDirectives.bind);
            }
          } else

            // normal directives
            if (name.indexOf('v-') === 0) {
              // check arg
              arg = (arg = name.match(argRE)) && arg[1];
              if (arg) {
                name = name.replace(argRE, '');
              }
              // extract directive name
              dirName = name.slice(2);

              // skip v-else (when used with v-show)
              if (dirName === 'else') {
                continue;
              }

              dirDef = resolveAsset(options, 'directives', dirName);

              if (process.env.NODE_ENV !== 'production') {
                assertAsset(dirDef, 'directive', dirName);
              }

              if (dirDef) {
                pushDir(dirName, dirDef);
              }
            }
  }

  /**
   * Push a directive.
   *
   * @param {String} dirName
   * @param {Object|Function} def
   * @param {Array} [interpTokens]
   */

  function pushDir(dirName, def, interpTokens) {
    var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
    var parsed = !hasOneTimeToken && parseDirective(value);
    dirs.push({
      name: dirName,
      attr: rawName,
      raw: rawValue,
      def: def,
      arg: arg,
      modifiers: modifiers,
      // conversion from interpolation strings with one-time token
      // to expression is differed until directive bind time so that we
      // have access to the actual vm context for one-time bindings.
      expression: parsed && parsed.expression,
      filters: parsed && parsed.filters,
      interp: interpTokens,
      hasOneTime: hasOneTimeToken
    });
  }

  if (dirs.length) {
    return makeNodeLinkFn(dirs);
  }
}

/**
 * Parse modifiers from directive attribute name.
 *
 * @param {String} name
 * @return {Object}
 */

function parseModifiers(name) {
  var res = Object.create(null);
  var match = name.match(modifierRE);
  if (match) {
    var i = match.length;
    while (i--) {
      res[match[i].slice(1)] = true;
    }
  }
  return res;
}

/**
 * Build a link function for all directives on a single node.
 *
 * @param {Array} directives
 * @return {Function} directivesLinkFn
 */

function makeNodeLinkFn(directives) {
  return function nodeLinkFn(vm, el, host, scope, frag) {
    // reverse apply because it's sorted low to high
    var i = directives.length;
    while (i--) {
      vm._bindDir(directives[i], el, host, scope, frag);
    }
  };
}

/**
 * Check if an interpolation string contains one-time tokens.
 *
 * @param {Array} tokens
 * @return {Boolean}
 */

function hasOneTime(tokens) {
  var i = tokens.length;
  while (i--) {
    if (tokens[i].oneTime) return true;
  }
}

var specialCharRE = /[^\w\-:\.]/;

/**
 * Process an element or a DocumentFragment based on a
 * instance option object. This allows us to transclude
 * a template node/fragment before the instance is created,
 * so the processed fragment can then be cloned and reused
 * in v-for.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Element|DocumentFragment}
 */

function transclude(el, options) {
  // extract container attributes to pass them down
  // to compiler, because they need to be compiled in
  // parent scope. we are mutating the options object here
  // assuming the same object will be used for compile
  // right after this.
  if (options) {
    options._containerAttrs = extractAttrs(el);
  }
  // for template tags, what we want is its content as
  // a documentFragment (for fragment instances)
  if (isTemplate(el)) {
    el = parseTemplate(el);
  }
  if (options) {
    if (options._asComponent && !options.template) {
      options.template = '<slot></slot>';
    }
    if (options.template) {
      options._content = extractContent(el);
      el = transcludeTemplate(el, options);
    }
  }
  if (el instanceof DocumentFragment) {
    // anchors for fragment instance
    // passing in `persist: true` to avoid them being
    // discarded by IE during template cloning
    prepend(createAnchor('v-start', true), el);
    el.appendChild(createAnchor('v-end', true));
  }
  return el;
}

/**
 * Process the template option.
 * If the replace option is true this will swap the $el.
 *
 * @param {Element} el
 * @param {Object} options
 * @return {Element|DocumentFragment}
 */

function transcludeTemplate(el, options) {
  var template = options.template;
  var frag = parseTemplate(template, true);
  if (frag) {
    var replacer = frag.firstChild;
    var tag = replacer.tagName && replacer.tagName.toLowerCase();
    if (options.replace) {
      /* istanbul ignore if */
      if (el === document.body) {
        process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
      }
      // there are many cases where the instance must
      // become a fragment instance: basically anything that
      // can create more than 1 root nodes.
      if (
      // multi-children template
      frag.childNodes.length > 1 ||
      // non-element template
      replacer.nodeType !== 1 ||
      // single nested component
      tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
      // element directive
      resolveAsset(options, 'elementDirectives', tag) ||
      // for block
      replacer.hasAttribute('v-for') ||
      // if block
      replacer.hasAttribute('v-if')) {
        return frag;
      } else {
        options._replacerAttrs = extractAttrs(replacer);
        mergeAttrs(el, replacer);
        return replacer;
      }
    } else {
      el.appendChild(frag);
      return el;
    }
  } else {
    process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
  }
}

/**
 * Helper to extract a component container's attributes
 * into a plain object array.
 *
 * @param {Element} el
 * @return {Array}
 */

function extractAttrs(el) {
  if (el.nodeType === 1 && el.hasAttributes()) {
    return toArray(el.attributes);
  }
}

/**
 * Merge the attributes of two elements, and make sure
 * the class names are merged properly.
 *
 * @param {Element} from
 * @param {Element} to
 */

function mergeAttrs(from, to) {
  var attrs = from.attributes;
  var i = attrs.length;
  var name, value;
  while (i--) {
    name = attrs[i].name;
    value = attrs[i].value;
    if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
      to.setAttribute(name, value);
    } else if (name === 'class' && !parseText(value)) {
      value.split(/\s+/).forEach(function (cls) {
        addClass(to, cls);
      });
    }
  }
}

var compiler = Object.freeze({
	compile: compile,
	compileAndLinkProps: compileAndLinkProps,
	compileRoot: compileRoot,
	terminalDirectives: terminalDirectives,
	transclude: transclude
});

function stateMixin (Vue) {

  /**
   * Accessor for `$data` property, since setting $data
   * requires observing the new object and updating
   * proxied properties.
   */

  Object.defineProperty(Vue.prototype, '$data', {
    get: function get() {
      return this._data;
    },
    set: function set(newData) {
      if (newData !== this._data) {
        this._setData(newData);
      }
    }
  });

  /**
   * Setup the scope of an instance, which contains:
   * - observed data
   * - computed properties
   * - user methods
   * - meta properties
   */

  Vue.prototype._initState = function () {
    this._initProps();
    this._initMeta();
    this._initMethods();
    this._initData();
    this._initComputed();
  };

  /**
   * Initialize props.
   */

  Vue.prototype._initProps = function () {
    var options = this.$options;
    var el = options.el;
    var props = options.props;
    if (props && !el) {
      process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');
    }
    // make sure to convert string selectors into element now
    el = options.el = query(el);
    this._propsUnlinkFn = el && el.nodeType === 1 && props
    // props must be linked in proper scope if inside v-for
    ? compileAndLinkProps(this, el, props, this._scope) : null;
  };

  /**
   * Initialize the data.
   */

  Vue.prototype._initData = function () {
    var propsData = this._data;
    var optionsDataFn = this.$options.data;
    var optionsData = optionsDataFn && optionsDataFn();
    if (optionsData) {
      this._data = optionsData;
      for (var prop in propsData) {
        if (process.env.NODE_ENV !== 'production' && hasOwn(optionsData, prop)) {
          warn('Data field "' + prop + '" is already defined ' + 'as a prop. Use prop default value instead.');
        }
        if (this._props[prop].raw !== null || !hasOwn(optionsData, prop)) {
          set(optionsData, prop, propsData[prop]);
        }
      }
    }
    var data = this._data;
    // proxy data on instance
    var keys = Object.keys(data);
    var i, key;
    i = keys.length;
    while (i--) {
      key = keys[i];
      this._proxy(key);
    }
    // observe data
    observe(data, this);
  };

  /**
   * Swap the instance's $data. Called in $data's setter.
   *
   * @param {Object} newData
   */

  Vue.prototype._setData = function (newData) {
    newData = newData || {};
    var oldData = this._data;
    this._data = newData;
    var keys, key, i;
    // unproxy keys not present in new data
    keys = Object.keys(oldData);
    i = keys.length;
    while (i--) {
      key = keys[i];
      if (!(key in newData)) {
        this._unproxy(key);
      }
    }
    // proxy keys not already proxied,
    // and trigger change for changed values
    keys = Object.keys(newData);
    i = keys.length;
    while (i--) {
      key = keys[i];
      if (!hasOwn(this, key)) {
        // new property
        this._proxy(key);
      }
    }
    oldData.__ob__.removeVm(this);
    observe(newData, this);
    this._digest();
  };

  /**
   * Proxy a property, so that
   * vm.prop === vm._data.prop
   *
   * @param {String} key
   */

  Vue.prototype._proxy = function (key) {
    if (!isReserved(key)) {
      // need to store ref to self here
      // because these getter/setters might
      // be called by child scopes via
      // prototype inheritance.
      var self = this;
      Object.defineProperty(self, key, {
        configurable: true,
        enumerable: true,
        get: function proxyGetter() {
          return self._data[key];
        },
        set: function proxySetter(val) {
          self._data[key] = val;
        }
      });
    }
  };

  /**
   * Unproxy a property.
   *
   * @param {String} key
   */

  Vue.prototype._unproxy = function (key) {
    if (!isReserved(key)) {
      delete this[key];
    }
  };

  /**
   * Force update on every watcher in scope.
   */

  Vue.prototype._digest = function () {
    for (var i = 0, l = this._watchers.length; i < l; i++) {
      this._watchers[i].update(true); // shallow updates
    }
  };

  /**
   * Setup computed properties. They are essentially
   * special getter/setters
   */

  function noop() {}
  Vue.prototype._initComputed = function () {
    var computed = this.$options.computed;
    if (computed) {
      for (var key in computed) {
        var userDef = computed[key];
        var def = {
          enumerable: true,
          configurable: true
        };
        if (typeof userDef === 'function') {
          def.get = makeComputedGetter(userDef, this);
          def.set = noop;
        } else {
          def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind$1(userDef.get, this) : noop;
          def.set = userDef.set ? bind$1(userDef.set, this) : noop;
        }
        Object.defineProperty(this, key, def);
      }
    }
  };

  function makeComputedGetter(getter, owner) {
    var watcher = new Watcher(owner, getter, null, {
      lazy: true
    });
    return function computedGetter() {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    };
  }

  /**
   * Setup instance methods. Methods must be bound to the
   * instance since they might be passed down as a prop to
   * child components.
   */

  Vue.prototype._initMethods = function () {
    var methods = this.$options.methods;
    if (methods) {
      for (var key in methods) {
        this[key] = bind$1(methods[key], this);
      }
    }
  };

  /**
   * Initialize meta information like $index, $key & $value.
   */

  Vue.prototype._initMeta = function () {
    var metas = this.$options._meta;
    if (metas) {
      for (var key in metas) {
        defineReactive(this, key, metas[key]);
      }
    }
  };
}

var eventRE = /^v-on:|^@/;

function eventsMixin (Vue) {

  /**
   * Setup the instance's option events & watchers.
   * If the value is a string, we pull it from the
   * instance's methods by name.
   */

  Vue.prototype._initEvents = function () {
    var options = this.$options;
    if (options._asComponent) {
      registerComponentEvents(this, options.el);
    }
    registerCallbacks(this, '$on', options.events);
    registerCallbacks(this, '$watch', options.watch);
  };

  /**
   * Register v-on events on a child component
   *
   * @param {Vue} vm
   * @param {Element} el
   */

  function registerComponentEvents(vm, el) {
    var attrs = el.attributes;
    var name, handler;
    for (var i = 0, l = attrs.length; i < l; i++) {
      name = attrs[i].name;
      if (eventRE.test(name)) {
        name = name.replace(eventRE, '');
        handler = (vm._scope || vm._context).$eval(attrs[i].value, true);
        handler._fromParent = true;
        vm.$on(name.replace(eventRE), handler);
      }
    }
  }

  /**
   * Register callbacks for option events and watchers.
   *
   * @param {Vue} vm
   * @param {String} action
   * @param {Object} hash
   */

  function registerCallbacks(vm, action, hash) {
    if (!hash) return;
    var handlers, key, i, j;
    for (key in hash) {
      handlers = hash[key];
      if (isArray(handlers)) {
        for (i = 0, j = handlers.length; i < j; i++) {
          register(vm, action, key, handlers[i]);
        }
      } else {
        register(vm, action, key, handlers);
      }
    }
  }

  /**
   * Helper to register an event/watch callback.
   *
   * @param {Vue} vm
   * @param {String} action
   * @param {String} key
   * @param {Function|String|Object} handler
   * @param {Object} [options]
   */

  function register(vm, action, key, handler, options) {
    var type = typeof handler;
    if (type === 'function') {
      vm[action](key, handler, options);
    } else if (type === 'string') {
      var methods = vm.$options.methods;
      var method = methods && methods[handler];
      if (method) {
        vm[action](key, method, options);
      } else {
        process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".');
      }
    } else if (handler && type === 'object') {
      register(vm, action, key, handler.handler, handler);
    }
  }

  /**
   * Setup recursive attached/detached calls
   */

  Vue.prototype._initDOMHooks = function () {
    this.$on('hook:attached', onAttached);
    this.$on('hook:detached', onDetached);
  };

  /**
   * Callback to recursively call attached hook on children
   */

  function onAttached() {
    if (!this._isAttached) {
      this._isAttached = true;
      this.$children.forEach(callAttach);
    }
  }

  /**
   * Iterator to call attached hook
   *
   * @param {Vue} child
   */

  function callAttach(child) {
    if (!child._isAttached && inDoc(child.$el)) {
      child._callHook('attached');
    }
  }

  /**
   * Callback to recursively call detached hook on children
   */

  function onDetached() {
    if (this._isAttached) {
      this._isAttached = false;
      this.$children.forEach(callDetach);
    }
  }

  /**
   * Iterator to call detached hook
   *
   * @param {Vue} child
   */

  function callDetach(child) {
    if (child._isAttached && !inDoc(child.$el)) {
      child._callHook('detached');
    }
  }

  /**
   * Trigger all handlers for a hook
   *
   * @param {String} hook
   */

  Vue.prototype._callHook = function (hook) {
    this.$emit('pre-hook:' + hook);
    var handlers = this.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        handlers[i].call(this);
      }
    }
    this.$emit('hook:' + hook);
  };
}

function noop() {}

/**
 * A directive links a DOM element with a piece of data,
 * which is the result of evaluating an expression.
 * It registers a watcher with the expression and calls
 * the DOM update function when a change is triggered.
 *
 * @param {String} name
 * @param {Node} el
 * @param {Vue} vm
 * @param {Object} descriptor
 *                 - {String} name
 *                 - {Object} def
 *                 - {String} expression
 *                 - {Array<Object>} [filters]
 *                 - {Boolean} literal
 *                 - {String} attr
 *                 - {String} raw
 * @param {Object} def - directive definition object
 * @param {Vue} [host] - transclusion host component
 * @param {Object} [scope] - v-for scope
 * @param {Fragment} [frag] - owner fragment
 * @constructor
 */
function Directive(descriptor, vm, el, host, scope, frag) {
  this.vm = vm;
  this.el = el;
  // copy descriptor properties
  this.descriptor = descriptor;
  this.name = descriptor.name;
  this.expression = descriptor.expression;
  this.arg = descriptor.arg;
  this.modifiers = descriptor.modifiers;
  this.filters = descriptor.filters;
  this.literal = this.modifiers && this.modifiers.literal;
  // private
  this._locked = false;
  this._bound = false;
  this._listeners = null;
  // link context
  this._host = host;
  this._scope = scope;
  this._frag = frag;
  // store directives on node in dev mode
  if (process.env.NODE_ENV !== 'production' && this.el) {
    this.el._vue_directives = this.el._vue_directives || [];
    this.el._vue_directives.push(this);
  }
}

/**
 * Initialize the directive, mixin definition properties,
 * setup the watcher, call definition bind() and update()
 * if present.
 *
 * @param {Object} def
 */

Directive.prototype._bind = function () {
  var name = this.name;
  var descriptor = this.descriptor;

  // remove attribute
  if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
    var attr = descriptor.attr || 'v-' + name;
    this.el.removeAttribute(attr);
  }

  // copy def properties
  var def = descriptor.def;
  if (typeof def === 'function') {
    this.update = def;
  } else {
    extend(this, def);
  }

  // setup directive params
  this._setupParams();

  // initial bind
  if (this.bind) {
    this.bind();
  }
  this._bound = true;

  if (this.literal) {
    this.update && this.update(descriptor.raw);
  } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
    // wrapped updater for context
    var dir = this;
    if (this.update) {
      this._update = function (val, oldVal) {
        if (!dir._locked) {
          dir.update(val, oldVal);
        }
      };
    } else {
      this._update = noop;
    }
    var preProcess = this._preProcess ? bind$1(this._preProcess, this) : null;
    var postProcess = this._postProcess ? bind$1(this._postProcess, this) : null;
    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
    {
      filters: this.filters,
      twoWay: this.twoWay,
      deep: this.deep,
      preProcess: preProcess,
      postProcess: postProcess,
      scope: this._scope
    });
    // v-model with inital inline value need to sync back to
    // model instead of update to DOM on init. They would
    // set the afterBind hook to indicate that.
    if (this.afterBind) {
      this.afterBind();
    } else if (this.update) {
      this.update(watcher.value);
    }
  }
};

/**
 * Setup all param attributes, e.g. track-by,
 * transition-mode, etc...
 */

Directive.prototype._setupParams = function () {
  if (!this.params) {
    return;
  }
  var params = this.params;
  // swap the params array with a fresh object.
  this.params = Object.create(null);
  var i = params.length;
  var key, val, mappedKey;
  while (i--) {
    key = params[i];
    mappedKey = camelize(key);
    val = getBindAttr(this.el, key);
    if (val != null) {
      // dynamic
      this._setupParamWatcher(mappedKey, val);
    } else {
      // static
      val = getAttr(this.el, key);
      if (val != null) {
        this.params[mappedKey] = val === '' ? true : val;
      }
    }
  }
};

/**
 * Setup a watcher for a dynamic param.
 *
 * @param {String} key
 * @param {String} expression
 */

Directive.prototype._setupParamWatcher = function (key, expression) {
  var self = this;
  var called = false;
  var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
    self.params[key] = val;
    // since we are in immediate mode,
    // only call the param change callbacks if this is not the first update.
    if (called) {
      var cb = self.paramWatchers && self.paramWatchers[key];
      if (cb) {
        cb.call(self, val, oldVal);
      }
    } else {
      called = true;
    }
  }, {
    immediate: true,
    user: false
  });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
};

/**
 * Check if the directive is a function caller
 * and if the expression is a callable one. If both true,
 * we wrap up the expression and use it as the event
 * handler.
 *
 * e.g. on-click="a++"
 *
 * @return {Boolean}
 */

Directive.prototype._checkStatement = function () {
  var expression = this.expression;
  if (expression && this.acceptStatement && !isSimplePath(expression)) {
    var fn = parseExpression(expression).get;
    var scope = this._scope || this.vm;
    var handler = function handler(e) {
      scope.$event = e;
      fn.call(scope, scope);
      scope.$event = null;
    };
    if (this.filters) {
      handler = scope._applyFilters(handler, null, this.filters);
    }
    this.update(handler);
    return true;
  }
};

/**
 * Set the corresponding value with the setter.
 * This should only be used in two-way directives
 * e.g. v-model.
 *
 * @param {*} value
 * @public
 */

Directive.prototype.set = function (value) {
  /* istanbul ignore else */
  if (this.twoWay) {
    this._withLock(function () {
      this._watcher.set(value);
    });
  } else if (process.env.NODE_ENV !== 'production') {
    warn('Directive.set() can only be used inside twoWay' + 'directives.');
  }
};

/**
 * Execute a function while preventing that function from
 * triggering updates on this directive instance.
 *
 * @param {Function} fn
 */

Directive.prototype._withLock = function (fn) {
  var self = this;
  self._locked = true;
  fn.call(self);
  nextTick(function () {
    self._locked = false;
  });
};

/**
 * Convenience method that attaches a DOM event listener
 * to the directive element and autometically tears it down
 * during unbind.
 *
 * @param {String} event
 * @param {Function} handler
 */

Directive.prototype.on = function (event, handler) {
  on$1(this.el, event, handler);(this._listeners || (this._listeners = [])).push([event, handler]);
};

/**
 * Teardown the watcher and call unbind.
 */

Directive.prototype._teardown = function () {
  if (this._bound) {
    this._bound = false;
    if (this.unbind) {
      this.unbind();
    }
    if (this._watcher) {
      this._watcher.teardown();
    }
    var listeners = this._listeners;
    var i;
    if (listeners) {
      i = listeners.length;
      while (i--) {
        off(this.el, listeners[i][0], listeners[i][1]);
      }
    }
    var unwatchFns = this._paramUnwatchFns;
    if (unwatchFns) {
      i = unwatchFns.length;
      while (i--) {
        unwatchFns[i]();
      }
    }
    if (process.env.NODE_ENV !== 'production' && this.el) {
      this.el._vue_directives.$remove(this);
    }
    this.vm = this.el = this._watcher = this._listeners = null;
  }
};

function lifecycleMixin (Vue) {

  /**
   * Update v-ref for component.
   *
   * @param {Boolean} remove
   */

  Vue.prototype._updateRef = function (remove) {
    var ref = this.$options._ref;
    if (ref) {
      var refs = (this._scope || this._context).$refs;
      if (remove) {
        if (refs[ref] === this) {
          refs[ref] = null;
        }
      } else {
        refs[ref] = this;
      }
    }
  };

  /**
   * Transclude, compile and link element.
   *
   * If a pre-compiled linker is available, that means the
   * passed in element will be pre-transcluded and compiled
   * as well - all we need to do is to call the linker.
   *
   * Otherwise we need to call transclude/compile/link here.
   *
   * @param {Element} el
   * @return {Element}
   */

  Vue.prototype._compile = function (el) {
    var options = this.$options;

    // transclude and init element
    // transclude can potentially replace original
    // so we need to keep reference; this step also injects
    // the template and caches the original attributes
    // on the container node and replacer node.
    var original = el;
    el = transclude(el, options);
    this._initElement(el);

    // handle v-pre on root node (#2026)
    if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
      return;
    }

    // root is always compiled per-instance, because
    // container attrs and props can be different every time.
    var contextOptions = this._context && this._context.$options;
    var rootLinker = compileRoot(el, options, contextOptions);

    // compile and link the rest
    var contentLinkFn;
    var ctor = this.constructor;
    // component compilation can be cached
    // as long as it's not using inline-template
    if (options._linkerCachable) {
      contentLinkFn = ctor.linker;
      if (!contentLinkFn) {
        contentLinkFn = ctor.linker = compile(el, options);
      }
    }

    // link phase
    // make sure to link root with prop scope!
    var rootUnlinkFn = rootLinker(this, el, this._scope);
    var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);

    // register composite unlink function
    // to be called during instance destruction
    this._unlinkFn = function () {
      rootUnlinkFn();
      // passing destroying: true to avoid searching and
      // splicing the directives
      contentUnlinkFn(true);
    };

    // finally replace original
    if (options.replace) {
      replace(original, el);
    }

    this._isCompiled = true;
    this._callHook('compiled');
    return el;
  };

  /**
   * Initialize instance element. Called in the public
   * $mount() method.
   *
   * @param {Element} el
   */

  Vue.prototype._initElement = function (el) {
    if (el instanceof DocumentFragment) {
      this._isFragment = true;
      this.$el = this._fragmentStart = el.firstChild;
      this._fragmentEnd = el.lastChild;
      // set persisted text anchors to empty
      if (this._fragmentStart.nodeType === 3) {
        this._fragmentStart.data = this._fragmentEnd.data = '';
      }
      this._fragment = el;
    } else {
      this.$el = el;
    }
    this.$el.__vue__ = this;
    this._callHook('beforeCompile');
  };

  /**
   * Create and bind a directive to an element.
   *
   * @param {String} name - directive name
   * @param {Node} node   - target node
   * @param {Object} desc - parsed directive descriptor
   * @param {Object} def  - directive definition object
   * @param {Vue} [host] - transclusion host component
   * @param {Object} [scope] - v-for scope
   * @param {Fragment} [frag] - owner fragment
   */

  Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
    this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
  };

  /**
   * Teardown an instance, unobserves the data, unbind all the
   * directives, turn off all the event listeners, etc.
   *
   * @param {Boolean} remove - whether to remove the DOM node.
   * @param {Boolean} deferCleanup - if true, defer cleanup to
   *                                 be called later
   */

  Vue.prototype._destroy = function (remove, deferCleanup) {
    if (this._isBeingDestroyed) {
      if (!deferCleanup) {
        this._cleanup();
      }
      return;
    }

    var destroyReady;
    var pendingRemoval;

    var self = this;
    // Cleanup should be called either synchronously or asynchronoysly as
    // callback of this.$remove(), or if remove and deferCleanup are false.
    // In any case it should be called after all other removing, unbinding and
    // turning of is done
    var cleanupIfPossible = function cleanupIfPossible() {
      if (destroyReady && !pendingRemoval && !deferCleanup) {
        self._cleanup();
      }
    };

    // remove DOM element
    if (remove && this.$el) {
      pendingRemoval = true;
      this.$remove(function () {
        pendingRemoval = false;
        cleanupIfPossible();
      });
    }

    this._callHook('beforeDestroy');
    this._isBeingDestroyed = true;
    var i;
    // remove self from parent. only necessary
    // if parent is not being destroyed as well.
    var parent = this.$parent;
    if (parent && !parent._isBeingDestroyed) {
      parent.$children.$remove(this);
      // unregister ref (remove: true)
      this._updateRef(true);
    }
    // destroy all children.
    i = this.$children.length;
    while (i--) {
      this.$children[i].$destroy();
    }
    // teardown props
    if (this._propsUnlinkFn) {
      this._propsUnlinkFn();
    }
    // teardown all directives. this also tearsdown all
    // directive-owned watchers.
    if (this._unlinkFn) {
      this._unlinkFn();
    }
    i = this._watchers.length;
    while (i--) {
      this._watchers[i].teardown();
    }
    // remove reference to self on $el
    if (this.$el) {
      this.$el.__vue__ = null;
    }

    destroyReady = true;
    cleanupIfPossible();
  };

  /**
   * Clean up to ensure garbage collection.
   * This is called after the leave transition if there
   * is any.
   */

  Vue.prototype._cleanup = function () {
    if (this._isDestroyed) {
      return;
    }
    // remove self from owner fragment
    // do it in cleanup so that we can call $destroy with
    // defer right when a fragment is about to be removed.
    if (this._frag) {
      this._frag.children.$remove(this);
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (this._data.__ob__) {
      this._data.__ob__.removeVm(this);
    }
    // Clean up references to private properties and other
    // instances. preserve reference to _data so that proxy
    // accessors still work. The only potential side effect
    // here is that mutating the instance after it's destroyed
    // may affect the state of other components that are still
    // observing the same object, but that seems to be a
    // reasonable responsibility for the user rather than
    // always throwing an error on them.
    this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
    // call the last hook...
    this._isDestroyed = true;
    this._callHook('destroyed');
    // turn off all instance listeners.
    this.$off();
  };
}

function miscMixin (Vue) {

  /**
   * Apply a list of filter (descriptors) to a value.
   * Using plain for loops here because this will be called in
   * the getter of any watcher with filters so it is very
   * performance sensitive.
   *
   * @param {*} value
   * @param {*} [oldValue]
   * @param {Array} filters
   * @param {Boolean} write
   * @return {*}
   */

  Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
    var filter, fn, args, arg, offset, i, l, j, k;
    for (i = 0, l = filters.length; i < l; i++) {
      filter = filters[i];
      fn = resolveAsset(this.$options, 'filters', filter.name);
      if (process.env.NODE_ENV !== 'production') {
        assertAsset(fn, 'filter', filter.name);
      }
      if (!fn) continue;
      fn = write ? fn.write : fn.read || fn;
      if (typeof fn !== 'function') continue;
      args = write ? [value, oldValue] : [value];
      offset = write ? 2 : 1;
      if (filter.args) {
        for (j = 0, k = filter.args.length; j < k; j++) {
          arg = filter.args[j];
          args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
        }
      }
      value = fn.apply(this, args);
    }
    return value;
  };

  /**
   * Resolve a component, depending on whether the component
   * is defined normally or using an async factory function.
   * Resolves synchronously if already resolved, otherwise
   * resolves asynchronously and caches the resolved
   * constructor on the factory.
   *
   * @param {String} id
   * @param {Function} cb
   */

  Vue.prototype._resolveComponent = function (id, cb) {
    var factory = resolveAsset(this.$options, 'components', id);
    if (process.env.NODE_ENV !== 'production') {
      assertAsset(factory, 'component', id);
    }
    if (!factory) {
      return;
    }
    // async component factory
    if (!factory.options) {
      if (factory.resolved) {
        // cached
        cb(factory.resolved);
      } else if (factory.requested) {
        // pool callbacks
        factory.pendingCallbacks.push(cb);
      } else {
        factory.requested = true;
        var cbs = factory.pendingCallbacks = [cb];
        factory(function resolve(res) {
          if (isPlainObject(res)) {
            res = Vue.extend(res);
          }
          // cache resolved
          factory.resolved = res;
          // invoke callbacks
          for (var i = 0, l = cbs.length; i < l; i++) {
            cbs[i](res);
          }
        }, function reject(reason) {
          process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\nReason: ' + reason : ''));
        });
      }
    } else {
      // normal component
      cb(factory);
    }
  };
}

function globalAPI (Vue) {

  /**
   * Expose useful internals
   */

  Vue.util = util;
  Vue.config = config;
  Vue.set = set;
  Vue['delete'] = del;
  Vue.nextTick = nextTick;

  /**
   * The following are exposed for advanced usage / plugins
   */

  Vue.compiler = compiler;
  Vue.FragmentFactory = FragmentFactory;
  Vue.internalDirectives = internalDirectives;
  Vue.parsers = {
    path: path,
    text: text$1,
    template: template,
    directive: directive,
    expression: expression
  };

  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */

  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   *
   * @param {Object} extendOptions
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var isFirstExtend = Super.cid === 0;
    if (isFirstExtend && extendOptions._Ctor) {
      return extendOptions._Ctor;
    }
    var name = extendOptions.name || Super.options.name;
    if (process.env.NODE_ENV !== 'production') {
      if (!/^[a-zA-Z][\w-]+$/.test(name)) {
        warn('Invalid component name: ' + name);
        name = null;
      }
    }
    var Sub = createClass(name || 'VueComponent');
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;
    // allow further extension
    Sub.extend = Super.extend;
    // create asset registers, so extended classes
    // can have their private assets too.
    config._assetTypes.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }
    // cache constructor
    if (isFirstExtend) {
      extendOptions._Ctor = Sub;
    }
    return Sub;
  };

  /**
   * A function that returns a sub-class constructor with the
   * given name. This gives us much nicer output when
   * logging instances in the console.
   *
   * @param {String} name
   * @return {Function}
   */

  function createClass(name) {
    return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
  }

  /**
   * Plugin system
   *
   * @param {Object} plugin
   */

  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };

  /**
   * Apply a global mixin by merging it into the default
   * options.
   */

  Vue.mixin = function (mixin) {
    Vue.options = mergeOptions(Vue.options, mixin);
  };

  /**
   * Create asset registration methods with the following
   * signature:
   *
   * @param {String} id
   * @param {*} definition
   */

  config._assetTypes.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production') {
          if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = id;
          definition = Vue.extend(definition);
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

var filterRE = /[^|]\|[^|]/;

function dataAPI (Vue) {

  /**
   * Get the value from an expression on this vm.
   *
   * @param {String} exp
   * @param {Boolean} [asStatement]
   * @return {*}
   */

  Vue.prototype.$get = function (exp, asStatement) {
    var res = parseExpression(exp);
    if (res) {
      if (asStatement && !isSimplePath(exp)) {
        var self = this;
        return function statementHandler() {
          self.$arguments = toArray(arguments);
          var result = res.get.call(self, self);
          self.$arguments = null;
          return result;
        };
      } else {
        try {
          return res.get.call(this, this);
        } catch (e) {}
      }
    }
  };

  /**
   * Set the value from an expression on this vm.
   * The expression must be a valid left-hand
   * expression in an assignment.
   *
   * @param {String} exp
   * @param {*} val
   */

  Vue.prototype.$set = function (exp, val) {
    var res = parseExpression(exp, true);
    if (res && res.set) {
      res.set.call(this, this, val);
    }
  };

  /**
   * Delete a property on the VM
   *
   * @param {String} key
   */

  Vue.prototype.$delete = function (key) {
    del(this._data, key);
  };

  /**
   * Watch an expression, trigger callback when its
   * value changes.
   *
   * @param {String|Function} expOrFn
   * @param {Function} cb
   * @param {Object} [options]
   *                 - {Boolean} deep
   *                 - {Boolean} immediate
   * @return {Function} - unwatchFn
   */

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    var parsed;
    if (typeof expOrFn === 'string') {
      parsed = parseDirective(expOrFn);
      expOrFn = parsed.expression;
    }
    var watcher = new Watcher(vm, expOrFn, cb, {
      deep: options && options.deep,
      sync: options && options.sync,
      filters: parsed && parsed.filters,
      user: !options || options.user !== false
    });
    if (options && options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };

  /**
   * Evaluate a text directive, including filters.
   *
   * @param {String} text
   * @param {Boolean} [asStatement]
   * @return {String}
   */

  Vue.prototype.$eval = function (text, asStatement) {
    // check for filters.
    if (filterRE.test(text)) {
      var dir = parseDirective(text);
      // the filter regex check might give false positive
      // for pipes inside strings, so it's possible that
      // we don't get any filters here
      var val = this.$get(dir.expression, asStatement);
      return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
    } else {
      // no filter
      return this.$get(text, asStatement);
    }
  };

  /**
   * Interpolate a piece of template text.
   *
   * @param {String} text
   * @return {String}
   */

  Vue.prototype.$interpolate = function (text) {
    var tokens = parseText(text);
    var vm = this;
    if (tokens) {
      if (tokens.length === 1) {
        return vm.$eval(tokens[0].value) + '';
      } else {
        return tokens.map(function (token) {
          return token.tag ? vm.$eval(token.value) : token.value;
        }).join('');
      }
    } else {
      return text;
    }
  };

  /**
   * Log instance data as a plain JS object
   * so that it is easier to inspect in console.
   * This method assumes console is available.
   *
   * @param {String} [path]
   */

  Vue.prototype.$log = function (path) {
    var data = path ? getPath(this._data, path) : this._data;
    if (data) {
      data = clean(data);
    }
    // include computed fields
    if (!path) {
      for (var key in this.$options.computed) {
        data[key] = clean(this[key]);
      }
    }
    console.log(data);
  };

  /**
   * "clean" a getter/setter converted object into a plain
   * object copy.
   *
   * @param {Object} - obj
   * @return {Object}
   */

  function clean(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
}

function domAPI (Vue) {

  /**
   * Convenience on-instance nextTick. The callback is
   * auto-bound to the instance, and this avoids component
   * modules having to rely on the global Vue.
   *
   * @param {Function} fn
   */

  Vue.prototype.$nextTick = function (fn) {
    nextTick(fn, this);
  };

  /**
   * Append instance to target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$appendTo = function (target, cb, withTransition) {
    return insert(this, target, cb, withTransition, append, appendWithTransition);
  };

  /**
   * Prepend instance to target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$prependTo = function (target, cb, withTransition) {
    target = query(target);
    if (target.hasChildNodes()) {
      this.$before(target.firstChild, cb, withTransition);
    } else {
      this.$appendTo(target, cb, withTransition);
    }
    return this;
  };

  /**
   * Insert instance before target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$before = function (target, cb, withTransition) {
    return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
  };

  /**
   * Insert instance after target
   *
   * @param {Node} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$after = function (target, cb, withTransition) {
    target = query(target);
    if (target.nextSibling) {
      this.$before(target.nextSibling, cb, withTransition);
    } else {
      this.$appendTo(target.parentNode, cb, withTransition);
    }
    return this;
  };

  /**
   * Remove instance from DOM
   *
   * @param {Function} [cb]
   * @param {Boolean} [withTransition] - defaults to true
   */

  Vue.prototype.$remove = function (cb, withTransition) {
    if (!this.$el.parentNode) {
      return cb && cb();
    }
    var inDocument = this._isAttached && inDoc(this.$el);
    // if we are not in document, no need to check
    // for transitions
    if (!inDocument) withTransition = false;
    var self = this;
    var realCb = function realCb() {
      if (inDocument) self._callHook('detached');
      if (cb) cb();
    };
    if (this._isFragment) {
      removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
    } else {
      var op = withTransition === false ? removeWithCb : removeWithTransition;
      op(this.$el, this, realCb);
    }
    return this;
  };

  /**
   * Shared DOM insertion function.
   *
   * @param {Vue} vm
   * @param {Element} target
   * @param {Function} [cb]
   * @param {Boolean} [withTransition]
   * @param {Function} op1 - op for non-transition insert
   * @param {Function} op2 - op for transition insert
   * @return vm
   */

  function insert(vm, target, cb, withTransition, op1, op2) {
    target = query(target);
    var targetIsDetached = !inDoc(target);
    var op = withTransition === false || targetIsDetached ? op1 : op2;
    var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
    if (vm._isFragment) {
      mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
        op(node, target, vm);
      });
      cb && cb();
    } else {
      op(vm.$el, target, vm, cb);
    }
    if (shouldCallHook) {
      vm._callHook('attached');
    }
    return vm;
  }

  /**
   * Check for selectors
   *
   * @param {String|Element} el
   */

  function query(el) {
    return typeof el === 'string' ? document.querySelector(el) : el;
  }

  /**
   * Append operation that takes a callback.
   *
   * @param {Node} el
   * @param {Node} target
   * @param {Vue} vm - unused
   * @param {Function} [cb]
   */

  function append(el, target, vm, cb) {
    target.appendChild(el);
    if (cb) cb();
  }

  /**
   * InsertBefore operation that takes a callback.
   *
   * @param {Node} el
   * @param {Node} target
   * @param {Vue} vm - unused
   * @param {Function} [cb]
   */

  function beforeWithCb(el, target, vm, cb) {
    before(el, target);
    if (cb) cb();
  }

  /**
   * Remove operation that takes a callback.
   *
   * @param {Node} el
   * @param {Vue} vm - unused
   * @param {Function} [cb]
   */

  function removeWithCb(el, vm, cb) {
    remove(el);
    if (cb) cb();
  }
}

function eventsAPI (Vue) {

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   */

  Vue.prototype.$on = function (event, fn) {
    (this._events[event] || (this._events[event] = [])).push(fn);
    modifyListenerCount(this, event, 1);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   */

  Vue.prototype.$once = function (event, fn) {
    var self = this;
    function on() {
      self.$off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.$on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   */

  Vue.prototype.$off = function (event, fn) {
    var cbs;
    // all
    if (!arguments.length) {
      if (this.$parent) {
        for (event in this._events) {
          cbs = this._events[event];
          if (cbs) {
            modifyListenerCount(this, event, -cbs.length);
          }
        }
      }
      this._events = {};
      return this;
    }
    // specific event
    cbs = this._events[event];
    if (!cbs) {
      return this;
    }
    if (arguments.length === 1) {
      modifyListenerCount(this, event, -cbs.length);
      this._events[event] = null;
      return this;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        modifyListenerCount(this, event, -1);
        cbs.splice(i, 1);
        break;
      }
    }
    return this;
  };

  /**
   * Trigger an event on self.
   *
   * @param {String|Object} event
   * @return {Boolean} shouldPropagate
   */

  Vue.prototype.$emit = function (event) {
    var isSource = typeof event === 'string';
    event = isSource ? event : event.name;
    var cbs = this._events[event];
    var shouldPropagate = isSource || !cbs;
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      // this is a somewhat hacky solution to the question raised
      // in #2102: for an inline component listener like <comp @test="doThis">,
      // the propagation handling is somewhat broken. Therefore we
      // need to treat these inline callbacks differently.
      var hasParentCbs = isSource && cbs.some(function (cb) {
        return cb._fromParent;
      });
      if (hasParentCbs) {
        shouldPropagate = false;
      }
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        var cb = cbs[i];
        var res = cb.apply(this, args);
        if (res === true && (!hasParentCbs || cb._fromParent)) {
          shouldPropagate = true;
        }
      }
    }
    return shouldPropagate;
  };

  /**
   * Recursively broadcast an event to all children instances.
   *
   * @param {String|Object} event
   * @param {...*} additional arguments
   */

  Vue.prototype.$broadcast = function (event) {
    var isSource = typeof event === 'string';
    event = isSource ? event : event.name;
    // if no child has registered for this event,
    // then there's no need to broadcast.
    if (!this._eventsCount[event]) return;
    var children = this.$children;
    var args = toArray(arguments);
    if (isSource) {
      // use object event to indicate non-source emit
      // on children
      args[0] = { name: event, source: this };
    }
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var shouldPropagate = child.$emit.apply(child, args);
      if (shouldPropagate) {
        child.$broadcast.apply(child, args);
      }
    }
    return this;
  };

  /**
   * Recursively propagate an event up the parent chain.
   *
   * @param {String} event
   * @param {...*} additional arguments
   */

  Vue.prototype.$dispatch = function (event) {
    var shouldPropagate = this.$emit.apply(this, arguments);
    if (!shouldPropagate) return;
    var parent = this.$parent;
    var args = toArray(arguments);
    // use object event to indicate non-source emit
    // on parents
    args[0] = { name: event, source: this };
    while (parent) {
      shouldPropagate = parent.$emit.apply(parent, args);
      parent = shouldPropagate ? parent.$parent : null;
    }
    return this;
  };

  /**
   * Modify the listener counts on all parents.
   * This bookkeeping allows $broadcast to return early when
   * no child has listened to a certain event.
   *
   * @param {Vue} vm
   * @param {String} event
   * @param {Number} count
   */

  var hookRE = /^hook:/;
  function modifyListenerCount(vm, event, count) {
    var parent = vm.$parent;
    // hooks do not get broadcasted so no need
    // to do bookkeeping for them
    if (!parent || !count || hookRE.test(event)) return;
    while (parent) {
      parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
      parent = parent.$parent;
    }
  }
}

function lifecycleAPI (Vue) {

  /**
   * Set instance target element and kick off the compilation
   * process. The passed in `el` can be a selector string, an
   * existing Element, or a DocumentFragment (for block
   * instances).
   *
   * @param {Element|DocumentFragment|string} el
   * @public
   */

  Vue.prototype.$mount = function (el) {
    if (this._isCompiled) {
      process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.');
      return;
    }
    el = query(el);
    if (!el) {
      el = document.createElement('div');
    }
    this._compile(el);
    this._initDOMHooks();
    if (inDoc(this.$el)) {
      this._callHook('attached');
      ready.call(this);
    } else {
      this.$once('hook:attached', ready);
    }
    return this;
  };

  /**
   * Mark an instance as ready.
   */

  function ready() {
    this._isAttached = true;
    this._isReady = true;
    this._callHook('ready');
  }

  /**
   * Teardown the instance, simply delegate to the internal
   * _destroy.
   */

  Vue.prototype.$destroy = function (remove, deferCleanup) {
    this._destroy(remove, deferCleanup);
  };

  /**
   * Partially compile a piece of DOM and return a
   * decompile function.
   *
   * @param {Element|DocumentFragment} el
   * @param {Vue} [host]
   * @return {Function}
   */

  Vue.prototype.$compile = function (el, host, scope, frag) {
    return compile(el, this.$options, true)(this, el, host, scope, frag);
  };
}

/**
 * The exposed Vue constructor.
 *
 * API conventions:
 * - public API methods/properties are prefixed with `$`
 * - internal methods/properties are prefixed with `_`
 * - non-prefixed properties are assumed to be proxied user
 *   data.
 *
 * @constructor
 * @param {Object} [options]
 * @public
 */

function Vue(options) {
  this._init(options);
}

// install internals
initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
miscMixin(Vue);

// install APIs
globalAPI(Vue);
dataAPI(Vue);
domAPI(Vue);
eventsAPI(Vue);
lifecycleAPI(Vue);

var convertArray = vFor._postProcess;

/**
 * Limit filter for arrays
 *
 * @param {Number} n
 * @param {Number} offset (Decimal expected)
 */

function limitBy(arr, n, offset) {
  offset = offset ? parseInt(offset, 10) : 0;
  n = toNumber(n);
  return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
}

/**
 * Filter filter for arrays
 *
 * @param {String} search
 * @param {String} [delimiter]
 * @param {String} ...dataKeys
 */

function filterBy(arr, search, delimiter) {
  arr = convertArray(arr);
  if (search == null) {
    return arr;
  }
  if (typeof search === 'function') {
    return arr.filter(search);
  }
  // cast to lowercase string
  search = ('' + search).toLowerCase();
  // allow optional `in` delimiter
  // because why not
  var n = delimiter === 'in' ? 3 : 2;
  // extract and flatten keys
  var keys = toArray(arguments, n).reduce(function (prev, cur) {
    return prev.concat(cur);
  }, []);
  var res = [];
  var item, key, val, j;
  for (var i = 0, l = arr.length; i < l; i++) {
    item = arr[i];
    val = item && item.$value || item;
    j = keys.length;
    if (j) {
      while (j--) {
        key = keys[j];
        if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
          res.push(item);
          break;
        }
      }
    } else if (contains(item, search)) {
      res.push(item);
    }
  }
  return res;
}

/**
 * Filter filter for arrays
 *
 * @param {String} sortKey
 * @param {String} reverse
 */

function orderBy(arr, sortKey, reverse) {
  arr = convertArray(arr);
  if (!sortKey) {
    return arr;
  }
  var order = reverse && reverse < 0 ? -1 : 1;
  // sort on a copy to avoid mutating original array
  return arr.slice().sort(function (a, b) {
    if (sortKey !== '$key') {
      if (isObject(a) && '$value' in a) a = a.$value;
      if (isObject(b) && '$value' in b) b = b.$value;
    }
    a = isObject(a) ? getPath(a, sortKey) : a;
    b = isObject(b) ? getPath(b, sortKey) : b;
    return a === b ? 0 : a > b ? order : -order;
  });
}

/**
 * String contain helper
 *
 * @param {*} val
 * @param {String} search
 */

function contains(val, search) {
  var i;
  if (isPlainObject(val)) {
    var keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      if (contains(val[keys[i]], search)) {
        return true;
      }
    }
  } else if (isArray(val)) {
    i = val.length;
    while (i--) {
      if (contains(val[i], search)) {
        return true;
      }
    }
  } else if (val != null) {
    return val.toString().toLowerCase().indexOf(search) > -1;
  }
}

var digitsRE = /(\d{3})(?=\d)/g;

// asset collections must be a plain object.
var filters = {

  orderBy: orderBy,
  filterBy: filterBy,
  limitBy: limitBy,

  /**
   * Stringify value.
   *
   * @param {Number} indent
   */

  json: {
    read: function read(value, indent) {
      return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
    },
    write: function write(value) {
      try {
        return JSON.parse(value);
      } catch (e) {
        return value;
      }
    }
  },

  /**
   * 'abc' => 'Abc'
   */

  capitalize: function capitalize(value) {
    if (!value && value !== 0) return '';
    value = value.toString();
    return value.charAt(0).toUpperCase() + value.slice(1);
  },

  /**
   * 'abc' => 'ABC'
   */

  uppercase: function uppercase(value) {
    return value || value === 0 ? value.toString().toUpperCase() : '';
  },

  /**
   * 'AbC' => 'abc'
   */

  lowercase: function lowercase(value) {
    return value || value === 0 ? value.toString().toLowerCase() : '';
  },

  /**
   * 12345 => $12,345.00
   *
   * @param {String} sign
   */

  currency: function currency(value, _currency) {
    value = parseFloat(value);
    if (!isFinite(value) || !value && value !== 0) return '';
    _currency = _currency != null ? _currency : '$';
    var stringified = Math.abs(value).toFixed(2);
    var _int = stringified.slice(0, -3);
    var i = _int.length % 3;
    var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
    var _float = stringified.slice(-3);
    var sign = value < 0 ? '-' : '';
    return _currency + sign + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
  },

  /**
   * 'item' => 'items'
   *
   * @params
   *  an array of strings corresponding to
   *  the single, double, triple ... forms of the word to
   *  be pluralized. When the number to be pluralized
   *  exceeds the length of the args, it will use the last
   *  entry in the array.
   *
   *  e.g. ['single', 'double', 'triple', 'multiple']
   */

  pluralize: function pluralize(value) {
    var args = toArray(arguments, 1);
    return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
  },

  /**
   * Debounce a handler function.
   *
   * @param {Function} handler
   * @param {Number} delay = 300
   * @return {Function}
   */

  debounce: function debounce(handler, delay) {
    if (!handler) return;
    if (!delay) {
      delay = 300;
    }
    return _debounce(handler, delay);
  }
};

var partial = {

  priority: PARTIAL,

  params: ['name'],

  // watch changes to name for dynamic partials
  paramWatchers: {
    name: function name(value) {
      vIf.remove.call(this);
      if (value) {
        this.insert(value);
      }
    }
  },

  bind: function bind() {
    this.anchor = createAnchor('v-partial');
    replace(this.el, this.anchor);
    this.insert(this.params.name);
  },

  insert: function insert(id) {
    var partial = resolveAsset(this.vm.$options, 'partials', id);
    if (process.env.NODE_ENV !== 'production') {
      assertAsset(partial, 'partial', id);
    }
    if (partial) {
      this.factory = new FragmentFactory(this.vm, partial);
      vIf.insert.call(this);
    }
  },

  unbind: function unbind() {
    if (this.frag) {
      this.frag.destroy();
    }
  }
};

// This is the elementDirective that handles <content>
// transclusions. It relies on the raw content of an
// instance being stored as `$options._content` during
// the transclude phase.

// We are exporting two versions, one for named and one
// for unnamed, because the unnamed slots must be compiled
// AFTER all named slots have selected their content. So
// we need to give them different priorities in the compilation
// process. (See #1965)

var slot = {

  priority: SLOT,

  bind: function bind() {
    var host = this.vm;
    var raw = host.$options._content;
    if (!raw) {
      this.fallback();
      return;
    }
    var context = host._context;
    var slotName = this.params && this.params.name;
    if (!slotName) {
      // Default slot
      this.tryCompile(extractFragment(raw.childNodes, raw, true), context, host);
    } else {
      // Named slot
      var selector = '[slot="' + slotName + '"]';
      var nodes = raw.querySelectorAll(selector);
      if (nodes.length) {
        this.tryCompile(extractFragment(nodes, raw), context, host);
      } else {
        this.fallback();
      }
    }
  },

  tryCompile: function tryCompile(content, context, host) {
    if (content.hasChildNodes()) {
      this.compile(content, context, host);
    } else {
      this.fallback();
    }
  },

  compile: function compile(content, context, host) {
    if (content && context) {
      var scope = host ? host._scope : this._scope;
      this.unlink = context.$compile(content, host, scope, this._frag);
    }
    if (content) {
      replace(this.el, content);
    } else {
      remove(this.el);
    }
  },

  fallback: function fallback() {
    this.compile(extractContent(this.el, true), this.vm);
  },

  unbind: function unbind() {
    if (this.unlink) {
      this.unlink();
    }
  }
};

var namedSlot = extend(extend({}, slot), {
  priority: slot.priority + 1,
  params: ['name']
});

/**
 * Extract qualified content nodes from a node list.
 *
 * @param {NodeList} nodes
 * @param {Element} parent
 * @param {Boolean} main
 * @return {DocumentFragment}
 */

function extractFragment(nodes, parent, main) {
  var frag = document.createDocumentFragment();
  for (var i = 0, l = nodes.length; i < l; i++) {
    var node = nodes[i];
    // if this is the main outlet, we want to skip all
    // previously selected nodes;
    // otherwise, we want to mark the node as selected.
    // clone the node so the original raw content remains
    // intact. this ensures proper re-compilation in cases
    // where the outlet is inside a conditional block
    if (main && !node.__v_selected) {
      append(node);
    } else if (!main && node.parentNode === parent) {
      node.__v_selected = true;
      append(node);
    }
  }
  return frag;

  function append(node) {
    if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
      node = parseTemplate(node);
    }
    node = cloneNode(node);
    frag.appendChild(node);
  }
}

var elementDirectives = {
  slot: slot,
  _namedSlot: namedSlot, // same as slot but with higher priority
  partial: partial
};

Vue.version = '1.0.15';

/**
 * Vue and every constructor that extends Vue has an
 * associated options object, which can be accessed during
 * compilation steps as `this.constructor.options`.
 *
 * These can be seen as the default options of every
 * Vue instance.
 */

Vue.options = {
  directives: publicDirectives,
  elementDirectives: elementDirectives,
  filters: filters,
  transitions: {},
  components: {},
  partials: {},
  replace: true
};

// devtools global hook
/* istanbul ignore if */
if (process.env.NODE_ENV !== 'production' && inBrowser) {
  if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
    window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue);
  } else if (/Chrome\/\d+/.test(navigator.userAgent)) {
    console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
  }
}

module.exports = Vue;
}).call(this,require('_process'))

},{"_process":21}],26:[function(require,module,exports){
module.exports = '<!--  -->\n\n<div class="bar bar-header bar-positive" v-touch:taphold="showTuts">\n    <button class="button button-icon icon-left icon ion-person-add" v-link="{ name: \'public.register\' }">Register</button>\n    <h1 class="title">Convoy</h1>\n    <button class="button button-icon icon-right icon ion-person" v-link="{ name: \'public.login\' }">Login</button>\n</div>\n\n<div id="content">\n    <div class="card">\n        <div class="item item-text-wrap">\n            <center>\n                <img src="/img/logo_blk.png" class="">\n            </center>\n        </div>\n        <li class="item item-divider">\n            <button class="button button-block button-positive" v-touch:tap="dev1">Open</button>\n            <button class="button button-block button-positive" v-touch:tap="dev2">Close</button>\n            <button class="button button-block button-positive" v-touch:tap="dev3">Dev3</button>\n        </li>\n    </div>\n</div>\n\n';
},{}],27:[function(require,module,exports){
module.exports = '<!--  -->\n\n<div class="row">\n    <div class="col col-100">\n        <p class="t-center t-huge">Getting Started</p>\n    </div>\n</div>\n\n<hr>\n\n<div class="row">\n    <div class="col col-100">\n        <p class="t-big">\n            <strong class="color-balanced">Activate quick tutorials</strong> by one of:\n        </p>\n        <ul class="t-list">\n            <li>\n                <strong class="color-energized">TAP HOLD</strong> the\n                <strong class="color-calm">top title bar</strong>\n            </li>\n            <li>\n                <strong class="color-energized">SWIPE UP</strong> on the\n                <strong class="color-calm">swipe bar</strong>\n            </li>\n            <li>\n                Each view has a different tutorial\n            </li>\n        </ul>\n    </div>\n</div>\n\n<hr>\n\n<div class="row">\n    <div class="col col-100">\n        <!-- <p class="t-big">Using the swipe bar:</p> -->\n        <ul class="t-list">\n            <!-- <li><u>You don\'t have to use the swipe bar.</u></li> -->\n            <li>The swipe bar provides the user an easy &amp; fluent experience. It adapts to the current view you\'re on providing\n                you dynamic action buttons directly below your thumb.\n            </li>\n        </ul>\n    </div>\n</div>\n\n\n\n<div class="row bottom-3">\n    <div class="col col-33 t-center">\n        <p>\n            <strong class="color-energized">SWIPE RIGHT</strong>\n        </p>\n        <p>\n            <strong class="color-calm">Go Back</strong>\n        </p>\n    </div>\n    <div class="col col-33 t-center">\n        <p>\n            <strong class="color-energized">SWIPE UP</strong>\n        </p>\n        <p>\n            <strong class="color-calm">Tutorial</strong>\n        </p>\n    </div>\n    <div class="col col-33 t-center">\n        <p>\n            <strong class="color-energized">SWIPE LEFT</strong>\n        </p>\n        <p>\n            <strong class="color-calm">Extra Actions</strong>\n        </p>\n    </div>\n</div>\n\n<div class="row bottom-2">\n    <div class="col t-center">\n        <i class="icon ion-arrow-down-a"></i>\n    </div>\n    <div class="col col-50 t-center t-massive">SWIPE BAR</div>\n    <div class="col t-center">\n        <i class="icon ion-arrow-down-a"></i>\n    </div>\n</div>\n\n';
},{}],28:[function(require,module,exports){
//

var _$db = require( '../../../app/db.js' )
var _$http = require( '../../../app/http.js' )
var _$utils = require( '../../../app/utils.js' )
var _$samsara = require( '../../../app/samsara.js' )



module.exports = {
	template: require( './about-template.html' ),

	ready: function () {

		console.info( 'about > _$db >', _$db )

		// _$db.save('yayy')

		// console.log( '_$db.temp >', JSON.stringify( _$db.temp, true, 4 ) )

		// _$samsara.sBar.update( [ {
		// 	_text: "Back",
		// 	_icon: "ion-arrow-left-c",
		// 	_color: 'assertive',
		// 	_href: true,
		// 	_click: function () {
		// 		console.warn( 'go back' )
		// 	}.bind( this )
		// }, {
		// 	_text: "Boundaries",
		// 	_icon: "ion-log-out",
		// 	_href: true,
		// 	_click: function () {
		// 		console.warn( 'boundaries' )
		// 	}.bind( this )
		// }, {
		// 	_text: "Goto Map",
		// 	_icon: "ion-android-expand",
		// 	_href: true,
		// 	_click: function () {
		// 		console.warn( 'map' )
		// 	}.bind( this ),
		// 	_clickHold: function () {
		// 		console.warn( 'map _clickHold' )
		// 	}.bind( this )
		// }, {
		// 	_text: "Activities",
		// 	_icon: "ion-ios-pulse-strong",
		// 	_href: true,
		// 	_click: function () {
		// 		console.warn( 'Activities' )
		// 	}.bind( this ),
		// 	_clickHold: function () {
		// 		console.warn( 'Activities _clickHold' )
		// 	}.bind( this )
		// }, {
		// 	_text: "Submit",
		// 	_icon: "ion-checkmark done",
		// 	_click: function () {
		// 		console.warn( 'Submit' )
		// 	}.bind( this )
		// }, {
		// 	_text: "More Actions",
		// 	_icon: "ion-android-more-vertical",
		// 	_color: 'balanced',
		// 	_click: function () {
		// 		console.warn( 'smenu' )
		// 	}.bind( this )
		// } ] )


		// this.showTuts()



		this.$nextTick( function () {
			if ( !window.plugins ) {
				return
			}
			window.plugins.nativepagetransitions.executePendingTransition()
		} )

	},

	methods: {
		dev1: function () {
			// _$utils.events.emit( 'samsara.mMenu.open' )

			var d = {
				uname: 'rob',
				pass: 'abc123'
			}

			_$http.post( '/public/login', d, function ( err, response ) {
				if ( err ) {
					console.error( err )
					return
				}

				_$db.putitlogin( response )

			} )








		},
		dev2: function () {
			// _$utils.events.emit( 'samsara.mMenu.close' )

			var d = {
				stamp: 1
			}

			_$http.post( '/socket/update', d, function ( err, response ) {
				if ( err ) {
					console.error( err )
					return
				}

				_$db.putitsocket( response )

			} )



		},
		dev3: function () {
			console.warn( 'dev3' )
		},

		showTuts: function () {
			var html = require( './about-tuts.html' )
				// _$samsara.tuts.open( html )
		}
	}

}


},{"../../../app/db.js":5,"../../../app/http.js":6,"../../../app/samsara.js":10,"../../../app/utils.js":14,"./about-template.html":26,"./about-tuts.html":27}],29:[function(require,module,exports){
module.exports = '<!--  -->\n\n<div class="bar bar-header bar-positive" v-touch:taphold="showTuts">\n    <button class="button button-icon icon-left icon ion-person-add" v-link="{ name: \'public.register\' }">Register</button>\n    <h1 class="title">Login</h1>\n    <button class="button button-icon icon-right icon ion-information" v-link="{ name: \'public.about\' }">Convoy</button>\n</div>\n\n<div id="content">\n    <form class="list list-inset">\n    <!-- <ul class="list list-inset"> -->\n    <!-- <form class="list list-inset"> -->\n\n        <li class="item item-divider">\n            Username\n        </li>\n        <label class="item item-input">\n            <input type="text" v-model="uname">\n        </label>\n\n        <li class="item item-divider">\n            Password\n        </li>\n        <label class="item item-input">\n            <input type="text" v-model="pass">\n        </label>\n\n        <li class="item item-divider">\n            <button type="submit" class="button button-block button-positive">Login</button>\n        </li>\n\n<!--         <li class="item item-divider">\n            <button class="button button-block button-positive" v-on:click="login(\'androidp\')">Login Android Phone</button>\n            <button class="button button-block button-positive" v-on:click="login(\'applep\')">Login Apple iPhone</button>\n            <button class="button button-block button-positive" v-on:click="login(\'androidt\')">Login Android Tablet</button>\n        </li> -->\n\n        <!--         <li class="item item-divider">\n            <button class="button button-block button-positive" ng-click="login_DEV(\'cel123\')">Login cl123</button>\n            <button class="button button-block button-positive" ng-click="login_DEV(\'ll123\')">Login ll123</button>\n        </li> -->\n        <!-- </ul> -->\n    </form>\n\n</div>\n\n';
},{}],30:[function(require,module,exports){
//

var _$samsara = require( '../../../app/samsara.js' )



module.exports = {
	template: require( './login-template.html' ),

	data: function () {
		var data = {}
		data.uname = ""
		data.pass = ""
		return data
	},

	ready: function () {



		this.$nextTick( function () {
			if ( !window.plugins ) {
				return
			}
			window.plugins.nativepagetransitions.executePendingTransition()
		} )

	},

	methods: {

	}
}


},{"../../../app/samsara.js":10,"./login-template.html":29}],31:[function(require,module,exports){
module.exports = '<!--  -->\n\n<div class="bar bar-header bar-positive" v-touch:taphold="showTuts">\n    <button class="button button-icon icon-left icon ion-information" v-link="{ name: \'public.about\' }">Convoy</button>\n    <h1 class="title">Register</h1>\n    <button class="button button-icon icon-right icon ion-person" v-link="{ name: \'public.login\' }">Login</button>\n</div>\n\n<div id="content">\n    <form class="list list-inset">\n        <!-- <ul class="list list-inset"> -->\n        \n        <li class="item item-divider">\n            Display Name\n            <p class="">We recommend using your first and last name, but you certainly don\'t have to.</p>\n        </li>\n        <label class="item item-input">\n            <input type="text" v-model="dname" required>\n        </label>\n\n        <!--         <li class="item item-divider item-icon-right">\n            Phone Number\n            <i class="icon ion-ios-flag-outline"></i>\n            <span class="item-note">\n                USA\n            </span>\n        </li>\n        <label class="item item-input">\n            <input type="tel" v-model="phone">\n        </label>\n        <li class="item">\n            <p>We will send you a verification link via SMS.\n                <br> Our number 662-337-6433\n                <br>\n                <small>You may opt out of providing this info. Your account will be flagged as unverified.</small>\n            </p> DEVVVVVVV\n        </li> -->\n\n        <li class="item item-divider">\n            Username\n        </li>\n        <label class="item item-input">\n            <input type="text" v-model="uname" required>\n        </label>\n\n        <li class="item item-divider">\n            Password\n        </li>\n        <label class="item item-input">\n            <input type="text" v-model="pass" required>\n        </label>\n\n        <li class="item item-divider">\n            <!-- <button type="submit" class="button button-block button-positive" v-on:click="register">Register</button> -->\n            <button type="submit" class="button button-block button-positive">Register</button>\n        </li>\n    </form>\n</div>\n\n';
},{}],32:[function(require,module,exports){
//

var _$samsara = require( '../../../app/samsara.js' )

module.exports = {
	template: require( './register-template.html' ),

	data: function () {
		var data = {}
		data.dname = ""
		// data.phone = "4018643464"
		data.uname = ""
		data.pass = ""
		
		// data.dname = "Robert Laverty"
		// data.uname = "roblav96"
		// data.pass = "abc123"
		return data
	},

	ready: function () {
		


		this.$nextTick( function () {
			if ( !window.plugins ) {
				return
			}
			window.plugins.nativepagetransitions.executePendingTransition()
		} )

	},

	// watch: {
	// 	'phone': function ( val, oldVal ) {
	// 		var phone1 = val.replace( /[^0-9]/g, '' ).substr( 0, 10 )
	// 		this.$nextTick( function () {
	// 			if ( phone1.length == 10 ) {
	// 				this.phone = _$utils.prettyPhoneNumber( phone1 )
	// 				return
	// 			}
	// 			this.phone = phone1
	// 		} )
	// 	}
	// },

	methods: {

		// formatPhone: function () {
		// 	// var str = _$utils.prettyPhoneNumber( this.phone )
		// 	// console.log( 'str >', str )
		// 	this.phone = this.phone.replace( /[^0-9]/g, '' )
		// },

		// getKey: function () {
		// 	_$pub.getInitKey()
		// }
	}
}









































































//


},{"../../../app/samsara.js":10,"./register-template.html":31}],33:[function(require,module,exports){
module.exports = '<!--  -->\n\n<router-view></router-view>\n\n';
},{}],34:[function(require,module,exports){
//


module.exports = {
	template: require( './tabs-template.html' ),

	/*=============================
	=            ROUTE            =
	=============================*/
	route: {
		activate: function ( trans ) {
			trans.next()
		}
	}

	// methods: {
	// 	href: function ( toState, e ) {
	// 		var curState = _$router._currentRoute.name
	// 		if ( toState == curState ) {
	// 			return
	// 		}

	// 		var str = curState.toString()
	// 		var hrefState = toState.substr( 7, toState.length )
	// 		var curState = str.substr( 7, str.length )

	// 		var direction = {}
	// 		direction[ 'register' ] = {}
	// 		direction[ 'register' ][ 'about' ] = 'right'
	// 		direction[ 'register' ][ 'login' ] = 'right'
	// 		direction[ 'login' ] = {}
	// 		direction[ 'login' ][ 'about' ] = 'left'
	// 		direction[ 'login' ][ 'register' ] = 'left'
	// 		direction[ 'about' ] = {}
	// 		direction[ 'about' ][ 'login' ] = 'right'
	// 		direction[ 'about' ][ 'register' ] = 'left'

	// 		_$famous.href( toState, direction[ curState ][ hrefState ] )
	// 	}

	// 	// classObject: function ( isState ) {
	// 	// 	var curState = _$router._currentRoute.name
	// 	// 	console.log( 'curState >', curState )
	// 	// 	console.log( 'isState >', isState )
	// 	// 	return curState == isState
	// 	// }
	// },

	// data: function () {
	// 	var data = {}
	// 	data.classObject = {
	// 		'active': this.classObject()
	// 	}
	// 	return data
	// }


	// computed: {
	// 	classObject: function () {
	// 		console.info( 'idk' )
	// 		return {
	// 			'active': true
	// 		}
	// 	}
	// }

	// computed: {
	// 	activeClass: function ( isState ) {
	// 		var curState = _$router._currentRoute.name
	// 		console.log( 'isState >', isState )
	// 		return true
	// 	}
	// }
}


},{"./tabs-template.html":33}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAuanMiLCJhcHAvQ3VydmVzLmpzIiwiYXBwL2RiLWRleGllLmpzIiwiYXBwL2RiLW9iamVjdC5qcyIsImFwcC9kYi5qcyIsImFwcC9odHRwLmpzIiwiYXBwL21tZW51LXN1cmYuanMiLCJhcHAvbW1lbnUuanMiLCJhcHAvcHJvZy5qcyIsImFwcC9zYW1zYXJhLmpzIiwiYXBwL3NiYXIuanMiLCJhcHAvc21lbnUuanMiLCJhcHAvdHV0cy5qcyIsImFwcC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9oYW1tZXJqcy9oYW1tZXIuanMiLCJub2RlX21vZHVsZXMvbG9raWpzL3NyYy9sb2tpLWluZGV4ZWQtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2tpanMvc3JjL2xva2lqcy5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYW1zYXJhanMvZGlzdC9zYW1zYXJhLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS10b3VjaC92dWUtdG91Y2guanMiLCJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcyIsInJvdXRlcy9wdWJsaWMvYWJvdXQvYWJvdXQtdGVtcGxhdGUuaHRtbCIsInJvdXRlcy9wdWJsaWMvYWJvdXQvYWJvdXQtdHV0cy5odG1sIiwicm91dGVzL3B1YmxpYy9hYm91dC9hYm91dC5qcyIsInJvdXRlcy9wdWJsaWMvbG9naW4vbG9naW4tdGVtcGxhdGUuaHRtbCIsInJvdXRlcy9wdWJsaWMvbG9naW4vbG9naW4uanMiLCJyb3V0ZXMvcHVibGljL3JlZ2lzdGVyL3JlZ2lzdGVyLXRlbXBsYXRlLmh0bWwiLCJyb3V0ZXMvcHVibGljL3JlZ2lzdGVyL3JlZ2lzdGVyLmpzIiwicm91dGVzL3B1YmxpYy90YWJzL3RhYnMtdGVtcGxhdGUuaHRtbCIsInJvdXRlcy9wdWJsaWMvdGFicy90YWJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Z0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbDBJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmhIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9sUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3prRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbnpTQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy9cblxudmFyIF8kZGIgPSByZXF1aXJlKCBcIi4vYXBwL2RiLmpzXCIgKVxudmFyIF8kc2Ftc2FyYSA9IHJlcXVpcmUoIFwiLi9hcHAvc2Ftc2FyYS5qc1wiIClcbnZhciBfJHV0aWxzID0gcmVxdWlyZSggXCIuL2FwcC91dGlscy5qc1wiIClcblxuXG52YXIgVnVlID0gcmVxdWlyZSggJ3Z1ZScgKVxuVnVlLmNvbmZpZy5kZWJ1ZyA9IGZhbHNlXG52YXIgVnVlUm91dGVyID0gcmVxdWlyZSggXCJ2dWUtcm91dGVyXCIgKVxudmFyIFZ1ZVRvdWNoID0gcmVxdWlyZSggJ3Z1ZS10b3VjaCcgKVxuVnVlLnVzZSggVnVlUm91dGVyIClcblZ1ZS51c2UoIFZ1ZVRvdWNoIClcblxuXG5cblxuXy5taXhpbigge1xuXHQncGFyc2VCb29sJzogZnVuY3Rpb24gKCBib29sICkge1xuXHRcdGlmICggXy5pc1N0cmluZyggYm9vbCApICkge1xuXHRcdFx0Ym9vbCA9IGJvb2wudG9Mb3dlckNhc2UoKVxuXHRcdH1cblx0XHRzd2l0Y2ggKCBib29sICkge1xuXHRcdGNhc2UgdHJ1ZTpcblx0XHRjYXNlIFwidHJ1ZVwiOlxuXHRcdGNhc2UgXCJ0XCI6XG5cdFx0Y2FzZSAxOlxuXHRcdGNhc2UgXCIxXCI6XG5cdFx0Y2FzZSBcIm9uXCI6XG5cdFx0Y2FzZSBcInllc1wiOlxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHRjYXNlIGZhbHNlOlxuXHRcdGNhc2UgXCJmYWxzZVwiOlxuXHRcdGNhc2UgXCJmXCI6XG5cdFx0Y2FzZSAwOlxuXHRcdGNhc2UgXCIwXCI6XG5cdFx0Y2FzZSBcIm9mZlwiOlxuXHRcdGNhc2UgXCJub1wiOlxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiB1bmRlZmluZWRcblx0XHR9XG5cdH1cbn0gKVxuXG5fLm1peGluKCB7XG5cdCdtYXRoQ2xhbXAnOiBmdW5jdGlvbiAoIHgsIGEsIGIgKSB7XG5cdFx0cmV0dXJuIE1hdGgubWluKCBNYXRoLm1heCggeCwgYSApLCBiIClcblx0fVxufSApXG5cbl8ubWl4aW4oIHtcblx0J2dldE1vbWVudCc6IGZ1bmN0aW9uICggc3RhbXAsIHNlY29uZHMgKSB7XG5cdFx0dmFyIHN0ciA9ICdoOm1tIEEnXG5cdFx0aWYgKCBzZWNvbmRzID09IHRydWUgKSB7XG5cdFx0XHRzdHIgPSAnaDptbTpzcyBBJ1xuXHRcdH1cblx0XHRyZXR1cm4gbW9tZW50KCBzdGFtcCApLmNhbGVuZGFyKCBfLm5vdygpLCB7XG5cdFx0XHRzYW1lRGF5OiBzdHIsXG5cdFx0XHRsYXN0RGF5OiAnW1llc3RlcmRheSBAXSBoOm1tIEEnLFxuXHRcdFx0bGFzdFdlZWs6ICdbUGFzdF0gZGRkIFtAXSBoOm1tIEEnLFxuXHRcdFx0c2FtZUVsc2U6ICdkZGQgTU1NIEQgW0BdIGg6bW0gQSdcblx0XHR9IClcblx0fVxufSApXG5cbl8ubWl4aW4oIHtcblx0J3N0ckluc2VydCc6IGZ1bmN0aW9uICggc3RyLCBpbmRleCwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIHN0ci5zdWJzdHIoIDAsIGluZGV4ICkgKyB2YWx1ZSArIHN0ci5zdWJzdHIoIGluZGV4IClcblx0fVxufSApXG5cbl8ubWl4aW4oIHtcblx0J3BhcnNlUGhvbmUnOiBmdW5jdGlvbiAoIG51bWIgKSB7XG5cdFx0bnVtYiA9IG51bWIubWF0Y2goIC9cXGQvZyApXG5cdFx0bnVtYiA9IG51bWIuam9pbiggXCJcIiApXG5cdFx0bnVtYiA9IG51bWIuc3Vic3RyaW5nKCBudW1iLmxlbmd0aCAtIDEwLCBudW1iLmxlbmd0aCApXG5cdFx0bnVtYiA9IFwiMVwiICsgbnVtYlxuXHRcdHJldHVybiBudW1iXG5cdH1cbn0gKVxuXG5fLm1peGluKCB7XG5cdCdwcmV0dHlQaG9uZSc6IGZ1bmN0aW9uICggbnVtYiApIHtcblx0XHRudW1iID0gXy5wYXJzZVBob25lKCBudW1iIClcblx0XHRudW1iID0gbnVtYi5zdWJzdHJpbmcoIG51bWIubGVuZ3RoIC0gMTAsIG51bWIubGVuZ3RoIClcblx0XHRudW1iID0gbnVtYi5yZXBsYWNlKCAvKFxcZHszfSkoXFxkezN9KShcXGR7NH0pLywgXCIkMS0kMi0kM1wiIClcblx0XHRyZXR1cm4gbnVtYlxuXHR9XG59IClcblxuXG5cblZ1ZVRvdWNoLnJlZ2lzdGVyQ3VzdG9tRXZlbnQoICdkb3VibGV0YXAnLCB7XG5cdHR5cGU6ICd0YXAnLFxuXHR0aHJlc2hvbGQ6IDMsXG5cdGludGVydmFsOiAzMDAsXG5cdHRhcHM6IDJcbn0gKVxuXG5WdWVUb3VjaC5yZWdpc3RlckN1c3RvbUV2ZW50KCAncXVpY2t0YXBob2xkJywge1xuXHR0eXBlOiAncHJlc3MnLFxuXHR0aHJlc2hvbGQ6IDEwLFxuXHR0aW1lOiAyNTBcbn0gKVxuXG5WdWVUb3VjaC5yZWdpc3RlckN1c3RvbUV2ZW50KCAncXVpbnRhcCcsIHtcblx0dHlwZTogJ3RhcCcsXG5cdHRocmVzaG9sZDogMyxcblx0aW50ZXJ2YWw6IDMwMCxcblx0dGFwczogNVxufSApXG5cblZ1ZVRvdWNoLnJlZ2lzdGVyQ3VzdG9tRXZlbnQoICd0YXBob2xkJywge1xuXHR0eXBlOiAncHJlc3MnLFxuXHR0aHJlc2hvbGQ6IDEwLFxuXHR0aW1lOiA1MDBcbn0gKVxuXG5WdWVUb3VjaC5yZWdpc3RlckN1c3RvbUV2ZW50KCAnc3dpcGVsZWZ0Jywge1xuXHR0eXBlOiAnc3dpcGUnLFxuXHR2ZWxvY2l0eTogMC41LFxuXHR0aHJlc2hvbGQ6IDEwLFxuXHRkaXJlY3Rpb246IEhNX0RJUkVDVElPTl9MRUZUXG59IClcblxuVnVlVG91Y2gucmVnaXN0ZXJDdXN0b21FdmVudCggJ3N3aXBlcmlnaHQnLCB7XG5cdHR5cGU6ICdzd2lwZScsXG5cdHZlbG9jaXR5OiAwLjUsXG5cdHRocmVzaG9sZDogMTAsXG5cdGRpcmVjdGlvbjogSE1fRElSRUNUSU9OX1JJR0hUXG59IClcblxuVnVlVG91Y2gucmVnaXN0ZXJDdXN0b21FdmVudCggJ3RhcGhlbHBob2xkJywge1xuXHR0eXBlOiAncHJlc3MnLFxuXHR0aHJlc2hvbGQ6IDEwMCxcblx0dGltZTogMTAwMFxufSApXG5cbnZhciBfJEFwcCA9IFZ1ZS5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBkYXRhID0ge31cblx0XHRkYXRhLmlkayA9IFwiYnV0dCBtdW5jaFwiXG5cdFx0cmV0dXJuIGRhdGFcblx0fSxcblx0cmVhZHk6IGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLndhcm4oICdTUkVBRERZWVlZJyApXG5cblx0XHR2YXIgYXJyID0gW1xuXHRcdFx0J3JlZ2lzdGVyJyxcblx0XHRcdCdhYm91dCcsXG5cdFx0XHQnbG9naW4nXG5cdFx0XVxuXG5cdFx0Ly8gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0XyRyb3V0ZXIuZ28oIHtcblx0XHQvLyBcdFx0bmFtZTogJ3B1YmxpYy4nICsgYXJyWyBfLnJhbmRvbSggMCwgMiApIF1cblx0XHQvLyBcdH0gKVxuXHRcdC8vIH0sIDIwMDAgKVxuXHR9XG59IClcblxuXG5cbl8kcm91dGVyID0gbmV3IFZ1ZVJvdXRlcigge1xuXHQvLyBhYnN0cmFjdDogZmFsc2UsXG5cdC8vIGhhc2hiYW5nOiBmYWxzZSxcblx0Ly8gcm9vdDogJy8nLFxuXHQvLyBoaXN0b3J5OiB0cnVlXG59IClcblxuXyRyb3V0ZXIuYmVmb3JlRWFjaCggZnVuY3Rpb24gKCB0cmFucyApIHtcblxuXHRpZiAoIF8uaXNFbXB0eSggdHJhbnMuZnJvbSApICkgeyAvLyBkdXJpbmcgZGV2aWNlcmVhZHkvZmlyc3QgbG9hZCBpdCB0cmFuc2VzXG5cdFx0dHJhbnMubmV4dCgpXG5cdFx0cmV0dXJuXG5cdH1cblxuXHRpZiAoICF3aW5kb3cucGx1Z2lucyApIHtcblx0XHR0cmFucy5uZXh0KClcblx0XHRyZXR1cm5cblx0fVxuXG5cdHdpbmRvdy5wbHVnaW5zLm5hdGl2ZXBhZ2V0cmFuc2l0aW9ucy5zbGlkZSgge1xuXHRcdGRpcmVjdGlvbjogJ2xlZnQnXG5cdH0sIGZ1bmN0aW9uICgpIHtcblx0XHR0cmFucy5uZXh0KClcblx0fSApXG5cbn0gKVxuXG5fJHJvdXRlci5hZnRlckVhY2goIGZ1bmN0aW9uICggdHJhbnMgKSB7XG5cblx0Ly8gY29uc29sZS5sb2coICdfJHJvdXRlci5hZnRlckVhY2ggPiB0cmFucyA+JywgdHJhbnMgKVxuXG5cdExvY2tyLnNldCggJ2xvY2F0aW9uLmhhc2gnLCBsb2NhdGlvbi5oYXNoIClcblxufSApXG5cblxuXG5cblxuXyRyb3V0ZXIubWFwKCB7XG5cblx0Jy9wdWJsaWMnOiB7XG5cdFx0Y29tcG9uZW50OiByZXF1aXJlKCAnLi9yb3V0ZXMvcHVibGljL3RhYnMvdGFicy5qcycgKSxcblx0XHRzdWJSb3V0ZXM6IHtcblx0XHRcdCcvbG9naW4nOiB7XG5cdFx0XHRcdGNvbXBvbmVudDogcmVxdWlyZSggJy4vcm91dGVzL3B1YmxpYy9sb2dpbi9sb2dpbi5qcycgKSxcblx0XHRcdFx0bmFtZTogJ3B1YmxpYy5sb2dpbidcblx0XHRcdH0sXG5cdFx0XHQnL2Fib3V0Jzoge1xuXHRcdFx0XHRjb21wb25lbnQ6IHJlcXVpcmUoICcuL3JvdXRlcy9wdWJsaWMvYWJvdXQvYWJvdXQuanMnICksXG5cdFx0XHRcdG5hbWU6ICdwdWJsaWMuYWJvdXQnXG5cdFx0XHR9LFxuXHRcdFx0Jy9yZWdpc3Rlcic6IHtcblx0XHRcdFx0Y29tcG9uZW50OiByZXF1aXJlKCAnLi9yb3V0ZXMvcHVibGljL3JlZ2lzdGVyL3JlZ2lzdGVyLmpzJyApLFxuXHRcdFx0XHRuYW1lOiAncHVibGljLnJlZ2lzdGVyJ1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59IClcblxuXyRyb3V0ZXIucmVkaXJlY3QoIHtcblx0JyonOiAnL3B1YmxpYy9ob21lJ1xufSApXG5cblxuXG5cblxuXG5cblxuXG52YXIgZGJSZWFkeSA9IGZhbHNlXG52YXIgZGV2aWNlUmVhZHkgPSBmYWxzZVxuXG52YXIgc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdGNvbnNvbGUud2FybiggJ1NUQVJUJyApXG5cblx0aWYgKCB3aW5kb3cuY29yZG92YSApIHtcblx0XHR3aW5kb3cucGx1Z2lucy5uYXRpdmVwYWdldHJhbnNpdGlvbnMuZ2xvYmFsT3B0aW9ucy5kdXJhdGlvbiA9IDI1MFxuXHRcdHdpbmRvdy5wbHVnaW5zLm5hdGl2ZXBhZ2V0cmFuc2l0aW9ucy5nbG9iYWxPcHRpb25zLmlvc2RlbGF5ID0gLTFcblx0XHR3aW5kb3cucGx1Z2lucy5uYXRpdmVwYWdldHJhbnNpdGlvbnMuZ2xvYmFsT3B0aW9ucy5hbmRyb2lkZGVsYXkgPSAtMVxuXHRcdHdpbmRvdy5wbHVnaW5zLm5hdGl2ZXBhZ2V0cmFuc2l0aW9ucy5nbG9iYWxPcHRpb25zLndpbnBob25lZGVsYXkgPSAtMVxuXHRcdHdpbmRvdy5wbHVnaW5zLm5hdGl2ZXBhZ2V0cmFuc2l0aW9ucy5nbG9iYWxPcHRpb25zLnNsb3dkb3duZmFjdG9yID0gM1xuXG5cdFx0aWYgKCBkZXZpY2UucGxhdGZvcm0gPT0gXCJpT1NcIiApIHtcblx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCAnYXBwJyApXG5cdFx0XHRlbC5zdHlsZS50b3AgPSAnMjBweCdcblx0XHR9XG5cdH1cblxuXHRfJHJvdXRlci5zdGFydCggXyRBcHAsICcjYXBwJyApXG5cbn1cblxuXyR1dGlscy5ldmVudHMub25jZSggJ2RiLnJlYWR5JywgZnVuY3Rpb24gKCkge1xuXHQvLyBjb25zb2xlLndhcm4oICdkYi5yZWFkeScgKVxuXHRkYlJlYWR5ID0gdHJ1ZVxuXG5cdGlmICggZGV2aWNlUmVhZHkgPT0gZmFsc2UgKSB7XG5cdFx0cmV0dXJuXG5cdH1cblx0c3RhcnQoKVxufSApXG5cbnZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gY29uc29sZS53YXJuKCAncmVhZHknIClcblx0ZGV2aWNlUmVhZHkgPSB0cnVlXG5cblx0aWYgKCBkYlJlYWR5ID09IGZhbHNlICkge1xuXHRcdHJldHVyblxuXHR9XG5cdHN0YXJ0KClcbn1cblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuPSAgICAgICAgICAgIERFVklDRVJFQURZICAgICAgICAgICAgPVxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpIHtcblxuXHRfJHNhbXNhcmEuaW5pdCgpXG5cblx0aWYgKCB3aW5kb3cuY29yZG92YSApIHtcblx0XHRyZXR1cm5cblx0fVxuXG5cdHJlYWR5KClcblxufSApXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiZGV2aWNlcmVhZHlcIiwgcmVhZHkgKVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuXG4iLCIvL1xuXG52YXIgQ3VydmVzID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gdDtcblx0fSxcblxuXHRlYXNlSW46IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dDogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiB0ICogKCAyIC0gdCApO1xuXHR9LFxuXG5cdGVhc2VJbk91dDogZnVuY3Rpb24gKCB0ICkge1xuXHRcdGlmICggdCA8PSAwLjUgKSByZXR1cm4gMiAqIHQgKiB0O1xuXHRcdGVsc2UgcmV0dXJuIC0yICogdCAqIHQgKyA0ICogdCAtIDE7XG5cdH0sXG5cblx0ZWFzZU91dEJvdW5jZTogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiB0ICogKCAzIC0gMiAqIHQgKTtcblx0fSxcblxuXHRzcHJpbmc6IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gKCAxIC0gdCApICogTWF0aC5zaW4oIDYgKiBNYXRoLlBJICogdCApICsgdDtcblx0fSxcblxuXHRpblF1YWQ6IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0b3V0UXVhZDogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiAtKCB0IC09IDEgKSAqIHQgKyAxO1xuXHR9LFxuXG5cdGluT3V0UXVhZDogZnVuY3Rpb24gKCB0ICkge1xuXHRcdGlmICggKCB0IC89IC41ICkgPCAxICkgcmV0dXJuIC41ICogdCAqIHQ7XG5cdFx0cmV0dXJuIC0uNSAqICggKCAtLXQgKSAqICggdCAtIDIgKSAtIDEgKTtcblx0fSxcblxuXHRpbkN1YmljOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdDtcblx0fSxcblxuXHRvdXRDdWJpYzogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiAoICggLS10ICkgKiB0ICogdCArIDEgKTtcblx0fSxcblxuXHRpbk91dEN1YmljOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0aWYgKCAoIHQgLz0gLjUgKSA8IDEgKSByZXR1cm4gLjUgKiB0ICogdCAqIHQ7XG5cdFx0cmV0dXJuIC41ICogKCAoIHQgLT0gMiApICogdCAqIHQgKyAyICk7XG5cdH0sXG5cblx0aW5RdWFydDogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdG91dFF1YXJ0OiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuIC0oICggLS10ICkgKiB0ICogdCAqIHQgLSAxICk7XG5cdH0sXG5cblx0aW5PdXRRdWFydDogZnVuY3Rpb24gKCB0ICkge1xuXHRcdGlmICggKCB0IC89IC41ICkgPCAxICkgcmV0dXJuIC41ICogdCAqIHQgKiB0ICogdDtcblx0XHRyZXR1cm4gLS41ICogKCAoIHQgLT0gMiApICogdCAqIHQgKiB0IC0gMiApO1xuXHR9LFxuXG5cdGluUXVpbnQ6IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0b3V0UXVpbnQ6IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gKCAoIC0tdCApICogdCAqIHQgKiB0ICogdCArIDEgKTtcblx0fSxcblxuXHRpbk91dFF1aW50OiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0aWYgKCAoIHQgLz0gLjUgKSA8IDEgKSByZXR1cm4gLjUgKiB0ICogdCAqIHQgKiB0ICogdDtcblx0XHRyZXR1cm4gLjUgKiAoICggdCAtPSAyICkgKiB0ICogdCAqIHQgKiB0ICsgMiApO1xuXHR9LFxuXG5cdGluU2luZTogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiAtMS4wICogTWF0aC5jb3MoIHQgKiAoIE1hdGguUEkgLyAyICkgKSArIDEuMDtcblx0fSxcblxuXHRvdXRTaW5lOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuIE1hdGguc2luKCB0ICogKCBNYXRoLlBJIC8gMiApICk7XG5cdH0sXG5cblx0aW5PdXRTaW5lOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuIC0uNSAqICggTWF0aC5jb3MoIE1hdGguUEkgKiB0ICkgLSAxICk7XG5cdH0sXG5cblx0aW5FeHBvOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuICggdCA9PT0gMCApID8gMC4wIDogTWF0aC5wb3coIDIsIDEwICogKCB0IC0gMSApICk7XG5cdH0sXG5cblx0b3V0RXhwbzogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHJldHVybiAoIHQgPT09IDEuMCApID8gMS4wIDogKCAtTWF0aC5wb3coIDIsIC0xMCAqIHQgKSArIDEgKTtcblx0fSxcblxuXHRpbk91dEV4cG86IGZ1bmN0aW9uICggdCApIHtcblx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gMC4wO1xuXHRcdGlmICggdCA9PT0gMS4wICkgcmV0dXJuIDEuMDtcblx0XHRpZiAoICggdCAvPSAuNSApIDwgMSApIHJldHVybiAuNSAqIE1hdGgucG93KCAyLCAxMCAqICggdCAtIDEgKSApO1xuXHRcdHJldHVybiAuNSAqICggLU1hdGgucG93KCAyLCAtMTAgKiAtLXQgKSArIDIgKTtcblx0fSxcblxuXHRpbkNpcmM6IGZ1bmN0aW9uICggdCApIHtcblx0XHRyZXR1cm4gLSggTWF0aC5zcXJ0KCAxIC0gdCAqIHQgKSAtIDEgKTtcblx0fSxcblxuXHRvdXRDaXJjOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCggMSAtICggLS10ICkgKiB0ICk7XG5cdH0sXG5cblx0aW5PdXRDaXJjOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0aWYgKCAoIHQgLz0gLjUgKSA8IDEgKSByZXR1cm4gLS41ICogKCBNYXRoLnNxcnQoIDEgLSB0ICogdCApIC0gMSApO1xuXHRcdHJldHVybiAuNSAqICggTWF0aC5zcXJ0KCAxIC0gKCB0IC09IDIgKSAqIHQgKSArIDEgKTtcblx0fSxcblxuXHRpbkVsYXN0aWM6IGZ1bmN0aW9uICggdCApIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMS4wO1xuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiAwLjA7XG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIDEuMDtcblx0XHRpZiAoICFwICkgcCA9IC4zO1xuXHRcdHMgPSBwIC8gKCAyICogTWF0aC5QSSApICogTWF0aC5hc2luKCAxLjAgLyBhICk7XG5cdFx0cmV0dXJuIC0oIGEgKiBNYXRoLnBvdyggMiwgMTAgKiAoIHQgLT0gMSApICkgKiBNYXRoLnNpbiggKCB0IC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICk7XG5cdH0sXG5cblx0b3V0RWxhc3RpYzogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxLjA7XG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIDAuMDtcblx0XHRpZiAoIHQgPT09IDEgKSByZXR1cm4gMS4wO1xuXHRcdGlmICggIXAgKSBwID0gLjM7XG5cdFx0cyA9IHAgLyAoIDIgKiBNYXRoLlBJICkgKiBNYXRoLmFzaW4oIDEuMCAvIGEgKTtcblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KCAyLCAtMTAgKiB0ICkgKiBNYXRoLnNpbiggKCB0IC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICsgMS4wO1xuXHR9LFxuXG5cdGluT3V0RWxhc3RpYzogZnVuY3Rpb24gKCB0ICkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxLjA7XG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIDAuMDtcblx0XHRpZiAoICggdCAvPSAuNSApID09PSAyICkgcmV0dXJuIDEuMDtcblx0XHRpZiAoICFwICkgcCA9ICggLjMgKiAxLjUgKTtcblx0XHRzID0gcCAvICggMiAqIE1hdGguUEkgKSAqIE1hdGguYXNpbiggMS4wIC8gYSApO1xuXHRcdGlmICggdCA8IDEgKSByZXR1cm4gLS41ICogKCBhICogTWF0aC5wb3coIDIsIDEwICogKCB0IC09IDEgKSApICogTWF0aC5zaW4oICggdCAtIHMgKSAqICggMiAqIE1hdGguUEkgKSAvIHAgKSApO1xuXHRcdHJldHVybiBhICogTWF0aC5wb3coIDIsIC0xMCAqICggdCAtPSAxICkgKSAqIE1hdGguc2luKCAoIHQgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKiAuNSArIDEuMDtcblx0fSxcblxuXHRpbkJhY2s6IGZ1bmN0aW9uICggdCwgcyApIHtcblx0XHRpZiAoIHMgPT09IHVuZGVmaW5lZCApIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiB0ICogdCAqICggKCBzICsgMSApICogdCAtIHMgKTtcblx0fSxcblxuXHRvdXRCYWNrOiBmdW5jdGlvbiAoIHQsIHMgKSB7XG5cdFx0aWYgKCBzID09PSB1bmRlZmluZWQgKSBzID0gMS43MDE1ODtcblx0XHRyZXR1cm4gKCAoIC0tdCApICogdCAqICggKCBzICsgMSApICogdCArIHMgKSArIDEgKTtcblx0fSxcblxuXHRpbk91dEJhY2s6IGZ1bmN0aW9uICggdCwgcyApIHtcblx0XHRpZiAoIHMgPT09IHVuZGVmaW5lZCApIHMgPSAxLjcwMTU4O1xuXHRcdGlmICggKCB0IC89IC41ICkgPCAxICkgcmV0dXJuIC41ICogKCB0ICogdCAqICggKCAoIHMgKj0gKCAxLjUyNSApICkgKyAxICkgKiB0IC0gcyApICk7XG5cdFx0cmV0dXJuIC41ICogKCAoIHQgLT0gMiApICogdCAqICggKCAoIHMgKj0gKCAxLjUyNSApICkgKyAxICkgKiB0ICsgcyApICsgMiApO1xuXHR9LFxuXG5cdGluQm91bmNlOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0cmV0dXJuIDEuMCAtIEN1cnZlcy5vdXRCb3VuY2UoIDEuMCAtIHQgKTtcblx0fSxcblxuXHRvdXRCb3VuY2U6IGZ1bmN0aW9uICggdCApIHtcblx0XHRpZiAoIHQgPCAoIDEgLyAyLjc1ICkgKSB7XG5cdFx0XHRyZXR1cm4gKCA3LjU2MjUgKiB0ICogdCApO1xuXHRcdH0gZWxzZSBpZiAoIHQgPCAoIDIgLyAyLjc1ICkgKSB7XG5cdFx0XHRyZXR1cm4gKCA3LjU2MjUgKiAoIHQgLT0gKCAxLjUgLyAyLjc1ICkgKSAqIHQgKyAuNzUgKTtcblx0XHR9IGVsc2UgaWYgKCB0IDwgKCAyLjUgLyAyLjc1ICkgKSB7XG5cdFx0XHRyZXR1cm4gKCA3LjU2MjUgKiAoIHQgLT0gKCAyLjI1IC8gMi43NSApICkgKiB0ICsgLjkzNzUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICggNy41NjI1ICogKCB0IC09ICggMi42MjUgLyAyLjc1ICkgKSAqIHQgKyAuOTg0Mzc1ICk7XG5cdFx0fVxuXHR9LFxuXG5cdGluT3V0Qm91bmNlOiBmdW5jdGlvbiAoIHQgKSB7XG5cdFx0aWYgKCB0IDwgLjUgKSByZXR1cm4gQ3VydmVzLmluQm91bmNlKCB0ICogMiApICogLjU7XG5cdFx0cmV0dXJuIEN1cnZlcy5vdXRCb3VuY2UoIHQgKiAyIC0gMS4wICkgKiAuNSArIC41O1xuXHR9LFxuXG5cdGZsYXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDdXJ2ZXM7XG5cbiIsIi8vXG5cbnZhciBfJHV0aWxzID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcblxuXG5cbnZhciB2ZXJzaW9uID0gMVxudmFyIG5hbWUgPSAnY29udm95LmRiXzEnXG52YXIgdGFibGVzID0gWyB7XG5cdG5hbWU6ICdjb250YWN0cycsXG5cdHNjaGVtYTogJ2lkLCB1bmFtZSdcbn0sIHtcblx0bmFtZTogJ2JvdW5kYXJpZXMnLFxuXHRzY2hlbWE6ICdpZCwgdHlwZSdcbn0sIHtcblx0bmFtZTogJ2FjdGl2aXRpZXMnLFxuXHRzY2hlbWE6ICd1dWlkLCB0eXBlLCBzdGFtcCwgeGlkJ1xufSwge1xuXHRuYW1lOiAnZ2VvJyxcblx0c2NoZW1hOiAndXVpZCwgc3RhbXAsIHhpZCdcbn0gXVxuXG5cblxudmFyIHN0b3JlcyA9IHt9XG52YXIgaSwgbGVuID0gdGFibGVzLmxlbmd0aFxuZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0c3RvcmVzWyB0YWJsZXNbIGkgXS5uYW1lIF0gPSB0YWJsZXNbIGkgXS5zY2hlbWFcblx0dGFibGVzWyBpIF0uaW5kaWNlcyA9IHRhYmxlc1sgaSBdLnNjaGVtYS5zcGxpdCggJywgJyApXG59XG5cbnZhciBkZXhpZSA9IG5ldyBEZXhpZSggbmFtZSApXG5kZXhpZS52ZXJzaW9uKCB2ZXJzaW9uICkuc3RvcmVzKCBzdG9yZXMgKVxuXHQvLyBkZXhpZS5vcGVuKClcblxuZGV4aWUuX3ZlcnNpb24gPSB2ZXJzaW9uXG5kZXhpZS5fbmFtZSA9IG5hbWVcbmRleGllLl90YWJsZXMgPSB0YWJsZXNcblxudmFyIHRoYXQgPSB7XG5cdGRleGllOiBkZXhpZVxufVxuXG5Qcm9taXNlLnJlc29sdmUoKS5iaW5kKCB0aGF0ICkudGhlbiggZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5kZXhpZS5vcGVuKClcbn0gKS5jYXRjaCggZnVuY3Rpb24gKCBlcnIgKSB7XG5cdGNvbnNvbGUud2FybiggJ18kZGIuaW5pdCA+IEZJUlNUIGNhdGNoID4nIClcblx0Y29uc29sZS5lcnJvciggZXJyIClcblx0Y29uc29sZS5lcnJvciggZXJyLnN0YWNrIClcblx0bmF2aWdhdG9yLm5vdGlmaWNhdGlvbi5hbGVydCggJ0RBVEFCQVNFIE5PVCBTVVBQT1JURUQgT04gREVWSUNFIScsIG51bGwsICdGQVRBTCBFUlJPUiEhIScsICc6KCcgKVxufSApLnRoZW4oIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIF8kdXRpbHMuZXZlbnRzLmVtaXQoICdkYi5vcGVuZWQnIClcbn0gKS5jYXRjaCggZnVuY3Rpb24gKCBlcnIgKSB7XG5cdGNvbnNvbGUud2FybiggJ18kZGIuaW5pdCA+IFNFQ09ORCBjYXRjaCA+JyApXG5cdGNvbnNvbGUuZXJyb3IoIGVyciApXG5cdGNvbnNvbGUuZXJyb3IoIGVyci5zdGFjayApXG59IClcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZGV4aWVcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuXG4iLCIvL1xuXG52YXIgTG9raSA9IHJlcXVpcmUoICdsb2tpanMnIClcbnZhciBkZXhpZSA9IHJlcXVpcmUoICcuL2RiLWRleGllLmpzJyApXG52YXIgXyR1dGlscyA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5cblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT1cbj0gICAgICAgICAgICBfJERCICAgICAgICAgICA9XG49PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERCXG5cbmZ1bmN0aW9uIERCKCBvcHRzICkge1xuXG5cdC8vIHtcblx0Ly8gXHRcIm5hbWVcIjogXCJnZW9cIixcblx0Ly8gXHRcInNjaGVtYVwiOiBcInV1aWQsIHN0YW1wLCB4aWRcIixcblx0Ly8gXHRcImluZGljZXNcIjogW1xuXHQvLyBcdFx0XCJ1dWlkXCIsXG5cdC8vIFx0XHRcInN0YW1wXCIsXG5cdC8vIFx0XHRcInhpZFwiXG5cdC8vIFx0XVxuXHQvLyB9XG5cblx0dGhpcy5vcHRzID0gb3B0c1xuXG5cdHRoaXMubG9raSA9IG5ldyBMb2tpLkNvbGxlY3Rpb24oIHRoaXMub3B0cy5uYW1lLCB7XG5cdFx0aW5kaWNlczogdGhpcy5vcHRzLmluZGljZXMsXG5cdFx0dW5pcXVlOiB0aGlzLm9wdHMuaW5kaWNlc1sgMCBdXG5cdH0gKVxuXG5cdC8vIHZhciB4aWQgPSBMb2Nrci5nZXQoICd1c2VyLnhpZCcgKVxuXHQvLyBpZiAoIF8uaXNVbmRlZmluZWQoIHhpZCApICkge1xuXHQvLyBcdHJldHVyblxuXHQvLyB9XG5cblx0dmFyIHRoYXQgPSB7XG5cdFx0b3B0czogdGhpcy5vcHRzLFxuXHRcdGxva2k6IHRoaXMubG9raVxuXHR9XG5cblx0aWYgKCB0aGlzLm9wdHMubmFtZSA9PSAnZ2VvJyApIHtcblx0XHRjb25zb2xlLmxvZyggJ3RoaXMubG9raS5kYXRhID4nLCB0aGlzLmxva2kuZGF0YSApXG5cdFx0XG5cdFx0cmV0dXJuXG5cdH1cblxuXHRQcm9taXNlLnJlc29sdmUoKS5iaW5kKCB0aGF0ICkudGhlbiggZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCB0aGlzLm9wdHMubmFtZSA9PSAnYWN0aXZpdGllcycgKSB7XG5cdFx0XHRyZXR1cm4gZGV4aWVbIHRoaXMub3B0cy5uYW1lIF0ub3JkZXJCeSggJ3N0YW1wJyApLnJldmVyc2UoKS5saW1pdCggNTAgKS50b0FycmF5KClcblx0XHR9XG5cblx0XHRyZXR1cm4gZGV4aWVbIHRoaXMub3B0cy5uYW1lIF0udG9BcnJheSgpXG5cblx0fSApLnRoZW4oIGZ1bmN0aW9uICggZG9jcyApIHtcblxuXHRcdGlmICggXy5pc0VtcHR5KCBkb2NzICkgKSB7IC8vIGRvbnQgbG9hZCBhbnkgZ2VvIHBvc2l0aW9ucyBpbnRvIG1lbW9yeVxuXHRcdFx0cmV0dXJuIG51bGxcblx0XHR9XG5cblx0XHR2YXIgaSwgbGVuID0gZG9jcy5sZW5ndGhcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0dGhpcy5sb2tpLmluc2VydCggZG9jc1sgaSBdIClcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZyggJ3RoaXMubG9raS5kYXRhID4nLCB0aGlzLmxva2kuZGF0YSApXG5cblx0fSApLmNhdGNoKCBmdW5jdGlvbiAoIGVyciApIHtcblx0XHRjb25zb2xlLmVycm9yKCBlcnIgKVxuXHRcdGNvbnNvbGUuZXJyb3IoIGVyci5zdGFjayApXG5cdH0gKVxuXG5cbn1cblxuREIucHJvdG90eXBlLmluaXRHZW8gPSBmdW5jdGlvbiAoKSB7XG5cdGNvbnNvbGUud2FybiggJ0lOSVRHRU8gPicgKVxuXG5cblxuXG5cbn1cblxuXG5EQi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKCBkb2MgKSB7XG5cdGNvbnNvbGUubG9nKCAnSU5TRVJUID4gZG9jID4nLCBkb2MgKVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vXG5cbiIsIi8vXG5cbnZhciBEQiA9IHJlcXVpcmUoICcuL2RiLW9iamVjdC5qcycgKVxudmFyIGRleGllID0gcmVxdWlyZSggJy4vZGItZGV4aWUuanMnIClcbnZhciBfJHV0aWxzID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcblxuXG5cbl8kdXRpbHMuZXZlbnRzLm9uY2UoICdkYi5vcGVuZWQnLCBmdW5jdGlvbiAoKSB7XG5cdGNvbnNvbGUuaW5mbyggJ2RiLm9wZW5lZCcgKVxuXG5cdHZhciB0YWJsZXMgPSBkZXhpZS5fdGFibGVzXG5cdHZhciBpLCBsZW4gPSB0YWJsZXMubGVuZ3RoXG5cdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGhpc1sgdGFibGVzWyBpIF0ubmFtZSBdID0gbmV3IERCKCB0YWJsZXNbIGkgXSApLmxva2lcblxuXHRcdF8kdXRpbHMuZXZlbnRzLmVtaXQoICdkYi5yZWFkeScgKVxuXHR9XG5cbn0uYmluZCggdGhpcyApIClcblxuXG5cblxudGhpcy5wdXRpdGxvZ2luID0gZnVuY3Rpb24gKCByZXNwb25zZSApIHsgLy8gREVWIGZvciBsb2dpblxuXHRjb25zb2xlLmxvZyggJ3B1dGl0bG9naW4gPiByZXNwb25zZSA+JywgcmVzcG9uc2UgKVxuXHRcblx0XG5cdFxufVxuXG50aGlzLnB1dGl0c29ja2V0ID0gZnVuY3Rpb24gKCByZXNwb25zZSApIHtcblx0Y29uc29sZS5sb2coICdwdXRpdHNvY2tldCA+IHJlc3BvbnNlID4nLCByZXNwb25zZSApXG5cblx0Ly8gdmFyIGdlb3MgPSByZXNwb25zZS5nZW9zXG5cdC8vIHZhciBpLCBsZW4gPSBnZW9zLmxlbmd0aFxuXHQvLyBmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHQvLyBcdHZhciBkb2MgPSBKU09OLnBhcnNlKCBnZW9zWyBpIF0uZG9jIClcblx0Ly8gXHRkb2MueGlkID0gZ2Vvc1sgaSBdLnhpZFxuXHQvLyBcdGRvYy5zdGFtcCA9IGdlb3NbIGkgXS5zdGFtcFxuXHQvLyBcdGRvYy51dWlkID0gZG9jLnhpZCArIGRvYy5zdGFtcFxuXHQvLyBcdGNvbnNvbGUubG9nKCAnZG9jID4nLCBKU09OLnN0cmluZ2lmeSggZG9jLCB0cnVlLCA0ICkgKVxuXHQvLyBcdGRleGllLmdlby5hZGQoIGRvYyApXG5cdC8vIH1cblx0XG5cdC8vIHZhciBhY3RpdmVzID0gcmVzcG9uc2UuYWN0aXZlc1xuXHQvLyB2YXIgaSwgbGVuID0gYWN0aXZlcy5sZW5ndGhcblx0Ly8gZm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0Ly8gXHR2YXIgZG9jID0gSlNPTi5wYXJzZSggYWN0aXZlc1sgaSBdIClcblx0Ly8gXHRkb2MudXVpZCA9IGRvYy54aWQgKyBkb2Muc3RhbXBcblx0Ly8gXHRjb25zb2xlLmxvZyggJ2RvYyA+JywgSlNPTi5zdHJpbmdpZnkoIGRvYywgdHJ1ZSwgNCApIClcblx0Ly8gXHRkZXhpZS5hY3Rpdml0aWVzLmFkZCggZG9jIClcblx0Ly8gfVxuXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuaWYgKCBFTlZfREVWRUxPUE1FTlQgPT0gdHJ1ZSApIHtcblx0d2luZG93LmRiID0gdGhpc1xufVxubW9kdWxlLmV4cG9ydHMgPSB0aGlzXG5cblxuXG5cblxuXG5cblxuLy9cblxuIiwiLy9cblxudmFyIG1vbWVudCA9IHJlcXVpcmUoICdtb21lbnQnIClcbnZhciBfJHV0aWxzID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbj0gICAgICAgICAgICBfJEhUVFAgICAgICAgICAgICA9XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xudmFyIF8kaHR0cCA9IHt9XG52YXIgc2VsZiA9IHt9XG5cblxuXG5cblxuc2VsZi5oZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBoZWFkcyA9IHt9XG5cblx0aGVhZHNbICd4LWJ5dGVzJyBdID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KCBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKCA4ICkgKVxuXG5cdC8vIGlmICggXyRzY29wZS5kYXRhLnVzZXIucHJlS2V5ICkge1xuXHQvLyBcdGhlYWRzWyAneC1wcmUta2V5JyBdID0gXyRzY29wZS5kYXRhLnVzZXIucHJlS2V5ICsgXCIuXCIgKyBfLm5vdygpXG5cdC8vIH1cblxuXHQvLyBpZiAoIF8kc2NvcGUuZGF0YS51c2VyLnRva2VuICYmIF8kc2NvcGUuZGF0YS51c2VyLnhpZCApIHtcblx0Ly8gXHRoZWFkc1sgJ3gtaWQnIF0gPSBfJHNjb3BlLmRhdGEudXNlci54aWRcblx0Ly8gXHRoZWFkc1sgJ3gtdG9rJyBdID0gXyRzY29wZS5kYXRhLnVzZXIudG9rZW4gKyBcIi5cIiArIF8ubm93KClcblx0Ly8gfVxuXG5cdHJldHVybiBoZWFkc1xufVxuXG5cblxuXyRodHRwLnBvc3QgPSBmdW5jdGlvbiAoIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdHZhciBzZW5kaSA9IHt9XG5cdF8uZm9yRWFjaCggZGF0YSwgZnVuY3Rpb24gKCB2YWwsIGluZCApIHtcblx0XHRzZW5kaVsgaW5kIF0gPSBKU09OLnN0cmluZ2lmeSggdmFsIClcblx0fSApXG5cdHdpbmRvdy5jb3Jkb3ZhSFRUUC5wb3N0KCBcImh0dHA6Ly8xOTIuMTY4LjEuMTI1OjEzMzcvYXBpXCIgKyB1cmwsIHNlbmRpLCBzZWxmLmhlYWRlcnMoKSwgZnVuY3Rpb24gKCByZXMgKSB7XG5cblx0XHRpZiAoIHJlcy5zdGF0dXMgPT0gMjAwICYmIHJlcy5kYXRhID09IFwiXCIgKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnSFRUUCBQT1NUIE5VTEwnIClcblx0XHRcdHJldHVybiBjYWxsYmFjayggbnVsbCwgbnVsbCApXG5cdFx0fVxuXG5cdFx0dmFyIGRhdGEgPSB7fVxuXHRcdHRyeSB7XG5cdFx0XHRkYXRhID0gSlNPTi5wYXJzZSggcmVzLmRhdGEgKVxuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIkpTT04gUEFSU0lORyBFUlJPUlwiIClcblx0XHRcdHJldHVybiBjYWxsYmFjayggZXJyIClcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuZXJyID09IHRydWUgKSB7XG5cdFx0XHRpZiAoIGRhdGEubXNnICkge1xuXHRcdFx0XHR3aW5kb3cucGx1Z2lucy50b2FzdC5oaWRlKClcblx0XHRcdFx0d2luZG93LnBsdWdpbnMudG9hc3Quc2hvd1Nob3J0Q2VudGVyKCBkYXRhLm1zZyApXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soIGRhdGEgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeSggZGF0YSwgdHJ1ZSwgNCApXG5cdFx0XHR2YXIgZmlsdGVyID0gW1xuXHRcdFx0XHQnL3NvY2tldC91cGRhdGUnLFxuXHRcdFx0XHQnL3B1YmxpYy9sb2dpbidcblx0XHRcdF1cblxuXHRcdFx0aWYgKCBfLmluY2x1ZGVzKCBmaWx0ZXIsIHVybCApICYmIHN0cmluZ2lmaWVkLmxlbmd0aCA+IDI1NiApIHtcblx0XHRcdFx0c3RyaW5naWZpZWQgPSBzdHJpbmdpZmllZC5zdWJzdHJpbmcoIDAsIDI1NiApXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnJWNfJGh0dHAuUE9TVCA+ICcgKyB1cmwgKyAnID4nLCBcImNvbG9yOiBibHVlOyBmb250LXNpemU6IDlwdDsgZm9udC13ZWlnaHQ6IGJvbGQ7XCIsICdcXG5cXG4nICsgc3RyaW5naWZpZWQgKyAnXFxuXFxuJyApXG5cdFx0XHRcdGNvbnNvbGUuaW5mbyggJyVjPCBUUlVOQ0FURUQnLCBcImNvbG9yOiBvcmFuZ2U7IGZvbnQtc2l6ZTogOXB0OyBmb250LXdlaWdodDogYm9sZDtcIiApXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZyggJyVjXyRodHRwLlBPU1QgPiAnICsgdXJsICsgJyA+JywgXCJjb2xvcjogYmx1ZTsgZm9udC1zaXplOiA5cHQ7IGZvbnQtd2VpZ2h0OiBib2xkO1wiLCAnXFxuXFxuJyArIHN0cmluZ2lmaWVkICsgJ1xcblxcbicgKVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soIG51bGwsIGRhdGEgKVxuXHRcdH1cblxuXHRcdC8vIHRyeSB7XG5cdFx0Ly8gXHR2YXIgZGF0YSA9IEpTT04ucGFyc2UoIHJlcy5kYXRhIClcblx0XHQvLyBcdGlmICggZGF0YS5lcnIgPT0gdHJ1ZSAmJiBkYXRhLm1zZyApIHtcblx0XHQvLyBcdFx0d2luZG93LnBsdWdpbnMudG9hc3Quc2hvd0xvbmdDZW50ZXIoIGRhdGEubXNnIClcblx0XHQvLyBcdH1cblx0XHQvLyBcdHJldHVybiBjYWxsYmFjayggbnVsbCwgZGF0YSApXG5cdFx0Ly8gfSBjYXRjaCAoIGVyciApIHtcblx0XHQvLyBcdGNvbnNvbGUuZXJyb3IoIFwiSlNPTiBQQVJTSU5HIEVSUk9SXCIgKVxuXHRcdC8vIFx0cmV0dXJuIGNhbGxiYWNrKCBlcnIgKVxuXHRcdC8vIH1cblx0fSwgZnVuY3Rpb24gKCByZWogKSB7XG5cdFx0Y29uc29sZS5lcnJvciggJ0hUVFAgUE9TVCBSRUpFQ1QgPiAnLCByZWogKVxuXG5cdFx0aWYgKCByZWouc3RhdHVzID09IDQxOCAmJiBFTlZfUFJPRFVDVElPTiApIHtcblx0XHRcdHdpbmRvdy5wbHVnaW5zLnRvYXN0LnNob3dMb25nQ2VudGVyKCAnTmV3IHNlc3Npb24gZGV0ZWN0ZWQuXFxuTG9naW4gY3JlZGVudGlhbHMgcmVxdWlyZWQhJyApXG5cdFx0XHRfJHJvdXRlci5nbygge1xuXHRcdFx0XHRuYW1lOiAncHVibGljLmxvZ2luJyxcblx0XHRcdFx0cXVlcnk6IHtcblx0XHRcdFx0XHRkaXJlY3Rpb246ICd1cCdcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNhbGxiYWNrKCByZWogKVxuXHR9IClcbn1cblxuXG5cblxuXG5cblxuXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoICdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uICgpIHtcblxuXHQvLyBfJHNjb3BlLmRhdGEudXNlci51dWlkID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKS51cGRhdGUoIGRldmljZS51dWlkICkuZGlnZXN0KCkudG9IZXgoKVxuXHRzZWxmLnV1aWQgPSBkZXZpY2UudXVpZFxuXG5cdHdpbmRvdy5jb3Jkb3ZhSFRUUC5lbmFibGVTU0xQaW5uaW5nKCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCAnc3VjY2VzcyEnICk7XG5cdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRjb25zb2xlLmxvZyggJ2Vycm9yIDooJyApO1xuXHR9IClcblxuXHR3aW5kb3cuY29yZG92YUhUVFAuYWNjZXB0QWxsQ2VydHMoIHRydWUsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBjb25zb2xlLmxvZyggJ3N1Y2Nlc3MhJyApO1xuXHR9LCBmdW5jdGlvbiAoKSB7XG5cdFx0Y29uc29sZS5sb2coICdlcnJvciA6KCcgKTtcblx0fSApXG5cblx0d2luZG93LmNvcmRvdmFIVFRQLnNldEhlYWRlciggXCJ4LXV1aWRcIiwgc2VsZi51dWlkLCBmdW5jdGlvbiAoIG1zZyApIHtcblx0XHQvLyBjb25zb2xlLmxvZyggJ21zZyA+JywgbXNnIClcblx0fSwgZnVuY3Rpb24gKCBtc2cgKSB7XG5cdFx0Y29uc29sZS53YXJuKCBtc2cgKVxuXHR9IClcblxuXHR3aW5kb3cuY29yZG92YUhUVFAuc2V0SGVhZGVyKCBcIkFjY2VwdHNcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGZ1bmN0aW9uICggbXNnICkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCAnbXNnID4nLCBtc2cgKVxuXHR9LCBmdW5jdGlvbiAoIG1zZyApIHtcblx0XHRjb25zb2xlLndhcm4oIG1zZyApXG5cdH0gKVxuXG59IClcblxuXG5cblxuXG5cbmlmICggRU5WX1BST0RVQ1RJT04gKSB7XG5cblx0c2VsZi5zZW5kRXJyb3JzID0gXy5kZWJvdW5jZSggZnVuY3Rpb24gKCkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCAnc2VsZi5zZW5kRXJyb3JzID4gQ19FUlJPUlMgPicsIEpTT04uc3RyaW5naWZ5KCBDX0VSUk9SUywgdHJ1ZSwgNCApIClcblxuXHRcdHZhciBzZW5kaUVycm9ycyA9IF8uY2xvbmVEZWVwKCBDX0VSUk9SUyApXG5cdFx0Q19FUlJPUlMgPSB7fVxuXG5cdFx0XyRodHRwLnBvc3QoICcvcHVibGljL2Vycm9yJywge1xuXHRcdFx0ZXJyb3JzOiBzZW5kaUVycm9yc1xuXHRcdH0sIGZ1bmN0aW9uICggZXJyLCByZXNwb25zZSApIHt9IClcblxuXHR9LCAxMDAwLCB7XG5cdFx0bWF4V2FpdDogMzAwMFxuXHR9IClcblxuXHR3aW5kb3cub25lcnJvciA9IGZ1bmN0aW9uICggbXNnLCB1cmwsIGxpbmUsIGNvbHVtbiwgZXJyICkge1xuXG5cdFx0dmFyIGRldmljZVR5cGUgPSBcIk4vQVwiXG5cdFx0dmFyIGRldmljZU1vZGVsID0gXCJOL0FcIlxuXHRcdHZhciBkZXZpY2VWZXJzaW9uID0gXCJOL0FcIlxuXHRcdGlmICggZGV2aWNlICkge1xuXHRcdFx0aWYgKCBkZXZpY2UucGxhdGZvcm0gKSB7XG5cdFx0XHRcdGRldmljZVR5cGUgPSBkZXZpY2UucGxhdGZvcm1cblx0XHRcdH1cblx0XHRcdGlmICggZGV2aWNlLnBsYXRmb3JtICkge1xuXHRcdFx0XHRkZXZpY2VNb2RlbCA9IGRldmljZS5tb2RlbFxuXHRcdFx0fVxuXHRcdFx0aWYgKCBkZXZpY2UucGxhdGZvcm0gKSB7XG5cdFx0XHRcdGRldmljZVZlcnNpb24gPSBkZXZpY2UudmVyc2lvblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciB4aWQgPSBMb2Nrci5nZXQoICd1c2VyLnhpZCcgKSB8fCBcIk4vQVwiXG5cdFx0dmFyIGRuYW1lID0gTG9ja3IuZ2V0KCAndXNlci5kbmFtZScgKSB8fCBcIk4vQVwiXG5cdFx0dmFyIHN0YW1wID0gXy5ub3coKVxuXHRcdHZhciB0cmFjZSA9IHVybCArIFwiOlwiICsgbGluZVxuXHRcdHZhciBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKS51cGRhdGUoIG1zZyArIHRyYWNlICkuZGlnZXN0KCkudG9IZXgoKVxuXG5cdFx0Q19FUlJPUlNbIGhhc2ggXSA9IHtcblx0XHRcdG1lc3NhZ2U6IG1zZyxcblx0XHRcdHRyYWNlOiB0cmFjZSxcblx0XHRcdGVycjogZXJyLFxuXHRcdFx0c3RhbXA6IHN0YW1wLFxuXHRcdFx0dGltZTogbW9tZW50KCBzdGFtcCApLmZvcm1hdCggJ2RkZCwgTU1NIEQsIGhoOm1tOnNzIEEnICksXG5cdFx0XHRhcHBWZXJzaW9uOiBFTlZfVkVSU0lPTixcblx0XHRcdGRldmljZVR5cGU6IGRldmljZVR5cGUsXG5cdFx0XHRkZXZpY2VNb2RlbDogZGV2aWNlTW9kZWwsXG5cdFx0XHRkZXZpY2VWZXJzaW9uOiBkZXZpY2VWZXJzaW9uLFxuXHRcdFx0eGlkOiB4aWQsXG5cdFx0XHRkbmFtZTogZG5hbWVcblx0XHR9XG5cblx0XHRzZWxmLnNlbmRFcnJvcnMoKVxuXG5cdFx0Ly8gY29uc29sZS5lcnJvciggJ0Vycm9yOiAnICsgZXJyb3JNc2cgKyAnIFNjcmlwdDogJyArIHVybCArICcgTGluZTogJyArIGxpbmVOdW1iZXIgKyAnIENvbHVtbjogJyArIGNvbHVtbiArICcgU3RhY2tUcmFjZTogJyArIGVycm9yT2JqIClcblx0fVxuXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBfJGh0dHBcblxuLy9cblxuIiwiLy9cblxudmFyIF8kdXRpbHMgPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxudmFyIEN1cnZlcyA9IHJlcXVpcmUoICcuL0N1cnZlcy5qcycgKVxudmFyIFNhbXNhcmEgPSByZXF1aXJlKCAnc2Ftc2FyYWpzJyApXG52YXIgU3VyZmFjZSA9IFNhbXNhcmEuRE9NLlN1cmZhY2VcbnZhciBDb250YWluZXJTdXJmYWNlID0gU2Ftc2FyYS5ET00uQ29udGFpbmVyU3VyZmFjZVxudmFyIFRyYW5zZm9ybSA9IFNhbXNhcmEuQ29yZS5UcmFuc2Zvcm1cbnZhciBMYXlvdXROb2RlID0gU2Ftc2FyYS5Db3JlLkxheW91dE5vZGVcbnZhciBWaWV3ID0gU2Ftc2FyYS5Db3JlLlZpZXdcbnZhciBNb3VzZUlucHV0ID0gU2Ftc2FyYS5JbnB1dHMuTW91c2VJbnB1dFxudmFyIFRvdWNoSW5wdXQgPSBTYW1zYXJhLklucHV0cy5Ub3VjaElucHV0XG52YXIgU2VxdWVudGlhbExheW91dCA9IFNhbXNhcmEuTGF5b3V0cy5TZXF1ZW50aWFsTGF5b3V0XG52YXIgVHJhbnNpdGlvbmFibGUgPSBTYW1zYXJhLkNvcmUuVHJhbnNpdGlvbmFibGVcbnZhciBBY2N1bXVsYXRvciA9IFNhbXNhcmEuU3RyZWFtcy5BY2N1bXVsYXRvclxudmFyIFRpbWVyID0gU2Ftc2FyYS5Db3JlLlRpbWVyXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKCB7XG5cblx0ZGVmYXVsdHM6IHtcblx0XHR3aWR0aDogMTAwLFxuXHRcdGhlaWdodDogODBcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoIG9wdHMgKSB7XG5cblx0XHR0aGlzLnNldFNpemUoIFsgb3B0cy53aWR0aCwgb3B0cy5oZWlnaHQgXSApXG5cblx0XHR2YXIgdGVtcCA9IG9wdHMudGhlVGVtcFxuXG5cdFx0dmFyIGNvbnRlbnQgPSAnPGRpdiBjbGFzcz1cImxpc3QgdGFicyBzaWRlLXRhYiB0YWJzLWljb24tdG9wXCI+PGxpIGNsYXNzPVwiaXRlbSB0YWItaXRlbVwiPjxpIGNsYXNzPVwiaWNvbiAnICsgdGVtcC5pY29uICsgJ1wiPjwvaT4nICsgdGVtcC50ZXh0ICsgJzwvbGk+PC9kaXY+J1xuXHRcdGlmICggdGVtcC5hY3RpdmVTdGF0ZSA9PSBcImhlbHBcIiApIHtcblx0XHRcdGNvbnRlbnQgPSAnPGRpdiBjbGFzcz1cImxpc3QgdGFicyBzaWRlLXRhYiB0YWJzLWljb24tdG9wIGhlbHAtbWVcIj48bGkgY2xhc3M9XCJpdGVtIHRhYi1pdGVtXCI+PGkgY2xhc3M9XCJpY29uICcgKyB0ZW1wLmljb24gKyAnXCI+PC9pPicgKyB0ZW1wLnRleHQgKyAnPC9saT48L2Rpdj4nXG5cdFx0fVxuXG5cdFx0dGhpcy5zdXJmID0gbmV3IFN1cmZhY2UoIHtcblx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRzaXplOiBbIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0IF1cblx0XHR9IClcblxuXHRcdHRoaXMuc3VyZi5zY2FsZXMgPSBuZXcgVHJhbnNpdGlvbmFibGUoIDEgKVxuXHRcdHRoaXMuc2NhbGVzVHJhbnMgPSB0aGlzLnN1cmYuc2NhbGVzLm1hcCggZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBUcmFuc2Zvcm0uc2NhbGUoIFsgdmFsdWUsIDEgXSApXG5cdFx0fSApXG5cblx0XHR0aGlzLnN1cmYudGhlVGVtcCA9IHRlbXBcblx0XHR0aGlzLnN1cmYudGVtcCA9IG9wdHMudGVtcFxuXG5cdFx0dGhpcy5zdXJmLm9uKCAndG91Y2hzdGFydCcsIHRoaXMuaHJlZlByZXAgKVxuXG5cdFx0dGhpcy5hZGQoIHtcblx0XHRcdHRyYW5zZm9ybTogdGhpcy5zY2FsZXNUcmFuc1xuXHRcdH0gKS5hZGQoIHRoaXMuc3VyZiApXG5cblx0fSxcblxuXG5cdGhyZWZQcmVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coICd0aGlzID4nLCB0aGlzIClcblxuXHRcdC8vIGlmICggXyRyb3V0ZXIuX2N1cnJlbnRSb3V0ZS5uYW1lID09IHRoaXMudGhlVGVtcC5zdGF0ZSApIHtcblx0XHQvLyBcdF8kdXRpbHMuZXZlbnRzLmVtaXQoICdzYW1zYXJhLmZpeE1lbnVzJyApXG5cdFx0Ly8gXHRyZXR1cm5cblx0XHQvLyB9XG5cblx0XHQvLyB2YXIgY3VyTmFtZSA9IF8kcm91dGVyLl9jdXJyZW50Um91dGUubmFtZS5zcGxpdCggJy4nIClbIDAgXVxuXHRcdC8vIGlmICggY3VyTmFtZSA9PSAncHVibGljJyApIHtcblx0XHQvLyBcdF8kdXRpbHMuZXZlbnRzLmVtaXQoICdzYW1zYXJhLmZpeE1lbnVzJyApXG5cdFx0Ly8gXHRyZXR1cm5cblx0XHQvLyB9XG5cblx0XHQvLyBpZiAoIHRoaXMudGhlVGVtcC5hY3RpdmVTdGF0ZSA9PSAnaGVscCcgKSB7XG5cdFx0Ly8gXHRfJHJvdXRlci5hcHAub3BlblNPUygpXG5cdFx0Ly8gXHRyZXR1cm5cblx0XHQvLyB9XG5cblx0XHQvLyB2YXIgaUZyb20gPSBfLmZpbmRJbmRleCggdGhpcy50ZW1wLCBmdW5jdGlvbiAoIHYgKSB7XG5cdFx0Ly8gXHRyZXR1cm4gdi5zdGF0ZSA9PSBjdXJOYW1lXG5cdFx0Ly8gfSApXG5cdFx0Ly8gY29uc29sZS5sb2coICdpRnJvbSA+JywgaUZyb20gKVxuXG5cdFx0Ly8gdmFyIGRpcmVjdCA9ICdsZWZ0J1xuXHRcdC8vIGlmICggaUZyb20gPiB0aGlzLnRoZVRlbXAuaW5kZXggKSB7XG5cdFx0Ly8gXHRkaXJlY3QgPSAnZG93bidcblx0XHQvLyB9IGVsc2UgaWYgKCBpRnJvbSA8IHRoaXMudGhlVGVtcC5pbmRleCApIHtcblx0XHQvLyBcdGRpcmVjdCA9ICd1cCdcblx0XHQvLyB9XG5cblx0XHR0aGlzLnNjYWxlcy5zZXQoIDEuMjUgKVxuXG5cdFx0Ly8gXyRyb3V0ZXIuZ28oIHtcblx0XHQvLyBcdG5hbWU6IHRoaXMudGhlVGVtcC5zdGF0ZSxcblx0XHQvLyBcdHF1ZXJ5OiB7XG5cdFx0Ly8gXHRcdGRpcmVjdGlvbjogZGlyZWN0XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSApXG5cblx0XHRUaW1lci5hZnRlciggZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zY2FsZXMuc2V0KCAxIClcblx0XHR9LmJpbmQoIHRoaXMgKSwgNSApXG5cblx0fVxuXG5cblxuXG5cblxuXG5cbn0gKVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vXG5cbiIsIi8vXG5cbnZhciBfJHV0aWxzID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcbnZhciBDdXJ2ZXMgPSByZXF1aXJlKCAnLi9DdXJ2ZXMuanMnIClcbnZhciBTYW1zYXJhID0gcmVxdWlyZSggJ3NhbXNhcmFqcycgKVxudmFyIFN1cmZhY2UgPSBTYW1zYXJhLkRPTS5TdXJmYWNlXG52YXIgQ29udGFpbmVyU3VyZmFjZSA9IFNhbXNhcmEuRE9NLkNvbnRhaW5lclN1cmZhY2VcbnZhciBUcmFuc2Zvcm0gPSBTYW1zYXJhLkNvcmUuVHJhbnNmb3JtXG52YXIgTGF5b3V0Tm9kZSA9IFNhbXNhcmEuQ29yZS5MYXlvdXROb2RlXG52YXIgVmlldyA9IFNhbXNhcmEuQ29yZS5WaWV3XG52YXIgTW91c2VJbnB1dCA9IFNhbXNhcmEuSW5wdXRzLk1vdXNlSW5wdXRcbnZhciBUb3VjaElucHV0ID0gU2Ftc2FyYS5JbnB1dHMuVG91Y2hJbnB1dFxudmFyIFNlcXVlbnRpYWxMYXlvdXQgPSBTYW1zYXJhLkxheW91dHMuU2VxdWVudGlhbExheW91dFxudmFyIFRyYW5zaXRpb25hYmxlID0gU2Ftc2FyYS5Db3JlLlRyYW5zaXRpb25hYmxlXG52YXIgQWNjdW11bGF0b3IgPSBTYW1zYXJhLlN0cmVhbXMuQWNjdW11bGF0b3JcbnZhciBtTWVudV9TVVJGID0gcmVxdWlyZSggJy4vbW1lbnUtc3VyZi5qcycgKVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCgge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLndXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG5cdFx0dGhpcy53SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG5cblx0XHR0aGlzLmluZGV4ID0gNDAxXG5cdFx0dGhpcy53aWR0aCA9IDEwMFxuXHRcdHRoaXMuaGVpZ2h0ID0gODBcblx0XHR0aGlzLnNob3duID0gZmFsc2Vcblx0XHR0aGlzLnNob3dpbmcgPSBmYWxzZVxuXHRcdHRoaXMuYWN0aXZlQ2xhc3MgPSAnJ1xuXG5cdFx0dGhpcy50ZW1wID0gWyB7XG5cdFx0XHR0ZXh0OiBcIlMuTy5TXCIsXG5cdFx0XHRpY29uOiBcImlvbi1oZWxwLWJ1b3lcIixcblx0XHRcdGFjdGl2ZVN0YXRlOiAnaGVscCcsXG5cdFx0XHRpbmRleDogMFxuXHRcdH0sIHtcblx0XHRcdHRleHQ6IFwiTWFwXCIsXG5cdFx0XHRpY29uOiBcImlvbi1tYXBcIixcblx0XHRcdHN0YXRlOiBcIm1hcC5pbmRleFwiLFxuXHRcdFx0YWN0aXZlU3RhdGU6ICdtYXAnLFxuXHRcdFx0aW5kZXg6IDFcblx0XHR9LCB7XG5cdFx0XHR0ZXh0OiBcIk15IENvbnZveVwiLFxuXHRcdFx0aWNvbjogXCJpb24tcGVyc29uLXN0YWxrZXJcIixcblx0XHRcdHN0YXRlOiBcImNvbnRhY3RzLmluZGV4XCIsXG5cdFx0XHRhY3RpdmVTdGF0ZTogJ2NvbnRhY3RzJyxcblx0XHRcdGluZGV4OiAyXG5cdFx0fSwge1xuXHRcdFx0dGV4dDogXCJBY3Rpdml0aWVzXCIsXG5cdFx0XHRpY29uOiBcImlvbi1pb3MtcHVsc2Utc3Ryb25nXCIsXG5cdFx0XHRzdGF0ZTogXCJhY3Rpdml0eS5pbmRleFwiLFxuXHRcdFx0YWN0aXZlU3RhdGU6ICdhY3Rpdml0eScsXG5cdFx0XHRpbmRleDogM1xuXHRcdH0sIHtcblx0XHRcdHRleHQ6IFwiU2V0dGluZ3NcIixcblx0XHRcdGljb246IFwiaW9uLXNldHRpbmdzXCIsXG5cdFx0XHRzdGF0ZTogXCJzZXR0aW5ncy5pbmRleFwiLFxuXHRcdFx0YWN0aXZlU3RhdGU6ICdzZXR0aW5ncycsXG5cdFx0XHRpbmRleDogNFxuXHRcdH0gXVxuXG5cdFx0dGhpcy5zdXJmcyA9IFtdXG5cdFx0dGhpcy5sYXlvdXQgPSBuZXcgU2VxdWVudGlhbExheW91dCgge1xuXHRcdFx0ZGlyZWN0aW9uOiAxXG5cdFx0fSApXG5cblx0XHR0aGlzLnggPSBuZXcgVHJhbnNpdGlvbmFibGUoIC0xMDAgKVxuXHRcdHRoaXMub3BhID0gbmV3IFRyYW5zaXRpb25hYmxlKCAwIClcblxuXHRcdHRoaXMueFRyYW5zID0gdGhpcy54Lm1hcCggZnVuY3Rpb24gKCB2ICkge1xuXHRcdFx0dmFyIHZhbCA9IHZcblx0XHRcdHJldHVybiBUcmFuc2Zvcm0udHJhbnNsYXRlKCBbIHZhbCwgLTQ0OSBdIClcblx0XHR9IClcblxuXHRcdHZhciBpLCBsZW4gPSB0aGlzLnRlbXAubGVuZ3RoXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdHRoaXMuc3VyZnNbIGkgXSA9IG5ldyBtTWVudV9TVVJGKCB7XG5cdFx0XHRcdHRoZVRlbXA6IHRoaXMudGVtcFsgaSBdLFxuXHRcdFx0XHR0ZW1wOiB0aGlzLnRlbXBcblx0XHRcdH0gKVxuXHRcdH1cblxuXHRcdHRoaXMubGF5b3V0LmFkZEl0ZW1zKCB0aGlzLnN1cmZzIClcblxuXG5cblxuXG5cblxuXHRcdHRoaXMuYWRkKCB7XG5cdFx0XHRhbGlnbjogWyAwLCAxIF0sXG5cdFx0XHR0cmFuc2Zvcm06IHRoaXMueFRyYW5zLFxuXHRcdFx0b3BhY2l0eTogdGhpcy5vcGFcblx0XHR9ICkuYWRkKCB0aGlzLmxheW91dCApXG5cblxuXG5cblxuXHR9LFxuXG5cblxuXHR0b2dnbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIHRoaXMuc2hvd2luZyA9PSB0cnVlICkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnNob3duID09IHRydWUgKSB7XG5cdFx0XHR0aGlzLmNsb3NlKClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcGVuKClcblx0XHR9XG5cdH0sXG5cblxuXG5cdG9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIHRoaXMuc2hvd24gPT0gdHJ1ZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdF8kdXRpbHMuZXZlbnRzLmVtaXQoICdzYW1zYXJhLnNNZW51LmNsb3NlJyApXG5cdFx0dGhpcy5zaG93aW5nID0gdHJ1ZVxuXG5cdFx0dGhpcy5vcGEuc2V0KCAxLCB7XG5cdFx0XHRkdXJhdGlvbjogMjAwXG5cdFx0fSApXG5cdFx0dGhpcy54LnNldCggMCwge1xuXHRcdFx0ZHVyYXRpb246IDIwMCxcblx0XHRcdGN1cnZlOiBDdXJ2ZXMub3V0QmFja1xuXHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2hvd24gPSB0cnVlXG5cdFx0XHR0aGlzLnNob3dpbmcgPSBmYWxzZVxuXHRcdH0uYmluZCggdGhpcyApIClcblxuXHR9LFxuXG5cblxuXHRjbG9zZTogZnVuY3Rpb24gKCBub3cgKSB7XG5cdFx0aWYgKCB0aGlzLnNob3duID09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dGhpcy5zaG93aW5nID0gdHJ1ZVxuXG5cdFx0aWYgKCBub3cgPT0gdHJ1ZSApIHtcblx0XHRcdHRoaXMub3BhLnNldCggMCApXG5cdFx0XHR0aGlzLm9wYS5yZXNldCggMCApXG5cdFx0XHR0aGlzLnguc2V0KCAtMTAwIClcblx0XHRcdHRoaXMueC5yZXNldCggLTEwMCApXG5cdFx0XHR0aGlzLnNob3dpbmcgPSBmYWxzZVxuXHRcdFx0dGhpcy5zaG93biA9IGZhbHNlXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR0aGlzLm9wYS5zZXQoIDAsIHtcblx0XHRcdGR1cmF0aW9uOiAyNTAsXG5cdFx0XHRjdXJ2ZTogQ3VydmVzLmVhc2VJblxuXHRcdH0gKVxuXHRcdHRoaXMueC5zZXQoIC0xMDAsIHtcblx0XHRcdGR1cmF0aW9uOiAyNTAsXG5cdFx0XHRjdXJ2ZTogQ3VydmVzLmVhc2VJblxuXHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuc2hvd24gPSBmYWxzZVxuXHRcdFx0dGhpcy5zaG93aW5nID0gZmFsc2Vcblx0XHR9LmJpbmQoIHRoaXMgKSApXG5cdH1cblxuXG5cblxuXG5cblxuXG59IClcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuXG4iLCIvL1xuXG52YXIgQ3VydmVzID0gcmVxdWlyZSggJy4vQ3VydmVzLmpzJyApXG52YXIgU2Ftc2FyYSA9IHJlcXVpcmUoICdzYW1zYXJhanMnIClcbnZhciBTdXJmYWNlID0gU2Ftc2FyYS5ET00uU3VyZmFjZVxudmFyIFRyYW5zZm9ybSA9IFNhbXNhcmEuQ29yZS5UcmFuc2Zvcm1cbnZhciBNb3VzZUlucHV0ID0gU2Ftc2FyYS5JbnB1dHMuTW91c2VJbnB1dFxudmFyIFRvdWNoSW5wdXQgPSBTYW1zYXJhLklucHV0cy5Ub3VjaElucHV0XG52YXIgU2VxdWVudGlhbExheW91dCA9IFNhbXNhcmEuTGF5b3V0cy5TZXF1ZW50aWFsTGF5b3V0XG52YXIgVHJhbnNpdGlvbmFibGUgPSBTYW1zYXJhLkNvcmUuVHJhbnNpdGlvbmFibGVcbnZhciBBY2N1bXVsYXRvciA9IFNhbXNhcmEuU3RyZWFtcy5BY2N1bXVsYXRvclxuXG5cblxuZnVuY3Rpb24gUHJvZyggY29udGV4dCApIHtcblx0dGhpcy53V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuXHR0aGlzLmhhbGZ3V2lkdGggPSB0aGlzLndXaWR0aCAqIDAuNVxuXHR0aGlzLndIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcblx0dGhpcy5oYWxmd0hlaWdodCA9IHRoaXMud0hlaWdodCAqIDAuNVxuXG5cdHRoaXMuaW5kZXggPSA1MDFcblx0dGhpcy5wb3NYID0gMFxuXHR0aGlzLmFjdGl2ZSA9IGZhbHNlXG5cdHRoaXMuZXJyID0gZmFsc2Vcblx0dGhpcy53aWR0aCA9IHRoaXMud1dpZHRoICogMC4yNVxuXHR0aGlzLmhlaWdodCA9IDVcblxuXG5cblx0dGhpcy54ID0gbmV3IFRyYW5zaXRpb25hYmxlKCB0aGlzLnBvc1ggKVxuXHR0aGlzLm9wYSA9IG5ldyBUcmFuc2l0aW9uYWJsZSggMCApXG5cblx0dGhpcy54VHJhbnMgPSB0aGlzLngubWFwKCBmdW5jdGlvbiAoIHYgKSB7XG5cdFx0cmV0dXJuIFRyYW5zZm9ybS50cmFuc2xhdGVYKCB2IClcblx0fSApXG5cblx0dGhpcy5zdXJmID0gbmV3IFN1cmZhY2UoIHtcblx0XHRzaXplOiBbIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0IF0sXG5cdFx0b3JpZ2luOiBbIDAuNSwgMCBdLFxuXHRcdG9wYWNpdHk6IHRoaXMub3BhLFxuXHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdGlkOiAncHJvZ19zdXJmJ1xuXHRcdH0sXG5cdFx0cHJvcGVydGllczoge1xuXHRcdFx0YmFja2dyb3VuZDogJyMxMUMxRjMnXG5cdFx0fVxuXHR9IClcblxuXHR0aGlzLnN3YXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCB0aGlzLmFjdGl2ZSA9PSBmYWxzZSB8fCB0aGlzLmVyciA9PSB0cnVlICkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dGhpcy5wb3NYID0gKCB0aGlzLnBvc1ggKSA/IDAgOiB0aGlzLndXaWR0aFxuXHRcdHRoaXMueC5zZXQoIHRoaXMucG9zWCwge1xuXHRcdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0XHRjdXJ2ZTogJ2Vhc2VPdXRCb3VuY2UnXG5cdFx0fSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCB0aGlzLmFjdGl2ZSA9PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy54LnJlc2V0KCAwIClcblx0XHRcdFx0dGhpcy54LnNldCggMCApXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnN3YXAoKVxuXHRcdH0uYmluZCggdGhpcyApIClcblx0fVxuXG5cdHRoaXMuZG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIHRoaXMuZXJyID09IHRydWUgKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlXG5cdFx0dGhpcy5wb3NYID0gMFxuXG5cdFx0dGhpcy5vcGEucmVzZXQoIDAgKVxuXG5cdFx0dGhpcy5zdXJmLnNldFByb3BlcnRpZXMoIHtcblx0XHRcdGJhY2tncm91bmQ6ICcjMTFDMUYzJ1xuXHRcdH0gKVxuXG5cdH1cblxuXHR0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5hY3RpdmUgPT0gdHJ1ZSB8fCB0aGlzLmVyciA9PSB0cnVlICkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlXG5cdFx0dGhpcy5wb3NYID0gMFxuXG5cdFx0dGhpcy5vcGEuc2V0KCAxIClcblxuXHRcdHRoaXMueC5yZXNldCggMCApXG5cblx0XHR0aGlzLnN3YXAoKVxuXHR9XG5cblx0dGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5hY3RpdmUgPT0gZmFsc2UgfHwgdGhpcy5lcnIgPT0gdHJ1ZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHRoaXMuc3VyZi5zZXRQcm9wZXJ0aWVzKCB7XG5cdFx0XHRiYWNrZ3JvdW5kOiAnIzMzQ0Q1Ridcblx0XHR9IClcblxuXHRcdHRoaXMub3BhLnNldCggMCwge1xuXHRcdFx0ZHVyYXRpb246IDUwMFxuXHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICggdGhpcy5hY3RpdmUgPT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0dGhpcy5kb25lKClcblx0XHR9LmJpbmQoIHRoaXMgKSApXG5cdH1cblxuXHR0aGlzLmVycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICggdGhpcy5lcnIgPT0gdHJ1ZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRcblx0XHR0aGlzLmVyciA9IHRydWVcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWVcblx0XHR0aGlzLnN1cmYuc2V0UHJvcGVydGllcygge1xuXHRcdFx0YmFja2dyb3VuZDogJyNFRjQ3M0EnXG5cdFx0fSApXG5cblx0XHR0aGlzLm9wYS5yZXNldCggMSApXG5cdFx0dGhpcy5vcGEuc2V0KCAxIClcblx0XHR0aGlzLnN1cmYuc2V0U2l6ZSggWyB0aGlzLndXaWR0aCwgdGhpcy5oZWlnaHQgXSApXG5cblx0XHR0aGlzLngucmVzZXQoIHRoaXMud1dpZHRoICogMS41IClcblxuXHRcdHRoaXMueC5zZXQoIHRoaXMud1dpZHRoICogMC41LCB7XG5cdFx0XHRkdXJhdGlvbjogMTAwMCxcblx0XHRcdGN1cnZlOiBDdXJ2ZXMub3V0Qm91bmNlXG5cdFx0fSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5vcGEuc2V0KCAwLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiAxMDAwXG5cdFx0XHR9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoaXMuc3VyZi5zZXRTaXplKCBbIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0IF0gKVxuXHRcdFx0XHR0aGlzLmVyciA9IGZhbHNlXG5cdFx0XHRcdHRoaXMuZG9uZSgpXG5cdFx0XHR9LmJpbmQoIHRoaXMgKSApXG5cdFx0fS5iaW5kKCB0aGlzICkgKVxuXG5cdH1cblxuXHRjb250ZXh0LmFkZCgge1xuXHRcdHRyYW5zZm9ybTogdGhpcy54VHJhbnNcblx0fSApLmFkZCggdGhpcy5zdXJmIClcblxufVxuXG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZ1xuXG4vL1xuXG4iLCIvL1xuXG52YXIgXyR1dGlscyA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG52YXIgU2Ftc2FyYSA9IHJlcXVpcmUoICdzYW1zYXJhanMnIClcbnZhciBDb250ZXh0ID0gU2Ftc2FyYS5ET00uQ29udGV4dFxuXG52YXIgdHV0cyA9IHJlcXVpcmUoICcuL3R1dHMuanMnIClcbnZhciBwcm9nID0gcmVxdWlyZSggJy4vcHJvZy5qcycgKVxudmFyIF9tTWVudSA9IHJlcXVpcmUoICcuL21tZW51LmpzJyApXG52YXIgc01lbnUgPSByZXF1aXJlKCAnLi9zbWVudS5qcycgKVxudmFyIHNCYXIgPSByZXF1aXJlKCAnLi9zYmFyLmpzJyApXG5cblxuXG52YXIgXyRzYW1zYXJhID0ge31cbl8kc2Ftc2FyYS50dXRzID0ge31cbl8kc2Ftc2FyYS5wcm9nID0ge31cbl8kc2Ftc2FyYS5tTWVudSA9IHt9XG5fJHNhbXNhcmEuc01lbnUgPSB7fVxuXyRzYW1zYXJhLnNCYXIgPSB7fVxuXG5cblxuXyRzYW1zYXJhLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpXG5cdGNvbnRleHQuc2V0UGVyc3BlY3RpdmUoIDEwMDAgKVxuXG5cdC8vIF8kc2Ftc2FyYS50dXRzID0gbmV3IHR1dHMoIGNvbnRleHQgKVxuXHQvLyBfJHNhbXNhcmEucHJvZyA9IG5ldyBwcm9nKCBjb250ZXh0IClcblxuXHR2YXIgbU1lbnUgPSBuZXcgX21NZW51KClcblx0Y29udGV4dC5hZGQoIG1NZW51IClcblx0XG5cdC8vIGNvbnNvbGUubG9nKCAnbU1lbnUgPicsIG1NZW51IClcblx0XG5cdF8kc2Ftc2FyYS5tTWVudS50b2dnbGUgPSBtTWVudS50b2dnbGVcblx0XyRzYW1zYXJhLm1NZW51Lm9wZW4gPSBtTWVudS5vcGVuXG5cdF8kc2Ftc2FyYS5tTWVudS5jbG9zZSA9IG1NZW51LmNsb3NlXG5cdFxuXHRcblxuXHQvLyBfJHNhbXNhcmEuc01lbnUgPSBuZXcgc01lbnUoIGNvbnRleHQgKVxuXHQvLyBfJHNhbXNhcmEuc0JhciA9IG5ldyBzQmFyKCBjb250ZXh0IClcblxuXHRjb250ZXh0Lm1vdW50KCBkb2N1bWVudC5ib2R5IClcblxuXHQvKj09PT09ICBNQUlOIE1FTlUgID09PT09PSovXG5cdC8vIF8kdXRpbHMuZXZlbnRzLm9uKCAnc2Ftc2FyYS5tTWVudS5vcGVuJywgXyRzYW1zYXJhLm1NZW51Lm9wZW4gKVxuXHQvLyBfJHV0aWxzLmV2ZW50cy5vbiggJ3NhbXNhcmEubU1lbnUuY2xvc2UnLCBfJHNhbXNhcmEubU1lbnUuY2xvc2UgKVxuXHQvLyBfJHV0aWxzLmV2ZW50cy5vbiggJ3Nvcy1iYXItaGVhZGVyJywgXyRzYW1zYXJhLm1NZW51LnNvc0JhckhlYWRlciApXG5cdC8vIF8kdXRpbHMuZXZlbnRzLm9uKCAnc2Ftc2FyYS5hY3Rpdml0aWVzJywgXyRzYW1zYXJhLm1NZW51LmFjdGl2aXRpZXMgKVxuXG5cdC8qPT09PT0gIFNJREUgTUVOVSAgPT09PT09Ki9cblx0Ly8gXyR1dGlscy5ldmVudHMub24oICdzYW1zYXJhLnNNZW51Lm9wZW4nLCBfJHNhbXNhcmEuc01lbnUub3BlbiApXG5cdC8vIF8kdXRpbHMuZXZlbnRzLm9uKCAnc2Ftc2FyYS5zTWVudS5jbG9zZScsIF8kc2Ftc2FyYS5zTWVudS5jbG9zZSApXG5cblx0Lyo9PT09PSAgU1dJUEUgQkFSICA9PT09PT0qL1xuXHQvLyBfJHV0aWxzLmV2ZW50cy5vbiggJ3NhbXNhcmEuc0Jhci5jZW50ZXJJdCcsIF8kc2Ftc2FyYS5zQmFyLmNlbnRlckl0IClcblxuXHQvKj09PT09ICBPVEhFUiAgPT09PT09Ki9cblx0Ly8gXyR1dGlscy5ldmVudHMub24oICdzYW1zYXJhLmZpeE1lbnVzJywgXyRzYW1zYXJhLmZpeE1lbnVzIClcblxufVxuXG4vLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgXyRzYW1zYXJhLmluaXQgKVxuXG5fJHNhbXNhcmEuc2V0R3B1U2V0dGluZ3MgPSBmdW5jdGlvbiAoIGJvb2wsIHBsYXRmb3JtICkge1xuXHRjb25zb2xlLndhcm4oICdfJHNhbXNhcmEuc2V0R3B1U2V0dGluZ3MnIClcbn1cblxuXG5fJHNhbXNhcmEuZml4TWVudXMgPSBmdW5jdGlvbiAoIG5vdyApIHtcblx0Ly8gXyRzYW1zYXJhLm1NZW51LmNsb3NlKCBub3cgKVxuXHQvLyBfJHNhbXNhcmEuc01lbnUuY2xvc2UoIG5vdyApXG5cdC8vIF8kc2Ftc2FyYS50dXRzLmNsb3NlKCBub3cgKVxuXHQvLyBcdC8vIF8kc2Ftc2FyYS5xdWlja2llLmNsb3NlKCBub3cgKVxuXHQvLyBfJHNhbXNhcmEuc0Jhci5jZW50ZXJJdCggbm93IClcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gXyRzYW1zYXJhXG5cblxuXG4vL1xuXG4iLCIvL1xuXG52YXIgXyR1dGlscyA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG52YXIgQ3VydmVzID0gcmVxdWlyZSggJy4vQ3VydmVzLmpzJyApXG52YXIgU2Ftc2FyYSA9IHJlcXVpcmUoICdzYW1zYXJhanMnIClcbnZhciBTdXJmYWNlID0gU2Ftc2FyYS5ET00uU3VyZmFjZVxudmFyIFRyYW5zZm9ybSA9IFNhbXNhcmEuQ29yZS5UcmFuc2Zvcm1cbnZhciBUaW1lciA9IFNhbXNhcmEuQ29yZS5UaW1lclxudmFyIE1vdXNlSW5wdXQgPSBTYW1zYXJhLklucHV0cy5Nb3VzZUlucHV0XG52YXIgVG91Y2hJbnB1dCA9IFNhbXNhcmEuSW5wdXRzLlRvdWNoSW5wdXRcbnZhciBDb250YWluZXJTdXJmYWNlID0gU2Ftc2FyYS5ET00uQ29udGFpbmVyU3VyZmFjZVxudmFyIFNlcXVlbnRpYWxMYXlvdXQgPSBTYW1zYXJhLkxheW91dHMuU2VxdWVudGlhbExheW91dFxudmFyIFRyYW5zaXRpb25hYmxlID0gU2Ftc2FyYS5Db3JlLlRyYW5zaXRpb25hYmxlXG52YXIgQWNjdW11bGF0b3IgPSBTYW1zYXJhLlN0cmVhbXMuQWNjdW11bGF0b3JcblxuXG5cbmZ1bmN0aW9uIHNCYXIoIGNvbnRleHQgKSB7XG5cdHRoaXMud1dpZHRoID0gd2luZG93LmlubmVyV2lkdGhcblx0dGhpcy5oYWxmd1dpZHRoID0gdGhpcy53V2lkdGggKiAwLjVcblx0dGhpcy53SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG5cdHRoaXMuaGFsZndIZWlnaHQgPSB0aGlzLndIZWlnaHQgKiAwLjVcblxuXHR0aGlzLmluZGV4ID0gNDUxXG5cdHRoaXMueERlbHRhID0gdGhpcy53V2lkdGggKiAwLjI1XG5cdHRoaXMuaGVpZ2h0ID0gNDlcblx0dGhpcy5zd2lwZVlUaHJlc2hvbGQgPSA0MFxuXHR0aGlzLmNsaWNrVGhyZXNob2xkID0gMTBcblxuXHR0aGlzLmNsYW1wID0gZnVuY3Rpb24gKCB4LCBhLCBiICkge1xuXHRcdHJldHVybiBNYXRoLm1pbiggTWF0aC5tYXgoIHgsIGEgKSwgYiApXG5cdH1cblxuXHR0aGlzLnRlbXAgPSBbIHt9LCB7fSwge30sIHt9LCB7fSwge30sIHt9LCB7fSBdXG5cdHRoaXMuc3VyZnMgPSBbXVxuXHR0aGlzLm5vZGVzID0gW11cblx0dGhpcy5zY2FsZXMgPSBbXVxuXHR0aGlzLnNjYWxlc1RyYW5zID0gW11cblx0dGhpcy5qdW1wcyA9IFtdXG5cdHRoaXMuanVtcHNUcmFucyA9IFtdXG5cblx0dGhpcy5sYXlvdXQgPSBuZXcgU2VxdWVudGlhbExheW91dCgge1xuXHRcdGRpcmVjdGlvbjogMFxuXHR9IClcblxuXHR0aGlzLmlucHV0ID0gbmV3IFRvdWNoSW5wdXQoKVxuXG5cdHRoaXMueCA9IG5ldyBUcmFuc2l0aW9uYWJsZSggMCApXG5cdHRoaXMudHJhbnNmb3JtID0gdGhpcy54Lm1hcCggZnVuY3Rpb24gKCB2ICkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCAndiA+JywgdiApXG5cdFx0cmV0dXJuIFRyYW5zZm9ybS50cmFuc2xhdGVYKCB2ICsgKCB0aGlzLnhEZWx0YSAqIDAuNSApIClcblx0fS5iaW5kKCB0aGlzICkgKVxuXG5cdHZhciBpLCBsZW4gPSB0aGlzLnRlbXAubGVuZ3RoXG5cdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0dGhpcy5ub2Rlc1sgaSBdID0gbmV3IENvbnRhaW5lclN1cmZhY2UoIHtcblx0XHRcdHNpemU6IFsgdGhpcy54RGVsdGEsIHRoaXMuaGVpZ2h0IF1cblx0XHR9IClcblxuXHRcdHRoaXMuc3VyZnNbIGkgXSA9IG5ldyBTdXJmYWNlKCB7XG5cdFx0XHRjb250ZW50OiAnJyxcblx0XHRcdHNpemU6IFsgdGhpcy54RGVsdGEsIHRoaXMuaGVpZ2h0IF0sXG5cdFx0XHRvcmlnaW46IFsgMC41LCAxIF1cblx0XHR9IClcblxuXHRcdHRoaXMudGVtcFsgaSBdLmNsaWNrID0gbnVsbFxuXHRcdHRoaXMudGVtcFsgaSBdLmNsaWNrSG9sZCA9IG51bGxcblx0XHR0aGlzLnRlbXBbIGkgXS5ocmVmID0gbnVsbFxuXHRcdHRoaXMudGVtcFsgaSBdLmhpZGRlbiA9IGZhbHNlXG5cblx0XHR0aGlzLmlucHV0LnN1YnNjcmliZSggdGhpcy5zdXJmc1sgaSBdIClcblxuXHRcdHRoaXMuc2NhbGVzWyBpIF0gPSBuZXcgVHJhbnNpdGlvbmFibGUoIDEgKVxuXHRcdHRoaXMuc2NhbGVzVHJhbnNbIGkgXSA9IHRoaXMuc2NhbGVzWyBpIF0ubWFwKCBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIFRyYW5zZm9ybS5zY2FsZSggWyB2YWx1ZSwgdmFsdWUgXSApXG5cdFx0fSApXG5cblx0XHR0aGlzLmp1bXBzWyBpIF0gPSBuZXcgVHJhbnNpdGlvbmFibGUoIDAgKVxuXHRcdHRoaXMuanVtcHNUcmFuc1sgaSBdID0gdGhpcy5qdW1wc1sgaSBdLm1hcCggZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBUcmFuc2Zvcm0udHJhbnNsYXRlWSggdmFsdWUgKVxuXHRcdH0gKVxuXG5cdFx0dGhpcy5ub2Rlc1sgaSBdLmFkZCgge1xuXHRcdFx0dHJhbnNmb3JtOiB0aGlzLnNjYWxlc1RyYW5zWyBpIF1cblx0XHR9ICkuYWRkKCB7XG5cdFx0XHR0cmFuc2Zvcm06IHRoaXMuanVtcHNUcmFuc1sgaSBdXG5cdFx0fSApLmFkZCggdGhpcy5zdXJmc1sgaSBdIClcblxuXHR9XG5cblx0dGhpcy5sYXlvdXQuYWRkSXRlbXMoIHRoaXMubm9kZXMgKVxuXG5cdHRoaXMuY2xpY2tIb2xkRm4gPSBmdW5jdGlvbiAoIHBvc1ggKSB7XG5cdFx0aWYgKCB0aGlzLmFic0FjY3UgPiB0aGlzLmNsaWNrVGhyZXNob2xkIHx8IHRoaXMuZGlkQ2xpY2sgPT0gdHJ1ZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHZhciBpID0gdGhpcy5nZXRTdXJmQnlQb3MoIHBvc1ggKVxuXG5cdFx0aWYgKCBfLmlzRnVuY3Rpb24oIHRoaXMudGVtcFsgaSBdLmNsaWNrSG9sZCApICkge1xuXG5cdFx0XHR0aGlzLmRpZENsaWNrID0gdHJ1ZVxuXHRcdFx0dGhpcy5zdG9wRHJhZ2dpbmcgPSB0cnVlXG5cblx0XHRcdG5hdmlnYXRvci52aWJyYXRlKCA1MCApXG5cblx0XHRcdHRoaXMudGVtcFsgaSBdLmNsaWNrSG9sZCgpXG5cdFx0XHR0aGlzLmRpZENsaWNrID0gdHJ1ZVxuXG5cdFx0XHR0aGlzLnNjYWxlc1sgaSBdLnJlc2V0KCAxLjUgKVxuXHRcdFx0dGhpcy5zY2FsZXNbIGkgXS5zZXQoIDEsIHtcblx0XHRcdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0XHRcdGN1cnZlOiBDdXJ2ZXMub3V0Qm91bmNlXG5cdFx0XHR9IClcblxuXHRcdFx0dGhpcy5qdW1wc1sgaSBdLnJlc2V0KCAtdGhpcy5oZWlnaHQgKVxuXHRcdFx0dGhpcy5qdW1wc1sgaSBdLnNldCggMCwge1xuXHRcdFx0XHRkdXJhdGlvbjogMTAwMCxcblx0XHRcdFx0Y3VydmU6IEN1cnZlcy5vdXRCb3VuY2Vcblx0XHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhpcy5jZW50ZXJJdCgpXG5cdFx0XHR9LmJpbmQoIHRoaXMgKSApXG5cblx0XHRcdC8vIHRoaXMudGVtcFsgaSBdLnNjYWxlQ29tcC5zZXQoIDEuNSwgMS41LCAxIClcblx0XHRcdC8vIHRoaXMudGVtcFsgaSBdLnNjYWxlQ29tcC5zZXQoIDEsIDEsIDEsIHtcblx0XHRcdC8vIFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0XHQvLyBcdGN1cnZlOiAnb3V0Qm91bmNlJ1xuXHRcdFx0Ly8gfSApXG5cblx0XHRcdC8vIHRoaXMudGVtcFsgaSBdLnBvc0NvbXAuc2V0WSggLTczLjUgKVxuXHRcdFx0Ly8gdGhpcy50ZW1wWyBpIF0ucG9zQ29tcC5zZXRZKCAwLCB7XG5cdFx0XHQvLyBcdGR1cmF0aW9uOiAxMDAwLFxuXHRcdFx0Ly8gXHRjdXJ2ZTogJ291dEJvdW5jZSdcblx0XHRcdC8vIH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIFx0dGhpcy5jZW50ZXJJdCgpXG5cdFx0XHQvLyB9LmJpbmQoIHRoaXMgKSApXG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuaW5wdXQub24oICdzdGFydCcsIGZ1bmN0aW9uICggcGF5ICkge1xuXHRcdC8vIGNvbnNvbGUud2FybiggJ1NUQVJUID4gcGF5ID4nLCBKU09OLnN0cmluZ2lmeSggcGF5LCB0cnVlLCA0ICkgKVxuXG5cdFx0dGhpcy54LnJlc2V0KClcblxuXHRcdHRoaXMuZG93biA9IDBcblx0XHR0aGlzLmFic0FjY3UgPSAwXG5cdFx0dGhpcy5hY2N1ID0gMFxuXHRcdHRoaXMuZGlkQ2xpY2sgPSBmYWxzZVxuXHRcdHRoaXMuc3RvcERyYWdnaW5nID0gZmFsc2VcblxuXHRcdHZhciBpID0gcGF5LmNsaWVudFhcblx0XHR0aGlzLnRpbWVvdXQgPSBUaW1lci5hZnRlciggZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5jbGlja0hvbGRGbiggaSApXG5cdFx0fS5iaW5kKCB0aGlzICksIDI1IClcblxuXHRcdF8kdXRpbHMuZXZlbnRzLmVtaXQoICdzYW1zYXJhLm1NZW51LmNsb3NlJyApXG5cdFx0XyR1dGlscy5ldmVudHMuZW1pdCggJ3NhbXNhcmEuc01lbnUuY2xvc2UnIClcblxuXHR9LmJpbmQoIHRoaXMgKSApXG5cblx0dGhpcy5pbnB1dC5vbiggJ3VwZGF0ZScsIGZ1bmN0aW9uICggcGF5ICkge1xuXHRcdC8vIGNvbnNvbGUubG9nKCAnVVBEQVRFID4gcGF5ID4nLCBKU09OLnN0cmluZ2lmeSggcGF5LCB0cnVlLCA0ICkgKVxuXG5cdFx0aWYgKCB0aGlzLnN0b3BEcmFnZ2luZyA9PSB0cnVlICkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dmFyIGRlbHRhID0gcGF5LmRlbHRhXG5cdFx0dmFyIHZlbG9jaXR5ID0gcGF5LnZlbG9jaXR5XG5cdFx0dmFyIHZhbHVlID0gcGF5LnZhbHVlXG5cblx0XHRpZiAoIHRoaXMuZG93biA8IHRoaXMuc3dpcGVZVGhyZXNob2xkICkge1xuXHRcdFx0dGhpcy5kb3duID0gdGhpcy5kb3duICsgKCAoIGRlbHRhWyAxIF0gKiB2ZWxvY2l0eVsgMSBdICkgLSAoIGRlbHRhWyAwIF0gKiB2ZWxvY2l0eVsgMCBdICkgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRfJHV0aWxzLmV2ZW50cy5lbWl0KCAnc2Ftc2FyYS5tTWVudS5vcGVuJyApXG5cdFx0XHR0aGlzLnN0b3BEcmFnZ2luZyA9IHRydWVcblx0XHRcdHRoaXMuZGlkQ2xpY2sgPSB0cnVlXG5cdFx0XHR0aGlzLmNlbnRlckl0KClcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hYnNBY2N1IDwgdGhpcy5jbGlja1RocmVzaG9sZCApIHsgLy8gZm9yIGdldHRpbmcgYSB0aHJlc2hvbGQgb24gY2xpY2sgZXZlbnRzXG5cdFx0XHR0aGlzLmFic0FjY3UgPSB0aGlzLmFic0FjY3UgKyBNYXRoLmFicyggZGVsdGFbIDAgXSApICsgTWF0aC5hYnMoIGRlbHRhWyAxIF0gKVxuXHRcdH1cblxuXHRcdHZhciBib29zdCA9IHRoaXMuY2xhbXAoIE1hdGguYWJzKCB2ZWxvY2l0eVsgMCBdICogMS4yNSApLCAxLCAzIClcblx0XHR2YXIgYWNjdSA9IHRoaXMuYWNjdSArICggZGVsdGFbIDAgXSAqIGJvb3N0IClcblx0XHR0aGlzLmFjY3UgPSB0aGlzLmNsYW1wKCBhY2N1LCAtdGhpcy54RGVsdGEsIHRoaXMueERlbHRhIClcblx0XHR0aGlzLnguc2V0KCB0aGlzLmFjY3UgKVxuXG5cblxuXHRcdGlmICggTWF0aC5hYnMoIHRoaXMuYWNjdSApID49IHRoaXMueERlbHRhICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYWNjdSA+IDAgKSB7IC8vIHRlc3QgaWYgaXRzIGxlZnQgb3IgcmlnaHRcblxuXHRcdFx0XHRpZiAoIF8uaXNGdW5jdGlvbiggdGhpcy50ZW1wWyAwIF0uY2xpY2sgKSApIHtcblx0XHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuc3VyZnNbIDAgXS5nZXRDbGFzc0xpc3QoKVxuXHRcdFx0XHRcdGlmICggY2xhc3Nlcy5pbmRleE9mKCAnc0Jhci1hY3RpdmUnICkgPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN1cmZzWyAwIF0uYWRkQ2xhc3MoICdzQmFyLWFjdGl2ZScgKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuZGlkQ2xpY2sgPSB0cnVlXG5cdFx0XHRcdFx0dGhpcy5zdG9wRHJhZ2dpbmcgPSB0cnVlXG5cblx0XHRcdFx0XHRpZiAoIHRoaXMudGVtcFsgMCBdLmhyZWYgIT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGVtcFsgMCBdLmNsaWNrKClcblx0XHRcdFx0XHRcdFRpbWVyLmFmdGVyKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuY2VudGVySXQoKVxuXHRcdFx0XHRcdFx0fS5iaW5kKCB0aGlzICksIDUgKVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0VGltZXIuYWZ0ZXIoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHRoaXMudGVtcFsgMCBdLmNsaWNrKClcblx0XHRcdFx0XHRcdFx0Ly8gVGltZXIuYWZ0ZXIoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0Ly8gXHR0aGlzLmNlbnRlckl0KCB0cnVlIClcblx0XHRcdFx0XHRcdFx0Ly8gfS5iaW5kKCB0aGlzICksIDUgKVxuXHRcdFx0XHRcdH0uYmluZCggdGhpcyApLCA1IClcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggXy5pc0Z1bmN0aW9uKCB0aGlzLnRlbXBbIDUgXS5jbGljayApICkge1xuXHRcdFx0XHRcdHZhciBjbGFzc2VzID0gdGhpcy5zdXJmc1sgNSBdLmdldENsYXNzTGlzdCgpXG5cdFx0XHRcdFx0aWYgKCBjbGFzc2VzLmluZGV4T2YoICdzQmFyLWFjdGl2ZScgKSA9PSAtMSApIHtcblx0XHRcdFx0XHRcdHRoaXMuc3VyZnNbIDUgXS5hZGRDbGFzcyggJ3NCYXItYWN0aXZlJyApXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5kaWRDbGljayA9IHRydWVcblx0XHRcdFx0XHR0aGlzLnN0b3BEcmFnZ2luZyA9IHRydWVcblxuXHRcdFx0XHRcdGlmICggdGhpcy50ZW1wWyA1IF0uaHJlZiAhPSB0cnVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZW1wWyA1IF0uY2xpY2soKVxuXHRcdFx0XHRcdFx0VGltZXIuYWZ0ZXIoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5jZW50ZXJJdCgpXG5cdFx0XHRcdFx0XHR9LmJpbmQoIHRoaXMgKSwgNSApXG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRUaW1lci5hZnRlciggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZW1wWyA1IF0uY2xpY2soKVxuXHRcdFx0XHRcdFx0XHQvLyBUaW1lci5hZnRlciggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHQvLyBcdHRoaXMuY2VudGVySXQoIHRydWUgKVxuXHRcdFx0XHRcdFx0XHQvLyB9LmJpbmQoIHRoaXMgKSwgNSApXG5cdFx0XHRcdFx0fS5iaW5kKCB0aGlzICksIDUgKVxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmFjY3UgPiAwICkgeyAvLyB0ZXN0IGlmIGl0cyBsZWZ0IG9yIHJpZ2h0XG5cdFx0XHR2YXIgY2xhc3NlcyA9IHRoaXMuc3VyZnNbIDAgXS5nZXRDbGFzc0xpc3QoKVxuXHRcdFx0aWYgKCBjbGFzc2VzLmluZGV4T2YoICdzQmFyLWFjdGl2ZScgKSAhPSAtMSApIHtcblx0XHRcdFx0dGhpcy5zdXJmc1sgMCBdLnJlbW92ZUNsYXNzKCAnc0Jhci1hY3RpdmUnIClcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNsYXNzZXMgPSB0aGlzLnN1cmZzWyA1IF0uZ2V0Q2xhc3NMaXN0KClcblx0XHRcdGlmICggY2xhc3Nlcy5pbmRleE9mKCAnc0Jhci1hY3RpdmUnICkgIT0gLTEgKSB7XG5cdFx0XHRcdHRoaXMuc3VyZnNbIDUgXS5yZW1vdmVDbGFzcyggJ3NCYXItYWN0aXZlJyApXG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0uYmluZCggdGhpcyApIClcblxuXHR0aGlzLmlucHV0Lm9uKCAnZW5kJywgZnVuY3Rpb24gKCBwYXkgKSB7XG5cdFx0Ly8gY29uc29sZS53YXJuKCAnRU5EID4gcGF5ID4nLCBKU09OLnN0cmluZ2lmeSggcGF5LCB0cnVlLCA0ICkgKVxuXG5cdFx0aWYgKCB0aGlzLnRpbWVvdXQgKSB7XG5cdFx0XHRUaW1lci5jbGVhciggdGhpcy50aW1lb3V0IClcblx0XHRcdHRoaXMudGltZW91dCA9IG51bGxcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZGlkQ2xpY2sgPT0gdHJ1ZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hYnNBY2N1IDwgdGhpcy5jbGlja1RocmVzaG9sZCApIHtcblxuXHRcdFx0dmFyIGkgPSB0aGlzLmdldFN1cmZCeVBvcyggcGF5LmNsaWVudFggKVxuXG5cdFx0XHRpZiAoIF8uaXNGdW5jdGlvbiggdGhpcy50ZW1wWyBpIF0uY2xpY2sgKSApIHtcblxuXHRcdFx0XHR0aGlzLmRpZENsaWNrID0gdHJ1ZVxuXG5cdFx0XHRcdGlmICggdGhpcy50ZW1wWyBpIF0uaHJlZiA9PSB0cnVlICkge1xuXHRcdFx0XHRcdHRoaXMuc2NhbGVzWyBpIF0uc2V0KCAxLjI1IClcblxuXHRcdFx0XHRcdFRpbWVyLmFmdGVyKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRlbXBbIGkgXS5jbGljaygpXG5cdFx0XHRcdFx0XHRUaW1lci5hZnRlciggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNjYWxlc1sgaSBdLnNldCggMSApXG5cdFx0XHRcdFx0XHR9LmJpbmQoIHRoaXMgKSwgNSApXG5cdFx0XHRcdFx0fS5iaW5kKCB0aGlzICksIDUgKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50ZW1wWyBpIF0uY2xpY2soKVxuXHRcdFx0XHR0aGlzLnNjYWxlc1sgaSBdLnNldCggMS4yNSwge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiAxMDAsXG5cdFx0XHRcdFx0Y3VydmU6IEN1cnZlcy5lYXNlT3V0Qm91bmNlXG5cdFx0XHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLnNjYWxlc1sgaSBdLnNldCggMSwge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDEwMCxcblx0XHRcdFx0XHRcdGN1cnZlOiBDdXJ2ZXMuZWFzZUluXG5cdFx0XHRcdFx0fSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5jZW50ZXJJdCgpXG5cdFx0XHRcdFx0fS5iaW5kKCB0aGlzICkgKVxuXHRcdFx0XHR9LmJpbmQoIHRoaXMgKSApXG5cblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5jZW50ZXJJdCgpXG5cblx0fS5iaW5kKCB0aGlzICkgKVxuXG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHRlbXAgKSB7XG5cblx0XHQvLyBpZiAoIF8kcm91dGVyLmhpc3RBcnJbIDEgXSApIHtcblx0XHQvLyBcdHZhciBiYWNrYWJsZSA9IF8ucGFyc2VCb29sKCBfJHJvdXRlci5oaXN0QXJyWyAwIF0ucXVlcnkuYmFja2FibGUgKVxuXHRcdC8vIFx0aWYgKCBiYWNrYWJsZSA9PSB0cnVlICkge1xuXHRcdC8vIFx0XHR0ZW1wWyAwIF0gPSB7XG5cdFx0Ly8gXHRcdFx0X3RleHQ6IFwiR28gQmFja1wiLFxuXHRcdC8vIFx0XHRcdF9pY29uOiBcImlvbi1hcnJvdy1sZWZ0LWNcIixcblx0XHQvLyBcdFx0XHRfY29sb3I6ICdhc3NlcnRpdmUnLFxuXHRcdC8vIFx0XHRcdF9ocmVmOiB0cnVlLFxuXHRcdC8vIFx0XHRcdF9jbGljazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0XHRcdFx0XyRyb3V0ZXIuZ29CYWNrKClcblx0XHQvLyBcdFx0XHR9LmJpbmQoIHRoaXMgKVxuXHRcdC8vIFx0XHR9XG5cdFx0Ly8gXHRcdF8kcm91dGVyLmhpc3RBcnJbIDAgXS5xdWVyeSA9IF8ub21pdCggXyRyb3V0ZXIuaGlzdEFyclsgMCBdLnF1ZXJ5LCAnYmFja2FibGUnIClcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cblx0XHR2YXIgaSwgbGVuID0gdGVtcC5sZW5ndGhcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXG5cdFx0XHR0aGlzLnRlbXBbIGkgXS5ocmVmID0gbnVsbFxuXHRcdFx0aWYgKCB0ZW1wWyBpIF0uX2hyZWYgKSB7XG5cdFx0XHRcdHRoaXMudGVtcFsgaSBdLmhyZWYgPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjbGFzc2VzID0gJydcblx0XHRcdGlmICggaSA9PSAxICkge1xuXHRcdFx0XHRjbGFzc2VzID0gJyBzQmFyLWxlZnQtJyArIHRlbXBbIDAgXS5fY29sb3Jcblx0XHRcdH1cblx0XHRcdGlmICggaSA9PSA0ICYmIHRlbXBbIDUgXS5fY29sb3IgKSB7XG5cdFx0XHRcdGNsYXNzZXMgPSAnIHNCYXItcmlnaHQtJyArIHRlbXBbIDUgXS5fY29sb3Jcblx0XHRcdH1cblxuXHRcdFx0dmFyIGljb24gPSAnJ1xuXHRcdFx0aWYgKCB0ZW1wWyBpIF0uX2ljb24gKSB7XG5cdFx0XHRcdGljb24gPSAnICcgKyB0ZW1wWyBpIF0uX2ljb25cblx0XHRcdH1cblxuXHRcdFx0dmFyIHRleHQgPSAnJ1xuXHRcdFx0aWYgKCB0ZW1wWyBpIF0uX3RleHQgKSB7XG5cdFx0XHRcdHRleHQgPSB0ZW1wWyBpIF0uX3RleHRcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zdXJmc1sgaSBdLnNldENvbnRlbnQoICc8ZGl2IGNsYXNzPVwidGFicyB0YWJzLWljb24tdG9wJyArIGNsYXNzZXMgKyAnXCI+PGEgY2xhc3M9XCJ0YWItaXRlbVwiPjxpIGNsYXNzPVwiaWNvbicgKyBpY29uICsgJ1wiPjwvaT4nICsgdGV4dCArICc8L2E+PC9kaXY+JyApXG5cblx0XHRcdHRoaXMudGVtcFsgaSBdLmNsaWNrID0gbnVsbFxuXHRcdFx0aWYgKCB0ZW1wWyBpIF0uX2NsaWNrICkge1xuXHRcdFx0XHR0aGlzLnRlbXBbIGkgXS5jbGljayA9IHRlbXBbIGkgXS5fY2xpY2tcblx0XHRcdH1cblxuXHRcdFx0dGhpcy50ZW1wWyBpIF0uY2xpY2tIb2xkID0gbnVsbFxuXHRcdFx0aWYgKCB0ZW1wWyBpIF0uX2NsaWNrSG9sZCApIHtcblx0XHRcdFx0dGhpcy50ZW1wWyBpIF0uY2xpY2tIb2xkID0gdGVtcFsgaSBdLl9jbGlja0hvbGRcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpID49IDEgJiYgaSA8PSA0ICYmIHRoaXMudGVtcFsgaSBdLl9oaWRkZW4gPT0gdHJ1ZSApIHtcblx0XHRcdFx0dGhpcy5zaG93KCBpIClcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuc3VyZnNbIDAgXS5zZXRDbGFzc2VzKCBbXSApXG5cdFx0dGhpcy5zdXJmc1sgNSBdLnNldENsYXNzZXMoIFtdIClcblxuXHRcdHRoaXMuc3VyZnNbIDAgXS5hZGRDbGFzcyggWyAnc0Jhci0nICsgdGVtcFsgMCBdLl9jb2xvciBdIClcblx0XHRpZiAoIHRlbXBbIDUgXS5fY29sb3IgKSB7XG5cdFx0XHR0aGlzLnN1cmZzWyA1IF0uYWRkQ2xhc3MoIFsgJ3NCYXItJyArIHRlbXBbIDUgXS5fY29sb3IgXSApXG5cdFx0fVxuXG5cdH1cblxuXG5cblx0dGhpcy5jZW50ZXJJdCA9IGZ1bmN0aW9uICggbm93ICkge1xuXHRcdGlmICggbm93ID09IHRydWUgKSB7XG5cdFx0XHR0aGlzLnguc2V0KCAwIClcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHRoaXMueC5zZXQoIDAsIHtcblx0XHRcdGR1cmF0aW9uOiAyNTAsXG5cdFx0XHRjdXJ2ZTogQ3VydmVzLm91dEJhY2tcblx0XHR9IClcblx0fVxuXG5cdHRoaXMuc2hvdyA9IGZ1bmN0aW9uICggaSApIHtcblx0XHR0aGlzLnN1cmZzWyBpIF0ucmVtb3ZlQ2xhc3MoICdzYmFyLWhpZGUnIClcblx0XHR0aGlzLnRlbXBbIGkgXS5faGlkZGVuID0gZmFsc2Vcblx0fVxuXG5cdHRoaXMuaGlkZSA9IGZ1bmN0aW9uICggaSApIHtcblx0XHR0aGlzLnN1cmZzWyBpIF0uYWRkQ2xhc3MoICdzYmFyLWhpZGUnIClcblx0XHR0aGlzLnRlbXBbIGkgXS5faGlkZGVuID0gdHJ1ZVxuXHR9XG5cblx0dGhpcy5nZXRTdXJmQnlQb3MgPSBmdW5jdGlvbiAoIHBvc1ggKSB7XG5cdFx0aWYgKCBfLmluUmFuZ2UoIHBvc1gsIDAsIHRoaXMueERlbHRhICkgKSB7XG5cdFx0XHRyZXR1cm4gMVxuXHRcdH0gZWxzZSBpZiAoIF8uaW5SYW5nZSggcG9zWCwgdGhpcy54RGVsdGEsIHRoaXMueERlbHRhICogMiApICkge1xuXHRcdFx0cmV0dXJuIDJcblx0XHR9IGVsc2UgaWYgKCBfLmluUmFuZ2UoIHBvc1gsIHRoaXMueERlbHRhICogMiwgdGhpcy54RGVsdGEgKiAzICkgKSB7XG5cdFx0XHRyZXR1cm4gM1xuXHRcdH0gZWxzZSBpZiAoIF8uaW5SYW5nZSggcG9zWCwgdGhpcy54RGVsdGEgKiAzLCB0aGlzLnhEZWx0YSAqIDQgKSApIHtcblx0XHRcdHJldHVybiA0XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoICd0aGlzLmdldFN1cmZCeVBvcyA+JyApXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnV1RGIE5PVCBJTiBSQU5HRT8/PycgKVxuXHRcdH1cblx0fVxuXG5cblxuXHRjb250ZXh0LmFkZCgge1xuXHRcdGFsaWduOiBbIDAsIDEgXSxcblx0XHR0cmFuc2Zvcm06IFRyYW5zZm9ybS50cmFuc2xhdGUoIFsgLXRoaXMueERlbHRhLCAwIF0gKVxuXHR9ICkuYWRkKCB7XG5cdFx0dHJhbnNmb3JtOiB0aGlzLnRyYW5zZm9ybVxuXHR9ICkuYWRkKCB0aGlzLmxheW91dCApXG5cbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHNCYXJcblxuLy9cblxuIiwiLy9cblxudmFyIF8kdXRpbHMgPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxudmFyIEN1cnZlcyA9IHJlcXVpcmUoICcuL0N1cnZlcy5qcycgKVxudmFyIFNhbXNhcmEgPSByZXF1aXJlKCAnc2Ftc2FyYWpzJyApXG52YXIgU3VyZmFjZSA9IFNhbXNhcmEuRE9NLlN1cmZhY2VcbnZhciBDb250YWluZXJTdXJmYWNlID0gU2Ftc2FyYS5ET00uQ29udGFpbmVyU3VyZmFjZVxudmFyIFRpbWVyID0gU2Ftc2FyYS5Db3JlLlRpbWVyXG52YXIgVHJhbnNmb3JtID0gU2Ftc2FyYS5Db3JlLlRyYW5zZm9ybVxudmFyIE1vdXNlSW5wdXQgPSBTYW1zYXJhLklucHV0cy5Nb3VzZUlucHV0XG52YXIgVG91Y2hJbnB1dCA9IFNhbXNhcmEuSW5wdXRzLlRvdWNoSW5wdXRcbnZhciBTZXF1ZW50aWFsTGF5b3V0ID0gU2Ftc2FyYS5MYXlvdXRzLlNlcXVlbnRpYWxMYXlvdXRcbnZhciBUcmFuc2l0aW9uYWJsZSA9IFNhbXNhcmEuQ29yZS5UcmFuc2l0aW9uYWJsZVxudmFyIEFjY3VtdWxhdG9yID0gU2Ftc2FyYS5TdHJlYW1zLkFjY3VtdWxhdG9yXG5cblxuXG5mdW5jdGlvbiBzTWVudSggY29udGV4dCApIHtcblx0Ly8gdGhpcy53V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuXHQvLyB0aGlzLmhhbGZ3V2lkdGggPSB0aGlzLndXaWR0aCAqIDAuNVxuXHQvLyB0aGlzLndIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcblx0Ly8gdGhpcy5oYWxmd0hlaWdodCA9IHRoaXMud0hlaWdodCAqIDAuNVxuXG5cdGNvbnN0IHdXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG5cblx0dGhpcy5pbmRleCA9IDMwMVxuXHR0aGlzLnNob3duID0gZmFsc2Vcblx0dGhpcy5zaG93aW5nID0gZmFsc2Vcblx0dGhpcy50ZW1wID0gWyB7fSwge30sIHt9LCB7fSwge30sIHt9LCB7fSwge30gXVxuXG5cdHRoaXMud2lkdGggPSBfLm1hdGhDbGFtcCggMjUwLCAwLCB3V2lkdGggKiAwLjggKVxuXHR0aGlzLmhlaWdodCA9IDUwXG5cblx0dGhpcy5zdXJmcyA9IFtdXG5cdHRoaXMubm9kZXMgPSBbXVxuXHR0aGlzLnNjYWxlcyA9IFtdXG5cdHRoaXMuc2NhbGVzVHJhbnMgPSBbXVxuXHR0aGlzLmxheW91dCA9IG5ldyBTZXF1ZW50aWFsTGF5b3V0KCB7XG5cdFx0ZGlyZWN0aW9uOiAxXG5cdH0gKVxuXG5cdHRoaXMueSA9IG5ldyBUcmFuc2l0aW9uYWJsZSggMCApXG5cblx0dGhpcy55VHJhbnMgPSB0aGlzLnkubWFwKCBmdW5jdGlvbiAoIHYgKSB7XG5cdFx0cmV0dXJuIFRyYW5zZm9ybS50cmFuc2xhdGUoIFsgd1dpZHRoICogMC41LCB2ICsgNTAgXSApXG5cdH0uYmluZCggdGhpcyApIClcblxuXHR0aGlzLnRvdWNoZWQgPSBmdW5jdGlvbiAoIGkgKSB7XG5cdFx0aWYgKCAhXy5pc0Z1bmN0aW9uKCB0aGlzLnRlbXBbIGkgXS5jbGljayApICkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dGhpcy5zY2FsZXNbIGkgXS5yZXNldCggMS4yIClcblx0XHR0aGlzLnRlbXBbIGkgXS5jbGljaygpXG5cblx0XHR0aGlzLnNjYWxlc1sgaSBdLnNldCggMSwge1xuXHRcdFx0ZHVyYXRpb246IDEwMFxuXHRcdH0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHRoaXMuY2xvc2UoKVxuXHRcdH0uYmluZCggdGhpcyApIClcblxuXHR9XG5cblx0Xy5mb3JFYWNoKCB0aGlzLnRlbXAsIGZ1bmN0aW9uICggdiwgaSApIHtcblx0XHR0aGlzLm5vZGVzWyBpIF0gPSBuZXcgQ29udGFpbmVyU3VyZmFjZSgge1xuXHRcdFx0c2l6ZTogWyB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCBdLFxuXHRcdFx0b3JpZ2luOiBbIDAuNSwgMSBdXG5cdFx0fSApXG5cblx0XHR0aGlzLnN1cmZzWyBpIF0gPSBuZXcgU3VyZmFjZSgge1xuXHRcdFx0Y29udGVudDogJzx1bCBjbGFzcz1cImxpc3RcIj48bGkgY2xhc3M9XCJpdGVtXCI+JyArIGkgKyAnPC9saT48L3VsPicsXG5cdFx0XHRzaXplOiBbIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0IF0sXG5cdFx0XHRvcmlnaW46IFsgMC41LCAxIF1cblx0XHR9IClcblxuXHRcdHRoaXMudGVtcFsgaSBdLmNsaWNrID0gbnVsbFxuXHRcdHRoaXMubm9kZXNbIGkgXS5vbiggJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnRvdWNoZWQoIGkgKVxuXHRcdH0uYmluZCggdGhpcyApIClcblxuXHRcdHRoaXMuc2NhbGVzWyBpIF0gPSBuZXcgVHJhbnNpdGlvbmFibGUoIDEgKVxuXHRcdHRoaXMuc2NhbGVzVHJhbnNbIGkgXSA9IHRoaXMuc2NhbGVzWyBpIF0ubWFwKCBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIFRyYW5zZm9ybS5zY2FsZSggWyB2YWx1ZSwgdmFsdWUgXSApXG5cdFx0fSApXG5cblx0XHR0aGlzLm5vZGVzWyBpIF0uYWRkKCB7XG5cdFx0XHR0cmFuc2Zvcm06IHRoaXMuc2NhbGVzVHJhbnNbIGkgXVxuXHRcdH0gKS5hZGQoIHRoaXMuc3VyZnNbIGkgXSApXG5cblx0fS5iaW5kKCB0aGlzICkgKVxuXG5cdHRoaXMubGF5b3V0LmFkZEl0ZW1zKCB0aGlzLm5vZGVzIClcblxuXHR0aGlzLm9wZW4gPSBmdW5jdGlvbiAoIHRlbXAgKSB7XG5cdFx0aWYgKCB0aGlzLnNob3duID09IHRydWUgKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR0aGlzLnNob3dpbmcgPSB0cnVlXG5cblx0XHRfJHV0aWxzLmV2ZW50cy5lbWl0KCAnc2Ftc2FyYS5tTWVudS5jbG9zZScgKVxuXG5cdFx0dmFyIGksIGxlbiA9IDhcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCB0ZW1wWyBpIF0gKSB7XG5cdFx0XHRcdHZhciBjb250ZW50ID0gJzx1bCBjbGFzcz1cImxpc3RcIj48bGkgY2xhc3M9XCJpdGVtXCI+JyArIHRlbXBbIGkgXS5fdGV4dCArICc8L2xpPjwvdWw+J1xuXHRcdFx0XHRpZiAoIHRlbXBbIGkgXS5faWNvbiApIHtcblx0XHRcdFx0XHRjb250ZW50ID0gJzx1bCBjbGFzcz1cImxpc3RcIj48bGkgY2xhc3M9XCJpdGVtIGl0ZW0taWNvbi1sZWZ0XCI+PGkgY2xhc3M9XCJpY29uICcgKyB0ZW1wWyBpIF0uX2ljb24gKyAnXCI+PC9pPiAnICsgdGVtcFsgaSBdLl90ZXh0ICsgJzwvbGk+PC91bD4nXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnN1cmZzWyBpIF0uc2V0Q29udGVudCggY29udGVudCApXG5cblx0XHRcdFx0dGhpcy50ZW1wWyBpIF0uY2xpY2sgPSBudWxsXG5cdFx0XHRcdGlmICggdGVtcFsgaSBdLl9jbGljayApIHtcblx0XHRcdFx0XHR0aGlzLnRlbXBbIGkgXS5jbGljayA9IHRlbXBbIGkgXS5fY2xpY2tcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHQvLyAgZWxzZSB7XG5cdFx0XHQvLyBcdC8vIHRoaXMuc3VyZnNbIGkgXS5zZXRDb250ZW50KCAnPHVsIGNsYXNzPVwibGlzdFwiPjxsaSBjbGFzcz1cIml0ZW1cIj4nICsgaSArICc8L2xpPjwvdWw+JyApXG5cdFx0XHQvLyBcdHRoaXMudGVtcFsgaSBdLmNsaWNrID0gbnVsbFxuXHRcdFx0Ly8gfVxuXHRcdH1cblxuXHRcdFRpbWVyLmFmdGVyKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnkuc2V0KCAtKCA0OSArICggKCB0ZW1wLmxlbmd0aCApICogNTAgKSApLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiAyMDAsXG5cdFx0XHRcdGN1cnZlOiBDdXJ2ZXMub3V0QmFja1xuXHRcdFx0fSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLnNob3duID0gdHJ1ZVxuXHRcdFx0XHR0aGlzLnNob3dpbmcgPSBmYWxzZVxuXHRcdFx0fS5iaW5kKCB0aGlzICkgKVxuXHRcdH0uYmluZCggdGhpcyApLCAyIClcblxuXHR9LmJpbmQoIHRoaXMgKVxuXG5cdHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoIG5vdyApIHtcblx0XHRpZiAoIHRoaXMuc2hvd24gPT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR0aGlzLnNob3dpbmcgPSB0cnVlXG5cblx0XHRpZiAoIG5vdyA9PSB0cnVlICkge1xuXHRcdFx0dGhpcy55LnNldCggMCApXG5cdFx0XHR0aGlzLnkucmVzZXQoIDAgKVxuXHRcdFx0dGhpcy5zaG93aW5nID0gZmFsc2Vcblx0XHRcdHRoaXMuc2hvd24gPSBmYWxzZVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dGhpcy55LnNldCggMCwge1xuXHRcdFx0ZHVyYXRpb246IDI1MCxcblx0XHRcdGN1cnZlOiBDdXJ2ZXMuZWFzZUluXG5cdFx0fSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0VGltZXIuYWZ0ZXIoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGksIGxlbiA9IHRoaXMudGVtcC5sZW5ndGhcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHR0aGlzLnN1cmZzWyBpIF0uc2V0Q29udGVudCggJycgKVxuXHRcdFx0XHRcdHRoaXMudGVtcFsgaSBdLmNsaWNrID0gbnVsbFxuXHRcdFx0XHR9XG5cblx0XHRcdHRoaXMueS5yZXNldCggMCApXG5cdFx0XHR0aGlzLnNob3duID0gZmFsc2Vcblx0XHRcdHRoaXMuc2hvd2luZyA9IGZhbHNlXG5cblx0XHRcdH0uYmluZCggdGhpcyApLCAxMCApXG5cdFx0fS5iaW5kKCB0aGlzICkgKVxuXG5cdH0uYmluZCggdGhpcyApXG5cblxuXG5cblxuXHRjb250ZXh0LmFkZCgge1xuXHRcdGFsaWduOiBbIDAsIDEgXSxcblx0XHR0cmFuc2Zvcm06IHRoaXMueVRyYW5zXG5cdH0gKS5hZGQoIHRoaXMubGF5b3V0IClcblxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gc01lbnVcblxuLy9cblxuIiwiLy9cblxudmFyIEN1cnZlcyA9IHJlcXVpcmUoICcuL0N1cnZlcy5qcycgKVxudmFyIFNhbXNhcmEgPSByZXF1aXJlKCAnc2Ftc2FyYWpzJyApXG52YXIgU3VyZmFjZSA9IFNhbXNhcmEuRE9NLlN1cmZhY2VcbnZhciBUaW1lciA9IFNhbXNhcmEuQ29yZS5UaW1lclxudmFyIFRyYW5zZm9ybSA9IFNhbXNhcmEuQ29yZS5UcmFuc2Zvcm1cbnZhciBNb3VzZUlucHV0ID0gU2Ftc2FyYS5JbnB1dHMuTW91c2VJbnB1dFxudmFyIFRvdWNoSW5wdXQgPSBTYW1zYXJhLklucHV0cy5Ub3VjaElucHV0XG52YXIgU2VxdWVudGlhbExheW91dCA9IFNhbXNhcmEuTGF5b3V0cy5TZXF1ZW50aWFsTGF5b3V0XG52YXIgVHJhbnNpdGlvbmFibGUgPSBTYW1zYXJhLkNvcmUuVHJhbnNpdGlvbmFibGVcbnZhciBBY2N1bXVsYXRvciA9IFNhbXNhcmEuU3RyZWFtcy5BY2N1bXVsYXRvclxuXG5cblxuZnVuY3Rpb24gVHV0cyggY29udGV4dCApIHtcblx0dGhpcy53V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuXHR0aGlzLmhhbGZ3V2lkdGggPSB0aGlzLndXaWR0aCAqIDAuNVxuXHR0aGlzLndIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHRcblx0dGhpcy5oYWxmd0hlaWdodCA9IHRoaXMud0hlaWdodCAqIDAuNVxuXG5cdHRoaXMuaW5kZXggPSA2MDFcblx0dGhpcy50b3AgPSAwXG5cdHRoaXMuc2hvd24gPSBmYWxzZVxuXHR0aGlzLnNob3dpbmcgPSBmYWxzZVxuXG5cblxuXHR0aGlzLnkgPSBuZXcgVHJhbnNpdGlvbmFibGUoIC10aGlzLndIZWlnaHQgKVxuXHR0aGlzLm9wYSA9IG5ldyBUcmFuc2l0aW9uYWJsZSggMSApXG5cdHRoaXMuc2NhbGUgPSBuZXcgVHJhbnNpdGlvbmFibGUoIDEgKVxuXG5cdHRoaXMueVRyYW5zID0gdGhpcy55Lm1hcCggZnVuY3Rpb24gKCB2ICkge1xuXHRcdHJldHVybiBUcmFuc2Zvcm0udHJhbnNsYXRlKCBbIHRoaXMud1dpZHRoICogMC41LCB2ICsgdGhpcy50b3AgKyA0NCBdIClcblx0fS5iaW5kKCB0aGlzICkgKVxuXHR0aGlzLnNjYWxlVHJhbnMgPSB0aGlzLnNjYWxlLm1hcCggZnVuY3Rpb24gKCB2ICkge1xuXHRcdHJldHVybiBUcmFuc2Zvcm0uc2NhbGUoIFsgdiwgdiBdIClcblx0fSApXG5cblx0dGhpcy5zdXJmID0gbmV3IFN1cmZhY2UoIHtcblx0XHRzaXplOiBbIHRoaXMud1dpZHRoLCB0aGlzLndIZWlnaHQgLSA0NCAtIDQ5IC0gdGhpcy50b3AgXSxcblx0XHRvcmlnaW46IFsgMC41LCAwIF0sXG5cdFx0b3BhY2l0eTogdGhpcy5vcGEsXG5cdFx0Y29udGVudDogJycsXG5cdFx0Y2xhc3NlczogWyAnaGVscC1zdXJmJyBdLFxuXHRcdHByb3BlcnRpZXM6IHtcblx0XHRcdGNvbG9yOiAnd2hpdGUnLFxuXHRcdFx0YmFja2dyb3VuZDogXCJyZ2JhKDAsIDAsIDAsIDAuOClcIlxuXHRcdH1cblx0fSApXG5cblx0dGhpcy5zdXJmLm9uKCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNsb3NlKClcblx0fS5iaW5kKCB0aGlzICkgKVxuXG5cdHRoaXMub3BlbiA9IGZ1bmN0aW9uICggdGVtcCApIHtcblx0XHRpZiAoIHRoaXMuc2hvd24gPT0gdHJ1ZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHRoaXMuc2hvd2luZyA9IHRydWVcblx0XHRuYXZpZ2F0b3IudmlicmF0ZSggNTAgKVxuXG5cdFx0dGhpcy5zdXJmLnNldENvbnRlbnQoIHRlbXAgKVxuXG5cdFx0VGltZXIuYWZ0ZXIoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBkdXJhdGlvbiA9IDI1MFxuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmVzLm91dEJhY2tcblxuXHRcdFx0dGhpcy5vcGEuc2V0KCAxLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0Y3VydmU6IGN1cnZlXG5cdFx0XHR9IClcblx0XHRcdHRoaXMuc2NhbGUuc2V0KCAxLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0Y3VydmU6IGN1cnZlXG5cdFx0XHR9IClcblxuXHRcdFx0dGhpcy55LnNldCggMCwge1xuXHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRcdGN1cnZlOiBjdXJ2ZVxuXHRcdFx0fSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLnNob3duID0gdHJ1ZVxuXHRcdFx0XHR0aGlzLnNob3dpbmcgPSBmYWxzZVxuXHRcdFx0fS5iaW5kKCB0aGlzICkgKVxuXHRcdH0uYmluZCggdGhpcyApLCAyIClcblxuXHR9XG5cblx0dGhpcy5jbG9zZSA9IGZ1bmN0aW9uICggbm93ICkge1xuXHRcdGlmICggdGhpcy5zaG93biA9PSBmYWxzZSApIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmICggbm93ID09IHRydWUgKSB7XG5cdFx0XHR0aGlzLm9wYS5zZXQoIDAgKVxuXHRcdFx0dGhpcy5zY2FsZS5zZXQoIDAuNSApXG5cdFx0XHR0aGlzLnkuc2V0KCAtdGhpcy53SGVpZ2h0IClcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHRoaXMuc2hvd2luZyA9IHRydWVcblxuXHRcdHZhciBkdXJhdGlvbiA9IDUwMFxuXHRcdHZhciBjdXJ2ZSA9IEN1cnZlcy5lYXNlSW5cblxuXHRcdHRoaXMub3BhLnNldCggMCwge1xuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0Y3VydmU6IGN1cnZlXG5cdFx0fSApXG5cdFx0dGhpcy5zY2FsZS5zZXQoIDAuNSwge1xuXHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0Y3VydmU6IGN1cnZlXG5cdFx0fSApXG5cblx0XHR0aGlzLnkuc2V0KCAtdGhpcy53SGVpZ2h0LCB7XG5cdFx0XHRkdXJhdGlvbjogZHVyYXRpb24sXG5cdFx0XHRjdXJ2ZTogY3VydmVcblx0XHR9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLnNob3duID0gZmFsc2Vcblx0XHRcdHRoaXMuc2hvd2luZyA9IGZhbHNlXG5cdFx0fS5iaW5kKCB0aGlzICkgKVxuXG5cdH1cblxuXG5cblxuXG5cblxuXHRjb250ZXh0LmFkZCgge1xuXHRcdHRyYW5zZm9ybTogdGhpcy55VHJhbnNcblx0fSApLmFkZCgge1xuXHRcdHRyYW5zZm9ybTogdGhpcy5zY2FsZVRyYW5zXG5cdH0gKS5hZGQoIHRoaXMuc3VyZiApXG5cbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBUdXRzXG5cbi8vXG5cbiIsIi8vXG5cbnZhciBldmVudHMgPSByZXF1aXJlKCAnZXZlbnRzJyApXG52YXIgbW9tZW50ID0gcmVxdWlyZSggJ21vbWVudCcgKVxuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuPSAgICAgICAgICAgIF8kdXRpbHMgICAgICAgICAgID1cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRldmVudHM6IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKClcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnNvbGUuaW5mbyhcblx0XCJcXG5cXG5cXG5cXG4lYy8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXCIgK1xuXHRcIj09PT09PT09PSAgICAgICAgICAgXCIgKyBtb21lbnQoIF8ubm93KCkgKS5mb3JtYXQoICdoaDptbTpzczpTU1MnICkgKyBcIiAgICAgICAgICAgPT09PT09PT09PVxcblwiICtcblx0XCI9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1wiLCBcImNvbG9yOiBibHVlOyBmb250LXNpemU6IDEwcHQ7IGZvbnQtd2VpZ2h0OiBib2xkZXI7XCJcbilcblxuXG5cblxuXG5cblxuXG5cbi8vXG5cbiIsIiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjYgLSAyMDE1LTEyLTIzXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFuPWZhbHNlfSBbbWVyZ2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5hbGxvdyA9IHRydWU7IC8vIHVzZWQgYnkgSW5wdXQuVG91Y2hNb3VzZSB0byBkaXNhYmxlIG1vdXNlIGV2ZW50c1xuICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gTUVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBNT1VTRV9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW91c2UgbXVzdCBiZSBkb3duLCBhbmQgbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkIChzZWUgdGhlIFRvdWNoTW91c2UgaW5wdXQpXG4gICAgICAgIGlmICghdGhpcy5wcmVzc2VkIHx8ICF0aGlzLmFsbG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbnZhciBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gICAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gICAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gICAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICAgIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTtcblxuLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cbnZhciBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAgIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgMzogSU5QVVRfVFlQRV9QRU4sXG4gICAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcbn07XG5cbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnO1xuXG4vLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcbmlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICAgIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdGhpcy5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gUE9JTlRFUl9XSU5ET1dfRVZFTlRTO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbn1cblxuaW5oZXJpdChQb2ludGVyRXZlbnRJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gUEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIHZhciByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBQT0lOVEVSX0lOUFVUX01BUFtldmVudFR5cGVOb3JtYWxpemVkXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICAgICAgdmFyIGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAgICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICAgICAgdmFyIHN0b3JlSW5kZXggPSBpbkFycmF5KHN0b3JlLCBldi5wb2ludGVySWQsICdwb2ludGVySWQnKTtcblxuICAgICAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4ID0gc3RvcmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpdCBub3QgZm91bmQsIHNvIHRoZSBwb2ludGVyIGhhc24ndCBiZWVuIGRvd24gKHNvIGl0J3MgcHJvYmFibHkgYSBob3ZlcilcbiAgICAgICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICAgICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xudmFyIFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gU2luZ2xlVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChTaW5nbGVUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIFRFaGFuZGxlcihldikge1xuICAgICAgICB2YXIgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAgICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgICAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICAgICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiB0b3VjaGVzWzBdLmxlbmd0aCAtIHRvdWNoZXNbMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICAgICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgICAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEB0aGlzIHtUb3VjaElucHV0fVxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBmbGFnXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEFycmF5fSBbYWxsLCBjaGFuZ2VkXVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVTaW5nbGVUb3VjaGVzKGV2LCB0eXBlKSB7XG4gICAgdmFyIGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG5cbnZhciBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gICAgdG91Y2hzdGFydDogSU5QVVRfU1RBUlQsXG4gICAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICAgIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gICAgdG91Y2hjYW5jZWw6IElOUFVUX0NBTkNFTFxufTtcblxudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIE11bHRpLXVzZXIgdG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmZ1bmN0aW9uIFRvdWNoSW5wdXQoKSB7XG4gICAgdGhpcy5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcblxuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmluaGVyaXQoVG91Y2hJbnB1dCwgSW5wdXQsIHtcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gICAgdmFyIHRhcmdldElkcyA9IHRoaXMudGFyZ2V0SWRzO1xuXG4gICAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFthbGxUb3VjaGVzLCBhbGxUb3VjaGVzXTtcbiAgICB9XG5cbiAgICB2YXIgaSxcbiAgICAgICAgdGFyZ2V0VG91Y2hlcyxcbiAgICAgICAgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXSxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG5cbiAgICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gICAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH0pO1xuXG4gICAgLy8gY29sbGVjdCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXJnZXRJZHNbdGFyZ2V0VG91Y2hlc1tpXS5pZGVudGlmaWVyXSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhbnVwIHJlbW92ZWQgdG91Y2hlc1xuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXNcbiAgICBdO1xufVxuXG4vKipcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hNb3VzZUlucHV0KCkge1xuICAgIElucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGJpbmRGbih0aGlzLmhhbmRsZXIsIHRoaXMpO1xuICAgIHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIGhhbmRsZXIpO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCBzbyAgYmxvY2sgYWxsIHVwY29taW5nIG1vdXNlIGV2ZW50c1xuICAgICAgICAvLyBtb3N0IG1vYmlsZSBicm93c2VyIGFsc28gZW1pdCBtb3VzZWV2ZW50cywgcmlnaHQgYWZ0ZXIgdG91Y2hzdGFydFxuICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgdGhpcy5tb3VzZS5hbGxvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91c2UgJiYgIXRoaXMubW91c2UuYWxsb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IHRoZSBhbGxvd01vdXNlIHdoZW4gd2UncmUgZG9uZVxuICAgICAgICBpZiAoaW5wdXRFdmVudCAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlLmFsbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRvdWNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfVxufSk7XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxudmFyIFRPVUNIX0FDVElPTl9DT01QVVRFID0gJ2NvbXB1dGUnO1xudmFyIFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xudmFyIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuXG4vKipcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVG91Y2hBY3Rpb24obWFuYWdlciwgdmFsdWUpIHtcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbn1cblxuVG91Y2hBY3Rpb24ucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgaWYgKHZhbHVlID09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoganVzdCByZS1zZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB2YWx1ZVxuICAgICAqL1xuICAgIGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgICAgICAgICAgaWYgKGJvb2xPckZuKHJlY29nbml6ZXIub3B0aW9ucy5lbmFibGUsIFtyZWNvZ25pemVyXSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0czogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgLy8gbm90IG5lZWRlZCB3aXRoIG5hdGl2ZSBzdXBwb3J0IGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHlcbiAgICAgICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpO1xuICAgICAgICB2YXIgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKTtcblxuICAgICAgICBpZiAoaGFzTm9uZSkge1xuICAgICAgICAgICAgLy9kbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcblxuICAgICAgICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICAgICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgICAgICAoaGFzUGFuWCAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICAgKi9cbiAgICBwcmV2ZW50U3JjOiBmdW5jdGlvbihzcmNFdmVudCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgICAvLyBub25lXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9OT05FKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgdmFyIGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAgIC8vIGlmIGJvdGggcGFuLXggYW5kIHBhbi15IGFyZSBzZXQgKGRpZmZlcmVudCByZWNvZ25pemVyc1xuICAgIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAgIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAgIC8vIHJlY29nbml6ZXJzIHdpbGwgd29yaywgc2luY2UgdGhlIGJyb3dzZXIgd291bGQgaGFuZGxlIGFsbCBwYW5uaW5nXG4gICAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgLy8gcGFuLXggT1IgcGFuLXlcbiAgICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICAgIH1cblxuICAgIC8vIG1hbmlwdWxhdGlvblxuICAgIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgICAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX0FVVE87XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG59XG5cblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBkZWZhdWx0czoge30sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNic7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLmFkZChuZXcgKGl0ZW1bMF0pKGl0ZW1bMV0pKTtcbiAgICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbn1cblxuTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgICAgIGlmIChvcHRpb25zLnRvdWNoQWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuICAgICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAgICogV2hlbiBmb3JjZWQsIHRoZSByZWNvZ25pemVyIGN5Y2xlIGlzIHN0b3BwZWQgaW1tZWRpYXRlbHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG4gICAgICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgICAqL1xuICAgIHJlY29nbml6ZTogZnVuY3Rpb24oaW5wdXREYXRhKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgICAgIHZhciByZWNvZ25pemVyO1xuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgICAgIC8vIGlmIG5vIHJlY29nbml6ZXIgaXMgZGV0ZWN0aW5nIGEgdGhpbmcsIGl0IGlzIHNldCB0byBgbnVsbGBcbiAgICAgICAgdmFyIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXI7XG5cbiAgICAgICAgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAgICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAgICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAgICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgICAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAgICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgICAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAgICAgICAgICAgICAgICFjdXJSZWNvZ25pemVyIHx8IHJlY29nbml6ZXIgPT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgICAgICAgICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXIucmVzZXQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIHJlY29nbml6ZXIgaGFzIGJlZW4gcmVjb2duaXppbmcgdGhlIGlucHV0IGFzIGEgdmFsaWQgZ2VzdHVyZSwgd2Ugd2FudCB0byBzdG9yZSB0aGlzIG9uZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIHJlY29nbml6ZXIuIGJ1dCBvbmx5IGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBhY3RpdmUgcmVjb2duaXplclxuICAgICAgICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICAgKiBleGlzdGluZyByZWNvZ25pemVycyB3aXRoIHRoZSBzYW1lIGV2ZW50IG5hbWUgd2lsbCBiZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdhZGQnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQocmVjb2duaXplci5vcHRpb25zLmV2ZW50KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsICdyZW1vdmUnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZWNvZ25pemVyID0gdGhpcy5nZXQocmVjb2duaXplcik7XG5cbiAgICAgICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICAgICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCByZWNvZ25pemVyKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICBlYWNoKHNwbGl0U3RyKGV2ZW50cyksIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICAgICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKV0gPSBhZGQgPyB2YWx1ZSA6ICcnO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICAgIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gICAgZGF0YS50YXJnZXQuZGlzcGF0Y2hFdmVudChnZXN0dXJlRXZlbnQpO1xufVxuXG5hc3NpZ24oSGFtbWVyLCB7XG4gICAgSU5QVVRfU1RBUlQ6IElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkU6IElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5EOiBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMOiBJTlBVVF9DQU5DRUwsXG5cbiAgICBTVEFURV9QT1NTSUJMRTogU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU46IFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQ6IFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfRU5ERUQ6IFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQ6IFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVEOiBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRkFJTEVEOiBTVEFURV9GQUlMRUQsXG5cbiAgICBESVJFQ1RJT05fTk9ORTogRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQ6IERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVDogRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUDogRElSRUNUSU9OX1VQLFxuICAgIERJUkVDVElPTl9ET1dOOiBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTDogRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMOiBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTDogRElSRUNUSU9OX0FMTCxcblxuICAgIE1hbmFnZXI6IE1hbmFnZXIsXG4gICAgSW5wdXQ6IElucHV0LFxuICAgIFRvdWNoQWN0aW9uOiBUb3VjaEFjdGlvbixcblxuICAgIFRvdWNoSW5wdXQ6IFRvdWNoSW5wdXQsXG4gICAgTW91c2VJbnB1dDogTW91c2VJbnB1dCxcbiAgICBQb2ludGVyRXZlbnRJbnB1dDogUG9pbnRlckV2ZW50SW5wdXQsXG4gICAgVG91Y2hNb3VzZUlucHV0OiBUb3VjaE1vdXNlSW5wdXQsXG4gICAgU2luZ2xlVG91Y2hJbnB1dDogU2luZ2xlVG91Y2hJbnB1dCxcblxuICAgIFJlY29nbml6ZXI6IFJlY29nbml6ZXIsXG4gICAgQXR0clJlY29nbml6ZXI6IEF0dHJSZWNvZ25pemVyLFxuICAgIFRhcDogVGFwUmVjb2duaXplcixcbiAgICBQYW46IFBhblJlY29nbml6ZXIsXG4gICAgU3dpcGU6IFN3aXBlUmVjb2duaXplcixcbiAgICBQaW5jaDogUGluY2hSZWNvZ25pemVyLFxuICAgIFJvdGF0ZTogUm90YXRlUmVjb2duaXplcixcbiAgICBQcmVzczogUHJlc3NSZWNvZ25pemVyLFxuXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXJzLFxuICAgIG9mZjogcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gICAgZWFjaDogZWFjaCxcbiAgICBtZXJnZTogbWVyZ2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgYXNzaWduOiBhc3NpZ24sXG4gICAgaW5oZXJpdDogaW5oZXJpdCxcbiAgICBiaW5kRm46IGJpbmRGbixcbiAgICBwcmVmaXhlZDogcHJlZml4ZWRcbn0pO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge30pKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5mcmVlR2xvYmFsLkhhbW1lciA9IEhhbW1lcjtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbW1lcjtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xufSBlbHNlIHtcbiAgICB3aW5kb3dbZXhwb3J0TmFtZV0gPSBIYW1tZXI7XG59XG5cbn0pKHdpbmRvdywgZG9jdW1lbnQsICdIYW1tZXInKTtcbiIsIi8qXG4gIExva2kgSW5kZXhlZERiIEFkYXB0ZXIgKG5lZWQgdG8gaW5jbHVkZSB0aGlzIHNjcmlwdCB0byB1c2UgaXQpXG5cbiAgSW5kZXhlZGRiIGlzIGhpZ2hseSBhc3luYywgYnV0IHRoaXMgYWRhcHRlciBoYXMgYmVlbiBtYWRlICdjb25zb2xlLWZyaWVuZGx5JyBhcyB3ZWxsLlxuICBBbnl3aGVyZSBhIGNhbGxiYWNrIGlzIG9taXR0ZWQsIGl0IHNob3VsZCByZXR1cm4gcmVzdWx0cyAoaWYgYXBwbGljYWJsZSkgdG8gY29uc29sZS5cblxuICBJbmRleGVkRGIgc3RvcmFnZSBpcyBwcm92aWRlZCBwZXItZG9tYWluLCBzbyB3ZSBpbXBsZW1lbnQgYXBwL2tleS92YWx1ZSBkYXRhYmFzZSB0byBhbGxvdyBzZXBhcmF0ZSBjb250ZXh0c1xuICBmb3Igc2VwYXJhdGUgYXBwcyB3aXRoaW4gYSBkb21haW4uXG5cbiAgRXhhbXBsZXMgOlxuXG4gIC8vIFNBVkUgOiB3aWxsIHNhdmUgQXBwL0tleS9WYWwgYXMgJ2ZpbmFuY2UnLyd0ZXN0Jy97c2VyaWFsaXplZERifVxuICAvLyBpZiBhcHBDb250ZWN0ICgnZmluYW5jZScgaW4gdGhpcyBleGFtcGxlKSBpcyBvbWl0dGVkLCAnbG9raScgd2lsbCBiZSB1c2VkXG4gIHZhciBpZGJBZGFwdGVyID0gbmV3IExva2lJbmRleGVkQWRhcHRlcignZmluYW5jZScpO1xuICB2YXIgZGIgPSBuZXcgbG9raSgndGVzdCcsIHsgYWRhcHRlcjogaWRiQWRhcHRlciB9KTtcbiAgdmFyIGNvbGwgPSBkYi5hZGRDb2xsZWN0aW9uKCd0ZXN0Q29sbCcpO1xuICBjb2xsLmluc2VydCh7dGVzdDogJ3ZhbCd9KTtcbiAgZGIuc2F2ZURhdGFiYXNlKCk7ICAvLyBjb3VsZCBwYXNzIGNhbGxiYWNrIGlmIG5lZWRlZCBmb3IgYXN5bmMgY29tcGxldGVcblxuICAvLyBMT0FEXG4gIHZhciBkYiA9IG5ldyBsb2tpKCd0ZXN0JywgeyBhZGFwdGVyOiBpZGJBZGFwdGVyIH0pO1xuICBkYi5sb2FkRGF0YWJhc2UoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgfSk7XG5cbiAgLy8gR0VUIERBVEFCQVNFIExJU1RcbiAgaWRiQWRhcHRlci5nZXREYXRhYmFzZUxpc3QoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgLy8gcmVzdWx0IGlzIGFycmF5IG9mIHN0cmluZyBuYW1lcyBmb3IgdGhhdCBhcHBjb250ZXh0ICgnZmluYW5jZScpXG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24oc3RyKSB7XG4gICAgICBjb25zb2xlLmxvZyhzdHIpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBERUxFVEUgREFUQUJBU0VcbiAgaWRiQWRhcHRlci5kZWxldGVEYXRhYmFzZSgndGVzdCcpOyAvLyBkZWxldGUgJ2ZpbmFuY2UnLyd0ZXN0JyB2YWx1ZSBmcm9tIGNhdGFsb2dcblxuICAvLyBDT05TT0xFIFVTQUdFIDogaWYgdXNpbmcgZnJvbSBjb25zb2xlIGZvciBtYW5hZ2VtZW50L2RpYWdub3N0aWMsIGhlcmUgYXJlIGEgZmV3IGV4YW1wbGVzIDpcbiAgYWRhcHRlci5nZXREYXRhYmFzZUxpc3QoKTsgLy8gd2l0aCBubyBjYWxsYmFjayBwYXNzZWQsIHRoaXMgbWV0aG9kIHdpbGwgbG9nIHJlc3VsdHMgdG8gY29uc29sZVxuICBhZGFwdGVyLnNhdmVEYXRhYmFzZSgnVXNlckRhdGFiYXNlJywgSlNPTi5zdHJpbmdpZnkobXlEYikpO1xuICBhZGFwdGVyLmxvYWREYXRhYmFzZSgnVXNlckRhdGFiYXNlJyk7IC8vIHdpbGwgbG9nIHRoZSBzZXJpYWxpemVkIGRiIHRvIGNvbnNvbGVcbiAgYWRhcHRlci5kZWxldGVEYXRhYmFzZSgnVXNlckRhdGFiYXNlJyk7XG4qL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRFxuICAgICAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUsIENvbW1vbkpTLWxpa2VcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5Mb2tpSW5kZXhlZEFkYXB0ZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBJbmRleGVkQWRhcHRlciAtIExva2kgcGVyc2lzdGVuY2UgYWRhcHRlciBjbGFzcyBmb3IgaW5kZXhlZERiLlxuICAgICAqICAgICBUaGlzIGNsYXNzIGZ1bGZpbGxzIGFic3RyYWN0IGFkYXB0ZXIgaW50ZXJmYWNlIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIG90aGVyIHN0b3JhZ2UgbWV0aG9kc1xuICAgICAqICAgICBVdGlsaXplcyB0aGUgaW5jbHVkZWQgTG9raUNhdGFsb2cgYXBwL2tleS92YWx1ZSBkYXRhYmFzZSBmb3IgYWN0dWFsIGRhdGFiYXNlIHBlcnNpc3RlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwcG5hbWUgLSBBcHBsaWNhdGlvbiBuYW1lIGNvbnRleHQgY2FuIGJlIHVzZWQgdG8gZGlzdGluZ3Vpc2ggc3ViZG9tYWlucyBvciBqdXN0ICdsb2tpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRBZGFwdGVyKGFwcG5hbWUpXG4gICAge1xuICAgICAgdGhpcy5hcHAgPSAnbG9raSc7XG5cbiAgICAgIGlmICh0eXBlb2YgKGFwcG5hbWUpICE9PSAndW5kZWZpbmVkJylcbiAgICAgIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHBuYW1lO1xuICAgICAgfVxuXG4gICAgICAvLyBrZWVwIHJlZmVyZW5jZSB0byBjYXRhbG9nIGNsYXNzIGZvciBiYXNlIEFLViBvcGVyYXRpb25zXG4gICAgICB0aGlzLmNhdGFsb2cgPSBudWxsO1xuXG4gICAgICBpZiAoIXRoaXMuY2hlY2tBdmFpbGFiaWxpdHkoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4ZWREQiBkb2VzIG5vdCBzZWVtIHRvIGJlIHN1cHBvcnRlZCBmb3IgeW91ciBlbnZpcm9ubWVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrQXZhaWxhYmlsaXR5IC0gdXNlZCB0byBjaGVjayBpZiBhZGFwdGVyIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgaW5kZXhlZGRiIGlzIGF2YWlsYWJsZSwgZmFsc2UgaWYgbm90LlxuICAgICAqL1xuICAgIEluZGV4ZWRBZGFwdGVyLnByb3RvdHlwZS5jaGVja0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5pbmRleGVkREIpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGxvYWREYXRhYmFzZSgpIC0gUmV0cmlldmVzIGEgc2VyaWFsaXplZCBkYiBzdHJpbmcgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBjYWxsYmFjayBzaG91bGQgYWNjZXB0IHN0cmluZyBwYXJhbSBjb250YWluaW5nIHNlcmlhbGl6ZWQgZGIgc3RyaW5nLlxuICAgICAqL1xuICAgIEluZGV4ZWRBZGFwdGVyLnByb3RvdHlwZS5sb2FkRGF0YWJhc2UgPSBmdW5jdGlvbihkYm5hbWUsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgIHZhciBhcHBOYW1lID0gdGhpcy5hcHA7XG4gICAgICB2YXIgYWRhcHRlciA9IHRoaXM7XG5cbiAgICAgIC8vIGxhenkgb3Blbi9jcmVhdGUgZGIgcmVmZXJlbmNlIHNvIGRvbnQgLW5lZWQtIGNhbGxiYWNrIGluIGNvbnN0cnVjdG9yXG4gICAgICBpZiAodGhpcy5jYXRhbG9nID09PSBudWxsIHx8IHRoaXMuY2F0YWxvZy5kYiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhdGFsb2cgPSBuZXcgTG9raUNhdGFsb2coZnVuY3Rpb24oY2F0KSB7XG4gICAgICAgICAgYWRhcHRlci5jYXRhbG9nID0gY2F0O1xuXG4gICAgICAgICAgYWRhcHRlci5sb2FkRGF0YWJhc2UoZGJuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbG9va3VwIHVwIGRiIHN0cmluZyBpbiBBS1YgZGJcbiAgICAgIHRoaXMuY2F0YWxvZy5nZXRBcHBLZXkoYXBwTmFtZSwgZGJuYW1lLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5pZCA9PT0gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdC52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIHN1cHBvcnQgY29uc29sZSB1c2Ugb2YgYXBpXG4gICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBhbGlhc1xuICAgIEluZGV4ZWRBZGFwdGVyLnByb3RvdHlwZS5sb2FkS2V5ID0gSW5kZXhlZEFkYXB0ZXIucHJvdG90eXBlLmxvYWREYXRhYmFzZTtcblxuICAgIC8qKlxuICAgICAqIHNhdmVEYXRhYmFzZSgpIC0gU2F2ZXMgYSBzZXJpYWxpemVkIGRiIHRvIHRoZSBjYXRhbG9nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRibmFtZSAtIHRoZSBuYW1lIHRvIGdpdmUgdGhlIHNlcmlhbGl6ZWQgZGF0YWJhc2Ugd2l0aGluIHRoZSBjYXRhbG9nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYnN0cmluZyAtIHRoZSBzZXJpYWxpemVkIGRiIHN0cmluZyB0byBzYXZlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gKE9wdGlvbmFsKSBjYWxsYmFjayBwYXNzZWQgb2JqLnN1Y2Nlc3Mgd2l0aCB0cnVlIG9yIGZhbHNlXG4gICAgICovXG4gICAgSW5kZXhlZEFkYXB0ZXIucHJvdG90eXBlLnNhdmVEYXRhYmFzZSA9IGZ1bmN0aW9uKGRibmFtZSwgZGJzdHJpbmcsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgIHZhciBhcHBOYW1lID0gdGhpcy5hcHA7XG4gICAgICB2YXIgYWRhcHRlciA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHNhdmVDYWxsYmFjayhyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3VjY2VzcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIkVycm9yIHNhdmluZyBkYXRhYmFzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbGF6eSBvcGVuL2NyZWF0ZSBkYiByZWZlcmVuY2Ugc28gZG9udCAtbmVlZC0gY2FsbGJhY2sgaW4gY29uc3RydWN0b3JcbiAgICAgIGlmICh0aGlzLmNhdGFsb2cgPT09IG51bGwgfHwgdGhpcy5jYXRhbG9nLmRiID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2F0YWxvZyA9IG5ldyBMb2tpQ2F0YWxvZyhmdW5jdGlvbihjYXQpIHtcbiAgICAgICAgICBhZGFwdGVyLmNhdGFsb2cgPSBjYXQ7XG5cbiAgICAgICAgICAvLyBub3cgdGhhdCBjYXRhbG9nIGhhcyBiZWVuIGluaXRpYWxpemVkLCBzZXQgKGFkZC91cGRhdGUpIHRoZSBBS1YgZW50cnlcbiAgICAgICAgICBjYXQuc2V0QXBwS2V5KGFwcE5hbWUsIGRibmFtZSwgZGJzdHJpbmcsIHNhdmVDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IChhZGQvdXBkYXRlKSBlbnRyeSB0byBBS1YgZGF0YWJhc2VcbiAgICAgIHRoaXMuY2F0YWxvZy5zZXRBcHBLZXkoYXBwTmFtZSwgZGJuYW1lLCBkYnN0cmluZywgc2F2ZUNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gYWxpYXNcbiAgICBJbmRleGVkQWRhcHRlci5wcm90b3R5cGUuc2F2ZUtleSA9IEluZGV4ZWRBZGFwdGVyLnByb3RvdHlwZS5zYXZlRGF0YWJhc2U7XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGVEYXRhYmFzZSgpIC0gRGVsZXRlcyBhIHNlcmlhbGl6ZWQgZGIgZnJvbSB0aGUgY2F0YWxvZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgdG8gZGVsZXRlIGZyb20gdGhlIGNhdGFsb2cuXG4gICAgICovXG4gICAgSW5kZXhlZEFkYXB0ZXIucHJvdG90eXBlLmRlbGV0ZURhdGFiYXNlID0gZnVuY3Rpb24oZGJuYW1lKVxuICAgIHtcbiAgICAgIHZhciBhcHBOYW1lID0gdGhpcy5hcHA7XG4gICAgICB2YXIgYWRhcHRlciA9IHRoaXM7XG5cbiAgICAgIC8vIGxhenkgb3Blbi9jcmVhdGUgZGIgcmVmZXJlbmNlIHNvIGRvbnQgLW5lZWQtIGNhbGxiYWNrIGluIGNvbnN0cnVjdG9yXG4gICAgICBpZiAodGhpcy5jYXRhbG9nID09PSBudWxsIHx8IHRoaXMuY2F0YWxvZy5kYiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhdGFsb2cgPSBuZXcgTG9raUNhdGFsb2coZnVuY3Rpb24oY2F0KSB7XG4gICAgICAgICAgYWRhcHRlci5jYXRhbG9nID0gY2F0O1xuXG4gICAgICAgICAgYWRhcHRlci5kZWxldGVEYXRhYmFzZShkYm5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNhdGFsb2cgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIHNvIGp1c3QgbG9va3VwIG9iamVjdCBhbmQgZGVsZXRlIGJ5IGlkXG4gICAgICB0aGlzLmNhdGFsb2cuZ2V0QXBwS2V5KGFwcE5hbWUsIGRibmFtZSwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBpZCA9IHJlc3VsdC5pZDtcblxuICAgICAgICBpZiAoaWQgIT09IDApIHtcbiAgICAgICAgICBhZGFwdGVyLmNhdGFsb2cuZGVsZXRlQXBwS2V5KGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFsaWFzXG4gICAgSW5kZXhlZEFkYXB0ZXIucHJvdG90eXBlLmRlbGV0ZUtleSA9IEluZGV4ZWRBZGFwdGVyLnByb3RvdHlwZS5kZWxldGVEYXRhYmFzZTtcblxuICAgIC8qKlxuICAgICAqIGdldERhdGFiYXNlTGlzdCgpIC0gUmV0cmlldmVzIG9iamVjdCBhcnJheSBvZiBjYXRhbG9nIGVudHJpZXMgZm9yIGN1cnJlbnQgYXBwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBzaG91bGQgYWNjZXB0IGFycmF5IG9mIGRhdGFiYXNlIG5hbWVzIGluIHRoZSBjYXRhbG9nIGZvciBjdXJyZW50IGFwcC5cbiAgICAgKi9cbiAgICBJbmRleGVkQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YWJhc2VMaXN0ID0gZnVuY3Rpb24oY2FsbGJhY2spXG4gICAge1xuICAgICAgdmFyIGFwcE5hbWUgPSB0aGlzLmFwcDtcbiAgICAgIHZhciBhZGFwdGVyID0gdGhpcztcblxuICAgICAgLy8gbGF6eSBvcGVuL2NyZWF0ZSBkYiByZWZlcmVuY2Ugc28gZG9udCAtbmVlZC0gY2FsbGJhY2sgaW4gY29uc3RydWN0b3JcbiAgICAgIGlmICh0aGlzLmNhdGFsb2cgPT09IG51bGwgfHwgdGhpcy5jYXRhbG9nLmRiID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2F0YWxvZyA9IG5ldyBMb2tpQ2F0YWxvZyhmdW5jdGlvbihjYXQpIHtcbiAgICAgICAgICBhZGFwdGVyLmNhdGFsb2cgPSBjYXQ7XG5cbiAgICAgICAgICBhZGFwdGVyLmdldERhdGFiYXNlTGlzdChjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY2F0YWxvZyBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICAvLyBnZXQgYWxsIGtleXMgZm9yIGN1cnJlbnQgYXBwTmFtZSwgYW5kIHRyYW5zcG9zZSByZXN1bHRzIHNvIGp1c3Qgc3RyaW5nIGFycmF5XG4gICAgICB0aGlzLmNhdGFsb2cuZ2V0QXBwS2V5cyhhcHBOYW1lLCBmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgIHZhciBuYW1lcyA9IFtdO1xuXG4gICAgICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgcmVzdWx0cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgbmFtZXMucHVzaChyZXN1bHRzW2lkeF0ua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cob2JqKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFsaWFzXG4gICAgSW5kZXhlZEFkYXB0ZXIucHJvdG90eXBlLmdldEtleUxpc3QgPSBJbmRleGVkQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YWJhc2VMaXN0O1xuXG4gICAgLyoqXG4gICAgICogZ2V0Q2F0YWxvZ1N1bW1hcnkgLSBhbGxvd3MgcmV0cmlldmFsIG9mIGxpc3Qgb2YgYWxsIGtleXMgaW4gY2F0YWxvZyBhbG9uZyB3aXRoIHNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gKE9wdGlvbmFsKSBjYWxsYmFjayB0byBhY2NlcHQgcmVzdWx0IGFycmF5LlxuICAgICAqL1xuICAgIEluZGV4ZWRBZGFwdGVyLnByb3RvdHlwZS5nZXRDYXRhbG9nU3VtbWFyeSA9IGZ1bmN0aW9uKGNhbGxiYWNrKVxuICAgIHtcbiAgICAgIHZhciBhcHBOYW1lID0gdGhpcy5hcHA7XG4gICAgICB2YXIgYWRhcHRlciA9IHRoaXM7XG5cbiAgICAgIC8vIGxhenkgb3Blbi9jcmVhdGUgZGIgcmVmZXJlbmNlXG4gICAgICBpZiAodGhpcy5jYXRhbG9nID09PSBudWxsIHx8IHRoaXMuY2F0YWxvZy5kYiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNhdGFsb2cgPSBuZXcgTG9raUNhdGFsb2coZnVuY3Rpb24oY2F0KSB7XG4gICAgICAgICAgYWRhcHRlci5jYXRhbG9nID0gY2F0O1xuXG4gICAgICAgICAgYWRhcHRlci5nZXRDYXRhbG9nU3VtbWFyeShjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY2F0YWxvZyBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICAvLyBnZXQgYWxsIGtleXMgZm9yIGN1cnJlbnQgYXBwTmFtZSwgYW5kIHRyYW5zcG9zZSByZXN1bHRzIHNvIGp1c3Qgc3RyaW5nIGFycmF5XG4gICAgICB0aGlzLmNhdGFsb2cuZ2V0QWxsS2V5cyhmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgIHZhciBvYmosXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICBvYXBwLFxuICAgICAgICAgIG9rZXksXG4gICAgICAgICAgb3ZhbDtcblxuICAgICAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IHJlc3VsdHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIG9iaiA9IHJlc3VsdHNbaWR4XTtcbiAgICAgICAgICBvYXBwID0gb2JqLmFwcCB8fCAnJztcbiAgICAgICAgICBva2V5ID0gb2JqLmtleSB8fCAnJztcbiAgICAgICAgICBvdmFsID0gb2JqLnZhbCB8fCAnJztcblxuICAgICAgICAgIC8vIGFwcCBhbmQga2V5IGFyZSBjb21wb3NpdGVkIGludG8gYW4gYXBwa2V5IGNvbHVtbiBzbyB3ZSB3aWxsIG11bHQgYnkgMlxuICAgICAgICAgIHNpemUgPSBvYXBwLmxlbmd0aCAqIDIgKyBva2V5Lmxlbmd0aCAqIDIgKyBvdmFsLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICBlbnRyaWVzLnB1c2goeyBcImFwcFwiOiBvYmouYXBwLCBcImtleVwiOiBvYmoua2V5LCBcInNpemVcIjogc2l6ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKGVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG9iaik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2tpQ2F0YWxvZyAtIHVuZGVybHlpbmcgQXBwL0tleS9WYWx1ZSBjYXRhbG9nIHBlcnNpc3RlbmNlXG4gICAgICogICAgVGhpcyBub24taW50ZXJmYWNlIGNsYXNzIGltcGxlbWVudHMgdGhlIGFjdHVhbCBwZXJzaXN0ZW5jZS5cbiAgICAgKiAgICBVc2VkIGJ5IHRoZSBJbmRleGVkQWRhcHRlciBjbGFzcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2tpQ2F0YWxvZyhjYWxsYmFjaylcbiAgICB7XG4gICAgICB0aGlzLmRiID0gbnVsbDtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUxva2lDYXRhbG9nKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBMb2tpQ2F0YWxvZy5wcm90b3R5cGUuaW5pdGlhbGl6ZUxva2lDYXRhbG9nID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHZhciBvcGVuUmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKCdMb2tpQ2F0YWxvZycsIDEpO1xuICAgICAgdmFyIGNhdCA9IHRoaXM7XG5cbiAgICAgIC8vIElmIGRhdGFiYXNlIGRvZXNuJ3QgZXhpc3QgeWV0IG9yIGl0cyB2ZXJzaW9uIGlzIGxvd2VyIHRoYW4gb3VyIHZlcnNpb24gc3BlY2lmaWVkIGFib3ZlICgybmQgcGFyYW0gaW4gbGluZSBhYm92ZSlcbiAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHRoaXNEQiA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgaWYgKHRoaXNEQi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdMb2tpQUtWJykpIHtcbiAgICAgICAgICB0aGlzREIuZGVsZXRlT2JqZWN0U3RvcmUoJ0xva2lBS1YnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzREIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygnTG9raUFLVicpKSB7XG4gICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gdGhpc0RCLmNyZWF0ZU9iamVjdFN0b3JlKCdMb2tpQUtWJywgeyBrZXlQYXRoOiAnaWQnLCBhdXRvSW5jcmVtZW50OnRydWUgfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ2FwcCcsICdhcHAnLCB7dW5pcXVlOmZhbHNlfSk7XG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ2tleScsICdrZXknLCB7dW5pcXVlOmZhbHNlfSk7XG4gICAgICAgICAgLy8gaGFjayB0byBzaW11bGF0ZSBjb21wb3NpdGUga2V5IHNpbmNlIG92ZXJoZWFkIGlzIGxvdyAobWFpbiBzaXplIHNob3VsZCBiZSBpbiB2YWwgZmllbGQpXG4gICAgICAgICAgLy8gdXNlciAobWUpIHJlcXVpcmVkIHRvIGR1cGxpY2F0ZSB0aGUgYXBwIGFuZCBrZXkgaW50byBjb21tYSBkZWxpbWl0ZWQgYXBwa2V5IGZpZWxkIG9mZiBvYmplY3RcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgYWxsb3cgcmV0cmlldmluZyBzaW5nbGUgcmVjb3JkIHdpdGggdGhhdCBjb21wb3NpdGUga2V5IGFzIHdlbGwgYXNcbiAgICAgICAgICAvLyBzdGlsbCBzdXBwb3J0aW5nIG9wZW5pbmcgY3Vyc29ycyBvbiBhcHAgb3Iga2V5IGFsb25lXG4gICAgICAgICAgb2JqZWN0U3RvcmUuY3JlYXRlSW5kZXgoJ2FwcGtleScsICdhcHBrZXknLCB7dW5pcXVlOnRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjYXQuZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiAoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayhjYXQpO1xuICAgICAgfTtcblxuICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIExva2lDYXRhbG9nLnByb3RvdHlwZS5nZXRBcHBLZXkgPSBmdW5jdGlvbihhcHAsIGtleSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oWydMb2tpQUtWJ10sICdyZWFkb25seScpO1xuICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ0xva2lBS1YnKTtcbiAgICAgIHZhciBpbmRleCA9IHN0b3JlLmluZGV4KCdhcHBrZXknKTtcbiAgICAgIHZhciBhcHBrZXkgPSBhcHAgKyBcIixcIiArIGtleTtcbiAgICAgIHZhciByZXF1ZXN0ID0gaW5kZXguZ2V0KGFwcGtleSk7XG5cbiAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGZ1bmN0aW9uKHVzZXJjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciBscmVzID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgaWYgKGxyZXMgPT09IG51bGwgfHwgdHlwZW9mKGxyZXMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbHJlcyA9IHtcbiAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YodXNlcmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdXNlcmNhbGxiYWNrKGxyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKGNhbGxiYWNrKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGZ1bmN0aW9uKHVzZXJjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YodXNlcmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdXNlcmNhbGxiYWNrKHsgaWQ6IDAsIHN1Y2Nlc3M6IGZhbHNlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkoY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBMb2tpQ2F0YWxvZy5wcm90b3R5cGUuZ2V0QXBwS2V5QnlJZCA9IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2ssIGRhdGEpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuZGIudHJhbnNhY3Rpb24oWydMb2tpQUtWJ10sICdyZWFkb25seScpO1xuICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ0xva2lBS1YnKTtcbiAgICAgIHZhciByZXF1ZXN0ID0gc3RvcmUuZ2V0KGlkKTtcblxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZnVuY3Rpb24oZGF0YSwgdXNlcmNhbGxiYWNrKXtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mKHVzZXJjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHVzZXJjYWxsYmFjayhlLnRhcmdldC5yZXN1bHQsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkoZGF0YSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBMb2tpQ2F0YWxvZy5wcm90b3R5cGUuc2V0QXBwS2V5ID0gZnVuY3Rpb24gKGFwcCwga2V5LCB2YWwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnTG9raUFLViddLCAncmVhZHdyaXRlJyk7XG4gICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnTG9raUFLVicpO1xuICAgICAgdmFyIGluZGV4ID0gc3RvcmUuaW5kZXgoJ2FwcGtleScpO1xuICAgICAgdmFyIGFwcGtleSA9IGFwcCArIFwiLFwiICsga2V5O1xuICAgICAgdmFyIHJlcXVlc3QgPSBpbmRleC5nZXQoYXBwa2V5KTtcblxuICAgICAgLy8gZmlyc3QgdHJ5IHRvIHJldHJpZXZlIGFuIGV4aXN0aW5nIG9iamVjdCBieSB0aGF0IGtleVxuICAgICAgLy8gbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgdG8gdXBkYXRlIGFuIG9iamVjdCB5b3UgbmVlZCB0byBoYXZlIGlkIGluIG9iamVjdCwgb3RoZXJ3aXNlIGl0IHdpbGwgYXBwZW5kIGlkIHdpdGggbmV3IGF1dG9jb3VudGVyIGFuZCBjbGFzaCB0aGUgdW5pcXVlIGluZGV4IGFwcGtleVxuICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZXMgPSBlLnRhcmdldC5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlcyA9IHtcbiAgICAgICAgICAgIGFwcDphcHAsXG4gICAgICAgICAgICBrZXk6a2V5LFxuICAgICAgICAgICAgYXBwa2V5OiBhcHAgKyAnLCcgKyBrZXksXG4gICAgICAgICAgICB2YWw6dmFsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXMudmFsID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcXVlc3RQdXQgPSBzdG9yZS5wdXQocmVzKTtcblxuICAgICAgICByZXF1ZXN0UHV0Lm9uZXJyb3IgPSAoZnVuY3Rpb24odXNlcmNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodXNlcmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB1c2VyY2FsbGJhY2soeyBzdWNjZXNzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMb2tpQ2F0YWxvZy5zZXRBcHBLZXkgKHNldCkgb25lcnJvcicpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSkoY2FsbGJhY2spO1xuXG4gICAgICAgIHJlcXVlc3RQdXQub25zdWNjZXNzID0gKGZ1bmN0aW9uKHVzZXJjYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHVzZXJjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgdXNlcmNhbGxiYWNrKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KShjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZnVuY3Rpb24odXNlcmNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZih1c2VyY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB1c2VyY2FsbGJhY2soeyBzdWNjZXNzOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMb2tpQ2F0YWxvZy5zZXRBcHBLZXkgKGdldCkgb25lcnJvcicpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KShjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIExva2lDYXRhbG9nLnByb3RvdHlwZS5kZWxldGVBcHBLZXkgPSBmdW5jdGlvbiAoaWQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnTG9raUFLViddLCAncmVhZHdyaXRlJyk7XG4gICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnTG9raUFLVicpO1xuICAgICAgdmFyIHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoaWQpO1xuXG4gICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChmdW5jdGlvbih1c2VyY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIGlmICh0eXBlb2YodXNlcmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykgdXNlcmNhbGxiYWNrKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKGNhbGxiYWNrKTtcblxuICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGZ1bmN0aW9uKHVzZXJjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZih1c2VyY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB1c2VyY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xva2lDYXRhbG9nLmRlbGV0ZUFwcEtleSByYWlzZWQgb25lcnJvcicpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KShjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIExva2lDYXRhbG9nLnByb3RvdHlwZS5nZXRBcHBLZXlzID0gZnVuY3Rpb24oYXBwLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbJ0xva2lBS1YnXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnTG9raUFLVicpO1xuICAgICAgdmFyIGluZGV4ID0gc3RvcmUuaW5kZXgoJ2FwcCcpO1xuXG4gICAgICAvLyBXZSB3YW50IGN1cnNvciB0byBhbGwgdmFsdWVzIG1hdGNoaW5nIG91ciAoc2luZ2xlKSBhcHAgcGFyYW1cbiAgICAgIHZhciBzaW5nbGVLZXlSYW5nZSA9IElEQktleVJhbmdlLm9ubHkoYXBwKTtcblxuICAgICAgLy8gVG8gdXNlIG9uZSBvZiB0aGUga2V5IHJhbmdlcywgcGFzcyBpdCBpbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2Ygb3BlbkN1cnNvcigpL29wZW5LZXlDdXJzb3IoKVxuICAgICAgdmFyIGN1cnNvciA9IGluZGV4Lm9wZW5DdXJzb3Ioc2luZ2xlS2V5UmFuZ2UpO1xuXG4gICAgICAvLyBjdXJzb3IgaW50ZXJuYWxseSwgcHVzaGluZyByZXN1bHRzIGludG8gdGhpcy5kYXRhW10gYW5kIHJldHVyblxuICAgICAgLy8gdGhpcy5kYXRhW10gd2hlbiBkb25lIChzaW1pbGFyIHRvIHNlcnZpY2UpXG4gICAgICB2YXIgbG9jYWxkYXRhID0gW107XG5cbiAgICAgIGN1cnNvci5vbnN1Y2Nlc3MgPSAoZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgIHZhciBjdXJyT2JqZWN0ID0gY3Vyc29yLnZhbHVlO1xuXG4gICAgICAgICAgICBkYXRhLnB1c2goY3Vyck9iamVjdCk7XG5cbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKGxvY2FsZGF0YSwgY2FsbGJhY2spO1xuXG4gICAgICBjdXJzb3Iub25lcnJvciA9IChmdW5jdGlvbih1c2VyY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mKHVzZXJjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHVzZXJjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMb2tpQ2F0YWxvZy5nZXRBcHBLZXlzIHJhaXNlZCBvbmVycm9yJyk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKGNhbGxiYWNrKTtcblxuICAgIH07XG5cbiAgICAvLyBIaWRlICdjdXJzb3JpbmcnIGFuZCByZXR1cm4gYXJyYXkgb2YgeyBpZDogaWQsIGtleToga2V5IH1cbiAgICBMb2tpQ2F0YWxvZy5wcm90b3R5cGUuZ2V0QWxsS2V5cyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbJ0xva2lBS1YnXSwgJ3JlYWRvbmx5Jyk7XG4gICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnTG9raUFLVicpO1xuICAgICAgdmFyIGN1cnNvciA9IHN0b3JlLm9wZW5DdXJzb3IoKTtcblxuICAgICAgdmFyIGxvY2FsZGF0YSA9IFtdO1xuXG4gICAgICBjdXJzb3Iub25zdWNjZXNzID0gKGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIGN1cnNvciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICB2YXIgY3Vyck9iamVjdCA9IGN1cnNvci52YWx1ZTtcblxuICAgICAgICAgICAgZGF0YS5wdXNoKGN1cnJPYmplY3QpO1xuXG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KShsb2NhbGRhdGEsIGNhbGxiYWNrKTtcblxuICAgICAgY3Vyc29yLm9uZXJyb3IgPSAoZnVuY3Rpb24odXNlcmNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZih1c2VyY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB1c2VyY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH07XG4gICAgICB9KShjYWxsYmFjayk7XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIEluZGV4ZWRBZGFwdGVyO1xuXG4gIH0oKSk7XG59KSk7XG4iLCIvKipcbiAqIExva2lKU1xuICogQGF1dGhvciBKb2UgTWluaWNoaW5vIDxqb2UubWluaWNoaW5vQGdtYWlsLmNvbT5cbiAqXG4gKiBBIGxpZ2h0d2VpZ2h0IGRvY3VtZW50IG9yaWVudGVkIGphdmFzY3JpcHQgZGF0YWJhc2VcbiAqL1xuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgcm9vdC5sb2tpID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgVXRpbHMgPSB7XG4gICAgICBjb3B5UHJvcGVydGllczogZnVuY3Rpb24gKHNyYywgZGVzdCkge1xuICAgICAgICB2YXIgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIHNyYykge1xuICAgICAgICAgIGRlc3RbcHJvcF0gPSBzcmNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IHNjYW4gaGllcmFyY2hpY2FsIHRyYW5zZm9ybSBzdGVwIG9iamVjdCBmb3IgcGFyYW0gc3Vic3RpdHV0aW9uXG4gICAgICByZXNvbHZlVHJhbnNmb3JtT2JqZWN0OiBmdW5jdGlvbiAoc3ViT2JqLCBwYXJhbXMsIGRlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wLFxuICAgICAgICAgIHBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwdGggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrZGVwdGggPj0gMTApIHJldHVybiBzdWJPYmo7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIHN1Yk9iaikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3ViT2JqW3Byb3BdID09PSAnc3RyaW5nJyAmJiBzdWJPYmpbcHJvcF0uaW5kZXhPZihcIlslbGt0eHBdXCIpID09PSAwKSB7XG4gICAgICAgICAgICBwbmFtZSA9IHN1Yk9ialtwcm9wXS5zdWJzdHJpbmcoOCk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBuYW1lKSkge1xuICAgICAgICAgICAgICBzdWJPYmpbcHJvcF0gPSBwYXJhbXNbcG5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Yk9ialtwcm9wXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgc3ViT2JqW3Byb3BdID0gVXRpbHMucmVzb2x2ZVRyYW5zZm9ybU9iamVjdChzdWJPYmpbcHJvcF0sIHBhcmFtcywgZGVwdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJPYmo7XG4gICAgICB9LFxuICAgICAgLy8gdG9wIGxldmVsIHV0aWxpdHkgdG8gcmVzb2x2ZSBhbiBlbnRpcmUgKHNpbmdsZSkgdHJhbnNmb3JtIChhcnJheSBvZiBzdGVwcykgZm9yIHBhcmFtZXRlciBzdWJzdGl0dXRpb25cbiAgICAgIHJlc29sdmVUcmFuc2Zvcm1QYXJhbXM6IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHBhcmFtcykge1xuICAgICAgICB2YXIgaWR4LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgY2xvbmVkU3RlcCxcbiAgICAgICAgICByZXNvbHZlZFRyYW5zZm9ybSA9IFtdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHRyYW5zZm9ybTtcblxuICAgICAgICAvLyBpdGVyYXRlIGFsbCBzdGVwcyBpbiB0aGUgdHJhbnNmb3JtIGFycmF5XG4gICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgdHJhbnNmb3JtLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAvLyBjbG9uZSB0cmFuc2Zvcm0gc28gb3VyIHNjYW4gYW5kIHJlcGxhY2UgY2FuIG9wZXJhdGUgZGlyZWN0bHkgb24gY2xvbmVkIHRyYW5zZm9ybVxuICAgICAgICAgIGNsb25lZFN0ZXAgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybVtpZHhdKSk7XG4gICAgICAgICAgcmVzb2x2ZWRUcmFuc2Zvcm0ucHVzaChVdGlscy5yZXNvbHZlVHJhbnNmb3JtT2JqZWN0KGNsb25lZFN0ZXAsIHBhcmFtcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTb3J0IGhlbHBlciB0aGF0IHN1cHBvcnQgbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gbHRIZWxwZXIocHJvcDEsIHByb3AyLCBlcXVhbCkge1xuICAgICAgaWYgKHByb3AxID09PSB1bmRlZmluZWQgfHwgcHJvcDEgPT09IG51bGwgfHwgcHJvcDEgPT09IGZhbHNlIHx8IHByb3AyID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AyID09PSB1bmRlZmluZWQgfHwgcHJvcDIgPT09IG51bGwgfHwgcHJvcDEgPT09IHRydWUgfHwgcHJvcDIgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AxIDwgcHJvcDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wMSA+IHByb3AyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gbm90IGx0IGFuZCBhbmQgbm90IGd0IHNvIGVxdWFsaXR5IGFzc3VtZWQtLSB0aGlzIG9yZGVyaW5nIG9mIHRlc3RzIGlzIGRhdGUgY29tcGF0aWJsZVxuICAgICAgaWYgKGVxdWFsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3RIZWxwZXIocHJvcDEsIHByb3AyLCBlcXVhbCkge1xuICAgICAgaWYgKHByb3AxID09PSB1bmRlZmluZWQgfHwgcHJvcDEgPT09IG51bGwgfHwgcHJvcDEgPT09IGZhbHNlIHx8IHByb3AyID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wMiA9PT0gdW5kZWZpbmVkIHx8IHByb3AyID09PSBudWxsIHx8IHByb3AxID09PSB0cnVlIHx8IHByb3AyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AxID4gcHJvcDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wMSA8IHByb3AyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gbm90IGx0IGFuZCBhbmQgbm90IGd0IHNvIGVxdWFsaXR5IGFzc3VtZWQtLSB0aGlzIG9yZGVyaW5nIG9mIHRlc3RzIGlzIGRhdGUgY29tcGF0aWJsZVxuICAgICAgaWYgKGVxdWFsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEhlbHBlcihwcm9wMSwgcHJvcDIsIGRlc2MpIHtcbiAgICAgIGlmIChsdEhlbHBlcihwcm9wMSwgcHJvcDIpKSB7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChndEhlbHBlcihwcm9wMSwgcHJvcDIpKSB7XG4gICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdCBsdCwgbm90IGd0IHNvIGltcGxpZWQgZXF1YWxpdHktLSBkYXRlIGNvbXBhdGlibGVcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zQ2hlY2tGbihhLCBiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnIpIHtcbiAgICAgICAgICByZXR1cm4gYS5pbmRleE9mKGN1cnIpICE9PSAtMTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYSAmJiB0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5kZXhPZihjdXJyKSAhPT0gLTE7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3Vycikge1xuICAgICAgICAgIHJldHVybiBhLmhhc093blByb3BlcnR5KGN1cnIpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBMb2tpT3BzID0ge1xuICAgICAgLy8gY29tcGFyaXNvbiBvcGVyYXRvcnNcbiAgICAgIC8vIGEgaXMgdGhlIHZhbHVlIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAvLyBiIGlzIHRoZSBxdWVyeSB2YWx1ZVxuICAgICAgJGVxOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH0sXG5cbiAgICAgICRkdGVxOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChsdEhlbHBlcihhLCBiKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChndEhlbHBlcihhLGIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuXG4gICAgICAkZ3Q6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBndEhlbHBlcihhLCBiKTtcbiAgICAgIH0sXG5cbiAgICAgICRndGU6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBndEhlbHBlcihhLCBiLCB0cnVlKTtcbiAgICAgIH0sXG5cbiAgICAgICRsdDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGx0SGVscGVyKGEsIGIpO1xuICAgICAgfSxcblxuICAgICAgJGx0ZTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGx0SGVscGVyKGEsIGIsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgJG5lOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAhPT0gYjtcbiAgICAgIH0sXG5cbiAgICAgICRyZWdleDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIudGVzdChhKTtcbiAgICAgIH0sXG5cbiAgICAgICRpbjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA+IC0xO1xuICAgICAgfSxcblxuICAgICAgJG5pbjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihhKSA9PSAtMTtcbiAgICAgIH0sXG5cbiAgICAgICRjb250YWluc05vbmU6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAhTG9raU9wcy4kY29udGFpbnNBbnkoYSwgYik7XG4gICAgICB9LFxuXG4gICAgICAkY29udGFpbnNBbnk6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjaGVja0ZuO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgIGIgPSBbYl07XG4gICAgICAgIH1cblxuICAgICAgICBjaGVja0ZuID0gY29udGFpbnNDaGVja0ZuKGEsIGIpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGIucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjaGVja0ZuKGN1cnIpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9LFxuXG4gICAgICAkY29udGFpbnM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBjaGVja0ZuO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgIGIgPSBbYl07XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gZmFsc2Ugb24gY2hlY2sgaWYgbm8gY2hlY2sgZm4gaXMgZm91bmRcbiAgICAgICAgY2hlY2tGbiA9IGNvbnRhaW5zQ2hlY2tGbihhLCBiKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBiLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNoZWNrRm4oY3Vycik7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb3BlcmF0b3JzID0ge1xuICAgICAgJyRlcSc6IExva2lPcHMuJGVxLFxuICAgICAgJyRkdGVxJzogTG9raU9wcy4kZHRlcSxcbiAgICAgICckZ3QnOiBMb2tpT3BzLiRndCxcbiAgICAgICckZ3RlJzogTG9raU9wcy4kZ3RlLFxuICAgICAgJyRsdCc6IExva2lPcHMuJGx0LFxuICAgICAgJyRsdGUnOiBMb2tpT3BzLiRsdGUsXG4gICAgICAnJG5lJzogTG9raU9wcy4kbmUsXG4gICAgICAnJHJlZ2V4JzogTG9raU9wcy4kcmVnZXgsXG4gICAgICAnJGluJzogTG9raU9wcy4kaW4sXG4gICAgICAnJG5pbic6IExva2lPcHMuJG5pbixcbiAgICAgICckY29udGFpbnMnOiBMb2tpT3BzLiRjb250YWlucyxcbiAgICAgICckY29udGFpbnNBbnknOiBMb2tpT3BzLiRjb250YWluc0FueSxcbiAgICAgICckY29udGFpbnNOb25lJzogTG9raU9wcy4kY29udGFpbnNOb25lXG4gICAgfTtcblxuICAgIC8vIG1ha2luZyBpbmRleGluZyBvcHQtaW4uLi4gb3VyIHJhbmdlIGZ1bmN0aW9uIGtub3dzIGhvdyB0byBkZWFsIHdpdGggdGhlc2Ugb3BzIDpcbiAgICB2YXIgaW5kZXhlZE9wc0xpc3QgPSBbJyRlcScsICckZHRlcScsICckZ3QnLCAnJGd0ZScsICckbHQnLCAnJGx0ZSddO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUoZGF0YSwgbWV0aG9kKSB7XG4gICAgICB2YXIgY2xvbmVNZXRob2QgPSBtZXRob2QgfHwgJ3BhcnNlLXN0cmluZ2lmeScsXG4gICAgICAgIGNsb25lZDtcblxuICAgICAgc3dpdGNoIChjbG9uZU1ldGhvZCkge1xuICAgICAgICBjYXNlIFwicGFyc2Utc3RyaW5naWZ5XCI6XG4gICAgICAgICAgY2xvbmVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJqcXVlcnktZXh0ZW5kLWRlZXBcIjpcbiAgICAgICAgICBjbG9uZWQgPSBqUXVlcnkuZXh0ZW5kKHRydWUsIHt9LCBkYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNoYWxsb3dcIjpcbiAgICAgICAgICBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKGRhdGEucHJvdG90eXBlIHx8IG51bGwpO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgY2xvbmVkW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy9pZiAoY2xvbmVNZXRob2QgPT09ICdwYXJzZS1zdHJpbmdpZnknKSB7XG4gICAgICAvLyAgY2xvbmVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAvL31cbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVPYmplY3RBcnJheShvYmphcnJheSwgbWV0aG9kKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGlmIChtZXRob2QgPT0gXCJwYXJzZS1zdHJpbmdpZnlcIikge1xuICAgICAgICByZXR1cm4gY2xvbmUob2JqYXJyYXksIG1ldGhvZCk7XG4gICAgICB9XG5cbiAgICAgIGkgPSBvYmphcnJheS5sZW5ndGgtMTtcblxuICAgICAgZm9yKDtpPD0wO2ktLSkge1xuICAgICAgICByZXN1bHQucHVzaChjbG9uZShvYmphcnJheVtpXSwgbWV0aG9kKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gbnVsbCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExva2lFdmVudEVtaXR0ZXIgaXMgYSBtaW5pbWFsaXN0IHZlcnNpb24gb2YgRXZlbnRFbWl0dGVyLiBJdCBlbmFibGVzIGFueVxuICAgICAqIGNvbnN0cnVjdG9yIHRoYXQgaW5oZXJpdHMgRXZlbnRFbWl0dGVyIHRvIGVtaXQgZXZlbnRzIGFuZCB0cmlnZ2VyXG4gICAgICogbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBldmVudCB0aHJvdWdoIHRoZSBvbihldmVudCwgY2FsbGJhY2spIG1ldGhvZFxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9raUV2ZW50RW1pdHRlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcCBFdmVudHMgcHJvcGVydHkgaXMgYSBoYXNobWFwLCB3aXRoIGVhY2ggcHJvcGVydHkgYmVpbmcgYW4gYXJyYXkgb2YgY2FsbGJhY2tzXG4gICAgICovXG4gICAgTG9raUV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnRzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcCBhc3luY0xpc3RlbmVycyAtIGJvb2xlYW4gZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgY2FsbGJhY2tzIGFzc29jaWF0ZWQgd2l0aCBlYWNoIGV2ZW50XG4gICAgICogc2hvdWxkIGhhcHBlbiBpbiBhbiBhc3luYyBmYXNoaW9uIG9yIG5vdFxuICAgICAqIERlZmF1bHQgaXMgZmFsc2UsIHdoaWNoIG1lYW5zIGV2ZW50cyBhcmUgc3luY2hyb25vdXNcbiAgICAgKi9cbiAgICBMb2tpRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hc3luY0xpc3RlbmVycyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3Agb24oZXZlbnROYW1lLCBsaXN0ZW5lcikgLSBhZGRzIGEgbGlzdGVuZXIgdG8gdGhlIHF1ZXVlIG9mIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHRvIGFuIGV2ZW50XG4gICAgICogQHJldHVybnMge2ludH0gdGhlIGluZGV4IG9mIHRoZSBjYWxsYmFjayBpbiB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIHBhcnRpY3VsYXIgZXZlbnRcbiAgICAgKi9cbiAgICBMb2tpRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICBldmVudCA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnB1c2gobGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcHQgZW1pdChldmVudE5hbWUsIGRhdGEpIC0gZW1pdHMgYSBwYXJ0aWN1bGFyIGV2ZW50XG4gICAgICogd2l0aCB0aGUgb3B0aW9uIG9mIHBhc3Npbmcgb3B0aW9uYWwgcGFyYW1ldGVycyB3aGljaCBhcmUgZ29pbmcgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBjYWxsYmFja1xuICAgICAqIHByb3ZpZGVkIHNpZ25hdHVyZXMgbWF0Y2ggKGkuZS4gaWYgcGFzc2luZyBlbWl0KGV2ZW50LCBhcmcwLCBhcmcxKSB0aGUgbGlzdGVuZXIgc2hvdWxkIHRha2UgdHdvIHBhcmFtZXRlcnMpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gb3B0aW9uYWwgb2JqZWN0IHBhc3NlZCB3aXRoIHRoZSBldmVudFxuICAgICAqL1xuICAgIExva2lFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAoZXZlbnROYW1lICYmIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGlmIChzZWxmLmFzeW5jTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIoZGF0YSk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXIoZGF0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldmVudCAnICsgZXZlbnROYW1lICsgJyBkZWZpbmVkJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wIHJlbW92ZSgpIC0gcmVtb3ZlcyB0aGUgbGlzdGVuZXIgYXQgcG9zaXRpb24gJ2luZGV4JyBmcm9tIHRoZSBldmVudCAnZXZlbnROYW1lJ1xuICAgICAqL1xuICAgIExva2lFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSwgMSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExva2k6IFRoZSBtYWluIGRhdGFiYXNlIGNsYXNzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBzYXZlZCB0b1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY29uZmlnIG9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExva2koZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZSB8fCAnbG9raS5kYic7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zID0gW107XG5cbiAgICAgIC8vIHBlcnNpc3QgdmVyc2lvbiBvZiBjb2RlIHdoaWNoIGNyZWF0ZWQgdGhlIGRhdGFiYXNlIHRvIHRoZSBkYXRhYmFzZS5cbiAgICAgIC8vIGNvdWxkIHVzZSBmb3IgdXBncmFkZSBzY2VuYXJpb3NcbiAgICAgIHRoaXMuZGF0YWJhc2VWZXJzaW9uID0gMS4xO1xuICAgICAgdGhpcy5lbmdpbmVWZXJzaW9uID0gMS4xO1xuXG4gICAgICAvLyBhdXRvc2F2ZSBzdXBwb3J0IChkaXNhYmxlZCBieSBkZWZhdWx0KVxuICAgICAgLy8gcGFzcyBhdXRvc2F2ZTogdHJ1ZSwgYXV0b3NhdmVJbnRlcnZhbDogNjAwMCBpbiBvcHRpb25zIHRvIHNldCA2IHNlY29uZCBhdXRvc2F2ZVxuICAgICAgdGhpcy5hdXRvc2F2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5hdXRvc2F2ZUludGVydmFsID0gNTAwMDtcbiAgICAgIHRoaXMuYXV0b3NhdmVIYW5kbGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcblxuICAgICAgLy8gY3VycmVudGx5IGtlZXBpbmcgcGVyc2lzdGVuY2VNZXRob2QgYW5kIHBlcnNpc3RlbmNlQWRhcHRlciBhcyBsb2tpIGxldmVsIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gd2lsbCBub3Qgb3IgY2Fubm90IGJlIGRlc2VyaWFsaXplZC4gIFlvdSBhcmUgcmVxdWlyZWQgdG8gY29uZmlndXJlIHBlcnNpc3RlbmNlIGV2ZXJ5IHRpbWVcbiAgICAgIC8vIHlvdSBpbnN0YW50aWF0ZSBhIGxva2kgb2JqZWN0IChvciB1c2UgZGVmYXVsdCBlbnZpcm9ubWVudCBkZXRlY3Rpb24pIGluIG9yZGVyIHRvIGxvYWQgdGhlIGRhdGFiYXNlIGFueXdheXMuXG5cbiAgICAgIC8vIHBlcnNpc3RlbmNlTWV0aG9kIGNvdWxkIGJlICdmcycsICdsb2NhbFN0b3JhZ2UnLCBvciAnYWRhcHRlcidcbiAgICAgIC8vIHRoaXMgaXMgb3B0aW9uYWwgb3B0aW9uIHBhcmFtLCBvdGhlcndpc2UgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIHdpbGwgYmUgdXNlZFxuICAgICAgLy8gaWYgdXNlciBwYXNzZXMgdGhlaXIgb3duIGFkYXB0ZXIgd2Ugd2lsbCBmb3JjZSB0aGlzIG1ldGhvZCB0byAnYWRhcHRlcicgbGF0ZXIsIHNvIG5vIG5lZWQgdG8gcGFzcyBtZXRob2Qgb3B0aW9uLlxuICAgICAgdGhpcy5wZXJzaXN0ZW5jZU1ldGhvZCA9IG51bGw7XG5cbiAgICAgIC8vIHJldGFpbiByZWZlcmVuY2UgdG8gb3B0aW9uYWwgKG5vbi1zZXJpYWxpemFibGUpIHBlcnNpc3RlbmNlQWRhcHRlciAnaW5zdGFuY2UnXG4gICAgICB0aGlzLnBlcnNpc3RlbmNlQWRhcHRlciA9IG51bGw7XG5cbiAgICAgIC8vIGVuYWJsZSBjb25zb2xlIG91dHB1dCBpZiB2ZXJib3NlIGZsYWcgaXMgc2V0IChkaXNhYmxlZCBieSBkZWZhdWx0KVxuICAgICAgdGhpcy52ZXJib3NlID0gb3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCd2ZXJib3NlJykgPyBvcHRpb25zLnZlcmJvc2UgOiBmYWxzZTtcblxuICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICdpbml0JzogW10sXG4gICAgICAgICdsb2FkZWQnOiBbXSxcbiAgICAgICAgJ2ZsdXNoQ2hhbmdlcyc6IFtdLFxuICAgICAgICAnY2xvc2UnOiBbXSxcbiAgICAgICAgJ2NoYW5nZXMnOiBbXSxcbiAgICAgICAgJ3dhcm5pbmcnOiBbXVxuICAgICAgfTtcblxuICAgICAgdmFyIGdldEVOViA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICdOT0RFSlMnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC53aW5kb3cpIHtcbiAgICAgICAgICByZXR1cm4gJ05PREVKUyc7IC8vbm9kZS13ZWJraXRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwOi8vJykgPT09IC0xICYmIGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwczovLycpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdDT1JET1ZBJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICdCUk9XU0VSJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0NPUkRPVkEnO1xuICAgICAgfTtcblxuICAgICAgLy8gcmVmYWN0b3JlZCBlbnZpcm9ubWVudCBkZXRlY3Rpb24gZHVlIHRvIGludmFsaWQgZGV0ZWN0aW9uIGZvciBicm93c2VyIGVudmlyb25tZW50cy5cbiAgICAgIC8vIGlmIHRoZXkgZG8gbm90IHNwZWNpZnkgYW4gb3B0aW9ucy5lbnYgd2Ugd2FudCB0byBkZXRlY3QgZW52IHJhdGhlciB0aGFuIGRlZmF1bHQgdG8gbm9kZWpzLlxuICAgICAgLy8gY3VycmVudGx5IGtlZXBpbmcgdHdvIHByb3BlcnRpZXMgZm9yIHNpbWlsYXIgdGhpbmcgKG9wdGlvbnMuZW52IGFuZCBvcHRpb25zLnBlcnNpc3RlbmNlTWV0aG9kKVxuICAgICAgLy8gICBtaWdodCB3YW50IHRvIHJldmlldyB3aGV0aGVyIHdlIGNhbiBjb25zb2xpZGF0ZS5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2VudicpKSB7XG4gICAgICAgIHRoaXMuRU5WID0gb3B0aW9ucy5lbnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLkVOViA9IGdldEVOVigpO1xuICAgICAgfVxuXG4gICAgICAvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIG5lY2Vzc2FyeSBub3cgdGhhdCBpIGhhdmUgcmVmYWN0b3JlZCB0aGUgbGluZSBhYm92ZVxuICAgICAgaWYgKHRoaXMuRU5WID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLkVOViA9ICdOT0RFSlMnO1xuICAgICAgfVxuXG4gICAgICAvL2lmICh0eXBlb2YgKG9wdGlvbnMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jb25maWd1cmVPcHRpb25zKG9wdGlvbnMsIHRydWUpO1xuICAgICAgLy99XG5cbiAgICAgIHRoaXMub24oJ2luaXQnLCB0aGlzLmNsZWFyQ2hhbmdlcyk7XG5cbiAgICB9XG5cbiAgICAvLyBkYiBjbGFzcyBpcyBhbiBFdmVudEVtaXR0ZXJcbiAgICBMb2tpLnByb3RvdHlwZSA9IG5ldyBMb2tpRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvLyBleHBlcmltZW50YWwgc3VwcG9ydCBmb3IgYnJvd3NlcmlmeSdzIGFic3RyYWN0IHN5bnRheCBzY2FuIHRvIHBpY2sgdXAgZGVwZW5kZW5jeSBvZiBpbmRleGVkIGFkYXB0ZXIuXG4gICAgLy8gSG9wZWZ1bGx5LCBvbmNlIHRoaXMgaGl0cyBucG0gYSBicm93c2VyaWZ5IHJlcXVpcmUgb2YgbG9raWpzIHNob3VsZCBzY2FuIHRoZSBtYWluIGZpbGUgYW5kIGRldGVjdCB0aGlzIGluZGV4ZWQgYWRhcHRlciByZWZlcmVuY2UuXG4gICAgTG9raS5wcm90b3R5cGUuZ2V0SW5kZXhlZEFkYXB0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWRhcHRlcjtcblxuICAgICAgaWYgKHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFkYXB0ZXIgPSByZXF1aXJlKFwiLi9sb2tpLWluZGV4ZWQtYWRhcHRlci5qc1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogY29uZmlndXJlT3B0aW9ucyAtIGFsbG93cyByZWNvbmZpZ3VyaW5nIGRhdGFiYXNlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIGFwcGx5IHRvIGxva2kgZGIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbml0aWFsQ29uZmlnIC0gKG9wdGlvbmFsKSBpZiB0aGlzIGlzIGEgcmVjb25maWcsIGRvbid0IHBhc3MgdGhpc1xuICAgICAqL1xuICAgIExva2kucHJvdG90eXBlLmNvbmZpZ3VyZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgaW5pdGlhbENvbmZpZykge1xuICAgICAgdmFyIGRlZmF1bHRQZXJzaXN0ZW5jZSA9IHtcbiAgICAgICAgICAnTk9ERUpTJzogJ2ZzJyxcbiAgICAgICAgICAnQlJPV1NFUic6ICdsb2NhbFN0b3JhZ2UnLFxuICAgICAgICAgICdDT1JET1ZBJzogJ2xvY2FsU3RvcmFnZSdcbiAgICAgICAgfSxcbiAgICAgICAgcGVyc2lzdGVuY2VNZXRob2RzID0ge1xuICAgICAgICAgICdmcyc6IExva2lGc0FkYXB0ZXIsXG4gICAgICAgICAgJ2xvY2FsU3RvcmFnZSc6IExva2lMb2NhbFN0b3JhZ2VBZGFwdGVyXG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuXG4gICAgICB0aGlzLnBlcnNpc3RlbmNlTWV0aG9kID0gbnVsbDtcbiAgICAgIC8vIHJldGFpbiByZWZlcmVuY2UgdG8gb3B0aW9uYWwgcGVyc2lzdGVuY2UgYWRhcHRlciAnaW5zdGFuY2UnXG4gICAgICAvLyBjdXJyZW50bHkga2VlcGluZyBvdXRzaWRlIG9wdGlvbnMgYmVjYXVzZSBpdCBjYW4ndCBiZSBzZXJpYWxpemVkXG4gICAgICB0aGlzLnBlcnNpc3RlbmNlQWRhcHRlciA9IG51bGw7XG5cbiAgICAgIC8vIHByb2Nlc3MgdGhlIG9wdGlvbnNcbiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGVyc2lzdGVuY2VNZXRob2QnKSkge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzcGVjaWZpZWQgcGVyc2lzdGVuY2UgbWV0aG9kIGlzIGtub3duXG4gICAgICAgICAgaWYgKHR5cGVvZiAocGVyc2lzdGVuY2VNZXRob2RzW29wdGlvbnMucGVyc2lzdGVuY2VNZXRob2RdKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlTWV0aG9kID0gb3B0aW9ucy5wZXJzaXN0ZW5jZU1ldGhvZDtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VBZGFwdGVyID0gbmV3IHBlcnNpc3RlbmNlTWV0aG9kc1tvcHRpb25zLnBlcnNpc3RlbmNlTWV0aG9kXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzaG91bGQgYmUgdGhyb3cgYW4gZXJyb3IgaGVyZSwgb3IganVzdCBmYWxsIGJhY2sgdG8gZGVmYXVsdHMgPz9cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHVzZXIgcGFzc2VzIGFkYXB0ZXIsIHNldCBwZXJzaXN0ZW5jZSBtb2RlIHRvIGFkYXB0ZXIgYW5kIHJldGFpbiBwZXJzaXN0ZW5jZSBhZGFwdGVyIGluc3RhbmNlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2FkYXB0ZXInKSkge1xuICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VNZXRob2QgPSAnYWRhcHRlcic7XG4gICAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUFkYXB0ZXIgPSBvcHRpb25zLmFkYXB0ZXI7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFkYXB0ZXIgPSBudWxsO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBpZiB0aGV5IHdhbnQgdG8gbG9hZCBkYXRhYmFzZSBvbiBsb2tpIGluc3RhbnRpYXRpb24sIG5vdyBpcyBhIGdvb2QgdGltZSB0byBsb2FkLi4uIGFmdGVyIGFkYXB0ZXIgc2V0IGFuZCBiZWZvcmUgcG9zc2libGUgYXV0b3NhdmUgaW5pdGlhdGlvblxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvbG9hZCAmJiBpbml0aWFsQ29uZmlnKSB7XG4gICAgICAgICAgLy8gZm9yIGF1dG9sb2FkLCBsZXQgdGhlIGNvbnN0cnVjdG9yIGNvbXBsZXRlIGJlZm9yZSBmaXJpbmcgY2FsbGJhY2tcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWREYXRhYmFzZShvcHRpb25zLCBvcHRpb25zLmF1dG9sb2FkQ2FsbGJhY2spO1xuICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYXV0b3NhdmVJbnRlcnZhbCcpKSB7XG4gICAgICAgICAgdGhpcy5hdXRvc2F2ZURpc2FibGUoKTtcbiAgICAgICAgICB0aGlzLmF1dG9zYXZlSW50ZXJ2YWwgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuYXV0b3NhdmVJbnRlcnZhbCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYXV0b3NhdmUnKSAmJiB0aGlzLm9wdGlvbnMuYXV0b3NhdmUpIHtcbiAgICAgICAgICB0aGlzLmF1dG9zYXZlRGlzYWJsZSgpO1xuICAgICAgICAgIHRoaXMuYXV0b3NhdmUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYXV0b3NhdmVDYWxsYmFjaycpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9zYXZlRW5hYmxlKG9wdGlvbnMsIG9wdGlvbnMuYXV0b3NhdmVDYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b3NhdmVFbmFibGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIG9mIG9wdGlvbnMgcHJvY2Vzc2luZ1xuXG4gICAgICAvLyBpZiBieSBub3cgdGhlcmUgaXMgbm8gYWRhcHRlciBzcGVjaWZpZWQgYnkgdXNlciBub3IgZGVyaXZlZCBmcm9tIHBlcnNpc3RlbmNlTWV0aG9kOiB1c2Ugc2Vuc2libGUgZGVmYXVsdHNcbiAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlQWRhcHRlciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlTWV0aG9kID0gZGVmYXVsdFBlcnNpc3RlbmNlW3RoaXMuRU5WXTtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VNZXRob2QpIHtcbiAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlQWRhcHRlciA9IG5ldyBwZXJzaXN0ZW5jZU1ldGhvZHNbdGhpcy5wZXJzaXN0ZW5jZU1ldGhvZF0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFub255bSgpIC0gc2hvcnRoYW5kIG1ldGhvZCBmb3IgcXVpY2tseSBjcmVhdGluZyBhbmQgcG9wdWxhdGluZyBhbiBhbm9ueW1vdXMgY29sbGVjdGlvbi5cbiAgICAgKiAgICBUaGlzIGNvbGxlY3Rpb24gaXMgbm90IHJlZmVyZW5jZWQgaW50ZXJuYWxseSBzbyB1cG9uIGxvc2luZyBzY29wZSBpdCB3aWxsIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICAgICAqXG4gICAgICogICAgRXhhbXBsZSA6IHZhciByZXN1bHRzID0gbmV3IGxva2koKS5hbm9ueW0obXlEb2NBcnJheSkuZmluZCh7J2FnZSc6IHsnJGd0JzogMzB9IH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZG9jcyAtIGRvY3VtZW50IGFycmF5IHRvIGluaXRpYWxpemUgdGhlIGFub255bW91cyBjb2xsZWN0aW9uIHdpdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzQXJyYXkgLSAoT3B0aW9uYWwpIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRvIGluZGV4XG4gICAgICogQHJldHVybnMge0NvbGxlY3Rpb259IE5ldyBjb2xsZWN0aW9uIHdoaWNoIHlvdSBjYW4gcXVlcnkgb3IgY2hhaW5cbiAgICAgKi9cbiAgICBMb2tpLnByb3RvdHlwZS5hbm9ueW0gPSBmdW5jdGlvbiAoZG9jcywgaW5kZXhlc0FycmF5KSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdhbm9ueW0nLCBpbmRleGVzQXJyYXkpO1xuICAgICAgY29sbGVjdGlvbi5pbnNlcnQoZG9jcyk7XG5cbiAgICAgIGlmKHRoaXMudmVyYm9zZSlcbiAgICAgICAgY29sbGVjdGlvbi5jb25zb2xlID0gY29uc29sZTtcblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfTtcblxuICAgIExva2kucHJvdG90eXBlLmFkZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbihuYW1lLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY29sbGVjdGlvbnMucHVzaChjb2xsZWN0aW9uKTtcblxuICAgICAgaWYodGhpcy52ZXJib3NlKVxuICAgICAgICBjb2xsZWN0aW9uLmNvbnNvbGUgPSBjb25zb2xlO1xuXG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9O1xuXG4gICAgTG9raS5wcm90b3R5cGUubG9hZENvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uIG11c3QgaGF2ZSBhIG5hbWUgcHJvcGVydHkgdG8gYmUgbG9hZGVkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zLnB1c2goY29sbGVjdGlvbik7XG4gICAgfTtcblxuICAgIExva2kucHJvdG90eXBlLmdldENvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY29sbGVjdGlvbk5hbWUpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICBsZW4gPSB0aGlzLmNvbGxlY3Rpb25zLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxlY3Rpb25zW2ldLm5hbWUgPT09IGNvbGxlY3Rpb25OYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gc3VjaCBjb2xsZWN0aW9uXG4gICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCAnY29sbGVjdGlvbiAnICsgY29sbGVjdGlvbk5hbWUgKyAnIG5vdCBmb3VuZCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIExva2kucHJvdG90eXBlLmxpc3RDb2xsZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgdmFyIGkgPSB0aGlzLmNvbGxlY3Rpb25zLmxlbmd0aCxcbiAgICAgICAgY29sbHMgPSBbXTtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2xscy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB0aGlzLmNvbGxlY3Rpb25zW2ldLm5hbWUsXG4gICAgICAgICAgdHlwZTogdGhpcy5jb2xsZWN0aW9uc1tpXS5vYmpUeXBlLFxuICAgICAgICAgIGNvdW50OiB0aGlzLmNvbGxlY3Rpb25zW2ldLmRhdGEubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxzO1xuICAgIH07XG5cbiAgICBMb2tpLnByb3RvdHlwZS5yZW1vdmVDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25OYW1lKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgbGVuID0gdGhpcy5jb2xsZWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5jb2xsZWN0aW9uc1tpXS5uYW1lID09PSBjb2xsZWN0aW9uTmFtZSkge1xuICAgICAgICAgIHRoaXMuY29sbGVjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBMb2tpLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2VyaWFsaXplUmVwbGFjZXIgLSB1c2VkIHRvIHByZXZlbnQgY2VydGFpbiBwcm9wZXJ0aWVzIGZyb20gYmVpbmcgc2VyaWFsaXplZFxuICAgICAqXG4gICAgICovXG4gICAgTG9raS5wcm90b3R5cGUuc2VyaWFsaXplUmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJ2F1dG9zYXZlSGFuZGxlJzpcbiAgICAgIGNhc2UgJ3BlcnNpc3RlbmNlQWRhcHRlcic6XG4gICAgICBjYXNlICdjb25zdHJhaW50cyc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB0b0pzb25cbiAgICBMb2tpLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgdGhpcy5zZXJpYWxpemVSZXBsYWNlcik7XG4gICAgfTtcbiAgICAvLyBhbGlhcyBvZiBzZXJpYWxpemVcbiAgICBMb2tpLnByb3RvdHlwZS50b0pzb24gPSBMb2tpLnByb3RvdHlwZS5zZXJpYWxpemU7XG5cbiAgICAvKipcbiAgICAgKiBsb2FkSlNPTiAtIGluZmxhdGVzIGEgbG9raSBkYXRhYmFzZSBmcm9tIGEgc2VyaWFsaXplZCBKU09OIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcmlhbGl6ZWREYiAtIGEgc2VyaWFsaXplZCBsb2tpIGRhdGFiYXNlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gYXBwbHkgb3Igb3ZlcnJpZGUgY29sbGVjdGlvbiBsZXZlbCBzZXR0aW5nc1xuICAgICAqL1xuICAgIExva2kucHJvdG90eXBlLmxvYWRKU09OID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWREYiwgb3B0aW9ucykge1xuXG4gICAgICBpZiAoc2VyaWFsaXplZERiLmxlbmd0aCA9PT0gMCkgc2VyaWFsaXplZERiID0gSlNPTi5zdHJpbmdpZnkoe30pO1xuICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZERiKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbiA9IG9iai5jb2xsZWN0aW9ucyA/IG9iai5jb2xsZWN0aW9ucy5sZW5ndGggOiAwLFxuICAgICAgICBjb2xsLFxuICAgICAgICBjb3B5Q29sbCxcbiAgICAgICAgY2xlbixcbiAgICAgICAgajtcblxuICAgICAgdGhpcy5uYW1lID0gb2JqLm5hbWU7XG5cbiAgICAgIC8vIHJlc3RvcmUgZGF0YWJhc2UgdmVyc2lvblxuICAgICAgdGhpcy5kYXRhYmFzZVZlcnNpb24gPSAxLjA7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KCdkYXRhYmFzZVZlcnNpb24nKSkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlVmVyc2lvbiA9IG9iai5kYXRhYmFzZVZlcnNpb247XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sbGVjdGlvbnMgPSBbXTtcblxuICAgICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29sbCA9IG9iai5jb2xsZWN0aW9uc1tpXTtcbiAgICAgICAgY29weUNvbGwgPSB0aGlzLmFkZENvbGxlY3Rpb24oY29sbC5uYW1lKTtcblxuICAgICAgICBjb3B5Q29sbC50cmFuc2FjdGlvbmFsID0gY29sbC50cmFuc2FjdGlvbmFsO1xuICAgICAgICBjb3B5Q29sbC5hc3luY0xpc3RlbmVycyA9IGNvbGwuYXN5bmNMaXN0ZW5lcnM7XG4gICAgICAgIGNvcHlDb2xsLmRpc2FibGVDaGFuZ2VzQXBpID0gY29sbC5kaXNhYmxlQ2hhbmdlc0FwaTtcbiAgICAgICAgY29weUNvbGwuY2xvbmVPYmplY3RzID0gY29sbC5jbG9uZU9iamVjdHM7XG4gICAgICAgIGNvcHlDb2xsLmNsb25lTWV0aG9kID0gY29sbC5jbG9uZU1ldGhvZCB8fCBcInBhcnNlLXN0cmluZ2lmeVwiO1xuICAgICAgICBjb3B5Q29sbC5hdXRvdXBkYXRlID0gY29sbC5hdXRvdXBkYXRlO1xuXG4gICAgICAgIC8vIGxvYWQgZWFjaCBlbGVtZW50IGluZGl2aWR1YWxseVxuICAgICAgICBjbGVuID0gY29sbC5kYXRhLmxlbmd0aDtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoY29sbC5uYW1lKSkge1xuXG4gICAgICAgICAgdmFyIGxvYWRlciA9IG9wdGlvbnNbY29sbC5uYW1lXS5pbmZsYXRlID8gb3B0aW9uc1tjb2xsLm5hbWVdLmluZmxhdGUgOiBVdGlscy5jb3B5UHJvcGVydGllcztcblxuICAgICAgICAgIGZvciAoajsgaiA8IGNsZW47IGorKykge1xuICAgICAgICAgICAgdmFyIGNvbGxPYmogPSBuZXcob3B0aW9uc1tjb2xsLm5hbWVdLnByb3RvKSgpO1xuICAgICAgICAgICAgbG9hZGVyKGNvbGwuZGF0YVtqXSwgY29sbE9iaik7XG4gICAgICAgICAgICBjb3B5Q29sbC5kYXRhW2pdID0gY29sbE9iajtcbiAgICAgICAgICAgIGNvcHlDb2xsLmFkZEF1dG9VcGRhdGVPYnNlcnZlcihjb2xsT2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBmb3IgKGo7IGogPCBjbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGNvcHlDb2xsLmRhdGFbal0gPSBjb2xsLmRhdGFbal07XG4gICAgICAgICAgICBjb3B5Q29sbC5hZGRBdXRvVXBkYXRlT2JzZXJ2ZXIoY29weUNvbGwuZGF0YVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29weUNvbGwubWF4SWQgPSAoY29sbC5kYXRhLmxlbmd0aCA9PT0gMCkgPyAwIDogY29sbC5tYXhJZDtcbiAgICAgICAgY29weUNvbGwuaWRJbmRleCA9IGNvbGwuaWRJbmRleDtcbiAgICAgICAgaWYgKHR5cGVvZiAoY29sbC5iaW5hcnlJbmRpY2VzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb3B5Q29sbC5iaW5hcnlJbmRpY2VzID0gY29sbC5iaW5hcnlJbmRpY2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbC50cmFuc2Zvcm1zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvcHlDb2xsLnRyYW5zZm9ybXMgPSBjb2xsLnRyYW5zZm9ybXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb3B5Q29sbC5lbnN1cmVJZCgpO1xuXG4gICAgICAgIC8vIHJlZ2VuZXJhdGUgdW5pcXVlIGluZGV4ZXNcbiAgICAgICAgY29weUNvbGwudW5pcXVlTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKGNvbGwuaGFzT3duUHJvcGVydHkoXCJ1bmlxdWVOYW1lc1wiKSkge1xuICAgICAgICAgIGNvcHlDb2xsLnVuaXF1ZU5hbWVzID0gY29sbC51bmlxdWVOYW1lcztcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29weUNvbGwudW5pcXVlTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvcHlDb2xsLmVuc3VyZVVuaXF1ZUluZGV4KGNvcHlDb2xsLnVuaXF1ZU5hbWVzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiBjYXNlIHRoZXkgYXJlIGxvYWRpbmcgYSBkYXRhYmFzZSBjcmVhdGVkIGJlZm9yZSB3ZSBhZGRlZCBkeW5hbWljIHZpZXdzLCBoYW5kbGUgdW5kZWZpbmVkXG4gICAgICAgIGlmICh0eXBlb2YgKGNvbGwuRHluYW1pY1ZpZXdzKSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIHJlaW5mbGF0ZSBEeW5hbWljVmlld3MgYW5kIGF0dGFjaGVkIFJlc3VsdHNldHNcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgY29sbC5EeW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIHZhciBjb2xsZHYgPSBjb2xsLkR5bmFtaWNWaWV3c1tpZHhdO1xuXG4gICAgICAgICAgdmFyIGR2ID0gY29weUNvbGwuYWRkRHluYW1pY1ZpZXcoY29sbGR2Lm5hbWUsIGNvbGxkdi5vcHRpb25zKTtcbiAgICAgICAgICBkdi5yZXN1bHRkYXRhID0gY29sbGR2LnJlc3VsdGRhdGE7XG4gICAgICAgICAgZHYucmVzdWx0c2RpcnR5ID0gY29sbGR2LnJlc3VsdHNkaXJ0eTtcbiAgICAgICAgICBkdi5maWx0ZXJQaXBlbGluZSA9IGNvbGxkdi5maWx0ZXJQaXBlbGluZTtcblxuICAgICAgICAgIGR2LnNvcnRDcml0ZXJpYSA9IGNvbGxkdi5zb3J0Q3JpdGVyaWE7XG4gICAgICAgICAgZHYuc29ydEZ1bmN0aW9uID0gbnVsbDtcblxuICAgICAgICAgIGR2LnNvcnREaXJ0eSA9IGNvbGxkdi5zb3J0RGlydHk7XG4gICAgICAgICAgZHYucmVzdWx0c2V0LmZpbHRlcmVkcm93cyA9IGNvbGxkdi5yZXN1bHRzZXQuZmlsdGVyZWRyb3dzO1xuICAgICAgICAgIGR2LnJlc3VsdHNldC5zZWFyY2hJc0NoYWluZWQgPSBjb2xsZHYucmVzdWx0c2V0LnNlYXJjaElzQ2hhaW5lZDtcbiAgICAgICAgICBkdi5yZXN1bHRzZXQuZmlsdGVySW5pdGlhbGl6ZWQgPSBjb2xsZHYucmVzdWx0c2V0LmZpbHRlckluaXRpYWxpemVkO1xuXG4gICAgICAgICAgZHYucmVtYXRlcmlhbGl6ZSh7XG4gICAgICAgICAgICByZW1vdmVXaGVyZUZpbHRlcnM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZShjYWxsYmFjaykgLSBlbWl0cyB0aGUgY2xvc2UgZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBjYWxsYmFjay4gRG9lcyBub3QgYWN0dWFsbHkgZGVzdHJveSB0aGUgZGJcbiAgICAgKiBidXQgdXNlZnVsIGZyb20gYW4gQVBJIHBlcnNwZWN0aXZlXG4gICAgICovXG4gICAgTG9raS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIGZvciBhdXRvc2F2ZSBzY2VuYXJpb3MsIHdlIHdpbGwgbGV0IGNsb3NlIHBlcmZvcm0gZmluYWwgc2F2ZSAoaWYgZGlydHkpXG4gICAgICAvLyBGb3Igd2ViIHVzZSwgeW91IG1pZ2h0IGNhbGwgZnJvbSB3aW5kb3cub25iZWZvcmV1bmxvYWQgdG8gc2h1dGRvd24gZGF0YWJhc2UsIHNhdmluZyBwZW5kaW5nIGNoYW5nZXNcbiAgICAgIGlmICh0aGlzLmF1dG9zYXZlKSB7XG4gICAgICAgIHRoaXMuYXV0b3NhdmVEaXNhYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9zYXZlRGlydHkoKSkge1xuICAgICAgICAgIHRoaXMuc2F2ZURhdGFiYXNlKGNhbGxiYWNrKTtcbiAgICAgICAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vbignY2xvc2UnLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfTtcblxuICAgIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgfCBDaGFuZ2VzIEFQSSAgICAgICAgICAgICAgIHxcbiAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIENoYW5nZXMgQVBJIGVuYWJsZXMgdGhlIHRyYWNraW5nIHRoZSBjaGFuZ2VzIG9jY3VycmVkIGluIHRoZSBjb2xsZWN0aW9ucyBzaW5jZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZXNzaW9uLFxuICAgICAqIHNvIGl0J3MgcG9zc2libGUgdG8gY3JlYXRlIGEgZGlmZmVyZW50aWFsIGRhdGFzZXQgZm9yIHN5bmNocm9uaXphdGlvbiBwdXJwb3NlcyAocG9zc2libHkgdG8gYSByZW1vdGUgZGIpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZUNoYW5nZXNOb3RpZmljYXRpb24oKSAtIHRha2VzIGFsbCB0aGUgY2hhbmdlcyBzdG9yZWQgaW4gZWFjaFxuICAgICAqIGNvbGxlY3Rpb24gYW5kIGNyZWF0ZXMgYSBzaW5nbGUgYXJyYXkgZm9yIHRoZSBlbnRpcmUgZGF0YWJhc2UuIElmIGFuIGFycmF5IG9mIG5hbWVzXG4gICAgICogb2YgY29sbGVjdGlvbnMgaXMgcGFzc2VkIHRoZW4gb25seSB0aGUgaW5jbHVkZWQgY29sbGVjdGlvbnMgd2lsbCBiZSB0cmFja2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gb3B0aW9uYWwgYXJyYXkgb2YgY29sbGVjdGlvbiBuYW1lcy4gTm8gYXJnIG1lYW5zIGFsbCBjb2xsZWN0aW9ucyBhcmUgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm5zIHthcnJheX0gYXJyYXkgb2YgY2hhbmdlc1xuICAgICAqIEBzZWUgcHJpdmF0ZSBtZXRob2QgY3JlYXRlQ2hhbmdlKCkgaW4gQ29sbGVjdGlvblxuICAgICAqL1xuICAgIExva2kucHJvdG90eXBlLmdlbmVyYXRlQ2hhbmdlc05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChhcnJheU9mQ29sbGVjdGlvbk5hbWVzKSB7XG4gICAgICBmdW5jdGlvbiBnZXRDb2xsTmFtZShjb2xsKSB7XG4gICAgICAgIHJldHVybiBjb2xsLm5hbWU7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlcyA9IFtdLFxuICAgICAgICBzZWxlY3RlZENvbGxlY3Rpb25zID0gYXJyYXlPZkNvbGxlY3Rpb25OYW1lcyB8fCB0aGlzLmNvbGxlY3Rpb25zLm1hcChnZXRDb2xsTmFtZSk7XG5cbiAgICAgIHRoaXMuY29sbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sbCkge1xuICAgICAgICBpZiAoc2VsZWN0ZWRDb2xsZWN0aW9ucy5pbmRleE9mKGdldENvbGxOYW1lKGNvbGwpKSAhPT0gLTEpIHtcbiAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb25jYXQoY29sbC5nZXRDaGFuZ2VzKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXJpYWxpemVDaGFuZ2VzKCkgLSBzdHJpbmdpZnkgY2hhbmdlcyBmb3IgbmV0d29yayB0cmFuc21pc3Npb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBMb2tpLnByb3RvdHlwZS5zZXJpYWxpemVDaGFuZ2VzID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25OYW1lc0FycmF5KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5nZW5lcmF0ZUNoYW5nZXNOb3RpZmljYXRpb24oY29sbGVjdGlvbk5hbWVzQXJyYXkpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogY2xlYXJDaGFuZ2VzKCkgLSBjbGVhcnMgYWxsIHRoZSBjaGFuZ2VzIGluIGFsbCBjb2xsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBMb2tpLnByb3RvdHlwZS5jbGVhckNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGNvbGwpIHtcbiAgICAgICAgaWYgKGNvbGwuZmx1c2hDaGFuZ2VzKSB7XG4gICAgICAgICAgY29sbC5mbHVzaENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgIHwgUEVSU0lTVEVOQ0UgICAgICAgfFxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbiAgICAvKiogdGhlcmUgYXJlIHR3byBidWlsZCBpbiBwZXJzaXN0ZW5jZSBhZGFwdGVycyBmb3IgaW50ZXJuYWwgdXNlXG4gICAgICogZnMgICAgICAgICAgICAgZm9yIHVzZSBpbiBOb2RlanMgdHlwZSBlbnZpcm9ubWVudHNcbiAgICAgKiBsb2NhbFN0b3JhZ2UgICBmb3IgdXNlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgKiBkZWZpbmVkIGFzIGhlbHBlciBjbGFzc2VzIGhlcmUgc28gaXRzIGVhc3kgYW5kIGNsZWFuIHRvIHVzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3IgZm9yIGZzXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9raUZzQWRhcHRlcigpIHtcbiAgICAgIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvYWREYXRhYmFzZSgpIC0gTG9hZCBkYXRhIGZyb20gZmlsZSwgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYm5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGRhdGFiYXNlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIExva2lGc0FkYXB0ZXIucHJvdG90eXBlLmxvYWREYXRhYmFzZSA9IGZ1bmN0aW9uIGxvYWREYXRhYmFzZShkYm5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmZzLnJlYWRGaWxlKGRibmFtZSwge1xuICAgICAgICBlbmNvZGluZzogJ3V0ZjgnXG4gICAgICB9LCBmdW5jdGlvbiByZWFkRmlsZUNhbGxiYWNrKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGVycikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2F2ZURhdGFiYXNlKCkgLSBzYXZlIGRhdGEgdG8gZmlsZSwgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZmlsZSBjYW4ndCBiZSBzYXZlZFxuICAgICAqIG1pZ2h0IHdhbnQgdG8gZXhwYW5kIHRoaXMgdG8gYXZvaWQgZGF0YWxvc3Mgb24gcGFydGlhbCBzYXZlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRibmFtZSAtIHRoZSBmaWxlbmFtZSBvZiB0aGUgZGF0YWJhc2UgdG8gbG9hZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRvIGhhbmRsZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgTG9raUZzQWRhcHRlci5wcm90b3R5cGUuc2F2ZURhdGFiYXNlID0gZnVuY3Rpb24gc2F2ZURhdGFiYXNlKGRibmFtZSwgZGJzdHJpbmcsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmZzLndyaXRlRmlsZShkYm5hbWUsIGRic3RyaW5nLCBjYWxsYmFjayk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3IgZm9yIGxvY2FsIHN0b3JhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2tpTG9jYWxTdG9yYWdlQWRhcHRlcigpIHt9XG5cbiAgICAvKipcbiAgICAgKiBsb2FkRGF0YWJhc2UoKSAtIExvYWQgZGF0YSBmcm9tIGxvY2Fsc3RvcmFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgdG8gbG9hZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIHRvIGhhbmRsZSB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgTG9raUxvY2FsU3RvcmFnZUFkYXB0ZXIucHJvdG90eXBlLmxvYWREYXRhYmFzZSA9IGZ1bmN0aW9uIGxvYWREYXRhYmFzZShkYm5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAobG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgY2FsbGJhY2sobG9jYWxTdG9yYWdlLmdldEl0ZW0oZGJuYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzYXZlRGF0YWJhc2UoKSAtIHNhdmUgZGF0YSB0byBsb2NhbHN0b3JhZ2UsIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGZpbGUgY2FuJ3QgYmUgc2F2ZWRcbiAgICAgKiBtaWdodCB3YW50IHRvIGV4cGFuZCB0aGlzIHRvIGF2b2lkIGRhdGFsb3NzIG9uIHBhcnRpYWwgc2F2ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYm5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGRhdGFiYXNlIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIExva2lMb2NhbFN0b3JhZ2VBZGFwdGVyLnByb3RvdHlwZS5zYXZlRGF0YWJhc2UgPSBmdW5jdGlvbiBzYXZlRGF0YWJhc2UoZGJuYW1lLCBkYnN0cmluZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChsb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShkYm5hbWUsIGRic3RyaW5nKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBsb2FkRGF0YWJhc2UgLSBIYW5kbGVzIGxvYWRpbmcgZnJvbSBmaWxlIHN5c3RlbSwgbG9jYWwgc3RvcmFnZSwgb3IgYWRhcHRlciAoaW5kZXhlZGRiKVxuICAgICAqICAgIFRoaXMgbWV0aG9kIHV0aWxpemVzIGxva2kgY29uZmlndXJhdGlvbiBvcHRpb25zIChpZiBwcm92aWRlZCkgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICogICAgcGVyc2lzdGVuY2UgbWV0aG9kIHRvIHVzZSwgb3IgZW52aXJvbm1lbnQgZGV0ZWN0aW9uIChpZiBjb25maWd1cmF0aW9uIHdhcyBub3QgcHJvdmlkZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBub3QgY3VycmVudGx5IHVzZWQgKHJlbW92ZSBvciBhbGxvdyBvdmVycmlkZXM/KVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gKE9wdGlvbmFsKSB1c2VyIHN1cHBsaWVkIGFzeW5jIGNhbGxiYWNrIC8gZXJyb3IgaGFuZGxlclxuICAgICAqL1xuICAgIExva2kucHJvdG90eXBlLmxvYWREYXRhYmFzZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGNGdW4gPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyB0aGUgcGVyc2lzdGVuY2VBZGFwdGVyIHNob3VsZCBiZSBwcmVzZW50IGlmIGFsbCBpcyBvaywgYnV0IGNoZWNrIHRvIGJlIHN1cmUuXG4gICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZUFkYXB0ZXIgIT09IG51bGwpIHtcblxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlQWRhcHRlci5sb2FkRGF0YWJhc2UodGhpcy5maWxlbmFtZSwgZnVuY3Rpb24gbG9hZERhdGFiYXNlQ2FsbGJhY2soZGJTdHJpbmcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIChkYlN0cmluZykgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRKU09OKGRiU3RyaW5nLCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgIGNGdW4obnVsbCk7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2xvYWRlZCcsICdkYXRhYmFzZSAnICsgc2VsZi5maWxlbmFtZSArICcgbG9hZGVkJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGRiU3RyaW5nKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICBjRnVuKGRiU3RyaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNGdW4oJ0RhdGFiYXNlIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNGdW4obmV3IEVycm9yKCdwZXJzaXN0ZW5jZUFkYXB0ZXIgbm90IGNvbmZpZ3VyZWQnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNhdmVEYXRhYmFzZSAtIEhhbmRsZXMgc2F2aW5nIHRvIGZpbGUgc3lzdGVtLCBsb2NhbCBzdG9yYWdlLCBvciBhZGFwdGVyIChpbmRleGVkZGIpXG4gICAgICogICAgVGhpcyBtZXRob2QgdXRpbGl6ZXMgbG9raSBjb25maWd1cmF0aW9uIG9wdGlvbnMgKGlmIHByb3ZpZGVkKSB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgKiAgICBwZXJzaXN0ZW5jZSBtZXRob2QgdG8gdXNlLCBvciBlbnZpcm9ubWVudCBkZXRlY3Rpb24gKGlmIGNvbmZpZ3VyYXRpb24gd2FzIG5vdCBwcm92aWRlZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG5vdCBjdXJyZW50bHkgdXNlZCAocmVtb3ZlIG9yIGFsbG93IG92ZXJyaWRlcz8pXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSAoT3B0aW9uYWwpIHVzZXIgc3VwcGxpZWQgYXN5bmMgY2FsbGJhY2sgLyBlcnJvciBoYW5kbGVyXG4gICAgICovXG4gICAgTG9raS5wcm90b3R5cGUuc2F2ZURhdGFiYXNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgY0Z1biA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8vIHRoZSBwZXJzaXN0ZW5jZUFkYXB0ZXIgc2hvdWxkIGJlIHByZXNlbnQgaWYgYWxsIGlzIG9rLCBidXQgY2hlY2sgdG8gYmUgc3VyZS5cbiAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlQWRhcHRlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgYWRhcHRlciBpcyByZXF1ZXN0aW5nIChhbmQgc3VwcG9ydHMpIGEgJ3JlZmVyZW5jZScgbW9kZSBleHBvcnRcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VBZGFwdGVyLm1vZGUgPT09IFwicmVmZXJlbmNlXCIgJiYgdHlwZW9mIHRoaXMucGVyc2lzdGVuY2VBZGFwdGVyLmV4cG9ydERhdGFiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBmaWxlbmFtZSBtYXkgc2VlbSByZWR1bmRhbnQgYnV0IGxvYWREYXRhYmFzZSB3aWxsIG5lZWQgdG8gZXhwZWN0IHRoaXMgc2FtZSBmaWxlbmFtZVxuICAgICAgICAgIHRoaXMucGVyc2lzdGVuY2VBZGFwdGVyLmV4cG9ydERhdGFiYXNlKHRoaXMuZmlsZW5hbWUsIHRoaXMsIGZ1bmN0aW9uIGV4cG9ydERhdGFiYXNlQ2FsbGJhY2soZXJyKSB7XG4gICAgICAgICAgICBzZWxmLmF1dG9zYXZlQ2xlYXJGbGFncygpO1xuICAgICAgICAgICAgY0Z1bihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHBhc3MgdGhlIHNlcmlhbGl6ZWQgZGF0YWJhc2UgdG8gYWRhcHRlclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlQWRhcHRlci5zYXZlRGF0YWJhc2UodGhpcy5maWxlbmFtZSwgc2VsZi5zZXJpYWxpemUoKSwgZnVuY3Rpb24gc2F2ZURhdGFiYXNlY2FsbGJhY2soZXJyKSB7XG4gICAgICAgICAgICBzZWxmLmF1dG9zYXZlQ2xlYXJGbGFncygpO1xuICAgICAgICAgICAgY0Z1bihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjRnVuKG5ldyBFcnJvcigncGVyc2lzdGVuY2VBZGFwdGVyIG5vdCBjb25maWd1cmVkJykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhbGlhc1xuICAgIExva2kucHJvdG90eXBlLnNhdmUgPSBMb2tpLnByb3RvdHlwZS5zYXZlRGF0YWJhc2U7XG5cbiAgICAvKipcbiAgICAgKiBhdXRvc2F2ZURpcnR5IC0gY2hlY2sgd2hldGhlciBhbnkgY29sbGVjdGlvbnMgYXJlICdkaXJ0eScgbWVhbmluZyB3ZSBuZWVkIHRvIHNhdmUgKGVudGlyZSkgZGF0YWJhc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgZGF0YWJhc2UgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCBhdXRvc2F2ZSwgZmFsc2UgaWYgbm90LlxuICAgICAqL1xuICAgIExva2kucHJvdG90eXBlLmF1dG9zYXZlRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmNvbGxlY3Rpb25zLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbnNbaWR4XS5kaXJ0eSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXV0b3NhdmVDbGVhckZsYWdzIC0gcmVzZXRzIGRpcnR5IGZsYWdzIG9uIGFsbCBjb2xsZWN0aW9ucy5cbiAgICAgKiAgICBDYWxsZWQgZnJvbSBzYXZlRGF0YWJhc2UoKSBhZnRlciBkYiBpcyBzYXZlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIExva2kucHJvdG90eXBlLmF1dG9zYXZlQ2xlYXJGbGFncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMuY29sbGVjdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25zW2lkeF0uZGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXV0b3NhdmVFbmFibGUgLSBiZWdpbiBhIGphdmFzY3JpcHQgaW50ZXJ2YWwgdG8gcGVyaW9kaWNhbGx5IHNhdmUgdGhlIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBub3QgY3VycmVudGx5IHVzZWQgKHJlbW92ZSBvciBhbGxvdyBvdmVycmlkZXM/KVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gKE9wdGlvbmFsKSB1c2VyIHN1cHBsaWVkIGFzeW5jIGNhbGxiYWNrXG4gICAgICovXG4gICAgTG9raS5wcm90b3R5cGUuYXV0b3NhdmVFbmFibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuYXV0b3NhdmUgPSB0cnVlO1xuXG4gICAgICB2YXIgZGVsYXkgPSA1MDAwLFxuICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiAodGhpcy5hdXRvc2F2ZUludGVydmFsKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5hdXRvc2F2ZUludGVydmFsICE9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gdGhpcy5hdXRvc2F2ZUludGVydmFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmF1dG9zYXZlSGFuZGxlID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gYXV0b3NhdmVIYW5kbGVJbnRlcnZhbCgpIHtcbiAgICAgICAgLy8gdXNlIG9mIGRpcnR5IGZsYWcgd2lsbCBuZWVkIHRvIGJlIGhpZXJhcmNoaWNhbCBzaW5jZSBtb2RzIGFyZSBkb25lIGF0IGNvbGxlY3Rpb24gbGV2ZWwgd2l0aCBubyB2aXNpYmlsaXR5IG9mICdkYidcbiAgICAgICAgLy8gc28gbmV4dCBzdGVwIHdpbGwgYmUgdG8gaW1wbGVtZW50IGNvbGxlY3Rpb24gbGV2ZWwgZGlydHkgZmxhZ3Mgc2V0IG9uIGluc2VydC91cGRhdGUvcmVtb3ZlXG4gICAgICAgIC8vIGFsb25nIHdpdGggbG9raSBsZXZlbCBpc2RpcnR5KCkgZnVuY3Rpb24gd2hpY2ggaXRlcmF0ZXMgYWxsIGNvbGxlY3Rpb25zIHRvIHNlZSBpZiBhbnkgYXJlIGRpcnR5XG5cbiAgICAgICAgaWYgKHNlbGYuYXV0b3NhdmVEaXJ0eSgpKSB7XG4gICAgICAgICAgc2VsZi5zYXZlRGF0YWJhc2UoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LCBkZWxheSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGF1dG9zYXZlRGlzYWJsZSAtIHN0b3AgdGhlIGF1dG9zYXZlIGludGVydmFsIHRpbWVyLlxuICAgICAqXG4gICAgICovXG4gICAgTG9raS5wcm90b3R5cGUuYXV0b3NhdmVEaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiAodGhpcy5hdXRvc2F2ZUhhbmRsZSkgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuYXV0b3NhdmVIYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9zYXZlSGFuZGxlKTtcbiAgICAgICAgdGhpcy5hdXRvc2F2ZUhhbmRsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmVzdWx0c2V0IGNsYXNzIGFsbG93aW5nIGNoYWluYWJsZSBxdWVyaWVzLiAgSW50ZW5kZWQgdG8gYmUgaW5zdGFuY2VkIGludGVybmFsbHkuXG4gICAgICogICAgQ29sbGVjdGlvbi5maW5kKCksIENvbGxlY3Rpb24ud2hlcmUoKSwgYW5kIENvbGxlY3Rpb24uY2hhaW4oKSBpbnN0YW50aWF0ZSB0aGlzLlxuICAgICAqXG4gICAgICogICAgRXhhbXBsZTpcbiAgICAgKiAgICBteWNvbGxlY3Rpb24uY2hhaW4oKVxuICAgICAqICAgICAgLmZpbmQoeyAnZG9vcnMnIDogNCB9KVxuICAgICAqICAgICAgLndoZXJlKGZ1bmN0aW9uKG9iaikgeyByZXR1cm4gb2JqLm5hbWUgPT09ICdUb3lvdGEnIH0pXG4gICAgICogICAgICAuZGF0YSgpO1xuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtDb2xsZWN0aW9ufSBjb2xsZWN0aW9uIC0gVGhlIGNvbGxlY3Rpb24gd2hpY2ggdGhpcyBSZXN1bHRzZXQgd2lsbCBxdWVyeSBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeU9iaiAtIE9wdGlvbmFsIG1vbmdvLXN0eWxlIHF1ZXJ5IG9iamVjdCB0byBpbml0aWFsaXplIHJlc3VsdHNldCB3aXRoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHF1ZXJ5RnVuYyAtIE9wdGlvbmFsIGphdmFzY3JpcHQgZmlsdGVyIGZ1bmN0aW9uIHRvIGluaXRpYWxpemUgcmVzdWx0c2V0IHdpdGguXG4gICAgICogQHBhcmFtIHtib29sfSBmaXJzdE9ubHkgLSBPcHRpb25hbCBib29sZWFuIHVzZWQgYnkgY29sbGVjdGlvbi5maW5kT25lKCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzdWx0c2V0KGNvbGxlY3Rpb24sIHF1ZXJ5T2JqLCBxdWVyeUZ1bmMsIGZpcnN0T25seSkge1xuICAgICAgLy8gcmV0YWluIHJlZmVyZW5jZSB0byBjb2xsZWN0aW9uIHdlIGFyZSBxdWVyeWluZyBhZ2FpbnN0XG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuXG4gICAgICAvLyBpZiBjaGFpbigpIGluc3RhbnRpYXRlcyB3aXRoIG51bGwgcXVlcnlPYmogYW5kIHF1ZXJ5RnVuYywgc28gd2Ugd2lsbCBrZWVwIGZsYWcgZm9yIGxhdGVyXG4gICAgICB0aGlzLnNlYXJjaElzQ2hhaW5lZCA9ICghcXVlcnlPYmogJiYgIXF1ZXJ5RnVuYyk7XG4gICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IFtdO1xuICAgICAgdGhpcy5maWx0ZXJJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICAvLyBpZiB1c2VyIHN1cHBsaWVkIGluaXRpYWwgcXVlcnlPYmogb3IgcXVlcnlGdW5jLCBhcHBseSBpdFxuICAgICAgaWYgKHR5cGVvZiAocXVlcnlPYmopICE9PSBcInVuZGVmaW5lZFwiICYmIHF1ZXJ5T2JqICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmQocXVlcnlPYmosIGZpcnN0T25seSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIChxdWVyeUZ1bmMpICE9PSBcInVuZGVmaW5lZFwiICYmIHF1ZXJ5RnVuYyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZShxdWVyeUZ1bmMpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHVuZmlsdGVyZWQgUmVzdWx0c2V0IGZvciBmdXR1cmUgZmlsdGVyaW5nXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b0pTT04oKSAtIE92ZXJyaWRlIG9mIHRvSlNPTiB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb3B5ID0gdGhpcy5jb3B5KCk7XG4gICAgICBjb3B5LmNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGxpbWl0KCkgLSBBbGxvd3MgeW91IHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHBhc3NlZCB0byBuZXh0IGNoYWluIG9wZXJhdGlvbi5cbiAgICAgKiAgICBBIHJlc3VsdHNldCBjb3B5KCkgaXMgbWFkZSB0byBhdm9pZCBhbHRlcmluZyBvcmlnaW5hbCByZXN1bHRzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludH0gcXR5IC0gVGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IFJldHVybnMgYSBjb3B5IG9mIHRoZSByZXN1bHRzZXQsIGxpbWl0ZWQgYnkgcXR5LCBmb3Igc3Vic2VxdWVudCBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgUmVzdWx0c2V0LnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIChxdHkpIHtcbiAgICAgIC8vIGlmIHRoaXMgaXMgY2hhaW5lZCByZXN1bHRzZXQgd2l0aCBubyBmaWx0ZXJzIGFwcGxpZWQsIHdlIG5lZWQgdG8gcG9wdWxhdGUgZmlsdGVyZWRyb3dzIGZpcnN0XG4gICAgICBpZiAodGhpcy5zZWFyY2hJc0NoYWluZWQgJiYgIXRoaXMuZmlsdGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRyb3dzID0gT2JqZWN0LmtleXModGhpcy5jb2xsZWN0aW9uLmRhdGEpLm1hcChOdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnNjb3B5ID0gdGhpcy5jb3B5KCk7XG5cbiAgICAgIHJzY29weS5maWx0ZXJlZHJvd3MgPSByc2NvcHkuZmlsdGVyZWRyb3dzLnNsaWNlKDAsIHF0eSk7XG5cbiAgICAgIHJldHVybiByc2NvcHk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG9mZnNldCgpIC0gVXNlZCBmb3Igc2tpcHBpbmcgJ3BvcycgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgcmVzdWx0c2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IHBvcyAtIE51bWJlciBvZiBkb2N1bWVudHMgdG8gc2tpcDsgYWxsIHByZWNlZGluZyBkb2N1bWVudHMgYXJlIGZpbHRlcmVkIG91dC5cbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0c2V0fSBSZXR1cm5zIGEgY29weSBvZiB0aGUgcmVzdWx0c2V0LCBjb250YWluaW5nIGRvY3Mgc3RhcnRpbmcgYXQgJ3BvcycgZm9yIHN1YnNlcXVlbnQgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgLy8gaWYgdGhpcyBpcyBjaGFpbmVkIHJlc3VsdHNldCB3aXRoIG5vIGZpbHRlcnMgYXBwbGllZCwgd2UgbmVlZCB0byBwb3B1bGF0ZSBmaWx0ZXJlZHJvd3MgZmlyc3RcbiAgICAgIGlmICh0aGlzLnNlYXJjaElzQ2hhaW5lZCAmJiAhdGhpcy5maWx0ZXJJbml0aWFsaXplZCAmJiB0aGlzLmZpbHRlcmVkcm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5maWx0ZXJlZHJvd3MgPSBPYmplY3Qua2V5cyh0aGlzLmNvbGxlY3Rpb24uZGF0YSkubWFwKE51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByc2NvcHkgPSB0aGlzLmNvcHkoKTtcblxuICAgICAgcnNjb3B5LmZpbHRlcmVkcm93cyA9IHJzY29weS5maWx0ZXJlZHJvd3Muc3BsaWNlKHBvcywgcnNjb3B5LmZpbHRlcmVkcm93cy5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gcnNjb3B5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb3B5KCkgLSBUbyBzdXBwb3J0IHJldXNlIG9mIHJlc3VsdHNldCBpbiBicmFuY2hlZCBxdWVyeSBzaXR1YXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Jlc3VsdHNldH0gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHJlc3VsdHNldCAoc2V0KSBidXQgdGhlIHVuZGVybHlpbmcgZG9jdW1lbnQgcmVmZXJlbmNlcyB3aWxsIGJlIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgUmVzdWx0c2V0KHRoaXMuY29sbGVjdGlvbiwgbnVsbCwgbnVsbCk7XG5cbiAgICAgIHJlc3VsdC5maWx0ZXJlZHJvd3MgPSB0aGlzLmZpbHRlcmVkcm93cy5zbGljZSgpO1xuICAgICAgcmVzdWx0LmZpbHRlckluaXRpYWxpemVkID0gdGhpcy5maWx0ZXJJbml0aWFsaXplZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gYWRkIGJyYW5jaCgpIGFzIGFsaWFzIG9mIGNvcHkoKVxuICAgIFJlc3VsdHNldC5wcm90b3R5cGUuYnJhbmNoID0gUmVzdWx0c2V0LnByb3RvdHlwZS5jb3B5O1xuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtKCkgLSBleGVjdXRlcyBhIG5hbWVkIGNvbGxlY3Rpb24gdHJhbnNmb3JtIG9yIHJhdyBhcnJheSBvZiB0cmFuc2Zvcm0gc3RlcHMgYWdhaW5zdCB0aGUgcmVzdWx0c2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybSB7c3RyaW5nfGFycmF5fSA6IChPcHRpb25hbCkgbmFtZSBvZiBjb2xsZWN0aW9uIHRyYW5zZm9ybSBvciByYXcgdHJhbnNmb3JtIGFycmF5XG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMge29iamVjdH0gOiAoT3B0aW9uYWwpIG9iamVjdCBwcm9wZXJ0eSBoYXNoIG9mIHBhcmFtZXRlcnMsIGlmIHRoZSB0cmFuc2Zvcm0gcmVxdWlyZXMgdGhlbS5cbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0c2V0fSA6IGVpdGhlciAodGhpcykgcmVzdWx0c2V0IG9yIGEgY2xvbmUgb2Ygb2YgdGhpcyByZXN1bHRzZXQgKGRlcGVuZGluZyBvbiBzdGVwcylcbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBpZHgsXG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHJzID0gdGhpcztcblxuICAgICAgLy8gaWYgdHJhbnNmb3JtIGlzIG5hbWUsIHRoZW4gZG8gbG9va3VwIGZpcnN0XG4gICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbi50cmFuc2Zvcm1zLmhhc093blByb3BlcnR5KHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLmNvbGxlY3Rpb24udHJhbnNmb3Jtc1t0cmFuc2Zvcm1dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciB0aGV5IHBhc3NlZCBpbiByYXcgdHJhbnNmb3JtIGFycmF5IG9yIHdlIGxvb2tlZCBpdCB1cCwgc28gcHJvY2Vzc1xuICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT09ICdvYmplY3QnIHx8ICFBcnJheS5pc0FycmF5KHRyYW5zZm9ybSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRyYW5zZm9ybVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwYXJhbWV0ZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cmFuc2Zvcm0gPSBVdGlscy5yZXNvbHZlVHJhbnNmb3JtUGFyYW1zKHRyYW5zZm9ybSwgcGFyYW1ldGVycyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgdHJhbnNmb3JtLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgc3RlcCA9IHRyYW5zZm9ybVtpZHhdO1xuXG4gICAgICAgIHN3aXRjaCAoc3RlcC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJmaW5kXCI6XG4gICAgICAgICAgcnMuZmluZChzdGVwLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIndoZXJlXCI6XG4gICAgICAgICAgcnMud2hlcmUoc3RlcC52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzaW1wbGVzb3J0XCI6XG4gICAgICAgICAgcnMuc2ltcGxlc29ydChzdGVwLnByb3BlcnR5LCBzdGVwLmRlc2MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29tcG91bmRzb3J0XCI6XG4gICAgICAgICAgcnMuY29tcG91bmRzb3J0KHN0ZXAudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic29ydFwiOlxuICAgICAgICAgIHJzLnNvcnQoc3RlcC52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW1pdFwiOlxuICAgICAgICAgIHJzID0gcnMubGltaXQoc3RlcC52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7IC8vIGxpbWl0IG1ha2VzIGNvcHkgc28gdXBkYXRlIHJlZmVyZW5jZVxuICAgICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgICAgcnMgPSBycy5vZmZzZXQoc3RlcC52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7IC8vIG9mZnNldCBtYWtlcyBjb3B5IHNvIHVwZGF0ZSByZWZlcmVuY2VcbiAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgIHJzID0gcnMubWFwKHN0ZXAudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZXFKb2luXCI6XG4gICAgICAgICAgcnMgPSBycy5lcUpvaW4oc3RlcC5qb2luRGF0YSwgc3RlcC5sZWZ0Sm9pbktleSwgc3RlcC5yaWdodEpvaW5LZXksIHN0ZXAubWFwRnVuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBmb2xsb3dpbmcgY2FzZXMgYnJlYWsgY2hhaW4gYnkgcmV0dXJuaW5nIGFycmF5IGRhdGEgc28gbWFrZSBhbnkgb2YgdGhlc2UgbGFzdCBpbiB0cmFuc2Zvcm0gc3RlcHNcbiAgICAgICAgY2FzZSBcIm1hcFJlZHVjZVwiOlxuICAgICAgICAgIHJzID0gcnMubWFwUmVkdWNlKHN0ZXAubWFwRnVuY3Rpb24sIHN0ZXAucmVkdWNlRnVuY3Rpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIGZvbGxvd2luZyBjYXNlcyB1cGRhdGUgZG9jdW1lbnRzIGluIGN1cnJlbnQgZmlsdGVyZWQgcmVzdWx0c2V0ICh1c2UgY2FyZWZ1bGx5KVxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgcnMudXBkYXRlKHN0ZXAudmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgcnMucmVtb3ZlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzb3J0KCkgLSBVc2VyIHN1cHBsaWVkIGNvbXBhcmUgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdHdvIGRvY3VtZW50cyB0byBjb21wYXJlLiAoY2hhaW5hYmxlKVxuICAgICAqICAgIEV4YW1wbGU6XG4gICAgICogICAgcnNsdC5zb3J0KGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcbiAgICAgKiAgICAgIGlmIChvYmoxLm5hbWUgPT09IG9iajIubmFtZSkgcmV0dXJuIDA7XG4gICAgICogICAgICBpZiAob2JqMS5uYW1lID4gb2JqMi5uYW1lKSByZXR1cm4gMTtcbiAgICAgKiAgICAgIGlmIChvYmoxLm5hbWUgPCBvYmoyLm5hbWUpIHJldHVybiAtMTtcbiAgICAgKiAgICB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmVmdW4gLSBBIGphdmFzY3JpcHQgY29tcGFyZSBmdW5jdGlvbiB1c2VkIGZvciBzb3J0aW5nLlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IFJlZmVyZW5jZSB0byB0aGlzIHJlc3VsdHNldCwgc29ydGVkLCBmb3IgZnV0dXJlIGNoYWluIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgUmVzdWx0c2V0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVmdW4pIHtcbiAgICAgIC8vIGlmIHRoaXMgaXMgY2hhaW5lZCByZXN1bHRzZXQgd2l0aCBubyBmaWx0ZXJzIGFwcGxpZWQsIGp1c3Qgd2UgbmVlZCB0byBwb3B1bGF0ZSBmaWx0ZXJlZHJvd3MgZmlyc3RcbiAgICAgIGlmICh0aGlzLnNlYXJjaElzQ2hhaW5lZCAmJiAhdGhpcy5maWx0ZXJJbml0aWFsaXplZCAmJiB0aGlzLmZpbHRlcmVkcm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5maWx0ZXJlZHJvd3MgPSBPYmplY3Qua2V5cyh0aGlzLmNvbGxlY3Rpb24uZGF0YSkubWFwKE51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciB3cmFwcGVkQ29tcGFyZXIgPVxuICAgICAgICAoZnVuY3Rpb24gKHVzZXJDb21wYXJlciwgcnNsdCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIG9iajEgPSByc2x0LmNvbGxlY3Rpb24uZGF0YVthXTtcbiAgICAgICAgICAgIHZhciBvYmoyID0gcnNsdC5jb2xsZWN0aW9uLmRhdGFbYl07XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VyQ29tcGFyZXIob2JqMSwgb2JqMik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoY29tcGFyZWZ1biwgdGhpcyk7XG5cbiAgICAgIHRoaXMuZmlsdGVyZWRyb3dzLnNvcnQod3JhcHBlZENvbXBhcmVyKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNpbXBsZXNvcnQoKSAtIFNpbXBsZXIsIGxvb3NlIGV2YWx1YXRpb24gZm9yIHVzZXIgdG8gc29ydCBiYXNlZCBvbiBhIHByb3BlcnR5IG5hbWUuIChjaGFpbmFibGUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcG5hbWUgLSBuYW1lIG9mIHByb3BlcnR5IHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sfSBpc2Rlc2MgLSAoT3B0aW9uYWwpIElmIHRydWUsIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gICAgICogQHJldHVybnMge1Jlc3VsdHNldH0gUmVmZXJlbmNlIHRvIHRoaXMgcmVzdWx0c2V0LCBzb3J0ZWQsIGZvciBmdXR1cmUgY2hhaW4gb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLnNpbXBsZXNvcnQgPSBmdW5jdGlvbiAocHJvcG5hbWUsIGlzZGVzYykge1xuICAgICAgLy8gaWYgdGhpcyBpcyBjaGFpbmVkIHJlc3VsdHNldCB3aXRoIG5vIGZpbHRlcnMgYXBwbGllZCwganVzdCB3ZSBuZWVkIHRvIHBvcHVsYXRlIGZpbHRlcmVkcm93cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuc2VhcmNoSXNDaGFpbmVkICYmICF0aGlzLmZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuZmlsdGVyZWRyb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IE9iamVjdC5rZXlzKHRoaXMuY29sbGVjdGlvbi5kYXRhKS5tYXAoTnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiAoaXNkZXNjKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXNkZXNjID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB3cmFwcGVkQ29tcGFyZXIgPVxuICAgICAgICAoZnVuY3Rpb24gKHByb3AsIGRlc2MsIHJzbHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBvYmoxID0gcnNsdC5jb2xsZWN0aW9uLmRhdGFbYV07XG4gICAgICAgICAgICB2YXIgb2JqMiA9IHJzbHQuY29sbGVjdGlvbi5kYXRhW2JdO1xuXG4gICAgICAgICAgICByZXR1cm4gc29ydEhlbHBlcihvYmoxW3Byb3BdLCBvYmoyW3Byb3BdLCBkZXNjKTtcblxuICAgICAgICAgIH07XG4gICAgICAgIH0pKHByb3BuYW1lLCBpc2Rlc2MsIHRoaXMpO1xuXG4gICAgICB0aGlzLmZpbHRlcmVkcm93cy5zb3J0KHdyYXBwZWRDb21wYXJlcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb21wb3VuZGV2YWwoKSAtIGhlbHBlciBtZXRob2QgZm9yIGNvbXBvdW5kc29ydCgpLCBwZXJmb3JtaW5nIGluZGl2aWR1YWwgb2JqZWN0IGNvbXBhcmlzb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwcm9wZXJ0aWVzIC0gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMsIGluIG9yZGVyLCBieSB3aGljaCB0byBldmFsdWF0ZSBzb3J0IG9yZGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iajEgLSBmaXJzdCBvYmplY3QgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmoyIC0gc2Vjb25kIG9iamVjdCB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2ludGVnZXJ9IDAsIC0xLCBvciAxIHRvIGRlc2lnbmF0ZSBpZiBpZGVudGljYWwgKHNvcnR3aXNlKSBvciB3aGljaCBzaG91bGQgYmUgZmlyc3RcbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLmNvbXBvdW5kZXZhbCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBvYmoxLCBvYmoyKSB7XG4gICAgICB2YXIgcHJvcGVydHlDb3VudCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBpZiAocHJvcGVydHlDb3VudCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGwgdG8gY29tcG91bmRldmFsLCBuZWVkIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVjb2RlIHByb3BlcnR5LCB3aGV0aGVyIGp1c3QgYSBzdHJpbmcgcHJvcGVydHkgbmFtZSBvciBzdWJhcnJheSBbcHJvcG5hbWUsIGlzZGVzY11cbiAgICAgIHZhciBpc2Rlc2MgPSBmYWxzZTtcbiAgICAgIHZhciBmaXJzdFByb3AgPSBwcm9wZXJ0aWVzWzBdO1xuICAgICAgaWYgKHR5cGVvZiAoZmlyc3RQcm9wKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3RQcm9wKSkge1xuICAgICAgICAgIGlzZGVzYyA9IGZpcnN0UHJvcFsxXTtcbiAgICAgICAgICBmaXJzdFByb3AgPSBmaXJzdFByb3BbMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iajFbZmlyc3RQcm9wXSA9PT0gb2JqMltmaXJzdFByb3BdKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG91bmRldmFsKHByb3BlcnRpZXMuc2xpY2UoMSksIG9iajEsIG9iajIsIGlzZGVzYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvcnRIZWxwZXIob2JqMVtmaXJzdFByb3BdLCBvYmoyW2ZpcnN0UHJvcF0sIGlzZGVzYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGNvbXBvdW5kc29ydCgpIC0gQWxsb3dzIHNvcnRpbmcgYSByZXN1bHRzZXQgYmFzZWQgb24gbXVsdGlwbGUgY29sdW1ucy5cbiAgICAgKiAgICBFeGFtcGxlIDogcnMuY29tcG91bmRzb3J0KFsnYWdlJywgJ25hbWUnXSk7IHRvIHNvcnQgYnkgYWdlIGFuZCB0aGVuIG5hbWUgKGJvdGggYXNjZW5kaW5nKVxuICAgICAqICAgIEV4YW1wbGUgOiBycy5jb21wb3VuZHNvcnQoWydhZ2UnLCBbJ25hbWUnLCB0cnVlXSk7IHRvIHNvcnQgYnkgYWdlIChhc2NlbmRpbmcpIGFuZCB0aGVuIGJ5IG5hbWUgKGRlc2NlbmRpbmcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBwcm9wZXJ0aWVzIC0gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgb3Igc3ViYXJyYXkgb2YgW3Byb3BlcnR5bmFtZSwgaXNkZXNjXSB1c2VkIGV2YWx1YXRlIHNvcnQgb3JkZXJcbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0c2V0fSBSZWZlcmVuY2UgdG8gdGhpcyByZXN1bHRzZXQsIHNvcnRlZCwgZm9yIGZ1dHVyZSBjaGFpbiBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUuY29tcG91bmRzb3J0ID0gZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBjaGFpbmVkIHJlc3VsdHNldCB3aXRoIG5vIGZpbHRlcnMgYXBwbGllZCwganVzdCB3ZSBuZWVkIHRvIHBvcHVsYXRlIGZpbHRlcmVkcm93cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuc2VhcmNoSXNDaGFpbmVkICYmICF0aGlzLmZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuZmlsdGVyZWRyb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IE9iamVjdC5rZXlzKHRoaXMuY29sbGVjdGlvbi5kYXRhKS5tYXAoTnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdyYXBwZWRDb21wYXJlciA9XG4gICAgICAgIChmdW5jdGlvbiAocHJvcHMsIHJzbHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBvYmoxID0gcnNsdC5jb2xsZWN0aW9uLmRhdGFbYV07XG4gICAgICAgICAgICB2YXIgb2JqMiA9IHJzbHQuY29sbGVjdGlvbi5kYXRhW2JdO1xuXG4gICAgICAgICAgICByZXR1cm4gcnNsdC5jb21wb3VuZGV2YWwocHJvcHMsIG9iajEsIG9iajIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHByb3BlcnRpZXMsIHRoaXMpO1xuXG4gICAgICB0aGlzLmZpbHRlcmVkcm93cy5zb3J0KHdyYXBwZWRDb21wYXJlcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVSYW5nZSgpIC0gQmluYXJ5IFNlYXJjaCB1dGlsaXR5IG1ldGhvZCB0byBmaW5kIHJhbmdlL3NlZ21lbnQgb2YgdmFsdWVzIG1hdGNoaW5nIGNyaXRlcmlhLlxuICAgICAqICAgIHRoaXMgaXMgdXNlZCBmb3IgY29sbGVjdGlvbi5maW5kKCkgYW5kIGZpcnN0IGZpbmQgZmlsdGVyIG9mIHJlc3VsdHNldC9keW52aWV3XG4gICAgICogICAgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gZ2V0KCkgYmluYXJ5IHNlYXJjaCBpbiB0aGF0IGdldCgpIGhvbmVzIGluIG9uIDEgdmFsdWUsXG4gICAgICogICAgYnV0IHdlIGhhdmUgdG8gaG9uZSBpbiBvbiBtYW55IChyYW5nZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3AgLSBvcGVyYXRpb24sIHN1Y2ggYXMgJGVxXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgLSBuYW1lIG9mIHByb3BlcnR5IHRvIGNhbGN1bGF0ZSByYW5nZSBmb3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsIC0gdmFsdWUgdG8gdXNlIGZvciByYW5nZSBjYWxjdWxhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IFtzdGFydCwgZW5kXSBpbmRleCBhcnJheSBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLmNhbGN1bGF0ZVJhbmdlID0gZnVuY3Rpb24gKG9wLCBwcm9wLCB2YWwpIHtcbiAgICAgIHZhciByY2QgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuY29sbGVjdGlvbi5iaW5hcnlJbmRpY2VzW3Byb3BdLnZhbHVlcztcbiAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgdmFyIG1heCA9IGluZGV4Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbWlkID0gbnVsbDtcbiAgICAgIHZhciBsYm91bmQgPSAwO1xuICAgICAgdmFyIHVib3VuZCA9IGluZGV4Lmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIHdoZW4gbm8gZG9jdW1lbnRzIGFyZSBpbiBjb2xsZWN0aW9uLCByZXR1cm4gZW1wdHkgcmFuZ2UgY29uZGl0aW9uXG4gICAgICBpZiAocmNkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIC0xXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pblZhbCA9IHJjZFtpbmRleFttaW5dXVtwcm9wXTtcbiAgICAgIHZhciBtYXhWYWwgPSByY2RbaW5kZXhbbWF4XV1bcHJvcF07XG5cbiAgICAgIC8vIGlmIHZhbHVlIGZhbGxzIG91dHNpZGUgb2Ygb3VyIHJhbmdlIHJldHVybiBbMCwgLTFdIHRvIGRlc2lnbmF0ZSBubyByZXN1bHRzXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlICckZXEnOlxuICAgICAgICBpZiAobHRIZWxwZXIodmFsLCBtaW5WYWwpIHx8IGd0SGVscGVyKHZhbCwgbWF4VmFsKSkge1xuICAgICAgICAgIHJldHVybiBbMCwgLTFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJGR0ZXEnOlxuICAgICAgICBpZiAobHRIZWxwZXIodmFsLCBtaW5WYWwpIHx8IGd0SGVscGVyKHZhbCwgbWF4VmFsKSkge1xuICAgICAgICAgIHJldHVybiBbMCwgLTFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJGd0JzpcbiAgICAgICAgaWYgKGd0SGVscGVyKHZhbCwgbWF4VmFsLCB0cnVlKSkge1xuICAgICAgICAgIHJldHVybiBbMCwgLTFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJGd0ZSc6XG4gICAgICAgIGlmIChndEhlbHBlcih2YWwsIG1heFZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gWzAsIC0xXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyRsdCc6XG4gICAgICAgIGlmIChsdEhlbHBlcih2YWwsIG1pblZhbCwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gWzAsIC0xXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobHRIZWxwZXIobWF4VmFsLCB2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIFswLCByY2QubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICckbHRlJzpcbiAgICAgICAgaWYgKGx0SGVscGVyKHZhbCwgbWluVmFsKSkge1xuICAgICAgICAgIHJldHVybiBbMCwgLTFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsdEhlbHBlcihtYXhWYWwsIHZhbCwgdHJ1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gWzAsIHJjZC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gaG9uZSBpbiBvbiBzdGFydCBwb3NpdGlvbiBvZiB2YWx1ZVxuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBNYXRoLmZsb29yKChtaW4gKyBtYXgpIC8gMik7XG5cbiAgICAgICAgaWYgKGx0SGVscGVyKHJjZFtpbmRleFttaWRdXVtwcm9wXSwgdmFsKSkge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxib3VuZCA9IG1pbjtcblxuICAgICAgbWluID0gMDtcbiAgICAgIG1heCA9IGluZGV4Lmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIGhvbmUgaW4gb24gZW5kIHBvc2l0aW9uIG9mIHZhbHVlXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IE1hdGguZmxvb3IoKG1pbiArIG1heCkgLyAyKTtcblxuICAgICAgICBpZiAobHRIZWxwZXIodmFsLCByY2RbaW5kZXhbbWlkXV1bcHJvcF0pKSB7XG4gICAgICAgICAgbWF4ID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdWJvdW5kID0gbWF4O1xuXG4gICAgICB2YXIgbHZhbCA9IHJjZFtpbmRleFtsYm91bmRdXVtwcm9wXTtcbiAgICAgIHZhciB1dmFsID0gcmNkW2luZGV4W3Vib3VuZF1dW3Byb3BdO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlICckZXEnOlxuICAgICAgICBpZiAobHZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgcmV0dXJuIFswLCAtMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV2YWwgIT09IHZhbCkge1xuICAgICAgICAgIHVib3VuZC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsYm91bmQsIHVib3VuZF07XG4gICAgICBjYXNlICckZHRlcSc6XG4gICAgICAgIGlmIChsdmFsID4gdmFsIHx8IGx2YWwgPCB2YWwpIHtcbiAgICAgICAgICByZXR1cm4gWzAsIC0xXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXZhbCA+IHZhbCB8fCB1dmFsIDwgdmFsKSB7XG4gICAgICAgICAgdWJvdW5kLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xib3VuZCwgdWJvdW5kXTtcblxuXG4gICAgICBjYXNlICckZ3QnOlxuICAgICAgICBpZiAobHRIZWxwZXIodXZhbCwgdmFsLCB0cnVlKSkge1xuICAgICAgICAgIHJldHVybiBbMCwgLTFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt1Ym91bmQsIHJjZC5sZW5ndGggLSAxXTtcblxuICAgICAgY2FzZSAnJGd0ZSc6XG4gICAgICAgIGlmIChsdEhlbHBlcihsdmFsLCB2YWwpKSB7XG4gICAgICAgICAgcmV0dXJuIFswLCAtMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2xib3VuZCwgcmNkLmxlbmd0aCAtIDFdO1xuXG4gICAgICBjYXNlICckbHQnOlxuICAgICAgICBpZiAobGJvdW5kID09PSAwICYmIGx0SGVscGVyKGx2YWwsIHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgbGJvdW5kIC0gMV07XG5cbiAgICAgIGNhc2UgJyRsdGUnOlxuICAgICAgICBpZiAodXZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgdWJvdW5kLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodWJvdW5kID09PSAwICYmIGx0SGVscGVyKHV2YWwsIHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgdWJvdW5kXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFswLCByY2QubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZpbmRPcigpIC0gb3ZlcnNlZSB0aGUgb3BlcmF0aW9uIG9mIE9SJ2VkIHF1ZXJ5IGV4cHJlc3Npb25zLlxuICAgICAqICAgIE9SJ2VkIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBydW5zIGVhY2ggZXhwcmVzc2lvbiBpbmRpdmlkdWFsbHkgYWdhaW5zdCB0aGUgZnVsbCBjb2xsZWN0aW9uLFxuICAgICAqICAgIGFuZCBmaW5hbGx5IGRvZXMgYSBzZXQgT1Igb24gZWFjaCBleHByZXNzaW9uJ3MgcmVzdWx0cy5cbiAgICAgKiAgICBFYWNoIGV2YWx1YXRpb24gY2FuIHV0aWxpemUgYSBiaW5hcnkgaW5kZXggdG8gcHJldmVudCBtdWx0aXBsZSBsaW5lYXIgYXJyYXkgc2NhbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBleHByZXNzaW9uQXJyYXkgLSBhcnJheSBvZiBleHByZXNzaW9uc1xuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IHRoaXMgcmVzdWx0c2V0IGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLmZpbmRPciA9IGZ1bmN0aW9uIChleHByZXNzaW9uQXJyYXkpIHtcbiAgICAgIHZhciBmcmkgPSAwLFxuICAgICAgICBlaSA9IDAsXG4gICAgICAgIGZyID0gbnVsbCxcbiAgICAgICAgZG9jc2V0ID0gW10sXG4gICAgICAgIGV4cFJlc3VsdHNldCA9IG51bGw7XG5cbiAgICAgIC8vIGlmIGZpbHRlciBpcyBhbHJlYWR5IGluaXRpYWxpemVkIHdlIG5lZWQgdG8gcXVlcnkgYWdhaW5zdCBvbmx5IHRob3NlIGl0ZW1zIGFscmVhZHkgaW4gZmlsdGVyLlxuICAgICAgLy8gVGhpcyBtZWFucyBubyBpbmRleCB1dGlsaXphdGlvbiBmb3IgZmllbGRzLCBzbyBob3BlZnVsbHkgaXRzIGZpbHRlcmVkIHRvIGEgc21hbGxpc2ggZmlsdGVyZWRyb3dzLlxuICAgICAgaWYgKHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgZG9jc2V0ID0gW107XG5cbiAgICAgICAgZm9yIChlaSA9IDA7IGVpIDwgZXhwcmVzc2lvbkFycmF5Lmxlbmd0aDsgZWkrKykge1xuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gYnJhbmNoIGV4aXN0aW5nIHF1ZXJ5IHRvIHJ1biBlYWNoIGZpbHRlciBzZXBhcmF0ZWx5IGFuZCBjb21iaW5lIHJlc3VsdHNcbiAgICAgICAgICBleHBSZXN1bHRzZXQgPSB0aGlzLmJyYW5jaCgpO1xuICAgICAgICAgIGV4cFJlc3VsdHNldC5maW5kKGV4cHJlc3Npb25BcnJheVtlaV0pO1xuICAgICAgICAgIGV4cFJlc3VsdHNldC5kYXRhKCk7XG5cbiAgICAgICAgICAvLyBhZGQgYW55IGRvY3VtZW50ICdoaXRzJ1xuICAgICAgICAgIGZyID0gZXhwUmVzdWx0c2V0LmZpbHRlcmVkcm93cztcbiAgICAgICAgICBmb3IgKGZyaSA9IDA7IGZyaSA8IGZyLmxlbmd0aDsgZnJpKyspIHtcbiAgICAgICAgICAgIGlmIChkb2NzZXQuaW5kZXhPZihmcltmcmldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZG9jc2V0LnB1c2goZnJbZnJpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWx0ZXJlZHJvd3MgPSBkb2NzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGVpID0gMDsgZWkgPCBleHByZXNzaW9uQXJyYXkubGVuZ3RoOyBlaSsrKSB7XG4gICAgICAgICAgLy8gd2Ugd2lsbCBsZXQgZWFjaCBmaWx0ZXIgcnVuIGluZGVwZW5kZW50bHkgYWdhaW5zdCBmdWxsIGNvbGxlY3Rpb24gYW5kIG1hc2h1cCBkb2N1bWVudCBoaXRzIGxhdGVyXG4gICAgICAgICAgZXhwUmVzdWx0c2V0ID0gdGhpcy5jb2xsZWN0aW9uLmNoYWluKCk7XG4gICAgICAgICAgZXhwUmVzdWx0c2V0LmZpbmQoZXhwcmVzc2lvbkFycmF5W2VpXSk7XG4gICAgICAgICAgZXhwUmVzdWx0c2V0LmRhdGEoKTtcblxuICAgICAgICAgIC8vIGFkZCBhbnkgZG9jdW1lbnQgJ2hpdHMnXG4gICAgICAgICAgZnIgPSBleHBSZXN1bHRzZXQuZmlsdGVyZWRyb3dzO1xuICAgICAgICAgIGZvciAoZnJpID0gMDsgZnJpIDwgZnIubGVuZ3RoOyBmcmkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWRyb3dzLmluZGV4T2YoZnJbZnJpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRyb3dzLnB1c2goZnJbZnJpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBwb3NzaWJseSBzb3J0IGluZGV4ZXNcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBmaW5kQW5kKCkgLSBvdmVyc2VlIHRoZSBvcGVyYXRpb24gb2YgQU5EJ2VkIHF1ZXJ5IGV4cHJlc3Npb25zLlxuICAgICAqICAgIEFORCdlZCBleHByZXNzaW9uIGV2YWx1YXRpb24gcnVucyBlYWNoIGV4cHJlc3Npb24gcHJvZ3Jlc3NpdmVseSBhZ2FpbnN0IHRoZSBmdWxsIGNvbGxlY3Rpb24sXG4gICAgICogICAgaW50ZXJuYWxseSB1dGlsaXppbmcgZXhpc3RpbmcgY2hhaW5lZCByZXN1bHRzZXQgZnVuY3Rpb25hbGl0eS5cbiAgICAgKiAgICBPbmx5IHRoZSBmaXJzdCBmaWx0ZXIgY2FuIHV0aWxpemUgYSBiaW5hcnkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBleHByZXNzaW9uQXJyYXkgLSBhcnJheSBvZiBleHByZXNzaW9uc1xuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IHRoaXMgcmVzdWx0c2V0IGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLmZpbmRBbmQgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbkFycmF5KSB7XG4gICAgICAvLyB3ZSBoYXZlIGFscmVhZHkgaW1wbGVtZW50aW5nIG1ldGhvZCBjaGFpbmluZyBpbiB0aGlzIChvdXIgUmVzdWx0c2V0IGNsYXNzKVxuICAgICAgLy8gc28gbGV0cyBqdXN0IHByb2dyZXNzaXZlbHkgYXBwbHkgdXNlciBzdXBwbGllZCBhbmQgZmlsdGVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5maW5kKGV4cHJlc3Npb25BcnJheVtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBkb3RTdWJTY2FuIC0gaGVscGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGRvdCBub3RhdGlvbiBxdWVyaWVzLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUuZG90U3ViU2NhbiA9IGZ1bmN0aW9uIChyb290LCBwcm9wZXJ0eSwgZnVuLCB2YWx1ZSkge1xuICAgICAgdmFyIGFycmF5UmVmID0gbnVsbDtcbiAgICAgIHZhciBwYXRoSW5kZXgsIHN1YkluZGV4O1xuICAgICAgdmFyIHBhdGhzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBmb3IgKHBhdGhJbmRleCA9IDA7IHBhdGhJbmRleCA8IHBhdGhzLmxlbmd0aDsgcGF0aEluZGV4KyspIHtcbiAgICAgICAgcGF0aCA9IHBhdGhzW3BhdGhJbmRleF07XG5cbiAgICAgICAgLy8gZm9yZWFjaCBhbHJlYWR5IGRldGVjdGVkIHBhcmVudCB3YXMgYXJyYXkgc28gdGhpcyBtdXN0IGJlIHdoZXJlIHdlIGl0ZXJhdGVcbiAgICAgICAgaWYgKGFycmF5UmVmKSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSBhbGwgc3ViLWFycmF5IGl0ZW1zIHRvIHNlZSBpZiBhbnkgeWllbGQgaGl0c1xuICAgICAgICAgIGZvciAoc3ViSW5kZXggPSAwOyBzdWJJbmRleCA8IGFycmF5UmVmLmxlbmd0aDsgc3ViSW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKGZ1bihhcnJheVJlZltzdWJJbmRleF1bcGF0aF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWxzZSBub3QgeWV0IGRldGVybWluZWQgaWYgc3ViYXJyYXkgc2NhbiBpcyBpbnZvbHZlZFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgZG90IG5vdGF0aW9uIGlzIGludmFsaWQgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LCB0aGVuIGlnbm9yZSB0aGlzIGRvY3VtZW50XG4gICAgICAgICAgaWYgKHR5cGVvZiByb290ID09PSAndW5kZWZpbmVkJyB8fCByb290ID09PSBudWxsIHx8ICFyb290Lmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSByb290W3BhdGhdO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb3QpKSB7XG4gICAgICAgICAgICBhcnJheVJlZiA9IHJvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1hZGUgaXQgdGhpcyBmYXIgc28gbXVzdCBiZSBkb3Qgbm90YXRpb24gb24gbm9uLWFycmF5IHByb3BlcnR5XG4gICAgICByZXR1cm4gZnVuKHJvb3QsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZmluZCgpIC0gVXNlZCBmb3IgcXVlcnlpbmcgdmlhIGEgbW9uZ28tc3R5bGUgcXVlcnkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJ5IC0gQSBtb25nby1zdHlsZSBxdWVyeSBvYmplY3QgdXNlZCBmb3IgZmlsdGVyaW5nIGN1cnJlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0T25seSAtIChPcHRpb25hbCkgVXNlZCBieSBjb2xsZWN0aW9uLmZpbmRPbmUoKVxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IHRoaXMgcmVzdWx0c2V0IGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAocXVlcnksIGZpcnN0T25seSkge1xuICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbi5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zZWFyY2hJc0NoYWluZWQpIHtcbiAgICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IFtdO1xuICAgICAgICAgIHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuXG4gICAgICB2YXIgcXVlcnlPYmplY3QgPSBxdWVyeSB8fCAnZ2V0QWxsJyxcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgcCxcbiAgICAgICAga2V5LFxuICAgICAgICBzZWFyY2hCeUluZGV4ID0gZmFsc2UsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBpbmRleCA9IG51bGwsXG4gICAgICAgIC8vIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgICAgICAgZnVuLFxuICAgICAgICAvLyBjb2xsZWN0aW9uIGRhdGFcbiAgICAgICAgdCxcbiAgICAgICAgLy8gY29sbGVjdGlvbiBkYXRhIGxlbmd0aFxuICAgICAgICBpLFxuICAgICAgICBlbXB0eVFPID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgdGhpcyB3YXMgbm90ZSBpbnZva2VkIHZpYSBmaW5kT25lKClcbiAgICAgIGZpcnN0T25seSA9IGZpcnN0T25seSB8fCBmYWxzZTtcblxuICAgICAgLy8gaWYgcGFzc2VkIGluIGVtcHR5IG9iamVjdCB7fSwgaW50ZXJwcmV0IGFzICdnZXRBbGwnXG4gICAgICAvLyBtb3JlIHBlcmZvcm1hbnQgdGhhbiBvYmplY3Qua2V5c1xuICAgICAgZm9yIChwIGluIHF1ZXJ5T2JqZWN0KSB7XG4gICAgICAgIGVtcHR5UU8gPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZW1wdHlRTykge1xuICAgICAgICBxdWVyeU9iamVjdCA9ICdnZXRBbGwnO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBubyBmaWx0ZXJzIGlmIHRoZXkgd2FudCBhbGxcbiAgICAgIGlmIChxdWVyeU9iamVjdCA9PT0gJ2dldEFsbCcpIHtcbiAgICAgICAgLy8gY2hhaW5lZCBxdWVyaWVzIGNhbiBqdXN0IGRvIGNvbGwuY2hhaW4oKS5kYXRhKCkgYnV0IGxldCdzXG4gICAgICAgIC8vIGJlIHZlcnNhdGlsZSBhbmQgYWxsb3cgdGhpcyBhbHNvIGNvbGwuY2hhaW4oKS5maW5kKCkuZGF0YSgpXG4gICAgICAgIGlmICh0aGlzLnNlYXJjaElzQ2hhaW5lZCkge1xuICAgICAgICAgIHRoaXMuZmlsdGVyZWRyb3dzID0gT2JqZWN0LmtleXModGhpcy5jb2xsZWN0aW9uLmRhdGEpLm1hcChOdW1iZXIpO1xuICAgICAgICAgIHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCBjaGFpbmVkLCBzbyByZXR1cm4gY29sbGVjdGlvbiBkYXRhIGFycmF5XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGF0YS5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHVzZXIgaXMgZGVlcCBxdWVyeWluZyB0aGUgb2JqZWN0IHN1Y2ggYXMgZmluZCgnbmFtZS5maXJzdCc6ICdvZGluJylcbiAgICAgIHZhciB1c2luZ0RvdE5vdGF0aW9uID0gZmFsc2U7XG5cbiAgICAgIGZvciAocCBpbiBxdWVyeU9iamVjdCkge1xuICAgICAgICBpZiAocXVlcnlPYmplY3QuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHA7XG5cbiAgICAgICAgICAvLyBpbmplY3RpbmcgJGFuZCBhbmQgJG9yIGV4cHJlc3Npb24gdHJlZSBldmFsdWF0aW9uIGhlcmUuXG4gICAgICAgICAgaWYgKHAgPT09ICckYW5kJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoSXNDaGFpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmluZEFuZChxdWVyeU9iamVjdFtwXSk7XG5cbiAgICAgICAgICAgICAgLy8gZm9yIGNoYWluZWQgZmluZCB3aXRoIGZpcnN0b25seSxcbiAgICAgICAgICAgICAgaWYgKGZpcnN0T25seSAmJiB0aGlzLmZpbHRlcmVkcm93cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZHJvd3MgPSB0aGlzLmZpbHRlcmVkcm93cy5zbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb3VyICRhbmQgb3BlcmF0aW9uIGludGVybmFsbHkgY2hhaW5zIGZpbHRlcnNcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb2xsZWN0aW9uLmNoYWluKCkuZmluZEFuZChxdWVyeU9iamVjdFtwXSkuZGF0YSgpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRoaXMgd2FzIGNvbGwuZmluZE9uZSgpIHJldHVybiBmaXJzdCBvYmplY3Qgb3IgZW1wdHkgYXJyYXkgaWYgbnVsbFxuICAgICAgICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIGludm9rZWQgZnJvbSBhIGNvbnN0cnVjdG9yIHdlIGNhbid0IHJldHVybiBudWxsLCBzbyB3ZSB3aWxsXG4gICAgICAgICAgICAgIC8vIG1ha2UgbnVsbCBpbiBjb2xsLmZpbmRPbmUoKTtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0T25seSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbm90IGZpcnN0IG9ubHkgcmV0dXJuIGFsbCByZXN1bHRzXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgPT09ICckb3InKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2hJc0NoYWluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5kT3IocXVlcnlPYmplY3RbcF0pO1xuXG4gICAgICAgICAgICAgIGlmIChmaXJzdE9ubHkgJiYgdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRyb3dzID0gdGhpcy5maWx0ZXJlZHJvd3Muc2xpY2UoMCwgMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNhbGwgb3V0IHRvIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgJG9yIHJlc3VsdHNcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb2xsZWN0aW9uLmNoYWluKCkuZmluZE9yKHF1ZXJ5T2JqZWN0W3BdKS5kYXRhKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGZpcnN0T25seSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbm90IGZpcnN0IG9ubHkgcmV0dXJuIGFsbCByZXN1bHRzXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAuaW5kZXhPZignLicpICE9IC0xKSB7XG4gICAgICAgICAgICB1c2luZ0RvdE5vdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzZWUgaWYgcXVlcnkgb2JqZWN0IGlzIGluIHNob3J0aGFuZCBtb2RlIChhc3N1bWluZyBlcSBvcGVyYXRvcilcbiAgICAgICAgICBpZiAocXVlcnlPYmplY3RbcF0gPT09IG51bGwgfHwgKHR5cGVvZiBxdWVyeU9iamVjdFtwXSAhPT0gJ29iamVjdCcgfHwgcXVlcnlPYmplY3RbcF0gaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgb3BlcmF0b3IgPSAnJGVxJztcbiAgICAgICAgICAgIHZhbHVlID0gcXVlcnlPYmplY3RbcF07XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcXVlcnlPYmplY3RbcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBxdWVyeU9iamVjdFtwXSkge1xuICAgICAgICAgICAgICBpZiAocXVlcnlPYmplY3RbcF0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcXVlcnlPYmplY3RbcF1ba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvIG5vdCBrbm93IHdoYXQgeW91IHdhbnQgdG8gZG8uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZvciByZWdleCBvcHMsIHByZWNvbXBpbGVcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJyRyZWdleCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb2xsZWN0aW9uLmRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbmRleCBleGlzdHMgZm9yIHRoZSBwcm9wZXJ0eSBiZWluZyBxdWVyaWVkIGFnYWluc3QsIHVzZSBpdFxuICAgICAgLy8gZm9yIG5vdyBvbmx5IGVuYWJsaW5nIGZvciBub24tY2hhaW5lZCBxdWVyeSAod2hvJ3Mgc2V0IG9mIGRvY3MgbWF0Y2hlcyBpbmRleClcbiAgICAgIC8vIG9yIGNoYWluZWQgcXVlcmllcyB3aGVyZSBpdCBpcyB0aGUgZmlyc3QgZmlsdGVyIGFwcGxpZWQgYW5kIHByb3AgaXMgaW5kZXhlZFxuICAgICAgaWYgKCghdGhpcy5zZWFyY2hJc0NoYWluZWQgfHwgKHRoaXMuc2VhcmNoSXNDaGFpbmVkICYmICF0aGlzLmZpbHRlckluaXRpYWxpemVkKSkgJiZcbiAgICAgICAgaW5kZXhlZE9wc0xpc3QuaW5kZXhPZihvcGVyYXRvcikgIT09IC0xICYmIHRoaXMuY29sbGVjdGlvbi5iaW5hcnlJbmRpY2VzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIG91ciBsYXp5IGluZGV4IHJlYnVpbGRpbmcgd2lsbCB0YWtlIHBsYWNlXG4gICAgICAgIC8vIGJhc2ljYWxseSB3ZSB3aWxsIGxlYXZlIGFsbCBpbmRleGVzIGRpcnR5IHVudGlsIHdlIG5lZWQgdGhlbVxuICAgICAgICAvLyBzbyBoZXJlIHdlIHdpbGwgcmVidWlsZCBvbmx5IHRoZSBpbmRleCB0aWVkIHRvIHRoaXMgcHJvcGVydHlcbiAgICAgICAgLy8gZW5zdXJlSW5kZXgoKSB3aWxsIG9ubHkgcmVidWlsZCBpZiBmbGFnZ2VkIGFzIGRpcnR5IHNpbmNlIHdlIGFyZSBub3QgcGFzc2luZyBmb3JjZT10cnVlIHBhcmFtXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbi5lbnN1cmVJbmRleChwcm9wZXJ0eSk7XG5cbiAgICAgICAgc2VhcmNoQnlJbmRleCA9IHRydWU7XG4gICAgICAgIGluZGV4ID0gdGhpcy5jb2xsZWN0aW9uLmJpbmFyeUluZGljZXNbcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgZnVuID0gb3BlcmF0b3JzW29wZXJhdG9yXTtcblxuICAgICAgLy8gUXVlcnkgZXhlY3V0ZWQgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIDpcbiAgICAgIC8vICAgIC0gd2hldGhlciBpdCBpcyBjaGFpbmVkIG9yIG5vdFxuICAgICAgLy8gICAgLSB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBiZWluZyBxdWVyaWVkIGhhcyBhbiBpbmRleCBkZWZpbmVkXG4gICAgICAvLyAgICAtIGlmIGNoYWluZWQsIHdlIGhhbmRsZSBmaXJzdCBwYXNzIGRpZmZlcmVudGx5IGZvciBpbml0aWFsIGZpbHRlcmVkcm93c1tdIHBvcHVsYXRpb25cbiAgICAgIC8vXG4gICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgZWFjaCBjYXNlIGhhcyBpdHMgb3duIGlmIGJsb2NrIHRvIG1pbmltaXplIGluLWxvb3AgY2FsY3VsYXRpb25zXG5cbiAgICAgIC8vIElmIG5vdCBhIGNoYWluZWQgcXVlcnksIGJ5cGFzcyBmaWx0ZXJlZHJvd3MgYW5kIHdvcmsgZGlyZWN0bHkgYWdhaW5zdCBkYXRhXG4gICAgICBpZiAoIXRoaXMuc2VhcmNoSXNDaGFpbmVkKSB7XG4gICAgICAgIGlmICghc2VhcmNoQnlJbmRleCkge1xuICAgICAgICAgIHQgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YTtcbiAgICAgICAgICBpID0gdC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoZmlyc3RPbmx5KSB7XG4gICAgICAgICAgICBpZiAodXNpbmdEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG90U3ViU2Nhbih0W2ldLCBwcm9wZXJ0eSwgZnVuLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAodFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bih0W2ldW3Byb3BlcnR5XSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKHRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHVzaW5nIGRvdCBub3RhdGlvbiB0aGVuIHRyZWF0IHByb3BlcnR5IGFzIGtleXBhdGggc3VjaCBhcyAnbmFtZS5maXJzdCcuXG4gICAgICAgICAgICAvLyBjdXJyZW50bHkgc3VwcG9ydGluZyBkb3Qgbm90YXRpb24gZm9yIG5vbi1pbmRleGVkIGNvbmRpdGlvbnMgb25seVxuICAgICAgICAgICAgaWYgKHVzaW5nRG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvdFN1YlNjYW4odFtpXSwgcHJvcGVydHksIGZ1biwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuKHRbaV1bcHJvcGVydHldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZWFyY2hpbmcgYnkgYmluYXJ5IGluZGV4IHZpYSBjYWxjdWxhdGVSYW5nZSgpIHV0aWxpdHkgbWV0aG9kXG4gICAgICAgICAgdCA9IHRoaXMuY29sbGVjdGlvbi5kYXRhO1xuXG4gICAgICAgICAgdmFyIHNlZyA9IHRoaXMuY2FsY3VsYXRlUmFuZ2Uob3BlcmF0b3IsIHByb3BlcnR5LCB2YWx1ZSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBub3QgY2hhaW5lZCBzbyB0aGlzICdmaW5kJyB3YXMgZGVzaWduYXRlZCBpbiBSZXN1bHRzZXQgY29uc3RydWN0b3JcbiAgICAgICAgICAvLyBzbyByZXR1cm4gb2JqZWN0IGl0c2VsZlxuICAgICAgICAgIGlmIChmaXJzdE9ubHkpIHtcbiAgICAgICAgICAgIGlmIChzZWdbMV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0W2luZGV4LnZhbHVlc1tzZWdbMF1dXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IHNlZ1swXTsgaSA8PSBzZWdbMV07IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godFtpbmRleC52YWx1ZXNbaV1dKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdCBhIGNoYWluZWQgcXVlcnkgc28gcmV0dXJuIHJlc3VsdCBhcyBkYXRhW11cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSB0aGlzIGlzIGEgY2hhaW5lZCBxdWVyeVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWx0ZXJlZHJvd3NbXSBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCB1c2UgaXRcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAvLyBub3Qgc2VhcmNoaW5nIGJ5IGluZGV4XG4gICAgICAgICAgaWYgKCFzZWFyY2hCeUluZGV4KSB7XG4gICAgICAgICAgICB0ID0gdGhpcy5jb2xsZWN0aW9uLmRhdGE7XG4gICAgICAgICAgICBpID0gdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBjdXJyZW50bHkgc3VwcG9ydGluZyBkb3Qgbm90YXRpb24gZm9yIG5vbi1pbmRleGVkIGNvbmRpdGlvbnMgb25seVxuICAgICAgICAgICAgaWYgKHVzaW5nRG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvdFN1YlNjYW4odFt0aGlzLmZpbHRlcmVkcm93c1tpXV0sIHByb3BlcnR5LCBmdW4sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5maWx0ZXJlZHJvd3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChmdW4odFt0aGlzLmZpbHRlcmVkcm93c1tpXV1bcHJvcGVydHldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZmlsdGVyZWRyb3dzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2VhcmNoIGJ5IGluZGV4XG4gICAgICAgICAgICB0ID0gaW5kZXg7XG4gICAgICAgICAgICBpID0gdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICBpZiAoZnVuKHRbdGhpcy5maWx0ZXJlZHJvd3NbaV1dLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmZpbHRlcmVkcm93c1tpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IHJlc3VsdDtcblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGNoYWluZWQgcXVlcnkgc28gd29yayBhZ2FpbnN0IGRhdGFbXSBidXQgcHV0IHJlc3VsdHMgaW4gZmlsdGVyZWRyb3dzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlmIG5vdCBzZWFyY2hpbmcgYnkgaW5kZXhcbiAgICAgICAgICBpZiAoIXNlYXJjaEJ5SW5kZXgpIHtcbiAgICAgICAgICAgIHQgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YTtcbiAgICAgICAgICAgIGkgPSB0Lmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHVzaW5nRG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvdFN1YlNjYW4odFtpXSwgcHJvcGVydHksIGZ1biwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuKHRbaV1bcHJvcGVydHldLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzZWFyY2ggYnkgaW5kZXhcbiAgICAgICAgICAgIHQgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YTtcbiAgICAgICAgICAgIHZhciBzZWdtID0gdGhpcy5jYWxjdWxhdGVSYW5nZShvcGVyYXRvciwgcHJvcGVydHksIHZhbHVlLCB0aGlzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gc2VnbVswXTsgaWR4IDw9IHNlZ21bMV07IGlkeCsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4LnZhbHVlc1tpZHhdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZHJvd3MgPSByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5maWx0ZXJlZHJvd3MgPSByZXN1bHQ7XG4gICAgICAgICAgdGhpcy5maWx0ZXJJbml0aWFsaXplZCA9IHRydWU7IC8vIG5leHQgdGltZSB3b3JrIGFnYWluc3QgZmlsdGVyZWRyb3dzW11cblxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiB3aGVyZSgpIC0gVXNlZCBmb3IgZmlsdGVyaW5nIHZpYSBhIGphdmFzY3JpcHQgZmlsdGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuIC0gQSBqYXZhc2NyaXB0IGZ1bmN0aW9uIHVzZWQgZm9yIGZpbHRlcmluZyBjdXJyZW50IHJlc3VsdHMgYnkuXG4gICAgICogQHJldHVybnMge1Jlc3VsdHNldH0gdGhpcyByZXN1bHRzZXQgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoZnVuKSB7XG5cbiAgICAgIHZhciB2aWV3RnVuY3Rpb24sXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZ1bikge1xuICAgICAgICB2aWV3RnVuY3Rpb24gPSBmdW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBzdG9yZWQgdmlldyBvciBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBpZiBub3QgYSBjaGFpbmVkIHF1ZXJ5IHRoZW4gcnVuIGRpcmVjdGx5IGFnYWluc3QgZGF0YVtdIGFuZCByZXR1cm4gb2JqZWN0IFtdXG4gICAgICAgIGlmICghdGhpcy5zZWFyY2hJc0NoYWluZWQpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuY29sbGVjdGlvbi5kYXRhLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmICh2aWV3RnVuY3Rpb24odGhpcy5jb2xsZWN0aW9uLmRhdGFbaV0pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY29sbGVjdGlvbi5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBub3QgYSBjaGFpbmVkIHF1ZXJ5IHNvIHJldHVybmluZyByZXN1bHQgYXMgZGF0YVtdXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGNoYWluZWQgcXVlcnksIHNvIHJ1biBhZ2FpbnN0IGZpbHRlcmVkcm93c1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZmlsdGVyZWRyb3dzW10gaXMgYWxyZWFkeSBpbml0aWFsaXplZCwgdXNlIGl0XG4gICAgICAgICAgaWYgKHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICAgIGlmICh2aWV3RnVuY3Rpb24odGhpcy5jb2xsZWN0aW9uLmRhdGFbdGhpcy5maWx0ZXJlZHJvd3Nbal1dKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZmlsdGVyZWRyb3dzW2pdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IHJlc3VsdDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIGlzIGluaXRpYWwgY2hhaW5lZCBvcCwgd29yayBhZ2FpbnN0IGRhdGEsIHB1c2ggaW50byBmaWx0ZXJlZHJvd3NbXVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGsgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHZpZXdGdW5jdGlvbih0aGlzLmNvbGxlY3Rpb24uZGF0YVtrXSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IHJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGRhdGEoKSAtIFRlcm1pbmF0ZXMgdGhlIGNoYWluIGFuZCByZXR1cm5zIGFycmF5IG9mIGZpbHRlcmVkIGRvY3VtZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gOiBhbGxvd3Mgc3BlY2lmeWluZyAnZm9yY2VDbG9uZXMnIGFuZCAnZm9yY2VDbG9uZU1ldGhvZCcgb3B0aW9ucy5cbiAgICAgKiAgICBvcHRpb25zIDpcbiAgICAgKiAgICAgIGZvcmNlQ2xvbmVzIHtib29sZWFufSA6IEFsbG93cyBmb3JjaW5nIHRoZSByZXR1cm4gb2YgY2xvbmVkIG9iamVjdHMgZXZlbiB3aGVuXG4gICAgICogICAgICAgIHRoZSBjb2xsZWN0aW9uIGlzIG5vdCBjb25maWd1cmVkIGZvciBjbG9uZSBvYmplY3QuXG4gICAgICogICAgICBmb3JjZUNsb25lTWV0aG9kIHtzdHJpbmd9IDogQWxsb3dzIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWQgY2xvbmluZyBtZXRob2QuXG4gICAgICogICAgICAgIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlICdwYXJzZS1zdHJpbmdpZnknLCAnanF1ZXJ5LWV4dGVuZC1kZWVwJywgYW5kICdzaGFsbG93J1xuICAgICAqXG4gICAgICogQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdHNldFxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNkLFxuICAgICAgICBjbDtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgY2hhaW5lZCByZXN1bHRzZXQgd2l0aCBubyBmaWx0ZXJzIGFwcGxpZWQsIGp1c3QgcmV0dXJuIGNvbGxlY3Rpb24uZGF0YVxuICAgICAgaWYgKHRoaXMuc2VhcmNoSXNDaGFpbmVkICYmICF0aGlzLmZpbHRlckluaXRpYWxpemVkKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkcm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGNsb25lIG9iamVjdHMgb3Igbm90XG4gICAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbi5jbG9uZU9iamVjdHMgfHwgb3B0aW9ucy5mb3JjZUNsb25lcykge1xuICAgICAgICAgICAgY2QgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YTtcbiAgICAgICAgICAgIGNsID0gY2wubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2w7IGkrKykge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChjbG9uZShjZFtpXSwgKG9wdGlvbnMuZm9yY2VDbG9uZU1ldGhvZCB8fCB0aGlzLmNvbGxlY3Rpb24uY2xvbmVNZXRob2QpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBhcmUgbm90IGNsb25pbmcgc28gcmV0dXJuIHNsaWNlZCBhcnJheSB3aXRoIHNhbWUgb2JqZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb24uZGF0YS5zbGljZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaWx0ZXJlZHJvd3MgbXVzdCBoYXZlIGJlZW4gc2V0IG1hbnVhbGx5LCBzbyB1c2UgaXRcbiAgICAgICAgICB0aGlzLmZpbHRlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuY29sbGVjdGlvbi5kYXRhLFxuICAgICAgICBmciA9IHRoaXMuZmlsdGVyZWRyb3dzO1xuXG4gICAgICB2YXIgaSxcbiAgICAgICAgbGVuID0gdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbi5jbG9uZU9iamVjdHMgfHwgb3B0aW9ucy5mb3JjZUNsb25lcykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNsb25lKGRhdGFbZnJbaV1dLCAob3B0aW9ucy5mb3JjZUNsb25lTWV0aG9kIHx8IHRoaXMuY29sbGVjdGlvbi5jbG9uZU1ldGhvZCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChkYXRhW2ZyW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSgpIC0gdXNlZCB0byBydW4gYW4gdXBkYXRlIG9wZXJhdGlvbiBvbiBhbGwgZG9jdW1lbnRzIGN1cnJlbnRseSBpbiB0aGUgcmVzdWx0c2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gdXBkYXRlRnVuY3Rpb24gLSBVc2VyIHN1cHBsaWVkIHVwZGF0ZUZ1bmN0aW9uKG9iaikgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCBkb2N1bWVudCBvYmplY3QuXG4gICAgICogQHJldHVybnMge1Jlc3VsdHNldH0gdGhpcyByZXN1bHRzZXQgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHVwZGF0ZUZ1bmN0aW9uKSB7XG5cbiAgICAgIGlmICh0eXBlb2YgKHVwZGF0ZUZ1bmN0aW9uKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgY2hhaW5lZCByZXN1bHRzZXQgd2l0aCBubyBmaWx0ZXJzIGFwcGxpZWQsIHdlIG5lZWQgdG8gcG9wdWxhdGUgZmlsdGVyZWRyb3dzIGZpcnN0XG4gICAgICBpZiAodGhpcy5zZWFyY2hJc0NoYWluZWQgJiYgIXRoaXMuZmlsdGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyZWRyb3dzID0gT2JqZWN0LmtleXModGhpcy5jb2xsZWN0aW9uLmRhdGEpLm1hcChOdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gdGhpcy5maWx0ZXJlZHJvd3MubGVuZ3RoLFxuICAgICAgICByY2QgPSB0aGlzLmNvbGxlY3Rpb24uZGF0YTtcblxuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgICAvLyBwYXNzIGluIGVhY2ggZG9jdW1lbnQgb2JqZWN0IGN1cnJlbnRseSBpbiByZXN1bHRzZXQgdG8gdXNlciBzdXBwbGllZCB1cGRhdGVGdW5jdGlvblxuICAgICAgICB1cGRhdGVGdW5jdGlvbihyY2RbdGhpcy5maWx0ZXJlZHJvd3NbaWR4XV0pO1xuXG4gICAgICAgIC8vIG5vdGlmeSBjb2xsZWN0aW9uIHdlIGhhdmUgY2hhbmdlZCB0aGlzIG9iamVjdCBzbyBpdCBjYW4gdXBkYXRlIG1ldGEgYW5kIGFsbG93IER5bmFtaWNWaWV3cyB0byByZS1ldmFsdWF0ZVxuICAgICAgICB0aGlzLmNvbGxlY3Rpb24udXBkYXRlKHJjZFt0aGlzLmZpbHRlcmVkcm93c1tpZHhdXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUoKSAtIHJlbW92ZXMgYWxsIGRvY3VtZW50IG9iamVjdHMgd2hpY2ggYXJlIGN1cnJlbnRseSBpbiByZXN1bHRzZXQgZnJvbSBjb2xsZWN0aW9uIChhcyB3ZWxsIGFzIHJlc3VsdHNldClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IHRoaXMgKGVtcHR5KSByZXN1bHRzZXQgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGNoYWluZWQgcmVzdWx0c2V0IHdpdGggbm8gZmlsdGVycyBhcHBsaWVkLCB3ZSBuZWVkIHRvIHBvcHVsYXRlIGZpbHRlcmVkcm93cyBmaXJzdFxuICAgICAgaWYgKHRoaXMuc2VhcmNoSXNDaGFpbmVkICYmICF0aGlzLmZpbHRlckluaXRpYWxpemVkICYmIHRoaXMuZmlsdGVyZWRyb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IE9iamVjdC5rZXlzKHRoaXMuY29sbGVjdGlvbi5kYXRhKS5tYXAoTnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb2xsZWN0aW9uLnJlbW92ZSh0aGlzLmRhdGEoKSk7XG5cbiAgICAgIHRoaXMuZmlsdGVyZWRyb3dzID0gW107XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBtYXBSZWR1Y2UoKSAtIGRhdGEgdHJhbnNmb3JtYXRpb24gdmlhIHVzZXIgc3VwcGxpZWQgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGdW5jdGlvbiAtIHRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIHNpbmdsZSBkb2N1bWVudCBmb3IgeW91IHRvIHRyYW5zZm9ybSBhbmQgcmV0dXJuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVkdWNlRnVuY3Rpb24gLSB0aGlzIGZ1bmN0aW9uIGFjY2VwdHMgbWFueSAoYXJyYXkgb2YgbWFwIG91dHB1dHMpIGFuZCByZXR1cm5zIHNpbmdsZSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBvdXRwdXQgb2YgeW91ciByZWR1Y2VGdW5jdGlvblxuICAgICAqL1xuICAgIFJlc3VsdHNldC5wcm90b3R5cGUubWFwUmVkdWNlID0gZnVuY3Rpb24gKG1hcEZ1bmN0aW9uLCByZWR1Y2VGdW5jdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZUZ1bmN0aW9uKHRoaXMuZGF0YSgpLm1hcChtYXBGdW5jdGlvbikpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZXFKb2luKCkgLSBMZWZ0IGpvaW5pbmcgdHdvIHNldHMgb2YgZGF0YS4gSm9pbiBrZXlzIGNhbiBiZSBkZWZpbmVkIG9yIGNhbGN1bGF0ZWQgcHJvcGVydGllc1xuICAgICAqIGVxSm9pbiBleHBlY3RzIHRoZSByaWdodCBqb2luIGtleSB2YWx1ZXMgdG8gYmUgdW5pcXVlLiAgT3RoZXJ3aXNlIGxlZnQgZGF0YSB3aWxsIGJlIGpvaW5lZCBvbiB0aGUgbGFzdCBqb2luRGF0YSBvYmplY3Qgd2l0aCB0aGF0IGtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGpvaW5EYXRhIC0gRGF0YSBhcnJheSB0byBqb2luIHRvLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nLGZ1bmN0aW9ufSBsZWZ0Sm9pbktleSAtIFByb3BlcnR5IG5hbWUgaW4gdGhpcyByZXN1bHQgc2V0IHRvIGpvaW4gb24gb3IgYSBmdW5jdGlvbiB0byBwcm9kdWNlIGEgdmFsdWUgdG8gam9pbiBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nLGZ1bmN0aW9ufSByaWdodEpvaW5LZXkgLSBQcm9wZXJ0eSBuYW1lIGluIHRoZSBqb2luRGF0YSB0byBqb2luIG9uIG9yIGEgZnVuY3Rpb24gdG8gcHJvZHVjZSBhIHZhbHVlIHRvIGpvaW4gb25cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAob3B0aW9uYWwpIG1hcEZ1biAtIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBlYWNoIG1hdGNoaW5nIHBhaXIgYW5kIG1hcHMgdGhlbSBpbnRvIG91dHB1dCBvYmplY3RzIC0gZnVuY3Rpb24obGVmdCxyaWdodCl7cmV0dXJuIGpvaW5lZE9iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7UmVzdWx0c2V0fSBBIHJlc3VsdHNldCB3aXRoIGRhdGEgaW4gdGhlIGZvcm1hdCBbe2xlZnQ6IGxlZnRPYmosIHJpZ2h0OiByaWdodE9ian1dXG4gICAgICovXG4gICAgUmVzdWx0c2V0LnByb3RvdHlwZS5lcUpvaW4gPSBmdW5jdGlvbiAoam9pbkRhdGEsIGxlZnRKb2luS2V5LCByaWdodEpvaW5LZXksIG1hcEZ1bikge1xuXG4gICAgICB2YXIgbGVmdERhdGEgPSBbXSxcbiAgICAgICAgbGVmdERhdGFMZW5ndGgsXG4gICAgICAgIHJpZ2h0RGF0YSA9IFtdLFxuICAgICAgICByaWdodERhdGFMZW5ndGgsXG4gICAgICAgIGtleSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIG9iaixcbiAgICAgICAgbGVmdEtleWlzRnVuY3Rpb24gPSB0eXBlb2YgbGVmdEpvaW5LZXkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgIHJpZ2h0S2V5aXNGdW5jdGlvbiA9IHR5cGVvZiByaWdodEpvaW5LZXkgPT09ICdmdW5jdGlvbicsXG4gICAgICAgIGpvaW5NYXAgPSB7fTtcblxuICAgICAgLy9nZXQgdGhlIGxlZnQgZGF0YVxuICAgICAgbGVmdERhdGEgPSB0aGlzLmRhdGEoKTtcbiAgICAgIGxlZnREYXRhTGVuZ3RoID0gbGVmdERhdGEubGVuZ3RoO1xuXG4gICAgICAvL2dldCB0aGUgcmlnaHQgZGF0YVxuICAgICAgaWYgKGpvaW5EYXRhIGluc3RhbmNlb2YgUmVzdWx0c2V0KSB7XG4gICAgICAgIHJpZ2h0RGF0YSA9IGpvaW5EYXRhLmRhdGEoKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShqb2luRGF0YSkpIHtcbiAgICAgICAgcmlnaHREYXRhID0gam9pbkRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqb2luRGF0YSBuZWVkcyB0byBiZSBhbiBhcnJheSBvciByZXN1bHQgc2V0Jyk7XG4gICAgICB9XG4gICAgICByaWdodERhdGFMZW5ndGggPSByaWdodERhdGEubGVuZ3RoO1xuXG4gICAgICAvL2NvbnN0cnVjdCBhIGxvb2t1cCB0YWJsZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpZ2h0RGF0YUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IHJpZ2h0S2V5aXNGdW5jdGlvbiA/IHJpZ2h0Sm9pbktleShyaWdodERhdGFbaV0pIDogcmlnaHREYXRhW2ldW3JpZ2h0Sm9pbktleV07XG4gICAgICAgIGpvaW5NYXBba2V5XSA9IHJpZ2h0RGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXBGdW4pIHtcbiAgICAgICAgbWFwRnVuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICByaWdodDogcmlnaHRcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvL1J1biBtYXAgZnVuY3Rpb24gb3ZlciBlYWNoIG9iamVjdCBpbiB0aGUgcmVzdWx0c2V0XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlZnREYXRhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAga2V5ID0gbGVmdEtleWlzRnVuY3Rpb24gPyBsZWZ0Sm9pbktleShsZWZ0RGF0YVtqXSkgOiBsZWZ0RGF0YVtqXVtsZWZ0Sm9pbktleV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG1hcEZ1bihsZWZ0RGF0YVtqXSwgam9pbk1hcFtrZXldIHx8IHt9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vcmV0dXJuIHJldHVybiBhIG5ldyByZXN1bHRzZXQgd2l0aCBubyBmaWx0ZXJzXG4gICAgICB0aGlzLmNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignam9pbkRhdGEnKTtcbiAgICAgIHRoaXMuY29sbGVjdGlvbi5pbnNlcnQocmVzdWx0KTtcbiAgICAgIHRoaXMuZmlsdGVyZWRyb3dzID0gW107XG4gICAgICB0aGlzLmZpbHRlckluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZXN1bHRzZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChtYXBGdW4pIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhKCkubWFwKG1hcEZ1bik7XG4gICAgICAvL3JldHVybiByZXR1cm4gYSBuZXcgcmVzdWx0c2V0IHdpdGggbm8gZmlsdGVyc1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ21hcHBlZERhdGEnKTtcbiAgICAgIHRoaXMuY29sbGVjdGlvbi5pbnNlcnQoZGF0YSk7XG4gICAgICB0aGlzLmZpbHRlcmVkcm93cyA9IFtdO1xuICAgICAgdGhpcy5maWx0ZXJJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHluYW1pY1ZpZXcgY2xhc3MgaXMgYSB2ZXJzYXRpbGUgJ2xpdmUnIHZpZXcgY2xhc3Mgd2hpY2ggY2FuIGhhdmUgZmlsdGVycyBhbmQgc29ydHMgYXBwbGllZC5cbiAgICAgKiAgICBDb2xsZWN0aW9uLmFkZER5bmFtaWNWaWV3KG5hbWUpIGluc3RhbnRpYXRlcyB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCBhbmQgbm90aWZpZXMgaXRcbiAgICAgKiAgICB3aGVuZXZlciBkb2N1bWVudHMgYXJlIGFkZC91cGRhdGVkL3JlbW92ZWQgc28gaXQgY2FuIHJlbWFpbiB1cC10by1kYXRlLiAoY2hhaW5hYmxlKVxuICAgICAqXG4gICAgICogICAgRXhhbXBsZXM6XG4gICAgICogICAgdmFyIG15ZHYgPSBteWNvbGxlY3Rpb24uYWRkRHluYW1pY1ZpZXcoJ3Rlc3QnKTsgIC8vIGRlZmF1bHQgaXMgbm9uLXBlcnNpc3RlbnRcbiAgICAgKiAgICBteWR2LmFwcGx5V2hlcmUoZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmoubmFtZSA9PT0gJ1RveW90YSc7IH0pO1xuICAgICAqICAgIG15ZHYuYXBwbHlGaW5kKHsgJ2Rvb3JzJyA6IDQgfSk7XG4gICAgICogICAgdmFyIHJlc3VsdHMgPSBteWR2LmRhdGEoKTtcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Q29sbGVjdGlvbn0gY29sbGVjdGlvbiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBjb2xsZWN0aW9uIHRvIHdvcmsgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBkeW5hbWljIHZpZXdcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIChPcHRpb25hbCkgUGFzcyBpbiBvYmplY3Qgd2l0aCAncGVyc2lzdGVudCcgYW5kL29yICdzb3J0UHJpb3JpdHknIG9wdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRHluYW1pY1ZpZXcoY29sbGVjdGlvbiwgbmFtZSwgb3B0aW9ucykge1xuICAgICAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnJlYnVpbGRQZW5kaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGVyc2lzdGVudCcpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vICdwZXJzaXN0ZW50U29ydFByaW9yaXR5JzpcbiAgICAgIC8vICdwYXNzaXZlJyB3aWxsIGRlZmVyIHRoZSBzb3J0IHBoYXNlIHVudGlsIHRoZXkgY2FsbCBkYXRhKCkuIChtb3N0IGVmZmljaWVudCBvdmVyYWxsKVxuICAgICAgLy8gJ2FjdGl2ZScgd2lsbCBzb3J0IGFzeW5jIHdoZW5ldmVyIG5leHQgaWRsZS4gKHByaW9yaXRpemVzIHJlYWQgc3BlZWRzKVxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NvcnRQcmlvcml0eScpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zb3J0UHJpb3JpdHkgPSAncGFzc2l2ZSc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzdWx0c2V0ID0gbmV3IFJlc3VsdHNldChjb2xsZWN0aW9uKTtcbiAgICAgIHRoaXMucmVzdWx0ZGF0YSA9IFtdO1xuICAgICAgdGhpcy5yZXN1bHRzZGlydHkgPSBmYWxzZTtcblxuICAgICAgdGhpcy5jYWNoZWRyZXN1bHRzZXQgPSBudWxsO1xuXG4gICAgICAvLyBrZWVwIG9yZGVyZWQgZmlsdGVyIHBpcGVsaW5lXG4gICAgICB0aGlzLmZpbHRlclBpcGVsaW5lID0gW107XG5cbiAgICAgIC8vIHNvcnRpbmcgbWVtYmVyIHZhcmlhYmxlc1xuICAgICAgLy8gd2Ugb25seSBzdXBwb3J0IG9uZSBhY3RpdmUgc2VhcmNoLCBhcHBsaWVkIHVzaW5nIGFwcGx5U29ydCgpIG9yIGFwcGx5U2ltcGxlU29ydCgpXG4gICAgICB0aGlzLnNvcnRGdW5jdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLnNvcnRDcml0ZXJpYSA9IG51bGw7XG4gICAgICB0aGlzLnNvcnREaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAvLyBmb3Igbm93IGp1c3QgaGF2ZSAxIGV2ZW50IGZvciB3aGVuIHdlIGZpbmFsbHkgcmVidWlsdCBsYXp5IHZpZXdcbiAgICAgIC8vIG9uY2Ugd2UgcmVmYWN0b3IgdHJhbnNhY3Rpb25zLCBpIHdpbGwgdGllIGluIGNlcnRhaW4gdHJhbnNhY3Rpb25hbCBldmVudHNcblxuICAgICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICAgICdyZWJ1aWxkJzogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlID0gbmV3IExva2lFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogcmVtYXRlcmlhbGl6ZSgpIC0gaW50ZW5kZWQgZm9yIHVzZSBpbW1lZGlhdGVseSBhZnRlciBkZXNlcmlhbGl6YXRpb24gKGxvYWRpbmcpXG4gICAgICogICAgVGhpcyB3aWxsIGNsZWFyIG91dCBhbmQgcmVhcHBseSBmaWx0ZXJQaXBlbGluZSBvcHMsIHJlY3JlYXRpbmcgdGhlIHZpZXcuXG4gICAgICogICAgU2luY2Ugd2hlcmUgZmlsdGVycyBkbyBub3QgcGVyc2lzdCBjb3JyZWN0bHksIHRoaXMgbWV0aG9kIGFsbG93c1xuICAgICAqICAgIHJlc3RvcmluZyB0aGUgdmlldyB0byBzdGF0ZSB3aGVyZSB1c2VyIGNhbiByZS1hcHBseSB0aG9zZSB3aGVyZSBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSAoT3B0aW9uYWwpIGFsbG93cyBzcGVjaWZpY2F0aW9uIG9mICdyZW1vdmVXaGVyZUZpbHRlcnMnIG9wdGlvblxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gVGhpcyBkeW5hbWljIHZpZXcgZm9yIGZ1cnRoZXIgY2hhaW5lZCBvcHMuXG4gICAgICovXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlLnJlbWF0ZXJpYWxpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGZwbCxcbiAgICAgICAgZnBpLFxuICAgICAgICBpZHg7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB0aGlzLnJlc3VsdGRhdGEgPSBbXTtcbiAgICAgIHRoaXMucmVzdWx0c2RpcnR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzdWx0c2V0ID0gbmV3IFJlc3VsdHNldCh0aGlzLmNvbGxlY3Rpb24pO1xuXG4gICAgICBpZiAodGhpcy5zb3J0RnVuY3Rpb24gfHwgdGhpcy5zb3J0Q3JpdGVyaWEpIHtcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncmVtb3ZlV2hlcmVGaWx0ZXJzJykpIHtcbiAgICAgICAgLy8gZm9yIGVhY2ggdmlldyBzZWUgaWYgaXQgaGFkIGFueSB3aGVyZSBmaWx0ZXJzIGFwcGxpZWQuLi4gc2luY2UgdGhleSBkb24ndFxuICAgICAgICAvLyBzZXJpYWxpemUgdGhvc2UgZnVuY3Rpb25zIGxldHMgcmVtb3ZlIHRob3NlIGludmFsaWQgZmlsdGVyc1xuICAgICAgICBmcGwgPSB0aGlzLmZpbHRlclBpcGVsaW5lLmxlbmd0aDtcbiAgICAgICAgZnBpID0gZnBsO1xuICAgICAgICB3aGlsZSAoZnBpLS0pIHtcbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJQaXBlbGluZVtmcGldLnR5cGUgPT09ICd3aGVyZScpIHtcbiAgICAgICAgICAgIGlmIChmcGkgIT09IHRoaXMuZmlsdGVyUGlwZWxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICB0aGlzLmZpbHRlclBpcGVsaW5lW2ZwaV0gPSB0aGlzLmZpbHRlclBpcGVsaW5lW3RoaXMuZmlsdGVyUGlwZWxpbmUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZmlsdGVyUGlwZWxpbmUubGVuZ3RoLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGJhY2sgdXAgb2xkIGZpbHRlciBwaXBlbGluZSwgY2xlYXIgZmlsdGVyIHBpcGVsaW5lLCBhbmQgcmVhcHBseSBwaXBlbGluZSBvcHNcbiAgICAgIHZhciBvZnAgPSB0aGlzLmZpbHRlclBpcGVsaW5lO1xuICAgICAgdGhpcy5maWx0ZXJQaXBlbGluZSA9IFtdO1xuXG4gICAgICAvLyBub3cgcmUtYXBwbHkgJ2ZpbmQnIGZpbHRlclBpcGVsaW5lIG9wc1xuICAgICAgZnBsID0gb2ZwLmxlbmd0aDtcbiAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgZnBsOyBpZHgrKykge1xuICAgICAgICB0aGlzLmFwcGx5RmluZChvZnBbaWR4XS52YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBkdXJpbmcgY3JlYXRpb24gb2YgdW5pdCB0ZXN0cywgaSB3aWxsIHJlbW92ZSB0aGlzIGZvcmNlZCByZWZyZXNoIGFuZCBsZWF2ZSBsYXp5XG4gICAgICB0aGlzLmRhdGEoKTtcblxuICAgICAgLy8gZW1pdCByZWJ1aWxkIGV2ZW50IGluIGNhc2UgdXNlciB3YW50cyB0byBiZSBub3RpZmllZFxuICAgICAgdGhpcy5lbWl0KCdyZWJ1aWxkJywgdGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBicmFuY2hSZXN1bHRzZXQoKSAtIE1ha2VzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgcmVzdWx0c2V0IGZvciBicmFuY2hlZCBxdWVyaWVzLlxuICAgICAqICAgIFVubGlrZSB0aGlzIGR5bmFtaWMgdmlldywgdGhlIGJyYW5jaGVkIHJlc3VsdHNldCB3aWxsIG5vdCBiZSAnbGl2ZScgdXBkYXRlZCxcbiAgICAgKiAgICBzbyB5b3VyIGJyYW5jaGVkIHF1ZXJ5IHNob3VsZCBiZSBpbW1lZGlhdGVseSByZXNvbHZlZCBhbmQgbm90IGhlbGQgZm9yIGZ1dHVyZSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcsIGFycmF5fSA6IE9wdGlvbmFsIG5hbWUgb2YgY29sbGVjdGlvbiB0cmFuc2Zvcm0sIG9yIGFuIGFycmF5IG9mIHRyYW5zZm9ybSBzdGVwc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSA6IG9wdGlvbmFsIHBhcmFtZXRlcnMgKGlmIG9wdGlvbmFsIHRyYW5zZm9ybSByZXF1aXJlcyB0aGVtKVxuICAgICAqIEByZXR1cm5zIHtSZXN1bHRzZXR9IEEgY29weSBvZiB0aGUgaW50ZXJuYWwgcmVzdWx0c2V0IGZvciBicmFuY2hlZCBxdWVyaWVzLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5icmFuY2hSZXN1bHRzZXQgPSBmdW5jdGlvbiAodHJhbnNmb3JtLCBwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgcnMgPSB0aGlzLnJlc3VsdHNldC5icmFuY2goKTtcblxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBycztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIHBhcmFtZXRlcnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0b0pTT04oKSAtIE92ZXJyaWRlIG9mIHRvSlNPTiB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvcHkgPSBuZXcgRHluYW1pY1ZpZXcodGhpcy5jb2xsZWN0aW9uLCB0aGlzLm5hbWUsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgIGNvcHkucmVzdWx0c2V0ID0gdGhpcy5yZXN1bHRzZXQ7XG4gICAgICBjb3B5LnJlc3VsdGRhdGEgPSBbXTsgLy8gbGV0J3Mgbm90IHNhdmUgZGF0YSAoY29weSkgdG8gbWluaW1pemUgc2l6ZVxuICAgICAgY29weS5yZXN1bHRzZGlydHkgPSB0cnVlO1xuICAgICAgY29weS5maWx0ZXJQaXBlbGluZSA9IHRoaXMuZmlsdGVyUGlwZWxpbmU7XG4gICAgICBjb3B5LnNvcnRGdW5jdGlvbiA9IHRoaXMuc29ydEZ1bmN0aW9uO1xuICAgICAgY29weS5zb3J0Q3JpdGVyaWEgPSB0aGlzLnNvcnRDcml0ZXJpYTtcbiAgICAgIGNvcHkuc29ydERpcnR5ID0gdGhpcy5zb3J0RGlydHk7XG5cbiAgICAgIC8vIGF2b2lkIGNpcmN1bGFyIHJlZmVyZW5jZSwgcmVhcHBseSBpbiBkYi5sb2FkSlNPTigpXG4gICAgICBjb3B5LmNvbGxlY3Rpb24gPSBudWxsO1xuXG4gICAgICByZXR1cm4gY29weTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlRmlsdGVycygpIC0gVXNlZCB0byBjbGVhciBwaXBlbGluZSBhbmQgcmVzZXQgZHluYW1pYyB2aWV3IHRvIGluaXRpYWwgc3RhdGUuXG4gICAgICogICAgIEV4aXN0aW5nIG9wdGlvbnMgc2hvdWxkIGJlIHJldGFpbmVkLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5yZW1vdmVGaWx0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZWJ1aWxkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5yZXN1bHRzZXQgPSBuZXcgUmVzdWx0c2V0KHRoaXMuY29sbGVjdGlvbik7XG4gICAgICB0aGlzLnJlc3VsdGRhdGEgPSBbXTtcbiAgICAgIHRoaXMucmVzdWx0c2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuY2FjaGVkcmVzdWx0c2V0ID0gbnVsbDtcblxuICAgICAgLy8ga2VlcCBvcmRlcmVkIGZpbHRlciBwaXBlbGluZVxuICAgICAgdGhpcy5maWx0ZXJQaXBlbGluZSA9IFtdO1xuXG4gICAgICAvLyBzb3J0aW5nIG1lbWJlciB2YXJpYWJsZXNcbiAgICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBvbmUgYWN0aXZlIHNlYXJjaCwgYXBwbGllZCB1c2luZyBhcHBseVNvcnQoKSBvciBhcHBseVNpbXBsZVNvcnQoKVxuICAgICAgdGhpcy5zb3J0RnVuY3Rpb24gPSBudWxsO1xuICAgICAgdGhpcy5zb3J0Q3JpdGVyaWEgPSBudWxsO1xuICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXBwbHlTb3J0KCkgLSBVc2VkIHRvIGFwcGx5IGEgc29ydCB0byB0aGUgZHluYW1pYyB2aWV3XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJlZnVuIC0gYSBqYXZhc2NyaXB0IGNvbXBhcmUgZnVuY3Rpb24gdXNlZCBmb3Igc29ydGluZ1xuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUuYXBwbHlTb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVmdW4pIHtcbiAgICAgIHRoaXMuc29ydEZ1bmN0aW9uID0gY29tcGFyZWZ1bjtcbiAgICAgIHRoaXMuc29ydENyaXRlcmlhID0gbnVsbDtcblxuICAgICAgdGhpcy5xdWV1ZVNvcnRQaGFzZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXBwbHlTaW1wbGVTb3J0KCkgLSBVc2VkIHRvIHNwZWNpZnkgYSBwcm9wZXJ0eSB1c2VkIGZvciB2aWV3IHRyYW5zbGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BuYW1lIC0gTmFtZSBvZiBwcm9wZXJ0eSBieSB3aGljaCB0byBzb3J0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNkZXNjIC0gKE9wdGlvbmFsKSBJZiB0cnVlLCB0aGUgc29ydCB3aWxsIGJlIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5hcHBseVNpbXBsZVNvcnQgPSBmdW5jdGlvbiAocHJvcG5hbWUsIGlzZGVzYykge1xuXG4gICAgICBpZiAodHlwZW9mIChpc2Rlc2MpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpc2Rlc2MgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zb3J0Q3JpdGVyaWEgPSBbXG4gICAgICAgIFtwcm9wbmFtZSwgaXNkZXNjXVxuICAgICAgXTtcbiAgICAgIHRoaXMuc29ydEZ1bmN0aW9uID0gbnVsbDtcblxuICAgICAgdGhpcy5xdWV1ZVNvcnRQaGFzZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXBwbHlTb3J0Q3JpdGVyaWEoKSAtIEFsbG93cyBzb3J0aW5nIGEgcmVzdWx0c2V0IGJhc2VkIG9uIG11bHRpcGxlIGNvbHVtbnMuXG4gICAgICogICAgRXhhbXBsZSA6IGR2LmFwcGx5U29ydENyaXRlcmlhKFsnYWdlJywgJ25hbWUnXSk7IHRvIHNvcnQgYnkgYWdlIGFuZCB0aGVuIG5hbWUgKGJvdGggYXNjZW5kaW5nKVxuICAgICAqICAgIEV4YW1wbGUgOiBkdi5hcHBseVNvcnRDcml0ZXJpYShbJ2FnZScsIFsnbmFtZScsIHRydWVdKTsgdG8gc29ydCBieSBhZ2UgKGFzY2VuZGluZykgYW5kIHRoZW4gYnkgbmFtZSAoZGVzY2VuZGluZylcbiAgICAgKiAgICBFeGFtcGxlIDogZHYuYXBwbHlTb3J0Q3JpdGVyaWEoWydhZ2UnLCB0cnVlXSwgWyduYW1lJywgdHJ1ZV0pOyB0byBzb3J0IGJ5IGFnZSAoZGVzY2VuZGluZykgYW5kIHRoZW4gYnkgbmFtZSAoZGVzY2VuZGluZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IHByb3BlcnRpZXMgLSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBvciBzdWJhcnJheSBvZiBbcHJvcGVydHluYW1lLCBpc2Rlc2NdIHVzZWQgZXZhbHVhdGUgc29ydCBvcmRlclxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gUmVmZXJlbmNlIHRvIHRoaXMgRHluYW1pY1ZpZXcsIHNvcnRlZCwgZm9yIGZ1dHVyZSBjaGFpbiBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5hcHBseVNvcnRDcml0ZXJpYSA9IGZ1bmN0aW9uIChjcml0ZXJpYSkge1xuICAgICAgdGhpcy5zb3J0Q3JpdGVyaWEgPSBjcml0ZXJpYTtcbiAgICAgIHRoaXMuc29ydEZ1bmN0aW9uID0gbnVsbDtcblxuICAgICAgdGhpcy5xdWV1ZVNvcnRQaGFzZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc3RhcnRUcmFuc2FjdGlvbigpIC0gbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5zdGFydFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZWRyZXN1bHRzZXQgPSB0aGlzLnJlc3VsdHNldC5jb3B5KCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBjb21taXQoKSAtIGNvbW1pdHMgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWNoZWRyZXN1bHRzZXQgPSBudWxsO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcm9sbGJhY2soKSAtIHJvbGxzIGJhY2sgYSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUucm9sbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlc3VsdHNldCA9IHRoaXMuY2FjaGVkcmVzdWx0c2V0O1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgLy8gZm9yIG5vdyBqdXN0IHJlYnVpbGQgdGhlIHBlcnNpc3RlbnQgZHluYW1pYyB2aWV3IGRhdGEgaW4gdGhpcyB3b3JzdCBjYXNlIHNjZW5hcmlvXG4gICAgICAgIC8vIChhIHBlcnNpc3RlbnQgdmlldyB1dGlsaXppbmcgdHJhbnNhY3Rpb25zIHdoaWNoIGdldCByb2xsZWQgYmFjayksIHdlIGFscmVhZHkga25vdyB0aGUgZmlsdGVyIHNvIG5vdCB0b28gYmFkLlxuICAgICAgICB0aGlzLnJlc3VsdGRhdGEgPSB0aGlzLnJlc3VsdHNldC5kYXRhKCk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdyZWJ1aWxkJywgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIGRldGFpbC5cbiAgICAgKiBfaW5kZXhPZkZpbHRlcldpdGhJZCgpIC0gRmluZCB0aGUgaW5kZXggb2YgYSBmaWx0ZXIgaW4gdGhlIHBpcGVsaW5lLCBieSB0aGF0IGZpbHRlcidzIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB1aWQgLSBUaGUgdW5pcXVlIElEIG9mIHRoZSBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn06IGluZGV4IG9mIHRoZSByZWZlcmVuY2VkIGZpbHRlciBpbiB0aGUgcGlwZWxpbmU7IC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUuX2luZGV4T2ZGaWx0ZXJXaXRoSWQgPSBmdW5jdGlvbiAodWlkKSB7XG4gICAgICBpZiAodHlwZW9mIHVpZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHVpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuID0gdGhpcy5maWx0ZXJQaXBlbGluZS5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4ICs9IDEpIHtcbiAgICAgICAgICBpZiAodWlkID09PSB0aGlzLmZpbHRlclBpcGVsaW5lW2lkeF0udWlkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICogX2FkZEZpbHRlcigpIC0gQWRkIHRoZSBmaWx0ZXIgb2JqZWN0IHRvIHRoZSBlbmQgb2YgdmlldydzIGZpbHRlciBwaXBlbGluZSBhbmQgYXBwbHkgdGhlIGZpbHRlciB0byB0aGUgcmVzdWx0c2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGZpbHRlciAtIFRoZSBmaWx0ZXIgb2JqZWN0LiBSZWZlciB0byBhcHBseUZpbHRlcigpIGZvciBleHRyYSBkZXRhaWxzLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5fYWRkRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuICAgICAgdGhpcy5yZXN1bHRzZXRbZmlsdGVyLnR5cGVdKGZpbHRlci52YWwpO1xuICAgICAgdGhpcy5maWx0ZXJQaXBlbGluZS5wdXNoKGZpbHRlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlYXBwbHlGaWx0ZXJzKCkgLSBSZWFwcGx5IGFsbCB0aGUgZmlsdGVycyBpbiB0aGUgY3VycmVudCBwaXBlbGluZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtEeW5hbWljVmlld30gdGhpcyBEeW5hbWljVmlldyBvYmplY3QsIGZvciBmdXJ0aGVyIGNoYWluIG9wcy5cbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUucmVhcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVyUGlwZWxpbmU7XG4gICAgICB2YXIgc29ydEZ1bmN0aW9uID0gdGhpcy5zb3J0RnVuY3Rpb247XG4gICAgICB2YXIgc29ydENyaXRlcmlhID0gdGhpcy5zb3J0Q3JpdGVyaWE7XG5cbiAgICAgIHRoaXMucmVtb3ZlRmlsdGVycygpO1xuXG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW4gPSBmaWx0ZXJzLmxlbmd0aDsgaWR4IDwgbGVuOyBpZHggKz0gMSkge1xuICAgICAgICB0aGlzLl9hZGRGaWx0ZXIoZmlsdGVyc1tpZHhdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvcnRGdW5jdGlvbiAhPT0gbnVsbCl7XG4gICAgICAgIHRoaXMuYXBwbHlTb3J0KHNvcnRGdW5jdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoc29ydENyaXRlcmlhICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTb3J0Q3JpdGVyaWEoc29ydENyaXRlcmlhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50KSB7XG4gICAgICAgIHRoaXMucmVzdWx0c2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXBwbHlGaWx0ZXIoKSAtIEFkZHMgb3IgdXBkYXRlcyBhIGZpbHRlciBpbiB0aGUgRHluYW1pY1ZpZXcgZmlsdGVyIHBpcGVsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZmlsdGVyIC0gQSBmaWx0ZXIgb2JqZWN0IHRvIGFkZCB0byB0aGUgcGlwZWxpbmUuXG4gICAgICogICAgVGhlIG9iamVjdCBpcyBpbiB0aGUgZm9ybWF0IHsgJ3R5cGUnOiBmaWx0ZXJfdHlwZSwgJ3ZhbCcsIGZpbHRlcl9wYXJhbSwgJ3VpZCcsIG9wdGlvbmFsX2ZpbHRlcl9pZCB9XG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLl9pbmRleE9mRmlsdGVyV2l0aElkKGZpbHRlci51aWQpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyUGlwZWxpbmVbaWR4XSA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5yZWFwcGx5RmlsdGVycygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpbHRlcihmaWx0ZXIpO1xuXG4gICAgICBpZiAodGhpcy5zb3J0RnVuY3Rpb24gfHwgdGhpcy5zb3J0Q3JpdGVyaWEpIHtcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnF1ZXVlU29ydFBoYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgICAgICB0aGlzLnJlc3VsdHNkaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMucXVldWVTb3J0UGhhc2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFwcGx5RmluZCgpIC0gQWRkcyBvciB1cGRhdGVzIGEgbW9uZ28tc3R5bGUgcXVlcnkgb3B0aW9uIGluIHRoZSBEeW5hbWljVmlldyBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBxdWVyeSAtIEEgbW9uZ28tc3R5bGUgcXVlcnkgb2JqZWN0IHRvIGFwcGx5IHRvIHBpcGVsaW5lXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB1aWQgLSBPcHRpb25hbDogVGhlIHVuaXF1ZSBJRCBvZiB0aGlzIGZpbHRlciwgdG8gcmVmZXJlbmNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICogQHJldHVybnMge0R5bmFtaWNWaWV3fSB0aGlzIER5bmFtaWNWaWV3IG9iamVjdCwgZm9yIGZ1cnRoZXIgY2hhaW4gb3BzLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5hcHBseUZpbmQgPSBmdW5jdGlvbiAocXVlcnksIHVpZCkge1xuICAgICAgdGhpcy5hcHBseUZpbHRlcih7XG4gICAgICAgIHR5cGU6ICdmaW5kJyxcbiAgICAgICAgdmFsOiBxdWVyeSxcbiAgICAgICAgdWlkOiB1aWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFwcGx5V2hlcmUoKSAtIEFkZHMgb3IgdXBkYXRlcyBhIGphdmFzY3JpcHQgZmlsdGVyIGZ1bmN0aW9uIGluIHRoZSBEeW5hbWljVmlldyBmaWx0ZXIgcGlwZWxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1biAtIEEgamF2YXNjcmlwdCBmaWx0ZXIgZnVuY3Rpb24gdG8gYXBwbHkgdG8gcGlwZWxpbmVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHVpZCAtIE9wdGlvbmFsOiBUaGUgdW5pcXVlIElEIG9mIHRoaXMgZmlsdGVyLCB0byByZWZlcmVuY2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAcmV0dXJucyB7RHluYW1pY1ZpZXd9IHRoaXMgRHluYW1pY1ZpZXcgb2JqZWN0LCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlLmFwcGx5V2hlcmUgPSBmdW5jdGlvbiAoZnVuLCB1aWQpIHtcbiAgICAgIHRoaXMuYXBwbHlGaWx0ZXIoe1xuICAgICAgICB0eXBlOiAnd2hlcmUnLFxuICAgICAgICB2YWw6IGZ1bixcbiAgICAgICAgdWlkOiB1aWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZUZpbHRlcigpIC0gUmVtb3ZlIHRoZSBzcGVjaWZpZWQgZmlsdGVyIGZyb20gdGhlIER5bmFtaWNWaWV3IGZpbHRlciBwaXBlbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB1aWQgLSBUaGUgdW5pcXVlIElEIG9mIHRoZSBmaWx0ZXIgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJucyB7RHluYW1pY1ZpZXd9IHRoaXMgRHluYW1pY1ZpZXcgb2JqZWN0LCBmb3IgZnVydGhlciBjaGFpbiBvcHMuXG4gICAgICovXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlLnJlbW92ZUZpbHRlciA9IGZ1bmN0aW9uICh1aWQpIHtcbiAgICAgIHZhciBpZHggPSB0aGlzLl9pbmRleE9mRmlsdGVyV2l0aElkKHVpZCk7XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIHZpZXcgZG9lcyBub3QgY29udGFpbiBhIGZpbHRlciB3aXRoIElEOiBcIiArIHVpZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmlsdGVyUGlwZWxpbmUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB0aGlzLnJlYXBwbHlGaWx0ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBkYXRhKCkgLSByZXNvbHZlcyBhbmQgcGVuZGluZyBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcsIHRoZW4gcmV0dXJucyBkb2N1bWVudCBhcnJheSBhcyByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGRvY3VtZW50cyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgRHluYW1pY1ZpZXcgY29udGVudHMuXG4gICAgICovXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBVbnRpbCBhIHByb3BlciBpbml0aWFsaXphdGlvbiBwaGFzZSBjYW4gYmUgaW1wbGVtZW50ZWQsIGxldCB1cyBpbml0aWFsaXplIGhlcmUgKGlmIG5lZWRlZClcbiAgICAgIGlmICh0aGlzLmZpbHRlclBpcGVsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmFwcGx5RmluZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyB1c2luZyBmaW5hbCBzb3J0IHBoYXNlIGFzICdjYXRjaCBhbGwnIGZvciBhIGZldyB1c2UgY2FzZXMgd2hpY2ggcmVxdWlyZSBmdWxsIHJlYnVpbGRcbiAgICAgIGlmICh0aGlzLnNvcnREaXJ0eSB8fCB0aGlzLnJlc3VsdHNkaXJ0eSkge1xuICAgICAgICB0aGlzLnBlcmZvcm1Tb3J0UGhhc2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRzZXQuZGF0YSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHRkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBxdWV1ZVJlYnVpbGRFdmVudCgpIC0gV2hlbiB0aGUgdmlldyBpcyBub3Qgc29ydGVkIHdlIG1heSBzdGlsbCB3aXNoIHRvIGJlIG5vdGlmaWVkIG9mIHJlYnVpbGQgZXZlbnRzLlxuICAgICAqICAgICBUaGlzIGV2ZW50IHdpbGwgdGhyb3R0bGUgYW5kIHF1ZXVlIGEgc2luZ2xlIHJlYnVpbGQgZXZlbnQgd2hlbiBiYXRjaGVzIG9mIHVwZGF0ZXMgYWZmZWN0IHRoZSB2aWV3LlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5xdWV1ZVJlYnVpbGRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucmVidWlsZFBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlYnVpbGRQZW5kaW5nID0gdHJ1ZTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucmVidWlsZFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5lbWl0KCdyZWJ1aWxkJywgc2VsZik7XG4gICAgICB9LCAxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcXVldWVTb3J0UGhhc2UgOiBJZiB0aGUgdmlldyBpcyBzb3J0ZWQgd2Ugd2lsbCB0aHJvdHRsZSBzb3J0aW5nIHRvIGVpdGhlciA6XG4gICAgICogICAgKDEpIHBhc3NpdmUgLSB3aGVuIHRoZSB1c2VyIGNhbGxzIGRhdGEoKSwgb3JcbiAgICAgKiAgICAoMikgYWN0aXZlIC0gb25jZSB0aGV5IHN0b3AgdXBkYXRpbmcgYW5kIHlpZWxkIGpzIHRocmVhZCBjb250cm9sXG4gICAgICovXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlLnF1ZXVlU29ydFBoYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAvLyBhbHJlYWR5IHF1ZXVlZD8gZXhpdCB3aXRob3V0IHF1ZXVpbmcgYWdhaW5cbiAgICAgIGlmICh0aGlzLnNvcnREaXJ0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb3J0UHJpb3JpdHkgPT09IFwiYWN0aXZlXCIpIHtcbiAgICAgICAgLy8gYWN0aXZlIHNvcnRpbmcuLi4gb25jZSB0aGV5IGFyZSBkb25lIGFuZCB5aWVsZCBqcyB0aHJlYWQsIHJ1biBhc3luYyBwZXJmb3JtU29ydFBoYXNlKClcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5wZXJmb3JtU29ydFBoYXNlKCk7XG4gICAgICAgIH0sIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbXVzdCBiZSBwYXNzaXZlIHNvcnRpbmcuLi4gc2luY2Ugbm90IGNhbGxpbmcgcGVyZm9ybVNvcnRQaGFzZSAodW50aWwgZGF0YSBjYWxsKSwgbGV0cyB1c2UgcXVldWVSZWJ1aWxkRXZlbnQgdG9cbiAgICAgICAgLy8gcG90ZW50aWFsbHkgbm90aWZ5IHVzZXIgdGhhdCBkYXRhIGhhcyBjaGFuZ2VkLlxuICAgICAgICB0aGlzLnF1ZXVlUmVidWlsZEV2ZW50KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHBlcmZvcm1Tb3J0UGhhc2UoKSAtIGludm9rZWQgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseSB0byBwZXJmb3JtIGZpbmFsIHNvcnQgcGhhc2UgKGlmIG5lZWRlZClcbiAgICAgKlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5wZXJmb3JtU29ydFBoYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gYXN5bmMgY2FsbCB0byB0aGlzIG1heSBoYXZlIGJlZW4gcHJlLWVtcHRlZCBieSBzeW5jaHJvbm91cyBjYWxsIHRvIGRhdGEgYmVmb3JlIGFzeW5jIGNvdWxkIGZpcmVcbiAgICAgIGlmICghdGhpcy5zb3J0RGlydHkgJiYgIXRoaXMucmVzdWx0c2RpcnR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc29ydEZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c2V0LnNvcnQodGhpcy5zb3J0RnVuY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3J0Q3JpdGVyaWEpIHtcbiAgICAgICAgdGhpcy5yZXN1bHRzZXQuY29tcG91bmRzb3J0KHRoaXMuc29ydENyaXRlcmlhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgICAgICB0aGlzLnNvcnREaXJ0eSA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHBlcnNpc3RlbnQgdmlldywgcmVidWlsZCBsb2NhbCByZXN1bHRkYXRhIGFycmF5XG4gICAgICB0aGlzLnJlc3VsdGRhdGEgPSB0aGlzLnJlc3VsdHNldC5kYXRhKCk7XG4gICAgICB0aGlzLnJlc3VsdHNkaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcblxuICAgICAgdGhpcy5lbWl0KCdyZWJ1aWxkJywgdGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGV2YWx1YXRlRG9jdW1lbnQoKSAtIGludGVybmFsIG1ldGhvZCBmb3IgKHJlKWV2YWx1YXRpbmcgZG9jdW1lbnQgaW5jbHVzaW9uLlxuICAgICAqICAgIENhbGxlZCBieSA6IGNvbGxlY3Rpb24uaW5zZXJ0KCkgYW5kIGNvbGxlY3Rpb24udXBkYXRlKCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludH0gb2JqSW5kZXggLSBpbmRleCBvZiBkb2N1bWVudCB0byAocmUpcnVuIHRocm91Z2ggZmlsdGVyIHBpcGVsaW5lLlxuICAgICAqL1xuICAgIER5bmFtaWNWaWV3LnByb3RvdHlwZS5ldmFsdWF0ZURvY3VtZW50ID0gZnVuY3Rpb24gKG9iakluZGV4KSB7XG4gICAgICB2YXIgb2ZyID0gdGhpcy5yZXN1bHRzZXQuZmlsdGVyZWRyb3dzO1xuICAgICAgdmFyIG9sZFBvcyA9IG9mci5pbmRleE9mKCtvYmpJbmRleCk7XG4gICAgICB2YXIgb2xkbGVuID0gb2ZyLmxlbmd0aDtcblxuICAgICAgLy8gY3JlYXRpbmcgYSAxLWVsZW1lbnQgcmVzdWx0c2V0IHRvIHJ1biBmaWx0ZXIgY2hhaW4gb3BzIG9uIHRvIHNlZSBpZiB0aGF0IGRvYyBwYXNzZXMgZmlsdGVycztcbiAgICAgIC8vIG1vc3RseSBlZmZpY2llbnQgYWxnb3JpdGhtLCBzbGlnaHQgc3RhY2sgb3ZlcmhlYWQgcHJpY2UgKHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGluc2VydHMgYW5kIHVwZGF0ZXMpXG4gICAgICB2YXIgZXZhbFJlc3VsdHNldCA9IG5ldyBSZXN1bHRzZXQodGhpcy5jb2xsZWN0aW9uKTtcbiAgICAgIGV2YWxSZXN1bHRzZXQuZmlsdGVyZWRyb3dzID0gW29iakluZGV4XTtcbiAgICAgIGV2YWxSZXN1bHRzZXQuZmlsdGVySW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5maWx0ZXJQaXBlbGluZS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5maWx0ZXJQaXBlbGluZVtpZHhdLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmluZCc6XG4gICAgICAgICAgZXZhbFJlc3VsdHNldC5maW5kKHRoaXMuZmlsdGVyUGlwZWxpbmVbaWR4XS52YWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3aGVyZSc6XG4gICAgICAgICAgZXZhbFJlc3VsdHNldC53aGVyZSh0aGlzLmZpbHRlclBpcGVsaW5lW2lkeF0udmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBub3QgYSB0cnVlIHBvc2l0aW9uLCBidXQgLTEgaWYgbm90IHBhc3Mgb3VyIGZpbHRlcihzKSwgMCBpZiBwYXNzZWQgZmlsdGVyKHMpXG4gICAgICB2YXIgbmV3UG9zID0gKGV2YWxSZXN1bHRzZXQuZmlsdGVyZWRyb3dzLmxlbmd0aCA9PT0gMCkgPyAtMSA6IDA7XG5cbiAgICAgIC8vIHdhc24ndCBpbiBvbGQsIHNob3VsZG4ndCBiZSBub3cuLi4gZG8gbm90aGluZ1xuICAgICAgaWYgKG9sZFBvcyA9PSAtMSAmJiBuZXdQb3MgPT0gLTEpIHJldHVybjtcblxuICAgICAgLy8gd2Fzbid0IGluIHJlc3VsdHNldCwgc2hvdWxkIGJlIG5vdy4uLiBhZGRcbiAgICAgIGlmIChvbGRQb3MgPT09IC0xICYmIG5ld1BvcyAhPT0gLTEpIHtcbiAgICAgICAgb2ZyLnB1c2gob2JqSW5kZXgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgICAgICAgIHRoaXMucmVzdWx0ZGF0YS5wdXNoKHRoaXMuY29sbGVjdGlvbi5kYXRhW29iakluZGV4XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZWVkIHRvIHJlLXNvcnQgdG8gc29ydCBuZXcgZG9jdW1lbnRcbiAgICAgICAgaWYgKHRoaXMuc29ydEZ1bmN0aW9uIHx8IHRoaXMuc29ydENyaXRlcmlhKSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZVNvcnRQaGFzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVldWVSZWJ1aWxkRXZlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2FzIGluIHJlc3VsdHNldCwgc2hvdWxkbid0IGJlIG5vdy4uLiBkZWxldGVcbiAgICAgIGlmIChvbGRQb3MgIT09IC0xICYmIG5ld1BvcyA9PT0gLTEpIHtcbiAgICAgICAgaWYgKG9sZFBvcyA8IG9sZGxlbiAtIDEpIHtcbiAgICAgICAgICAvLyBodHRwOi8vZHZvbHZyLmRhdmlkd2F0ZXJzdG9uLmNvbS8yMDEzLzA2LzA5L3Jlc3RhdGluZy10aGUtb2J2aW91cy10aGUtZmFzdGVzdC13YXktdG8tdHJ1bmNhdGUtYW4tYXJyYXktaW4tamF2YXNjcmlwdC9jb21tZW50LXBhZ2UtMS9cbiAgICAgICAgICBvZnJbb2xkUG9zXSA9IG9mcltvbGRsZW4gLSAxXTtcbiAgICAgICAgICBvZnIubGVuZ3RoID0gb2xkbGVuIC0gMTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRkYXRhW29sZFBvc10gPSB0aGlzLnJlc3VsdGRhdGFbb2xkbGVuIC0gMV07XG4gICAgICAgICAgICB0aGlzLnJlc3VsdGRhdGEubGVuZ3RoID0gb2xkbGVuIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZyLmxlbmd0aCA9IG9sZGxlbiAtIDE7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ZGF0YS5sZW5ndGggPSBvbGRsZW4gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluIGNhc2UgY2hhbmdlcyB0byBkYXRhIGFsdGVyZWQgYSBzb3J0IGNvbHVtblxuICAgICAgICBpZiAodGhpcy5zb3J0RnVuY3Rpb24gfHwgdGhpcy5zb3J0Q3JpdGVyaWEpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlU29ydFBoYXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZVJlYnVpbGRFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3YXMgaW4gcmVzdWx0c2V0LCBzaG91bGQgc3RpbGwgYmUgbm93Li4uICh1cGRhdGUgcGVyc2lzdGVudCBvbmx5PylcbiAgICAgIGlmIChvbGRQb3MgIT09IC0xICYmIG5ld1BvcyAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBkb2N1bWVudCBjaGFuZ2VkLCByZXBsYWNlIHBlcnNpc3RlbnQgdmlldyBkYXRhIHdpdGggdGhlIGxhdGVzdCBjb2xsZWN0aW9uLmRhdGEgZG9jdW1lbnRcbiAgICAgICAgICB0aGlzLnJlc3VsdGRhdGFbb2xkUG9zXSA9IHRoaXMuY29sbGVjdGlvbi5kYXRhW29iakluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluIGNhc2UgY2hhbmdlcyB0byBkYXRhIGFsdGVyZWQgYSBzb3J0IGNvbHVtblxuICAgICAgICBpZiAodGhpcy5zb3J0RnVuY3Rpb24gfHwgdGhpcy5zb3J0Q3JpdGVyaWEpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlU29ydFBoYXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWV1ZVJlYnVpbGRFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmVEb2N1bWVudCgpIC0gaW50ZXJuYWwgZnVuY3Rpb24gY2FsbGVkIG9uIGNvbGxlY3Rpb24uZGVsZXRlKClcbiAgICAgKi9cbiAgICBEeW5hbWljVmlldy5wcm90b3R5cGUucmVtb3ZlRG9jdW1lbnQgPSBmdW5jdGlvbiAob2JqSW5kZXgpIHtcbiAgICAgIHZhciBvZnIgPSB0aGlzLnJlc3VsdHNldC5maWx0ZXJlZHJvd3M7XG4gICAgICB2YXIgb2xkUG9zID0gb2ZyLmluZGV4T2YoK29iakluZGV4KTtcbiAgICAgIHZhciBvbGRsZW4gPSBvZnIubGVuZ3RoO1xuICAgICAgdmFyIGlkeDtcblxuICAgICAgaWYgKG9sZFBvcyAhPT0gLTEpIHtcbiAgICAgICAgLy8gaWYgbm90IGxhc3Qgcm93IGluIHJlc3VsdGRhdGEsIHN3YXAgbGFzdCB0byBob2xlIGFuZCB0cnVuY2F0ZSBsYXN0IHJvd1xuICAgICAgICBpZiAob2xkUG9zIDwgb2xkbGVuIC0gMSkge1xuICAgICAgICAgIG9mcltvbGRQb3NdID0gb2ZyW29sZGxlbiAtIDFdO1xuICAgICAgICAgIG9mci5sZW5ndGggPSBvbGRsZW4gLSAxO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdGRhdGFbb2xkUG9zXSA9IHRoaXMucmVzdWx0ZGF0YVtvbGRsZW4gLSAxXTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ZGF0YS5sZW5ndGggPSBvbGRsZW4gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsYXN0IHJvdywgc28ganVzdCB0cnVuY2F0ZSBsYXN0IHJvd1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvZnIubGVuZ3RoID0gb2xkbGVuIC0gMTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRkYXRhLmxlbmd0aCA9IG9sZGxlbiAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW4gY2FzZSBjaGFuZ2VzIHRvIGRhdGEgYWx0ZXJlZCBhIHNvcnQgY29sdW1uXG4gICAgICAgIGlmICh0aGlzLnNvcnRGdW5jdGlvbiB8fCB0aGlzLnNvcnRDcml0ZXJpYSkge1xuICAgICAgICAgIHRoaXMucXVldWVTb3J0UGhhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzaW5jZSB3ZSBhcmUgdXNpbmcgZmlsdGVyZWRyb3dzIHRvIHN0b3JlIGRhdGEgYXJyYXkgcG9zaXRpb25zXG4gICAgICAvLyBpZiB0aGV5IHJlbW92ZSBhIGRvY3VtZW50ICh3aGV0aGVyIGluIG91ciB2aWV3IG9yIG5vdCksXG4gICAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBhcnJheSBwb3NpdGlvbnMgLTEgZm9yIGFsbCBkb2N1bWVudCBhcnJheSByZWZlcmVuY2VzIGFmdGVyIHRoYXQgcG9zaXRpb25cbiAgICAgIG9sZGxlbiA9IG9mci5sZW5ndGg7XG4gICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IG9sZGxlbjsgaWR4KyspIHtcbiAgICAgICAgaWYgKG9mcltpZHhdID4gb2JqSW5kZXgpIHtcbiAgICAgICAgICBvZnJbaWR4XS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1hcFJlZHVjZSgpIC0gZGF0YSB0cmFuc2Zvcm1hdGlvbiB2aWEgdXNlciBzdXBwbGllZCBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1hcEZ1bmN0aW9uIC0gdGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgc2luZ2xlIGRvY3VtZW50IGZvciB5b3UgdG8gdHJhbnNmb3JtIGFuZCByZXR1cm5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWR1Y2VGdW5jdGlvbiAtIHRoaXMgZnVuY3Rpb24gYWNjZXB0cyBtYW55IChhcnJheSBvZiBtYXAgb3V0cHV0cykgYW5kIHJldHVybnMgc2luZ2xlIHZhbHVlXG4gICAgICogQHJldHVybnMgVGhlIG91dHB1dCBvZiB5b3VyIHJlZHVjZUZ1bmN0aW9uXG4gICAgICovXG4gICAgRHluYW1pY1ZpZXcucHJvdG90eXBlLm1hcFJlZHVjZSA9IGZ1bmN0aW9uIChtYXBGdW5jdGlvbiwgcmVkdWNlRnVuY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZWR1Y2VGdW5jdGlvbih0aGlzLmRhdGEoKS5tYXAobWFwRnVuY3Rpb24pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQ29sbGVjdGlvbiBjbGFzcyB0aGF0IGhhbmRsZXMgZG9jdW1lbnRzIG9mIHNhbWUgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIG5hbWVcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0byBiZSBpbmRpY2l6ZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIC8vIHRoZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG5cbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAvLyB0aGUgZGF0YSBoZWxkIGJ5IHRoZSBjb2xsZWN0aW9uXG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIHRoaXMuaWRJbmRleCA9IFtdOyAvLyBpbmRleCBvZiBpZFxuICAgICAgdGhpcy5iaW5hcnlJbmRpY2VzID0ge307IC8vIHVzZXIgZGVmaW5lZCBpbmRleGVzXG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0ge1xuICAgICAgICB1bmlxdWU6IHt9LFxuICAgICAgICBleGFjdDoge31cbiAgICAgIH07XG5cbiAgICAgIC8vIHVuaXF1ZSBjb250cmFpbnRzIGNvbnRhaW4gZHVwbGljYXRlIG9iamVjdCByZWZlcmVuY2VzLCBzbyB0aGV5IGFyZSBub3QgcGVyc2lzdGVkLlxuICAgICAgLy8gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIHByb3BlcnRpZXMgd2hpY2ggaGF2ZSB1bmlxdWUgY29udHJhaW50IGFwcGxpZWQgaGVyZSwgYW5kIHJlZ2VuZXJhdGUgb24gbG9hZFxuICAgICAgdGhpcy51bmlxdWVOYW1lcyA9IFtdO1xuXG4gICAgICAvLyB0cmFuc2Zvcm1zIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBmcmVxdWVudGx5IHVzZWQgcXVlcnkgY2hhaW5zIGFzIGEgc2VyaWVzIG9mIHN0ZXBzXG4gICAgICAvLyB3aGljaCBpdHNlbGYgY2FuIGJlIHN0b3JlZCBhbG9uZyB3aXRoIHRoZSBkYXRhYmFzZS5cbiAgICAgIHRoaXMudHJhbnNmb3JtcyA9IHt9O1xuXG4gICAgICAvLyB0aGUgb2JqZWN0IHR5cGUgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICAgIHRoaXMub2JqVHlwZSA9IG5hbWU7XG5cbiAgICAgIC8vIGluIGF1dG9zYXZlIHNjZW5hcmlvcyB3ZSB3aWxsIHVzZSBjb2xsZWN0aW9uIGxldmVsIGRpcnR5IGZsYWdzIHRvIGRldGVybWluZSB3aGV0aGVyIHNhdmUgaXMgbmVlZGVkLlxuICAgICAgLy8gY3VycmVudGx5LCBpZiBhbnkgY29sbGVjdGlvbiBpcyBkaXJ0eSB3ZSB3aWxsIGF1dG9zYXZlIHRoZSB3aG9sZSBkYXRhYmFzZSBpZiBhdXRvc2F2ZSBpcyBjb25maWd1cmVkLlxuICAgICAgLy8gZGVmYXVsdGluZyB0byB0cnVlIHNpbmNlIHRoaXMgaXMgY2FsbGVkIGZyb20gYWRkQ29sbGVjdGlvbiBhbmQgYWRkaW5nIGEgY29sbGVjdGlvbiBzaG91bGQgdHJpZ2dlciBzYXZlXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgLy8gcHJpdmF0ZSBob2xkZXJzIGZvciBjYWNoZWQgZGF0YVxuICAgICAgdGhpcy5jYWNoZWRJbmRleCA9IG51bGw7XG4gICAgICB0aGlzLmNhY2hlZEJpbmFyeUluZGV4ID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIC8qIE9QVElPTlMgKi9cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBleGFjdCBtYXRjaCBhbmQgdW5pcXVlIGNvbnN0cmFpbnRzXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndW5pcXVlJykpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMudW5pcXVlKSkge1xuICAgICAgICAgIG9wdGlvbnMudW5pcXVlID0gW29wdGlvbnMudW5pcXVlXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnVuaXF1ZS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgc2VsZi51bmlxdWVOYW1lcy5wdXNoKHByb3ApOyAvLyB1c2VkIHRvIHJlZ2VuZXJhdGUgb24gc3Vic2VxdWVudCBkYXRhYmFzZSBsb2Fkc1xuICAgICAgICAgIHNlbGYuY29uc3RyYWludHMudW5pcXVlW3Byb3BdID0gbmV3IFVuaXF1ZUluZGV4KHByb3ApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2V4YWN0JykpIHtcbiAgICAgICAgb3B0aW9ucy5leGFjdC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgc2VsZi5jb25zdHJhaW50cy5leGFjdFtwcm9wXSA9IG5ldyBFeGFjdEluZGV4KHByb3ApO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXMgY29sbGVjdGlvbiB0cmFuc2FjdGlvbmFsXG4gICAgICB0aGlzLnRyYW5zYWN0aW9uYWwgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCd0cmFuc2FjdGlvbmFsJykgPyBvcHRpb25zLnRyYW5zYWN0aW9uYWwgOiBmYWxzZTtcblxuICAgICAgLy8gb3B0aW9ucyB0byBjbG9uZSBvYmplY3RzIHdoZW4gaW5zZXJ0aW5nIHRoZW1cbiAgICAgIHRoaXMuY2xvbmVPYmplY3RzID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY2xvbmUnKSA/IG9wdGlvbnMuY2xvbmUgOiBmYWxzZTtcblxuICAgICAgLy8gZGVmYXVsdCBjbG9uZSBtZXRob2QgKGlmIGVuYWJsZWQpIGlzIHBhcnNlLXN0cmluZ2lmeVxuICAgICAgdGhpcy5jbG9uZU1ldGhvZCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Nsb25lbWV0aG9kJykgPyBvcHRpb25zLmNsb25lTWV0aG9kIDogXCJwYXJzZS1zdHJpbmdpZnlcIjtcblxuICAgICAgLy8gb3B0aW9uIHRvIG1ha2UgZXZlbnQgbGlzdGVuZXJzIGFzeW5jLCBkZWZhdWx0IGlzIHN5bmNcbiAgICAgIHRoaXMuYXN5bmNMaXN0ZW5lcnMgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdhc3luY0xpc3RlbmVycycpID8gb3B0aW9ucy5hc3luY0xpc3RlbmVycyA6IGZhbHNlO1xuXG4gICAgICAvLyBkaXNhYmxlIHRyYWNrIGNoYW5nZXNcbiAgICAgIHRoaXMuZGlzYWJsZUNoYW5nZXNBcGkgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdkaXNhYmxlQ2hhbmdlc0FwaScpID8gb3B0aW9ucy5kaXNhYmxlQ2hhbmdlc0FwaSA6IHRydWU7XG5cbiAgICAgIC8vIG9wdGlvbiB0byBvYnNlcnZlIG9iamVjdHMgYW5kIHVwZGF0ZSB0aGVtIGF1dG9tYXRpY2FsbHksIGlnbm9yZWQgaWYgT2JqZWN0Lm9ic2VydmUgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgdGhpcy5hdXRvdXBkYXRlID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYXV0b3VwZGF0ZScpID8gb3B0aW9ucy5hdXRvdXBkYXRlIDogZmFsc2U7XG5cbiAgICAgIC8vIGN1cnJlbnRNYXhJZCAtIGNoYW5nZSBtYW51YWxseSBhdCB5b3VyIG93biBwZXJpbCFcbiAgICAgIHRoaXMubWF4SWQgPSAwO1xuXG4gICAgICB0aGlzLkR5bmFtaWNWaWV3cyA9IFtdO1xuXG4gICAgICAvLyBldmVudHNcbiAgICAgIHRoaXMuZXZlbnRzID0ge1xuICAgICAgICAnaW5zZXJ0JzogW10sXG4gICAgICAgICd1cGRhdGUnOiBbXSxcbiAgICAgICAgJ3ByZS1pbnNlcnQnOiBbXSxcbiAgICAgICAgJ3ByZS11cGRhdGUnOiBbXSxcbiAgICAgICAgJ2Nsb3NlJzogW10sXG4gICAgICAgICdmbHVzaGJ1ZmZlcic6IFtdLFxuICAgICAgICAnZXJyb3InOiBbXSxcbiAgICAgICAgJ2RlbGV0ZSc6IFtdLFxuICAgICAgICAnd2FybmluZyc6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBjaGFuZ2VzIGFyZSB0cmFja2VkIGJ5IGNvbGxlY3Rpb24gYW5kIGFnZ3JlZ2F0ZWQgYnkgdGhlIGRiXG4gICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcblxuICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaWQgaW5kZXhcbiAgICAgIHRoaXMuZW5zdXJlSWQoKTtcbiAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAvLyBpbml0aWFsaXplIG9wdGlvbmFsIHVzZXItc3VwcGxpZWQgaW5kaWNlcyBhcnJheSBbJ2FnZScsICdsbmFtZScsICd6aXAnXVxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRpY2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0aW9ucy5pbmRpY2VzKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgIGluZGljZXMgPSBvcHRpb25zLmluZGljZXM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5kaWNlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpbmRpY2VzID0gW29wdGlvbnMuaW5kaWNlc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5kaWNlcyBuZWVkcyB0byBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgaW5kaWNlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlSW5kZXgoaW5kaWNlc1tpZHhdKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb2JzZXJ2ZXJDYWxsYmFjayhjaGFuZ2VzKSB7XG5cbiAgICAgICAgdmFyIGNoYW5nZWRPYmplY3RzID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBTZXQoKSA6IFtdO1xuXG4gICAgICAgIGlmKCFjaGFuZ2VkT2JqZWN0cy5hZGQpXG4gICAgICAgICAgY2hhbmdlZE9iamVjdHMuYWRkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICBpZih0aGlzLmluZGV4T2Yob2JqZWN0KSA9PT0gLTEpXG4gICAgICAgICAgICAgIHRoaXMucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfTtcblxuICAgICAgICBjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgIGNoYW5nZWRPYmplY3RzLmFkZChjaGFuZ2Uub2JqZWN0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2hhbmdlZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgaWYoIW9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnJGxva2knKSlcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnJlbW92ZUF1dG9VcGRhdGVPYnNlcnZlcihvYmplY3QpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZShvYmplY3QpO1xuICAgICAgICAgIH0gY2F0Y2goZXJyKSB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vYnNlcnZlckNhbGxiYWNrID0gb2JzZXJ2ZXJDYWxsYmFjaztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIGFuIG9iamVjdCBhbmQgYXNzb2NpYXRlcyBvcGVyYXRpb24gYW5kIGNvbGxlY3Rpb24gbmFtZSxcbiAgICAgICAqIHNvIHRoZSBwYXJlbnQgZGIgY2FuIGFnZ3JlZ2F0ZSBhbmQgZ2VuZXJhdGUgYSBjaGFuZ2VzIG9iamVjdCBmb3IgdGhlIGVudGlyZSBkYlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjcmVhdGVDaGFuZ2UobmFtZSwgb3AsIG9iaikge1xuICAgICAgICBzZWxmLmNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBvcGVyYXRpb246IG9wLFxuICAgICAgICAgIG9iajogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gY2xlYXIgYWxsIHRoZSBjaGFuZ2VzXG4gICAgICBmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG4gICAgICAgIHNlbGYuY2hhbmdlcyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdldENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYW5nZXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmZsdXNoQ2hhbmdlcyA9IGZsdXNoQ2hhbmdlcztcblxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0aGUgY2hhbmdlcyBBUEkgaXMgZGlzYWJsZWQgbWFrZSBzdXJlIG9ubHkgbWV0YWRhdGEgaXMgYWRkZWQgd2l0aG91dCByZS1ldmFsdWF0aW5nIGV2ZXJ5dGltZSBpZiB0aGUgY2hhbmdlc0FwaSBpcyBlbmFibGVkXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGluc2VydE1ldGEob2JqKSB7XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2JqLm1ldGEpIHtcbiAgICAgICAgICBvYmoubWV0YSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLm1ldGEuY3JlYXRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIG9iai5tZXRhLnJldmlzaW9uID0gMDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlTWV0YShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb2JqLm1ldGEudXBkYXRlZCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgIG9iai5tZXRhLnJldmlzaW9uICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUluc2VydENoYW5nZShvYmopIHtcbiAgICAgICAgY3JlYXRlQ2hhbmdlKHNlbGYubmFtZSwgJ0knLCBvYmopO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGVDaGFuZ2Uob2JqKSB7XG4gICAgICAgIGNyZWF0ZUNoYW5nZShzZWxmLm5hbWUsICdVJywgb2JqKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW5zZXJ0TWV0YVdpdGhDaGFuZ2Uob2JqKSB7XG4gICAgICAgIGluc2VydE1ldGEob2JqKTtcbiAgICAgICAgY3JlYXRlSW5zZXJ0Q2hhbmdlKG9iaik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZU1ldGFXaXRoQ2hhbmdlKG9iaikge1xuICAgICAgICB1cGRhdGVNZXRhKG9iaik7XG4gICAgICAgIGNyZWF0ZVVwZGF0ZUNoYW5nZShvYmopO1xuICAgICAgfVxuXG5cbiAgICAgIC8qIGFzc2lnbiBjb3JyZWN0IGhhbmRsZXIgYmFzZWQgb24gQ2hhbmdlc0FQSSBmbGFnICovXG4gICAgICB2YXIgaW5zZXJ0SGFuZGxlciwgdXBkYXRlSGFuZGxlcjtcblxuICAgICAgZnVuY3Rpb24gc2V0SGFuZGxlcnMoKSB7XG4gICAgICAgIGluc2VydEhhbmRsZXIgPSBzZWxmLmRpc2FibGVDaGFuZ2VzQXBpID8gaW5zZXJ0TWV0YSA6IGluc2VydE1ldGFXaXRoQ2hhbmdlO1xuICAgICAgICB1cGRhdGVIYW5kbGVyID0gc2VsZi5kaXNhYmxlQ2hhbmdlc0FwaSA/IHVwZGF0ZU1ldGEgOiB1cGRhdGVNZXRhV2l0aENoYW5nZTtcbiAgICAgIH1cblxuICAgICAgc2V0SGFuZGxlcnMoKTtcblxuICAgICAgdGhpcy5zZXRDaGFuZ2VzQXBpID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5kaXNhYmxlQ2hhbmdlc0FwaSA9ICFlbmFibGVkO1xuICAgICAgICBzZXRIYW5kbGVycygpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogYnVpbHQtaW4gZXZlbnRzXG4gICAgICAgKi9cbiAgICAgIHRoaXMub24oJ2luc2VydCcsIGZ1bmN0aW9uIGluc2VydENhbGxiYWNrKG9iaikge1xuICAgICAgICBpbnNlcnRIYW5kbGVyKG9iaik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbigndXBkYXRlJywgZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2sob2JqKSB7XG4gICAgICAgIHVwZGF0ZUhhbmRsZXIob2JqKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm9uKCdkZWxldGUnLCBmdW5jdGlvbiBkZWxldGVDYWxsYmFjayhvYmopIHtcbiAgICAgICAgaWYgKCFzZWxmLmRpc2FibGVDaGFuZ2VzQXBpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hhbmdlKHNlbGYubmFtZSwgJ1InLCBvYmopO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbignd2FybmluZycsIGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICAgIHNlbGYuY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgICAgfSk7XG4gICAgICAvLyBmb3IgZGUtc2VyaWFsaXphdGlvbiBwdXJwb3Nlc1xuICAgICAgZmx1c2hDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBuZXcgTG9raUV2ZW50RW1pdHRlcigpO1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc29sZSA9IHtcbiAgICAgIGxvZzogZnVuY3Rpb24gKCkge30sXG4gICAgICB3YXJuOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7fSxcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkQXV0b1VwZGF0ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuXG4gICAgICBpZighdGhpcy5hdXRvdXBkYXRlIHx8IHR5cGVvZiBPYmplY3Qub2JzZXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBPYmplY3Qub2JzZXJ2ZShvYmplY3QsIHRoaXMub2JzZXJ2ZXJDYWxsYmFjaywgWydhZGQnLCAndXBkYXRlJywgJ2RlbGV0ZScsICdyZWNvbmZpZ3VyZScsICdzZXRQcm90b3R5cGUnXSk7XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZUF1dG9VcGRhdGVPYnNlcnZlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmKCF0aGlzLmF1dG91cGRhdGUgfHwgdHlwZW9mIE9iamVjdC5vYnNlcnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIE9iamVjdC51bm9ic2VydmUob2JqZWN0LCB0aGlzLm9ic2VydmVyQ2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImEgdHJhbnNmb3JtIGJ5IHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFuc2Zvcm1zW25hbWVdID0gdHJhbnNmb3JtO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAobmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybXNbbmFtZV0gPSB0cmFuc2Zvcm07XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy50cmFuc2Zvcm1zW25hbWVdO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5ieUV4YW1wbGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgIHZhciBrLCBvYmosIHF1ZXJ5O1xuICAgICAgcXVlcnkgPSBbXTtcbiAgICAgIGZvciAoayBpbiB0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoIXRlbXBsYXRlLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgICAgICAgcXVlcnkucHVzaCgoXG4gICAgICAgICAgb2JqID0ge30sXG4gICAgICAgICAgb2JqW2tdID0gdGVtcGxhdGVba10sXG4gICAgICAgICAgb2JqXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJyRhbmQnOiBxdWVyeVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9iamVjdCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSh0aGlzLmJ5RXhhbXBsZSh0ZW1wbGF0ZSkpO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT2JqZWN0cyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZCh0aGlzLmJ5RXhhbXBsZSh0ZW1wbGF0ZSkpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgfCBJTkRFWElORyAgICAgICAgICAgICAgICAgICAgfFxuICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZSBiaW5hcnkgaW5kZXggb24gYSBjZXJ0YWluIGZpZWxkXG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZW5zdXJlSW5kZXggPSBmdW5jdGlvbiAocHJvcGVydHksIGZvcmNlKSB7XG4gICAgICAvLyBvcHRpb25hbCBwYXJhbWV0ZXIgdG8gZm9yY2UgcmVidWlsZCB3aGV0aGVyIGZsYWdnZWQgYXMgZGlydHkgb3Igbm90XG4gICAgICBpZiAodHlwZW9mIChmb3JjZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gbnVsbCB8fCBwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBzZXQgaW5kZXggd2l0aG91dCBhbiBhc3NvY2lhdGVkIHByb3BlcnR5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJpbmFyeUluZGljZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmICFmb3JjZSkge1xuICAgICAgICBpZiAoIXRoaXMuYmluYXJ5SW5kaWNlc1twcm9wZXJ0eV0uZGlydHkpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iaW5hcnlJbmRpY2VzW3Byb3BlcnR5XSA9IHtcbiAgICAgICAgJ25hbWUnOiBwcm9wZXJ0eSxcbiAgICAgICAgJ2RpcnR5JzogdHJ1ZSxcbiAgICAgICAgJ3ZhbHVlcyc6IFtdXG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXgsIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgICBpbmRleCA9IHRoaXMuYmluYXJ5SW5kaWNlc1twcm9wZXJ0eV07XG5cbiAgICAgIC8vIGluaXRpYWxpemUgaW5kZXggdmFsdWVzXG4gICAgICBmb3IgKGk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpbmRleC52YWx1ZXMucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdyYXBwZWRDb21wYXJlciA9XG4gICAgICAgIChmdW5jdGlvbiAocHJvcCwgY29sbCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgdmFyIG9iajEgPSBjb2xsLmRhdGFbYV07XG4gICAgICAgICAgICB2YXIgb2JqMiA9IGNvbGwuZGF0YVtiXTtcblxuICAgICAgICAgICAgaWYgKG9iajFbcHJvcF0gPT09IG9iajJbcHJvcF0pIHJldHVybiAwO1xuICAgICAgICAgICAgaWYgKGd0SGVscGVyKG9iajFbcHJvcF0sIG9iajJbcHJvcF0pKSByZXR1cm4gMTtcbiAgICAgICAgICAgIGlmIChsdEhlbHBlcihvYmoxW3Byb3BdLCBvYmoyW3Byb3BdKSkgcmV0dXJuIC0xO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHByb3BlcnR5LCB0aGlzKTtcblxuICAgICAgaW5kZXgudmFsdWVzLnNvcnQod3JhcHBlZENvbXBhcmVyKTtcbiAgICAgIGluZGV4LmRpcnR5ID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyBmb3IgYXV0b3NhdmUgc2NlbmFyaW9zXG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmVuc3VyZVVuaXF1ZUluZGV4ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuY29uc3RyYWludHMudW5pcXVlW2ZpZWxkXTtcbiAgICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBuZXcgdW5pcXVlIGluZGV4IGZvciByZWdlbmVyYXRlIGFmdGVyIGRhdGFiYXNlIChyZSlsb2FkLlxuICAgICAgICBpZiAodGhpcy51bmlxdWVOYW1lcy5pbmRleE9mKGZpZWxkKSA9PSAtMSkge1xuICAgICAgICAgIHRoaXMudW5pcXVlTmFtZXMucHVzaChmaWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdHJhaW50cy51bmlxdWVbZmllbGRdID0gaW5kZXggPSBuZXcgVW5pcXVlSW5kZXgoZmllbGQpO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpbmRleC5zZXQob2JqKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYWxsIGJpbmFyeSBpbmRpY2VzXG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZW5zdXJlQWxsSW5kZXhlcyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgdmFyIG9iaktleXMgPSBPYmplY3Qua2V5cyh0aGlzLmJpbmFyeUluZGljZXMpO1xuXG4gICAgICB2YXIgaSA9IG9iaktleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB0aGlzLmVuc3VyZUluZGV4KG9iaktleXNbaV0sIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmxhZ0JpbmFyeUluZGV4ZXNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBvYmpLZXlzID0gT2JqZWN0LmtleXModGhpcy5iaW5hcnlJbmRpY2VzKTtcblxuICAgICAgdmFyIGkgPSBvYmpLZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5iaW5hcnlJbmRpY2VzW29iaktleXNbaV1dLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmxhZ0JpbmFyeUluZGV4RGlydHkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIGlmKHRoaXMuYmluYXJ5SW5kaWNlc1tpbmRleF0pXG4gICAgICAgIHRoaXMuYmluYXJ5SW5kaWNlc1tpbmRleF0uZGlydHkgPSB0cnVlO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgaWYgKCFxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2hhaW4oKS5maW5kKHF1ZXJ5KS5maWx0ZXJlZHJvd3MubGVuZ3RoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWJ1aWxkIGlkSW5kZXhcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lbnN1cmVJZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgICB0aGlzLmlkSW5kZXggPSBbXTtcbiAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuaWRJbmRleC5wdXNoKHRoaXMuZGF0YVtpXS4kbG9raSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlYnVpbGQgaWRJbmRleCBhc3luYyB3aXRoIGNhbGxiYWNrIC0gdXNlZnVsIGZvciBiYWNrZ3JvdW5kIHN5bmNpbmcgd2l0aCBhIHJlbW90ZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5lbnN1cmVJZEFzeW5jID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVJZCgpO1xuICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFYWNoIGNvbGxlY3Rpb24gbWFpbnRhaW5zIGEgbGlzdCBvZiBEeW5hbWljVmlld3MgYXNzb2NpYXRlZCB3aXRoIGl0XG4gICAgICoqL1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkRHluYW1pY1ZpZXcgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGR2ID0gbmV3IER5bmFtaWNWaWV3KHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5EeW5hbWljVmlld3MucHVzaChkdik7XG5cbiAgICAgIHJldHVybiBkdjtcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlRHluYW1pY1ZpZXcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5EeW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGhpcy5EeW5hbWljVmlld3NbaWR4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhpcy5EeW5hbWljVmlld3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0RHluYW1pY1ZpZXcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5EeW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAodGhpcy5EeW5hbWljVmlld3NbaWR4XS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuRHluYW1pY1ZpZXdzW2lkeF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGZpbmQgYW5kIHVwZGF0ZTogcGFzcyBhIGZpbHRlcmluZyBmdW5jdGlvbiB0byBzZWxlY3QgZWxlbWVudHMgdG8gYmUgdXBkYXRlZFxuICAgICAqIGFuZCBhcHBseSB0aGUgdXBkYXRlZnVuY3Rpbm8gdG8gdGhvc2UgZWxlbWVudHMgaXRlcmF0aXZlbHlcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maW5kQW5kVXBkYXRlID0gZnVuY3Rpb24gKGZpbHRlckZ1bmN0aW9uLCB1cGRhdGVGdW5jdGlvbikge1xuXG4gICAgICB2YXIgcmVzdWx0cyA9IHRoaXMud2hlcmUoZmlsdGVyRnVuY3Rpb24pLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgb2JqO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChpOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IHVwZGF0ZUZ1bmN0aW9uKHJlc3VsdHNbaV0pO1xuICAgICAgICAgIHRoaXMudXBkYXRlKG9iaik7XG4gICAgICAgIH1cblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMucm9sbGJhY2soKTtcbiAgICAgICAgdGhpcy5jb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgZG9jdW1lbnQgbWV0aG9kIC0gZW5zdXJlIG9iamVjdHMgaGF2ZSBpZCBhbmQgb2JqVHlwZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRoZSBkb2N1bWVudCB0byBiZSBpbnNlcnRlZCAob3IgYW4gYXJyYXkgb2Ygb2JqZWN0cylcbiAgICAgKiBAcmV0dXJucyBkb2N1bWVudCBvciBkb2N1bWVudHMgKGlmIHBhc3NlZCBhbiBhcnJheSBvZiBvYmplY3RzKVxuICAgICAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChkb2MpIHtcblxuICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdPYmplY3QgY2Fubm90IGJlIG51bGwnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIGhvbGRlciB0byB0aGUgY2xvbmUgb2YgdGhlIG9iamVjdCBpbnNlcnRlZCBpZiBjb2xsZWN0aW9ucyBpcyBzZXQgdG8gY2xvbmUgb2JqZWN0c1xuICAgICAgdmFyIG9iajtcbiAgICAgIHZhciBkb2NzID0gQXJyYXkuaXNBcnJheShkb2MpID8gZG9jIDogW2RvY107XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgZG9jcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEb2N1bWVudCBuZWVkcyB0byBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGNvbmZpZ3VyZWQgdG8gY2xvbmUsIGRvIHNvIG5vdy4uLiBvdGhlcndpc2UganVzdCB1c2Ugc2FtZSBvYmogcmVmZXJlbmNlXG4gICAgICAgIG9iaiA9IHNlbGYuY2xvbmVPYmplY3RzID8gY2xvbmUoZCwgc2VsZi5jbG9uZU1ldGhvZCkgOiBkO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1ldGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgb2JqLm1ldGEgPSB7XG4gICAgICAgICAgICByZXZpc2lvbjogMCxcbiAgICAgICAgICAgIGNyZWF0ZWQ6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW1pdCgncHJlLWluc2VydCcsIG9iaik7XG4gICAgICAgIGlmIChzZWxmLmFkZChvYmopKSB7XG4gICAgICAgICAgc2VsZi5hZGRBdXRvVXBkYXRlT2JzZXJ2ZXIob2JqKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2luc2VydCcsIG9iaik7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cy5sZW5ndGggPT09IDEgPyByZXN1bHRzWzBdIDogcmVzdWx0cztcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIHRoaXMuaWRJbmRleCA9IFtdO1xuICAgICAgdGhpcy5iaW5hcnlJbmRpY2VzID0ge307XG4gICAgICB0aGlzLmNhY2hlZEluZGV4ID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1heElkID0gMDtcbiAgICAgIHRoaXMuRHluYW1pY1ZpZXdzID0gW107XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIG1ldGhvZFxuICAgICAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmJpbmFyeUluZGljZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5mbGFnQmluYXJ5SW5kZXhlc0RpcnR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICAgICAgdmFyIGsgPSAwLFxuICAgICAgICAgIGxlbiA9IGRvYy5sZW5ndGg7XG4gICAgICAgIGZvciAoazsgayA8IGxlbjsgayArPSAxKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUoZG9jW2tdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSBvYmplY3QgaXMgYSBwcm9wZXJseSBmb3JtZWQgZG9jdW1lbnRcbiAgICAgIGlmICghZG9jLmhhc093blByb3BlcnR5KCckbG9raScpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHVwZGF0ZSB1bnN5bmNlZCBkb2N1bWVudC4gUGxlYXNlIHNhdmUgdGhlIGRvY3VtZW50IGZpcnN0IGJ5IHVzaW5nIGluc2VydCgpIG9yIGFkZE1hbnkoKScpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmdldChkb2MuJGxva2ksIHRydWUpLFxuICAgICAgICAgIG9iaixcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoIWFycikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHVwZGF0ZSBhIGRvY3VtZW50IG5vdCBpbiBjb2xsZWN0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncHJlLXVwZGF0ZScsIGRvYyk7XG5cbiAgICAgICAgb2JqID0gYXJyWzBdO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uc3RyYWludHMudW5pcXVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBzZWxmLmNvbnN0cmFpbnRzLnVuaXF1ZVtrZXldLnVwZGF0ZShvYmopO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBnZXQgY3VycmVudCBwb3NpdGlvbiBpbiBkYXRhIGFycmF5XG4gICAgICAgIHBvc2l0aW9uID0gYXJyWzFdO1xuXG4gICAgICAgIC8vIG9wZXJhdGUgdGhlIHVwZGF0ZVxuICAgICAgICB0aGlzLmRhdGFbcG9zaXRpb25dID0gZG9jO1xuXG4gICAgICAgIGlmKG9iaiAhPT0gZG9jKSB7XG4gICAgICAgICAgdGhpcy5hZGRBdXRvVXBkYXRlT2JzZXJ2ZXIoZG9jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyB0aGF0IHdlIGNhbiBlZmZpY2llbnRseSBkZXRlcm1pbmUgdGhlIGRhdGFbXSBwb3NpdGlvbiBvZiBuZXdseSBhZGRlZCBkb2N1bWVudCxcbiAgICAgICAgLy8gc3VibWl0IGl0IGZvciBhbGwgcmVnaXN0ZXJlZCBEeW5hbWljVmlld3MgdG8gZXZhbHVhdGUgZm9yIGluY2x1c2lvbi9leGNsdXNpb25cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5EeW5hbWljVmlld3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIHRoaXMuRHluYW1pY1ZpZXdzW2lkeF0uZXZhbHVhdGVEb2N1bWVudChwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlkSW5kZXhbcG9zaXRpb25dID0gb2JqLiRsb2tpO1xuXG4gICAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyBmb3IgYXV0b3NhdmUgc2NlbmFyaW9zXG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgZG9jKTtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLnJvbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyAoZXJyKTsgLy8gcmUtdGhyb3cgZXJyb3Igc28gdXNlciBkb2VzIG5vdCB0aGluayBpdCBzdWNjZWVkZWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIG9iamVjdCB0byBjb2xsZWN0aW9uXG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgdmFyIGR2bGVuID0gdGhpcy5EeW5hbWljVmlld3MubGVuZ3RoO1xuXG4gICAgICAvLyBpZiBwYXJhbWV0ZXIgaXNuJ3Qgb2JqZWN0IGV4aXQgd2l0aCB0aHJvd1xuICAgICAgaWYgKCdvYmplY3QnICE9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdCBiZWluZyBhZGRlZCBuZWVkcyB0byBiZSBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiB0cnkgYWRkaW5nIG9iamVjdCB0byBjb2xsZWN0aW9uXG4gICAgICAgKi9cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuYmluYXJ5SW5kaWNlcykubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmZsYWdCaW5hcnlJbmRleGVzRGlydHkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgb2JqZWN0IHlvdSBhcmUgYWRkaW5nIGFscmVhZHkgaGFzIGlkIGNvbHVtbiBpdCBpcyBlaXRoZXIgYWxyZWFkeSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgLy8gb3IgdGhlIG9iamVjdCBpcyBjYXJyeWluZyBpdHMgb3duICdpZCcgcHJvcGVydHkuICBJZiBpdCBhbHNvIGhhcyBhIG1ldGEgcHJvcGVydHksXG4gICAgICAvLyB0aGVuIHRoaXMgaXMgYWxyZWFkeSBpbiBjb2xsZWN0aW9uIHNvIHRocm93IGVycm9yLCBvdGhlcndpc2UgcmVuYW1lIHRvIG9yaWdpbmFsSWQgYW5kIGNvbnRpbnVlIGFkZGluZy5cbiAgICAgIGlmICh0eXBlb2YgKG9iai4kbG9raSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBpcyBhbHJlYWR5IGluIGNvbGxlY3Rpb24sIHBsZWFzZSB1c2UgdXBkYXRlKCknKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHRoaXMubWF4SWQrKztcblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5tYXhJZCkpIHtcbiAgICAgICAgICB0aGlzLm1heElkID0gKHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV0uJGxva2kgKyAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kbG9raSA9IHRoaXMubWF4SWQ7XG4gICAgICAgIG9iai5tZXRhLnZlcnNpb24gPSAwO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cy51bmlxdWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIC8vIEZ1bmN0aW9uIHNldCB3aWxsIHRocm93IGVycm9yIHdoZW4gdW5pcXVlIGNvbnN0cmFpbnQgaXMgbm90IGhvbm91cmVkXG4gICAgICAgICAgc2VsZi5jb25zdHJhaW50cy51bmlxdWVba2V5XS5zZXQob2JqKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBvYmplY3RcbiAgICAgICAgdGhpcy5kYXRhLnB1c2gob2JqKTtcblxuICAgICAgICAvLyBub3cgdGhhdCB3ZSBjYW4gZWZmaWNpZW50bHkgZGV0ZXJtaW5lIHRoZSBkYXRhW10gcG9zaXRpb24gb2YgbmV3bHkgYWRkZWQgZG9jdW1lbnQsXG4gICAgICAgIC8vIHN1Ym1pdCBpdCBmb3IgYWxsIHJlZ2lzdGVyZWQgRHluYW1pY1ZpZXdzIHRvIGV2YWx1YXRlIGZvciBpbmNsdXNpb24vZXhjbHVzaW9uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHZsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuRHluYW1pY1ZpZXdzW2ldLmV2YWx1YXRlRG9jdW1lbnQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG5ldyBvYmogaWQgdG8gaWRJbmRleFxuICAgICAgICB0aGlzLmlkSW5kZXgucHVzaChvYmouJGxva2kpO1xuXG4gICAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlOyAvLyBmb3IgYXV0b3NhdmUgc2NlbmFyaW9zXG5cbiAgICAgICAgaWYgKHRoaXMuY2xvbmVPYmplY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmUob2JqLCB0aGlzLmNsb25lTWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMucm9sbGJhY2soKTtcbiAgICAgICAgdGhpcy5jb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgdmFyIGxpc3Q7XG4gICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxpc3QgPSB0aGlzLmRhdGEuZmlsdGVyKHF1ZXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QgPSBuZXcgUmVzdWx0c2V0KHRoaXMsIHF1ZXJ5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlKGxpc3QpO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVEYXRhT25seSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRoaXMuZGF0YS5zbGljZSgpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZGVsZXRlIHdyYXBwZWRcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICBpZiAodHlwZW9mIGRvYyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZG9jID0gdGhpcy5nZXQoZG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdvYmplY3QnICE9PSB0eXBlb2YgZG9jKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW1ldGVyIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICAgICAgdmFyIGsgPSAwLFxuICAgICAgICAgIGxlbiA9IGRvYy5sZW5ndGg7XG4gICAgICAgIGZvciAoazsgayA8IGxlbjsgayArPSAxKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoZG9jW2tdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9jLmhhc093blByb3BlcnR5KCckbG9raScpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGlzIG5vdCBhIGRvY3VtZW50IHN0b3JlZCBpbiB0aGUgY29sbGVjdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5iaW5hcnlJbmRpY2VzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZmxhZ0JpbmFyeUluZGV4ZXNEaXJ0eSgpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnN0YXJ0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuZ2V0KGRvYy4kbG9raSwgdHJ1ZSksXG4gICAgICAgICAgLy8gb2JqID0gYXJyWzBdLFxuICAgICAgICAgIHBvc2l0aW9uID0gYXJyWzFdO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uc3RyYWludHMudW5pcXVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoZG9jW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIGRvY1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2VsZi5jb25zdHJhaW50cy51bmlxdWVba2V5XS5yZW1vdmUoZG9jW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG5vdyB0aGF0IHdlIGNhbiBlZmZpY2llbnRseSBkZXRlcm1pbmUgdGhlIGRhdGFbXSBwb3NpdGlvbiBvZiBuZXdseSBhZGRlZCBkb2N1bWVudCxcbiAgICAgICAgLy8gc3VibWl0IGl0IGZvciBhbGwgcmVnaXN0ZXJlZCBEeW5hbWljVmlld3MgdG8gcmVtb3ZlXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMuRHluYW1pY1ZpZXdzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICB0aGlzLkR5bmFtaWNWaWV3c1tpZHhdLnJlbW92ZURvY3VtZW50KHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YS5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgICAgICB0aGlzLnJlbW92ZUF1dG9VcGRhdGVPYnNlcnZlcihkb2MpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBpZCBmcm9tIGlkSW5kZXhcbiAgICAgICAgdGhpcy5pZEluZGV4LnNwbGljZShwb3NpdGlvbiwgMSk7XG5cbiAgICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7IC8vIGZvciBhdXRvc2F2ZSBzY2VuYXJpb3NcbiAgICAgICAgdGhpcy5lbWl0KCdkZWxldGUnLCBhcnJbMF0pO1xuICAgICAgICBkZWxldGUgZG9jLiRsb2tpO1xuICAgICAgICBkZWxldGUgZG9jLm1ldGE7XG4gICAgICAgIHJldHVybiBkb2M7XG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLnJvbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgfCBGaW5kaW5nIG1ldGhvZHMgICAgIHxcbiAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYnkgSWQgLSBmYXN0ZXIgdGhhbiBvdGhlciBtZXRob2RzIGJlY2F1c2Ugb2YgdGhlIHNlYXJjaGluZyBhbGdvcml0aG1cbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQsIHJldHVyblBvc2l0aW9uKSB7XG5cbiAgICAgIHZhciByZXRwb3MgPSByZXR1cm5Qb3NpdGlvbiB8fCBmYWxzZSxcbiAgICAgICAgZGF0YSA9IHRoaXMuaWRJbmRleCxcbiAgICAgICAgbWF4ID0gZGF0YS5sZW5ndGggLSAxLFxuICAgICAgICBtaW4gPSAwLFxuICAgICAgICBtaWQgPSBNYXRoLmZsb29yKG1pbiArIChtYXggLSBtaW4pIC8gMik7XG5cbiAgICAgIGlkID0gdHlwZW9mIGlkID09PSAnbnVtYmVyJyA/IGlkIDogcGFyc2VJbnQoaWQsIDEwKTtcblxuICAgICAgaWYgKGlzTmFOKGlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXNzZWQgaWQgaXMgbm90IGFuIGludGVnZXInKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGRhdGFbbWluXSA8IGRhdGFbbWF4XSkge1xuXG4gICAgICAgIG1pZCA9IE1hdGguZmxvb3IoKG1pbiArIG1heCkgLyAyKTtcblxuICAgICAgICBpZiAoZGF0YVttaWRdIDwgaWQpIHtcbiAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF4ID09PSBtaW4gJiYgZGF0YVttaW5dID09PSBpZCkge1xuXG4gICAgICAgIGlmIChyZXRwb3MpIHtcbiAgICAgICAgICByZXR1cm4gW3RoaXMuZGF0YVttaW5dLCBtaW5dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbbWluXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmJ5ID0gZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgdmFyIHNlbGY7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuYnkoZmllbGQsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNsb25lT2JqZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50cy51bmlxdWVbZmllbGRdLmdldCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKHRoaXMuY29uc3RyYWludHMudW5pcXVlW2ZpZWxkXS5nZXQodmFsdWUpLCB0aGlzLmNsb25lTWV0aG9kKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCBvbmUgb2JqZWN0IGJ5IGluZGV4IHByb3BlcnR5LCBieSBwcm9wZXJ0eSBlcXVhbCB0byB2YWx1ZVxuICAgICAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmRPbmUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgIC8vIEluc3RhbnRpYXRlIFJlc3VsdHNldCBhbmQgZXhlYyBmaW5kIG9wIHBhc3NpbmcgZmlyc3RPbmx5ID0gdHJ1ZSBwYXJhbVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBSZXN1bHRzZXQodGhpcywgcXVlcnksIG51bGwsIHRydWUpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb25lT2JqZWN0cykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lKHJlc3VsdCwgdGhpcy5jbG9uZU1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhaW4gbWV0aG9kLCB1c2VkIGZvciBiZWdpbm5pbmcgYSBzZXJpZXMgb2YgY2hhaW5lZCBmaW5kKCkgYW5kL29yIHZpZXcoKSBvcGVyYXRpb25zXG4gICAgICogb24gYSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gdHJhbnNmb3JtIDogT3JkZXJlZCBhcnJheSBvZiB0cmFuc2Zvcm0gc3RlcCBvYmplY3RzIHNpbWlsYXIgdG8gY2hhaW5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1ldGVyczogT2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyByZXByZXNlbnRpbmcgcGFyYW1ldGVycyB0byBzdWJzdGl0dXRlXG4gICAgICogQHJldHVybnMge1Jlc3VsdHNldH0gOiAob3IgZGF0YSBhcnJheSBpZiBhbnkgbWFwIG9yIGpvaW4gZnVuY3Rpb25zIHdoZXJlIGNhbGxlZClcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jaGFpbiA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0sIHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBycyA9IG5ldyBSZXN1bHRzZXQodGhpcywgbnVsbCwgbnVsbCk7XG5cbiAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcnM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBycy50cmFuc2Zvcm0odHJhbnNmb3JtLCBwYXJhbWV0ZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCBtZXRob2QsIGFwaSBpcyBzaW1pbGFyIHRvIG1vbmdvZGIgZXhjZXB0IGZvciBub3cgaXQgb25seSBzdXBwb3J0cyBvbmUgc2VhcmNoIHBhcmFtZXRlci5cbiAgICAgKiBmb3IgbW9yZSBjb21wbGV4IHF1ZXJpZXMgdXNlIHZpZXcoKSBhbmQgc3RvcmVWaWV3KClcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICBpZiAodHlwZW9mIChxdWVyeSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHF1ZXJ5ID0gJ2dldEFsbCc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jbG9uZU9iamVjdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRzZXQodGhpcywgcXVlcnksIG51bGwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gbmV3IFJlc3VsdHNldCh0aGlzLCBxdWVyeSwgbnVsbCk7XG5cbiAgICAgICAgcmV0dXJuIGNsb25lT2JqZWN0QXJyYXkocmVzdWx0cywgdGhpcy5jbG9uZU1ldGhvZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmQgb2JqZWN0IGJ5IHVuaW5kZXhlZCBmaWVsZCBieSBwcm9wZXJ0eSBlcXVhbCB0byB2YWx1ZSxcbiAgICAgKiBzaW1wbHkgaXRlcmF0ZXMgYW5kIHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgbWF0Y2hpbmcgdGhlIHF1ZXJ5XG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9uZVVuaW5kZXhlZCA9IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuXG4gICAgICB2YXIgaSA9IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgIGRvYztcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtpXVtwcm9wXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICBkb2MgPSB0aGlzLmRhdGFbaV07XG4gICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zYWN0aW9uIG1ldGhvZHNcbiAgICAgKi9cblxuICAgIC8qKiBzdGFydCB0aGUgdHJhbnNhdGlvbiAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnN0YXJ0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2FjdGlvbmFsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IGNsb25lKHRoaXMuZGF0YSwgdGhpcy5jbG9uZU1ldGhvZCk7XG4gICAgICAgIHRoaXMuY2FjaGVkSW5kZXggPSB0aGlzLmlkSW5kZXg7XG4gICAgICAgIHRoaXMuY2FjaGVkQmluYXJ5SW5kZXggPSB0aGlzLmJpbmFyeUluZGljZXM7XG5cbiAgICAgICAgLy8gcHJvcGFnYXRlIHN0YXJ0VHJhbnNhY3Rpb24gdG8gZHluYW1pYyB2aWV3c1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLkR5bmFtaWNWaWV3cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgdGhpcy5EeW5hbWljVmlld3NbaWR4XS5zdGFydFRyYW5zYWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIGNvbW1pdCB0aGUgdHJhbnNhdGlvbiAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uYWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FjaGVkQmluYXJ5SW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgLy8gcHJvcGFnYXRlIGNvbW1pdCB0byBkeW5hbWljIHZpZXdzXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMuRHluYW1pY1ZpZXdzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICB0aGlzLkR5bmFtaWNWaWV3c1tpZHhdLmNvbW1pdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKiByb2xsIGJhY2sgdGhlIHRyYW5zYXRpb24gKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5yb2xsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkRGF0YSAhPT0gbnVsbCAmJiB0aGlzLmNhY2hlZEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5jYWNoZWREYXRhO1xuICAgICAgICAgIHRoaXMuaWRJbmRleCA9IHRoaXMuY2FjaGVkSW5kZXg7XG4gICAgICAgICAgdGhpcy5iaW5hcnlJbmRpY2VzID0gdGhpcy5jYWNoZWRCaW5hcnlJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb3BhZ2F0ZSByb2xsYmFjayB0byBkeW5hbWljIHZpZXdzXG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMuRHluYW1pY1ZpZXdzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICB0aGlzLkR5bmFtaWNWaWV3c1tpZHhdLnJvbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYXN5bmMgZXhlY3V0b3IuIFRoaXMgaXMgb25seSB0byBlbmFibGUgY2FsbGJhY2tzIGF0IHRoZSBlbmQgb2YgdGhlIGV4ZWN1dGlvbi5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hc3luYyA9IGZ1bmN0aW9uIChmdW4sIGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBmdW4oKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBmb3IgYXN5bmMgZXhlY3V0aW9uIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdmlldyBmdW5jdGlvbiAtIGZpbHRlclxuICAgICAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgaWYgKCF0aGlzLmNsb25lT2JqZWN0cykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdHNldCh0aGlzLCBudWxsLCBmdW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gbmV3IFJlc3VsdHNldCh0aGlzLCBudWxsLCBmdW4pO1xuXG4gICAgICAgIHJldHVybiBjbG9uZU9iamVjdEFycmF5KHJlc3VsdHMsIHRoaXMuY2xvbmVNZXRob2QpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYXAgUmVkdWNlXG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubWFwUmVkdWNlID0gZnVuY3Rpb24gKG1hcEZ1bmN0aW9uLCByZWR1Y2VGdW5jdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZUZ1bmN0aW9uKHRoaXMuZGF0YS5tYXAobWFwRnVuY3Rpb24pKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGVxSm9pbiAtIEpvaW4gdHdvIGNvbGxlY3Rpb25zIG9uIHNwZWNpZmllZCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuZXFKb2luID0gZnVuY3Rpb24gKGpvaW5EYXRhLCBsZWZ0Sm9pblByb3AsIHJpZ2h0Sm9pblByb3AsIG1hcEZ1bikge1xuICAgICAgLy8gbG9naWMgaW4gUmVzdWx0c2V0IGNsYXNzXG4gICAgICByZXR1cm4gbmV3IFJlc3VsdHNldCh0aGlzKS5lcUpvaW4oam9pbkRhdGEsIGxlZnRKb2luUHJvcCwgcmlnaHRKb2luUHJvcCwgbWFwRnVuKTtcbiAgICB9O1xuXG4gICAgLyogLS0tLS0tIFNUQUdJTkcgQVBJIC0tLS0tLS0tICovXG4gICAgLyoqXG4gICAgICogc3RhZ2VzOiBhIG1hcCBvZiB1bmlxdWVseSBpZGVudGlmaWVkICdzdGFnZXMnLCB3aGljaCBob2xkIGNvcGllcyBvZiBvYmplY3RzIHRvIGJlXG4gICAgICogbWFuaXB1bGF0ZWQgd2l0aG91dCBhZmZlY3RpbmcgdGhlIGRhdGEgaW4gdGhlIG9yaWdpbmFsIGNvbGxlY3Rpb25cbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zdGFnZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIHN0YWdlIGFuZC9vciByZXRyaWV2ZSBpdFxuICAgICAqL1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmdldFN0YWdlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5zdGFnZXNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy5zdGFnZXNbbmFtZV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0YWdlc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlY29yZGluZyB0aGUgY2hhbmdlcyBhcHBsaWVkIHRocm91Z2ggYSBjb21tbWl0U3RhZ2VcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb21taXRMb2cgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIGNvcHkgb2YgYW4gb2JqZWN0IGFuZCBpbnNlcnQgaXQgaW50byBhIHN0YWdlXG4gICAgICovXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuc3RhZ2UgPSBmdW5jdGlvbiAoc3RhZ2VOYW1lLCBvYmopIHtcbiAgICAgIHZhciBjb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICAgIHRoaXMuZ2V0U3RhZ2Uoc3RhZ2VOYW1lKVtvYmouJGxva2ldID0gY29weTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiByZS1hdHRhY2ggYWxsIG9iamVjdHMgdG8gdGhlIG9yaWdpbmFsIGNvbGxlY3Rpb24sIHNvIGluZGV4ZXMgYW5kIHZpZXdzIGNhbiBiZSByZWJ1aWx0XG4gICAgICogdGhlbiBjcmVhdGUgYSBtZXNzYWdlIHRvIGJlIGluc2VydGVkIGluIHRoZSBjb21taXRsb2dcbiAgICAgKi9cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5jb21taXRTdGFnZSA9IGZ1bmN0aW9uIChzdGFnZU5hbWUsIG1lc3NhZ2UpIHtcbiAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2Uoc3RhZ2VOYW1lKSxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgdGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIGZvciAocHJvcCBpbiBzdGFnZSkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlKHN0YWdlW3Byb3BdKTtcbiAgICAgICAgdGhpcy5jb21taXRMb2cucHVzaCh7XG4gICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBkYXRhOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YWdlW3Byb3BdKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWdlc1tzdGFnZU5hbWVdID0ge307XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm5vX29wID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgIGlzRG90Tm90YXRpb24gPSBpc0RlZXBQcm9wZXJ0eShmaWVsZCksXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGVlcFByb3BlcnR5KHRoaXMuZGF0YVtpXSwgZmllbGQsIGlzRG90Tm90YXRpb24pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuZXh0cmFjdChmaWVsZCkpO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLmV4dHJhY3QoZmllbGQpKTtcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubWF4UmVjb3JkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgIGxlbiA9IHRoaXMuZGF0YS5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBpc0RlZXBQcm9wZXJ0eShmaWVsZCksXG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIG1heDtcblxuICAgICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG1heCA8IGRlZXBQcm9wZXJ0eSh0aGlzLmRhdGFbaV0sIGZpZWxkLCBkZWVwKSkge1xuICAgICAgICAgICAgbWF4ID0gZGVlcFByb3BlcnR5KHRoaXMuZGF0YVtpXSwgZmllbGQsIGRlZXApO1xuICAgICAgICAgICAgcmVzdWx0LmluZGV4ID0gdGhpcy5kYXRhW2ldLiRsb2tpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXggPSBkZWVwUHJvcGVydHkodGhpcy5kYXRhW2ldLCBmaWVsZCwgZGVlcCk7XG4gICAgICAgICAgcmVzdWx0LmluZGV4ID0gdGhpcy5kYXRhW2ldLiRsb2tpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQudmFsdWUgPSBtYXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5taW5SZWNvcmQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuID0gdGhpcy5kYXRhLmxlbmd0aCxcbiAgICAgICAgZGVlcCA9IGlzRGVlcFByb3BlcnR5KGZpZWxkKSxcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgbWluO1xuXG4gICAgICBmb3IgKGk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAobWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobWluID4gZGVlcFByb3BlcnR5KHRoaXMuZGF0YVtpXSwgZmllbGQsIGRlZXApKSB7XG4gICAgICAgICAgICBtaW4gPSBkZWVwUHJvcGVydHkodGhpcy5kYXRhW2ldLCBmaWVsZCwgZGVlcCk7XG4gICAgICAgICAgICByZXN1bHQuaW5kZXggPSB0aGlzLmRhdGFbaV0uJGxva2k7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pbiA9IGRlZXBQcm9wZXJ0eSh0aGlzLmRhdGFbaV0sIGZpZWxkLCBkZWVwKTtcbiAgICAgICAgICByZXN1bHQuaW5kZXggPSB0aGlzLmRhdGFbaV0uJGxva2k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC52YWx1ZSA9IG1pbjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmV4dHJhY3ROdW1lcmljYWwgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dHJhY3QoZmllbGQpLm1hcChwYXJzZUJhc2UxMCkuZmlsdGVyKE51bWJlcikuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAhKGlzTmFOKG4pKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hdmcgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBhdmVyYWdlKHRoaXMuZXh0cmFjdE51bWVyaWNhbChmaWVsZCkpO1xuICAgIH07XG5cbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5zdGREZXYgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBzdGFuZGFyZERldmlhdGlvbih0aGlzLmV4dHJhY3ROdW1lcmljYWwoZmllbGQpKTtcbiAgICB9O1xuXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIGRpY3QgPSB7fSxcbiAgICAgICAgZGF0YSA9IHRoaXMuZXh0cmFjdChmaWVsZCk7XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoZGljdFtvYmpdKSB7XG4gICAgICAgICAgZGljdFtvYmpdICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGljdFtvYmpdID0gMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgbWF4LFxuICAgICAgICBwcm9wLCBtb2RlO1xuICAgICAgZm9yIChwcm9wIGluIGRpY3QpIHtcbiAgICAgICAgaWYgKG1heCkge1xuICAgICAgICAgIGlmIChtYXggPCBkaWN0W3Byb3BdKSB7XG4gICAgICAgICAgICBtb2RlID0gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZSA9IHByb3A7XG4gICAgICAgICAgbWF4ID0gZGljdFtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLm1lZGlhbiA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZXh0cmFjdE51bWVyaWNhbChmaWVsZCk7XG4gICAgICB2YWx1ZXMuc29ydChzdWIpO1xuXG4gICAgICB2YXIgaGFsZiA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuXG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1toYWxmXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAodmFsdWVzW2hhbGYgLSAxXSArIHZhbHVlc1toYWxmXSkgLyAyLjA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYWwgdXRpbHMsIGluY2x1ZGluZyBzdGF0aXN0aWNhbCBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RlZXBQcm9wZXJ0eShmaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLmluZGV4T2YoJy4nKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VCYXNlMTAobnVtKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0sIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc05vdFVuZGVmaW5lZChvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoYSwgYikge1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVkaWFuKHZhbHVlcykge1xuICAgICAgdmFsdWVzLnNvcnQoc3ViKTtcbiAgICAgIHZhciBoYWxmID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gICAgICByZXR1cm4gKHZhbHVlcy5sZW5ndGggJSAyKSA/IHZhbHVlc1toYWxmXSA6ICgodmFsdWVzW2hhbGYgLSAxXSArIHZhbHVlc1toYWxmXSkgLyAyLjApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF2ZXJhZ2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkucmVkdWNlKGFkZCwgMCkpIC8gYXJyYXkubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YW5kYXJkRGV2aWF0aW9uKHZhbHVlcykge1xuICAgICAgdmFyIGF2ZyA9IGF2ZXJhZ2UodmFsdWVzKTtcbiAgICAgIHZhciBzcXVhcmVEaWZmcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkaWZmID0gdmFsdWUgLSBhdmc7XG4gICAgICAgIHZhciBzcXJEaWZmID0gZGlmZiAqIGRpZmY7XG4gICAgICAgIHJldHVybiBzcXJEaWZmO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBhdmdTcXVhcmVEaWZmID0gYXZlcmFnZShzcXVhcmVEaWZmcyk7XG5cbiAgICAgIHZhciBzdGREZXYgPSBNYXRoLnNxcnQoYXZnU3F1YXJlRGlmZik7XG4gICAgICByZXR1cm4gc3RkRGV2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZXBQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXAgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHBhc3Mgd2l0aG91dCBwcm9jZXNzaW5nXG4gICAgICAgIHJldHVybiBvYmpbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgdmFyIHBpZWNlcyA9IHByb3BlcnR5LnNwbGl0KCcuJyksXG4gICAgICAgIHJvb3QgPSBvYmo7XG4gICAgICB3aGlsZSAocGllY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcm9vdCA9IHJvb3RbcGllY2VzLnNoaWZ0KCldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFycmF5LCBpdGVtLCBmdW4pIHtcbiAgICAgIHZhciBsbyA9IDAsXG4gICAgICAgIGhpID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBjb21wYXJlZCxcbiAgICAgICAgbWlkO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgbWlkID0gKChsbyArIGhpKSAvIDIpIHwgMDtcbiAgICAgICAgY29tcGFyZWQgPSBmdW4uYXBwbHkobnVsbCwgW2l0ZW0sIGFycmF5W21pZF1dKTtcbiAgICAgICAgaWYgKGNvbXBhcmVkID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICAgICAgaW5kZXg6IG1pZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZWQgPCAwKSB7XG4gICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZDogZmFsc2UsXG4gICAgICAgIGluZGV4OiBoaVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCU29uU29ydChmdW4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyYXksIGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaChhcnJheSwgaXRlbSwgZnVuKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gS2V5VmFsdWVTdG9yZSgpIHt9XG5cbiAgICBLZXlWYWx1ZVN0b3JlLnByb3RvdHlwZSA9IHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgdmFsdWVzOiBbXSxcbiAgICAgIHNvcnQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSA8IGIpID8gLTEgOiAoKGEgPiBiKSA/IDEgOiAwKTtcbiAgICAgIH0sXG4gICAgICBzZXRTb3J0OiBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgIHRoaXMuYnMgPSBuZXcgQlNvblNvcnQoZnVuKTtcbiAgICAgIH0sXG4gICAgICBiczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJTb25Tb3J0KHRoaXMuc29ydCk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5icyh0aGlzLmtleXMsIGtleSk7XG4gICAgICAgIGlmIChwb3MuZm91bmQpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlc1twb3MuaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShwb3MuaW5kZXgsIDAsIGtleSk7XG4gICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKHBvcy5pbmRleCwgMCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tiaW5hcnlTZWFyY2godGhpcy5rZXlzLCBrZXksIHRoaXMuc29ydCkuaW5kZXhdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBVbmlxdWVJbmRleCh1bmlxdWVGaWVsZCkge1xuICAgICAgdGhpcy5maWVsZCA9IHVuaXF1ZUZpZWxkO1xuICAgICAgdGhpcy5rZXlNYXAgPSB7fTtcbiAgICAgIHRoaXMubG9raU1hcCA9IHt9O1xuICAgIH1cbiAgICBVbmlxdWVJbmRleC5wcm90b3R5cGUua2V5TWFwID0ge307XG4gICAgVW5pcXVlSW5kZXgucHJvdG90eXBlLmxva2lNYXAgPSB7fTtcbiAgICBVbmlxdWVJbmRleC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKG9ialt0aGlzLmZpZWxkXSAhPT0gbnVsbCAmJiB0eXBlb2YgKG9ialt0aGlzLmZpZWxkXSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0aGlzLmtleU1hcFtvYmpbdGhpcy5maWVsZF1dKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUga2V5IGZvciBwcm9wZXJ0eSAnICsgdGhpcy5maWVsZCArICc6ICcgKyBvYmpbdGhpcy5maWVsZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMua2V5TWFwW29ialt0aGlzLmZpZWxkXV0gPSBvYmo7XG4gICAgICAgICAgdGhpcy5sb2tpTWFwW29iai4kbG9raV0gPSBvYmpbdGhpcy5maWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFVuaXF1ZUluZGV4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlNYXBba2V5XTtcbiAgICB9O1xuXG4gICAgVW5pcXVlSW5kZXgucHJvdG90eXBlLmJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleU1hcFt0aGlzLmxva2lNYXBbaWRdXTtcbiAgICB9O1xuICAgIFVuaXF1ZUluZGV4LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAodGhpcy5sb2tpTWFwW29iai4kbG9raV0gIT09IG9ialt0aGlzLmZpZWxkXSkge1xuICAgICAgICB2YXIgb2xkID0gdGhpcy5sb2tpTWFwW29iai4kbG9raV07XG4gICAgICAgIHRoaXMuc2V0KG9iaik7XG4gICAgICAgIC8vIG1ha2UgdGhlIG9sZCBrZXkgZmFpbCBib29sIHRlc3QsIHdoaWxlIGF2b2lkaW5nIHRoZSB1c2Ugb2YgZGVsZXRlIChtZW0tbGVhayBwcm9uZSlcbiAgICAgICAgdGhpcy5rZXlNYXBbb2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5TWFwW29ialt0aGlzLmZpZWxkXV0gPSBvYmo7XG4gICAgICB9XG4gICAgfTtcbiAgICBVbmlxdWVJbmRleC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMua2V5TWFwW2tleV07XG4gICAgICBpZiAob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMua2V5TWFwW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9raU1hcFtvYmouJGxva2ldID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgaXMgbm90IGluIHVuaXF1ZSBpbmRleDogJyArIHRoaXMuZmllbGQpO1xuICAgICAgfVxuICAgIH07XG4gICAgVW5pcXVlSW5kZXgucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5rZXlNYXAgPSB7fTtcbiAgICAgIHRoaXMubG9raU1hcCA9IHt9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFeGFjdEluZGV4KGV4YWN0RmllbGQpIHtcbiAgICAgIHRoaXMuaW5kZXggPSB7fTtcbiAgICAgIHRoaXMuZmllbGQgPSBleGFjdEZpZWxkO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGUgdmFsdWUgeW91IHdhbnQgcmV0dXJuZWQgdG8gdGhlIGtleSBpbiB0aGUgaW5kZXhcbiAgICBFeGFjdEluZGV4LnByb3RvdHlwZSA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24gYWRkKGtleSwgdmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgICB0aGlzLmluZGV4W2tleV0ucHVzaCh2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5kZXhba2V5XSA9IFt2YWxdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyByZW1vdmUgdGhlIHZhbHVlIGZyb20gdGhlIGluZGV4LCBpZiB0aGUgdmFsdWUgd2FzIHRoZSBsYXN0IG9uZSwgcmVtb3ZlIHRoZSBrZXlcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSwgdmFsKSB7XG4gICAgICAgIHZhciBpZHhTZXQgPSB0aGlzLmluZGV4W2tleV07XG4gICAgICAgIGZvciAodmFyIGkgaW4gaWR4U2V0KSB7XG4gICAgICAgICAgaWYgKGlkeFNldFtpXSA9PSB2YWwpIHtcbiAgICAgICAgICAgIGlkeFNldC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZHhTZXQubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRoaXMuaW5kZXhba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gZ2V0IHRoZSB2YWx1ZXMgcmVsYXRlZCB0byB0aGUga2V5LCBjb3VsZCBiZSBtb3JlIHRoYW4gb25lXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhba2V5XTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIGNsZWFyIHdpbGwgemFwIHRoZSBpbmRleFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKGtleSkge1xuICAgICAgICB0aGlzLmluZGV4ID0ge307XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFNvcnRlZEluZGV4KHNvcnRlZEZpZWxkKSB7XG4gICAgICB0aGlzLmZpZWxkID0gc29ydGVkRmllbGQ7XG4gICAgfVxuXG4gICAgU29ydGVkSW5kZXgucHJvdG90eXBlID0ge1xuICAgICAga2V5czogW10sXG4gICAgICB2YWx1ZXM6IFtdLFxuICAgICAgLy8gc2V0IHRoZSBkZWZhdWx0IHNvcnRcbiAgICAgIHNvcnQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYSA8IGIpID8gLTEgOiAoKGEgPiBiKSA/IDEgOiAwKTtcbiAgICAgIH0sXG4gICAgICBiczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJTb25Tb3J0KHRoaXMuc29ydCk7XG4gICAgICB9LFxuICAgICAgLy8gYW5kIGFsbG93IG92ZXJyaWRlIG9mIHRoZSBkZWZhdWx0IHNvcnRcbiAgICAgIHNldFNvcnQ6IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdGhpcy5icyA9IG5ldyBCU29uU29ydChmdW4pO1xuICAgICAgfSxcbiAgICAgIC8vIGFkZCB0aGUgdmFsdWUgeW91IHdhbnQgcmV0dXJuZWQgIHRvIHRoZSBrZXkgaW4gdGhlIGluZGV4XG4gICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBwb3MgPSBiaW5hcnlTZWFyY2godGhpcy5rZXlzLCBrZXksIHRoaXMuc29ydCk7XG4gICAgICAgIGlmIChwb3MuZm91bmQpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlc1twb3MuaW5kZXhdLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2UocG9zLmluZGV4LCAwLCBrZXkpO1xuICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShwb3MuaW5kZXgsIDAsIFt2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gZ2V0IGFsbCB2YWx1ZXMgd2hpY2ggaGF2ZSBhIGtleSA9PSB0aGUgZ2l2ZW4ga2V5XG4gICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGJzciA9IGJpbmFyeVNlYXJjaCh0aGlzLmtleXMsIGtleSwgdGhpcy5zb3J0KTtcbiAgICAgICAgaWYgKGJzci5mb3VuZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tic3IuaW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGdldCBhbGwgdmFsdWVzIHdoaWNoIGhhdmUgYSBrZXkgPCB0aGUgZ2l2ZW4ga2V5XG4gICAgICBnZXRMdDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgYnNyID0gYmluYXJ5U2VhcmNoKHRoaXMua2V5cywga2V5LCB0aGlzLnNvcnQpO1xuICAgICAgICB2YXIgcG9zID0gYnNyLmluZGV4O1xuICAgICAgICBpZiAoYnNyLmZvdW5kKSBwb3MtLTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKGtleSwgMCwgcG9zKTtcbiAgICAgIH0sXG4gICAgICAvLyBnZXQgYWxsIHZhbHVlcyB3aGljaCBoYXZlIGEga2V5ID4gdGhlIGdpdmVuIGtleVxuICAgICAgZ2V0R3Q6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGJzciA9IGJpbmFyeVNlYXJjaCh0aGlzLmtleXMsIGtleSwgdGhpcy5zb3J0KTtcbiAgICAgICAgdmFyIHBvcyA9IGJzci5pbmRleDtcbiAgICAgICAgaWYgKGJzci5mb3VuZCkgcG9zKys7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbChrZXksIHBvcywgdGhpcy5rZXlzLmxlbmd0aCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBnZXQgYWxsIHZhbHMgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgIGdldEFsbDogZnVuY3Rpb24gKGtleSwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdCh0aGlzLnZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9LFxuICAgICAgLy8ganVzdCBpbiBjYXNlIHNvbWVvbmUgd2FudHMgdG8gZG8gc29tZXRoaW5nIHNtYXJ0IHdpdGggcmFuZ2VzXG4gICAgICBnZXRQb3M6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNlYXJjaCh0aGlzLmtleXMsIGtleSwgdGhpcy5zb3J0KTtcbiAgICAgIH0sXG4gICAgICAvLyByZW1vdmUgdGhlIHZhbHVlIGZyb20gdGhlIGluZGV4LCBpZiB0aGUgdmFsdWUgd2FzIHRoZSBsYXN0IG9uZSwgcmVtb3ZlIHRoZSBrZXlcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBvcyA9IGJpbmFyeVNlYXJjaCh0aGlzLmtleXMsIGtleSwgdGhpcy5zb3J0KS5pbmRleDtcbiAgICAgICAgdmFyIGlkeFNldCA9IHRoaXMudmFsdWVzW3Bvc107XG4gICAgICAgIGZvciAodmFyIGkgaW4gaWR4U2V0KSB7XG4gICAgICAgICAgaWYgKGlkeFNldFtpXSA9PSB2YWx1ZSkgaWR4U2V0LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWR4U2V0Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBjbGVhciB3aWxsIHphcCB0aGUgaW5kZXhcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIExva2kuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG4gICAgTG9raS5LZXlWYWx1ZVN0b3JlID0gS2V5VmFsdWVTdG9yZTtcbiAgICByZXR1cm4gTG9raTtcbiAgfSgpKTtcblxufSkpO1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjExLjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIHV0aWxzX2hvb2tzX19ob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoKSB7XG4gICAgfVxuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdW5kbyB0aGF0IGZvciBsYXp5IGxvYWRlZCBsb2NhbGVzXG4gICAgICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXSB8fCBuZXcgTG9jYWxlKCk7XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19nZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19zZXQgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdW5pdDtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodW5pdCBpbiB1bml0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHVuaXQsIHVuaXRzW3VuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cblxuICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccyspK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIGhlcmUhXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKSQnLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJykkJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignLCAnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPy87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXG4gICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQwNyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTM0OC9pbnN0YW50aWF0aW5nLWEtamF2YXNjcmlwdC1vYmplY3QtYnktY2FsbGluZy1wcm90b3R5cGUtY29uc3RydWN0b3ItYXBwbHlcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuXG4gICAgICAgIC8vdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbGlkX19pc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodXRpbHNfaG9va3NfX2hvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgraW5wdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbF9fY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIHZhciBvdGhlciA9IGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDM2ZTU7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcikgfHwgW10pO1xuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkpIC0gKCtyZXMpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUoK3Jlcy5fZCArIGRpZmYpO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKGMuX2EpIDogbG9jYWxfX2NyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooPzooWzAtOSwuXSopWSk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilEKT8oPzpUKD86KFswLTksLl0qKUgpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopUyk/KT98KFswLTksLl0qKVcpJC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgbG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBkdXJhdGlvbi5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLl9tb250aHM7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKCttb20uX2QgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIGdldF9zZXRfX3NldChtb20sICdEYXRlJywgZ2V0X3NldF9fZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXRfc2V0X19nZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIGFkZF9zdWJ0cmFjdF9fc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBsb2NhbF9fY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZihzb2QsICdkYXlzJywgdHJ1ZSksXG4gICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0oKSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzID4gK2xvY2FsSW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gK2xvY2FsSW5wdXQgPCArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPCArbG9jYWxJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSA8ICtsb2NhbElucHV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgJiYgdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPT09ICtsb2NhbElucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9ICtsb2NhbElucHV0O1xuICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KTtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgbG9jYWxfX2NyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShsb2NhbF9fY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgbG9jYWxfX2NyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gK3RoaXMuX2QgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIEpTT04uc3RyaW5naWZ5KG5ldyBEYXRlKE5hTikpID09PSAnbnVsbCdcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogJ251bGwnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImdvdFwiLCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgXCJzZXRcIiwgZGF0ZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBsb2NhbGUuX29yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzW20uZGF5KCldIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGxvY2FsX19jcmVhdGVMb2NhbChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gdGhpcy5kYXkoKSB8fCA3IDogdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyBpbnB1dCA6IGlucHV0IC0gNyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm90b3R5cGVfX3Byb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGRfc3VidHJhY3RfX2FkZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICAgID0gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgICAgID0gZ2V0U2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgICAgICA9IG1vbWVudF92YWxpZF9faXNWYWxpZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICAgICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB0b190eXBlX192YWx1ZU9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG5cbiAgICAvLyBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4gICAgLy8gV2VlayBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuICAgIC8vIFF1YXJ0ZXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuICAgIC8vIE1vbnRoXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuICAgIC8vIFdlZWtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWsgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2VlayAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuICAgIC8vIERheVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXkgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4gICAgLy8gSG91clxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91ciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4gICAgLy8gTWludXRlXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbiAgICAvLyBTZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuICAgIC8vIE1pbGxpc2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbiAgICAvLyBPZmZzZXRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUU2hpZnRlZCAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE3NzknLCBnZXRTZXRab25lKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0T3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlX19yZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfb3JkaW5hbFBhcnNlTGVuaWVudC5cbiAgICAgICAgdGhpcy5fb3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAodGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSArICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVfX3Byb3RvID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvdHlwZV9fcHJvdG8uX2NhbGVuZGFyICAgICAgID0gZGVmYXVsdENhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgID0gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9sb25nRGF0ZUZvcm1hdCA9IGRlZmF1bHRMb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2ludmFsaWREYXRlICAgID0gZGVmYXVsdEludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbCAgICAgICAgPSBkZWZhdWx0T3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5fb3JkaW5hbFBhcnNlICAgPSBkZWZhdWx0T3JkaW5hbFBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3JlbGF0aXZlVGltZSAgID0gZGVmYXVsdFJlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlX19yZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uc2V0ICAgICAgICAgICAgID0gbG9jYWxlX3NldF9fc2V0O1xuXG4gICAgLy8gTW9udGhcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHMgICAgICAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRoc1Nob3J0ICAgICAgPSBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNSZWdleCAgICAgID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrID0gZGVmYXVsdExvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5cyAgICAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNNaW4gICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIC8vIEhvdXJzXG4gICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tZXJpZGllbVBhcnNlID0gZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIGNvdW50LCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRocycsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSBkdXJhdGlvbl9odW1hbml6ZV9fcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBpc29fc3RyaW5nX19hYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgdmFyIHNlY29uZHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBpc29fc3RyaW5nX19hYnModGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoWSA/IFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb25fcHJvdG90eXBlX19wcm90byA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWJzICAgICAgICAgICAgPSBkdXJhdGlvbl9hYnNfX2FicztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3Q7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICA9IGR1cmF0aW9uX2FzX192YWx1ZU9mO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgICA9IGR1cmF0aW9uX2dldF9fZ2V0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lTT1N0cmluZyAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9TdHJpbmcgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSlNPTiAgICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgaXNvX3N0cmluZ19fdG9JU09TdHJpbmcpO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICB1dGlsc19ob29rc19faG9va3MudmVyc2lvbiA9ICcyLjExLjEnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGxvY2FsX19jcmVhdGVMb2NhbCk7XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlVW5peDtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c01pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG5cbiAgICB2YXIgX21vbWVudCA9IHV0aWxzX2hvb2tzX19ob29rcztcblxuICAgIHJldHVybiBfbW9tZW50O1xuXG59KSk7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJTYW1zYXJhXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlNhbXNhcmFcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXHQgICAgICAgIENvcmU6IF9fd2VicGFja19yZXF1aXJlX18oMSksXG5cdCAgICAgICAgRE9NOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcblx0ICAgICAgICBFdmVudHM6IF9fd2VicGFja19yZXF1aXJlX18oMzkpLFxuXHQgICAgICAgIElucHV0czogX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksXG5cdCAgICAgICAgTGF5b3V0czogX193ZWJwYWNrX3JlcXVpcmVfXyg1MCksXG5cdCAgICAgICAgU3RyZWFtczogX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksXG5cdCAgICAgICAgVHJhbnNpdGlvbnM6IF9fd2VicGFja19yZXF1aXJlX18oNTkpXG5cdCAgICB9O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG5cdCAgICAgICAgRW5naW5lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLFxuXHQgICAgICAgIExheW91dE5vZGU6IF9fd2VicGFja19yZXF1aXJlX18oOCksXG5cdCAgICAgICAgU2l6ZU5vZGU6IF9fd2VicGFja19yZXF1aXJlX18oMTcpLFxuXHQgICAgICAgIFRpbWVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSxcblx0ICAgICAgICBUcmFuc2Zvcm06IF9fd2VicGFja19yZXF1aXJlX18oMjEpLFxuXHQgICAgICAgIFRyYW5zaXRpb25hYmxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKSxcblx0ICAgICAgICBWaWV3OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVxuXHQgICAgfTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIE1vZGlmaWVkIHdvcmsgY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXHQvLyBUT0RPOiBjYW5jZWwgUkFGIHdoZW4gYXNsZWVwXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdCAgICB2YXIgcG9zdFRpY2tRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdCAgICB2YXIgcHJlVGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0ICAgIHZhciBkaXJ0eVF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0ICAgIHZhciB0aWNrUXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdCAgICB2YXIgcmFmSWQgPSAwO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuZ2luZSBpcyBhIHNpbmdsZXRvbiBvYmplY3QgdGhhdCBpcyByZXF1aXJlZCB0byBydW4gYSBTYW1zYXJhIGFwcGxpY2F0aW9uLlxuXHQgICAgICogIEl0IGlzIHRoZSBcImhlYXJ0YmVhdFwiIG9mIHRoZSBhcHBsaWNhdGlvbiwgbWFuYWdpbmcgdGhlIGJhdGNoaW5nIG9mIHN0cmVhbXNcblx0ICAgICAqICBhbmQgY3JlYXRpbmcgYFJvb3ROb2Rlc2AgYW5kIGBDb250ZXh0c2AgdG8gYmVnaW4gcmVuZGVyIHRyZWVzLlxuXHQgICAgICpcblx0ICAgICAqICBJdCBhbHNvIGxpc3RlbnMgYW5kIGNhbiByZXNwb25kIHRvIERPTSBldmVudHMgb24gdGhlIEhUTUwgYDxib2R5PmAgdGFnXG5cdCAgICAgKiAgYW5kIGB3aW5kb3dgIG9iamVjdC4gRm9yIGluc3RhbmNlIHRoZSBgcmVzaXplYCBldmVudC5cblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgRW5naW5lXG5cdCAgICAgKiBAbmFtZXNwYWNlIENvcmVcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAdXNlcyBDb3JlLkV2ZW50SGFuZGxlclxuXHQgICAgICovXG5cdCAgICB2YXIgRW5naW5lID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogVXBkYXRlcyBieSBhIHNpbmdsZSBmcmFtZSBvZiB0aGUgYXBwbGljYXRpb24gYnkgbG9vcGluZyB0aHJvdWdoIGFsbCBmdW5jdGlvbiBxdWV1ZXMuXG5cdCAgICAgKiAgVGhpcyBpcyByZXBlYXRlZGx5IGNhbGxlZCB3aXRoaW4gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCB1bnRpbCB0aGUgYXBwbGljYXRpb25cblx0ICAgICAqICBpcyByZWNlaXZpbmcgbm8gbGF5b3V0IGNoYW5nZXMuIEF0IHRoaXMgcG9pbnQgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aWxsIGJlXG5cdCAgICAgKiAgY2FuY2VsZWQgdW50aWwgdGhlIG5leHQgY2hhbmdlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAbWV0aG9kIHN0ZXBcblx0ICAgICAqL1xuXHQgICAgRW5naW5lLnN0ZXAgPSBmdW5jdGlvbiBzdGVwKCkge1xuXHQgICAgICAgIC8vIGJyb3dzZXIgZXZlbnRzIGFuZCB0aGVpciBoYW5kbGVycyBoYXBwZW4gYmVmb3JlIHJlbmRlcmluZyBiZWdpbnNcblx0ICAgICAgICB3aGlsZSAocHJlVGlja1F1ZXVlLmxlbmd0aCkgKHByZVRpY2tRdWV1ZS5zaGlmdCgpKSgpO1xuXG5cdCAgICAgICAgLy8gdGljayBzaWduYWxzIGJhc2UgZXZlbnQgZmxvdyBjb21pbmcgaW5cblx0ICAgICAgICBTdGF0ZS5zZXQoU3RhdGUuU1RBVEVTLlVQREFURSk7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tRdWV1ZS5sZW5ndGg7IGkrKykgdGlja1F1ZXVlW2ldKCk7XG5cblx0ICAgICAgICAvLyBwb3N0IHRpY2sgaXMgZm9yIHJlc29sdmluZyBsYXJnZXIgY29tcG9uZW50cyBmcm9tIHRoZWlyIGluY29taW5nIHNpZ25hbHNcblx0ICAgICAgICB3aGlsZSAocG9zdFRpY2tRdWV1ZS5sZW5ndGgpIChwb3N0VGlja1F1ZXVlLnNoaWZ0KCkpKCk7XG5cblx0ICAgICAgICBTdGF0ZS5zZXQoU3RhdGUuU1RBVEVTLkVORCk7XG5cblx0ICAgICAgICB3aGlsZSAoZGlydHlRdWV1ZS5sZW5ndGgpIChkaXJ0eVF1ZXVlLnNoaWZ0KCkpKCk7XG5cblx0ICAgICAgICBTdGF0ZS5zZXQoU3RhdGUuU1RBVEVTLlNUQVJUKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogSW5pdGlhdGUgdGhlIEVuZ2luZSdzIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIGxvb3AuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzdGFydFxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICovXG5cdCAgICBFbmdpbmUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpe1xuXHQgICAgICAgIEVuZ2luZS5zdGVwKCk7XG5cdCAgICAgICAgcmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0YXJ0KTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gRW5naW5lO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBTVEFURSA9IHtcblx0ICAgICAgICBOT05FIDogLTEsXG5cdCAgICAgICAgU1RBUlQgOiAwLFxuXHQgICAgICAgIFVQREFURSA6IDEsXG5cdCAgICAgICAgRU5EIDogMlxuXHQgICAgfTtcblxuXHQgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IFNUQVRFLlNUQVJUO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNVRSBzcGVjaWZpZWQgdGhlIGdsb2JhbCBzdGF0ZSBvZiB0aGUgYXBwbGljYXRpb24sIHdoZXRoZXIgaXQgaXMgaW4gYVxuXHQgICAgICogIGBzdGFydGAsIGB1cGRhdGVgIG9yIGBlbmRgIHN0YXRlLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29vcmRpbmF0aW5nXG5cdCAgICAgKiAgYHJlc2l6ZWAgZXZlbnRzIHdpdGggYHN0YXJ0YCwgYHVwZGF0ZWAsIGBlbmRgIHN0YXRlcyBpbiBzdHJlYW0uXG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIFNVRVxuXHQgICAgICogQG5hbWVzcGFjZSBDb3JlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICovXG5cdCAgICB2YXIgU1VFID0ge307XG5cblx0ICAgIFNVRS5TVEFURVMgPSBTVEFURTtcblxuXHQgICAgU1VFLnNldCA9IGZ1bmN0aW9uIHNldChzdGF0ZSl7XG5cdCAgICAgICAgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cdCAgICB9O1xuXG5cdCAgICBTVUUuZ2V0ID0gZnVuY3Rpb24gZ2V0KCl7XG5cdCAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gU1VFO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICAvKipcblx0ICAgICAqIFF1ZXVlIHRoYXQgYmF0Y2hlcyBgdXBkYXRlYCBldmVudHMuXG5cdCAgICAgKiAgVGhpcyBxdWV1ZSBpcyB0cmF2ZXJzZWQgYWZ0ZXIgdGhlIGBwcmVUaWNrUXVldWVgIGJ1dCBiZWZvcmUgYGRpcnRRdWV1ZWBcblx0ICAgICAqICBieSB0aGUgRW5naW5lLlxuXHQgICAgICpcblx0ICAgICAqICBAcHJpdmF0ZVxuXHQgICAgICovXG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gW107XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIC8qKlxuXHQgICAgICogUXVldWUgdGhhdCBiYXRjaGVzIGBzdGFydGAgZXZlbnRzLlxuXHQgICAgICogIFRoaXMgcXVldWUgaXMgdHJhdmVyc2VkIGZpcnN0IChidXQgYWZ0ZXIgRE9NIGV2ZW50cyBhcmUgZXhlY3V0ZWQpIGJ5IHRoZSBFbmdpbmUuXG5cdCAgICAgKlxuXHQgICAgICogIEBwcml2YXRlXG5cdCAgICAgKi9cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBbXTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgLyoqXG5cdCAgICAgKiBRdWV1ZSB0aGF0IGJhdGNoZXMgYGVuZGAgYW5kIGBkaXJ0eWAgZXZlbnRzLlxuXHQgICAgICogIFRoaXMgcXVldWUgaXMgdHJhdmVyc2VkIGFmdGVyIHRoZSBgcG9zdFRpY2tRdWV1ZWAgYnkgdGhlIEVuZ2luZS5cblx0ICAgICAqXG5cdCAgICAgKiAgQHByaXZhdGVcblx0ICAgICAqL1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFtdO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4vKioqLyB9LFxuLyogNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICAvKipcblx0ICAgICAqIFRoaXMgcXVldWUgaXMgZXhlY3V0ZWQgYmVmb3JlIHRoZSBwb3N0VGlja1F1ZXVlIGFuZCBhZnRlciB0aGUgcHJlVGlja1F1ZXVlLlxuXHQgICAgICogIGhvd2V2ZXIsIGl0IGRpZmZlcnMgaW4gdGhhdCB0aGUgRW5naW5lIGRvZXMgbm90IGNsZWFyIHRoZSBxdWV1ZS5cblx0ICAgICAqICBUaGlzIG11c3QgYmUgZG9uZSBtYW51YWxseS5cblx0ICAgICAqXG5cdCAgICAgKiAgQHByaXZhdGVcblx0ICAgICAqL1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFtdO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4vKioqLyB9LFxuLyogOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBTaW1wbGVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0ICAgIHZhciBTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICAgIHZhciBPYnNlcnZhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jYXBzdWxhdGVzIGEgc3RyZWFtIG9mIGxheW91dCBkYXRhICh0cmFuc2Zvcm0sIG9yaWdpbiwgYWxpZ24sIG9wYWNpdHkpLlxuXHQgICAgICogIExpc3RlbnMgb24gc3RhcnQvdXBkYXRlL2VuZCBldmVudHMsIGJhdGNoZXMgdGhlbSwgYW5kIGVtaXRzIHRoZW0gZG93bnN0cmVhbVxuXHQgICAgICogIHRvIGRlc2NlbmRhbnQgbGF5b3V0IG5vZGVzLlxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGNvbnRleHQgPSBDb250ZXh0KCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgc3VyZmFjZSA9IG5ldyBTdXJmYWNlKHtcblx0ICAgICAqICAgICAgICAgIHNpemUgOiBbMTAwLDEwMF0sXG5cdCAgICAgKiAgICAgICAgICBwcm9wZXJ0aWVzIDoge2JhY2tncm91bmQgOiAncmVkJ31cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgb3BhY2l0eSA9IG5ldyBUcmFuc2l0aW9uYWJsZSgxKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0Tm9kZSh7XG5cdCAgICAgKiAgICAgICAgICB0cmFuc2Zvcm0gOiBUcmFuc2Zvcm0udHJhbnNsYXRlWCgxMDApLFxuXHQgICAgICogICAgICAgICAgb3BhY2l0eSA6IG9wYWNpdHlcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBjb250ZXh0LmFkZChsYXlvdXQpLmFkZChzdXJmYWNlKTtcblx0ICAgICAqICAgICAgY29udGV4dC5tb3VudChkb2N1bWVudC5ib2R5KVxuXHQgICAgICpcblx0ICAgICAqICAgICAgb3BhY2l0eS5zZXQoMCwge2R1cmF0aW9uIDogMTAwMH0pO1xuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBMYXlvdXROb2RlXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBuYW1lc3BhY2UgQ29yZVxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSBzb3VyY2VzIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgb2YgbGF5b3V0IHNvdXJjZXNcblx0ICAgICAqIEBwYXJhbSBbc291cmNlcy50cmFuc2Zvcm1dIHtTdHJlYW18VHJhbnNmb3JtfSAgICBUcmFuc2Zvcm0gc291cmNlXG5cdCAgICAgKiBAcGFyYW0gW3NvdXJjZXMuYWxpZ25dIHtTdHJlYW18QXJyYXl9ICAgICAgICAgICAgQWxpZ24gc291cmNlXG5cdCAgICAgKiBAcGFyYW0gW3NvdXJjZXMub3JpZ2luXSB7U3RyZWFtfEFycmF5fSAgICAgICAgICAgT3JpZ2luIHNvdXJjZVxuXHQgICAgICogQHBhcmFtIFtzb3VyY2VzLm9wYWNpdHldIHtTdHJlYW18TnVtYmVyfSAgICAgICAgIE9wYWNpdHkgc291cmNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIExheW91dE5vZGUoc291cmNlcykge1xuXHQgICAgICAgIHRoaXMuc3RyZWFtID0gX2NyZWF0ZVN0cmVhbShzb3VyY2VzKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0T3V0cHV0SGFuZGxlcih0aGlzLCB0aGlzLnN0cmVhbSk7XG5cdCAgICB9XG5cblx0ICAgIC8vIEVudW1lcmF0aW9uIG9mIHR5cGVzIG9mIGxheW91dCBwcm9wZXJ0aWVzXG5cdCAgICBMYXlvdXROb2RlLktFWVMgPSB7XG5cdCAgICAgICAgdHJhbnNmb3JtIDogJ3RyYW5zZm9ybScsXG5cdCAgICAgICAgb3JpZ2luIDogJ29yaWdpbicsXG5cdCAgICAgICAgYWxpZ24gOiAnYWxpZ24nLFxuXHQgICAgICAgIG9wYWNpdHkgOiAnb3BhY2l0eSdcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogSW50cm9kdWNlIG5ldyBkYXRhIHN0cmVhbXMgdG8gdGhlIGxheW91dCBub2RlIGluIHtrZXkgOiB2YWx1ZX0gcGFpcnMuXG5cdCAgICAgKiAgSGVyZSB0aGUgYGtleWAgaXMgb25lIG9mIFwidHJhbnNmb3JtXCIsIFwib3JpZ2luXCIsIFwiYWxpZ25cIiBvciBcIm9wYWNpdHlcIi5cblx0ICAgICAqICBUaGUgYHZhbHVlYCBpcyBlaXRoZXIgYSBzdHJlYW0sIG9yIGEgc2ltcGxlIHR5cGUgbGlrZSBhIGBOdW1iZXJgIG9yIGBBcnJheWAuXG5cdCAgICAgKiAgU2ltcGxlIHR5cGVzIHdpbGwgYmUgd3JhcHBlZCBpbiBhbiBgT2JzZXJ2ZXJhYmxlYCB0byBlbWl0IGFwcHJvcHJpYXRlIGV2ZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldFxuXHQgICAgICogQHBhcmFtIHNvdXJjZXMge09iamVjdH0gICAgICBPYmplY3Qgb2YgZGF0YSBzb3VyY2VzXG5cdCAgICAgKi9cblx0ICAgIExheW91dE5vZGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNvdXJjZXMpe1xuXHQgICAgICAgIC8vIFRPRE86IGJlIGFibGUgdG8gb3ZlcndyaXRlIHN0cmVhbXMuIE5vdCBvbmx5IGFkZFxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2VzKXtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlc1trZXldO1xuXG5cdCAgICAgICAgICAgIHZhciBzb3VyY2UgPSAodmFsdWUgaW5zdGFuY2VvZiBTaW1wbGVTdHJlYW0pXG5cdCAgICAgICAgICAgICAgICA/IHZhbHVlXG5cdCAgICAgICAgICAgICAgICA6IG5ldyBPYnNlcnZhYmxlKHZhbHVlKTtcblxuXHQgICAgICAgICAgICB0aGlzLnN0cmVhbS5hZGRTdHJlYW0oa2V5LCBzb3VyY2UpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIF9jcmVhdGVTdHJlYW0oc291cmNlcyl7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZXMpe1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VzW2tleV07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpe1xuXHQgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBPYnNlcnZhYmxlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZXNba2V5XSA9IHNvdXJjZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gU3RyZWFtLm1lcmdlKHNvdXJjZXMpO1xuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IExheW91dE5vZGU7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIEV2ZW50RW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEV2ZW50SGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB0byBwcm92aWRlIHN1YnNjcmlwdGlvbiBtZXRob2RzLlxuXHQgICAgICogIEl0IGFsc28gaW5jbHVkZXMgaGVscGVyIG1ldGhvZHMgb24gdGhlIGNvbnN0cnVjdG9yIGZvciBzZXR0aW5nIHVwIENvbnRyb2xsZXJzIGFuZCBWaWV3c1xuXHQgICAgICogIHdpdGggaW5wdXQgYW5kIG91dHB1dCBlbWl0dGVycy5cblx0ICAgICAqXG5cdCAgICAgKiAgQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBldmVudEhhbmRsZXJBID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICogICAgICB2YXIgZXZlbnRIYW5kbGVyQiA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGV2ZW50SGFuZGxlckIuc3Vic2NyaWJlKGV2ZW50SGFuZGxlckEpO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgZXZlbnRIYW5kbGVyQi5vbignbmFtZScsIGZ1bmN0aW9uKHBheWxvYWQpe1xuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2cocGF5bG9hZCkgLy8ge2RhdGEgOiAwfVxuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGV2ZW50SGFuZGxlckEuZW1pdCgnbmFtZScsIHtkYXRhIDogMH0pO1xuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBFdmVudEhhbmRsZXJcblx0ICAgICAqIEBuYW1lc3BhY2UgRXZlbnRzXG5cdCAgICAgKiBAZXh0ZW5kcyBFdmVudHMuRXZlbnRFbWl0dGVyXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyKCkge1xuXHQgICAgICAgIEV2ZW50RW1pdHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgdGhpcy51cHN0cmVhbSA9IFtdOyAvLyB1cHN0cmVhbSBldmVudCBoYW5kbGVyc1xuXHQgICAgICAgIHRoaXMudXBzdHJlYW1MaXN0ZW5lcnMgPSB7fTsgLy8gdXBzdHJlYW0gbGlzdGVuZXJzXG5cdCAgICB9XG5cblx0ICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXHQgICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50SGFuZGxlcjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgbWV0aG9kLiBBc3NpZ24gYW4gZXZlbnQgaGFuZGxlciB0byByZWNlaXZlIGFuIG9iamVjdCdzIGlucHV0IGV2ZW50cy5cblx0ICAgICAqICBEZWZpbmVzIGB0cmlnZ2VyYCwgYHN1YnNjcmliZWAgYW5kIGB1bnN1YnNjcmliZWAgbWV0aG9kcyBvbiB0aGUgY2xhc3MgaW5zdGFuY2UuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRJbnB1dEhhbmRsZXJcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSBvYmplY3Qge09iamVjdH0gICAgICAgICAgIENsYXNzIGluc3RhbmNlXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RXZlbnRIYW5kbGVyfSAgICBFdmVudEhhbmRsZXIgcmVwcmVzZW50aW5nIGFuIGlucHV0IHNvdXJjZVxuXHQgICAgICovXG5cdCAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gc2V0SW5wdXRIYW5kbGVyKG9iamVjdCwgaGFuZGxlcikge1xuXHQgICAgICAgIG9iamVjdC50cmlnZ2VyID0gaGFuZGxlci50cmlnZ2VyLmJpbmQoaGFuZGxlcik7XG5cdCAgICAgICAgb2JqZWN0LnN1YnNjcmliZSA9IGhhbmRsZXIuc3Vic2NyaWJlLmJpbmQoaGFuZGxlcik7XG5cdCAgICAgICAgb2JqZWN0LnVuc3Vic2NyaWJlID0gaGFuZGxlci51bnN1YnNjcmliZS5iaW5kKGhhbmRsZXIpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgbWV0aG9kLiBBc3NpZ24gYW4gZXZlbnQgaGFuZGxlciB0byBlbWl0IGFuIG9iamVjdCdzIG91dHB1dCBldmVudHMuXG5cdCAgICAgKiAgRGVmaW5lcyBgZW1pdGAsIGBvbmAgYW5kIGBvZmZgIG1ldGhvZHMgb24gdGhlIGNsYXNzIGluc3RhbmNlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0T3V0cHV0SGFuZGxlclxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIG9iamVjdCB7T2JqZWN0fSAgICAgICAgICAgT2JqZWN0IHRvIHByb3ZpZGUgb24sIG9mZiBhbmQgZW1pdCBtZXRob2RzXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RXZlbnRIYW5kbGVyfSAgICBIYW5kbGVyIGFzc2lnbmVkIGV2ZW50IGhhbmRsZXJcblx0ICAgICAqL1xuXHQgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIgPSBmdW5jdGlvbiBzZXRPdXRwdXRIYW5kbGVyKG9iamVjdCwgaGFuZGxlcikge1xuXHQgICAgICAgIGhhbmRsZXIuYmluZFRoaXMob2JqZWN0KTtcblx0ICAgICAgICBvYmplY3QuZW1pdCA9IGhhbmRsZXIuZW1pdC5iaW5kKGhhbmRsZXIpO1xuXHQgICAgICAgIG9iamVjdC5vbiA9IGhhbmRsZXIub24uYmluZChoYW5kbGVyKTtcblx0ICAgICAgICBvYmplY3Qub2ZmID0gaGFuZGxlci5vZmYuYmluZChoYW5kbGVyKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29uc3RydWN0b3IgaGVscGVyIG1ldGhvZC4gR2l2ZW4gYW4gZXZlbnRzIGRpY3Rpb25hcnkgb2Yge2V2ZW50TmFtZSA6IGhhbmRsZXJ9IHBhaXJzLCBhdHRhY2ggdGhlbSB0b1xuXHQgICAgICogIGEgcHJvdmlkZWQgaW5wdXQgaGFuZGxlciBmb3IgYW4gb2JqZWN0LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0SW5wdXRFdmVudHNcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0gb2JqZWN0IHtPYmplY3R9ICAgICAgICAgICBPYmplY3QgdG8gcHJvdmlkZSBvbiwgb2ZmIGFuZCBlbWl0IG1ldGhvZHNcblx0ICAgICAqIEBwYXJhbSBoYW5kbGVyIHtFdmVudEhhbmRsZXJ9ICAgIEhhbmRsZXIgYXNzaWduZWQgZXZlbnQgaGFuZGxlclxuXHQgICAgICovXG5cdCAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRFdmVudHMgPSBmdW5jdGlvbiBzZXRJbnB1dEV2ZW50cyhvYmplY3QsIGV2ZW50cywgaGFuZGxlckluKXtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG5cdCAgICAgICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGV2ZW50c1trZXldO1xuXHQgICAgICAgICAgICB2YXIgaGFuZGxlciA9ICh0eXBlb2YgaGFuZGxlck5hbWUgPT09ICdzdHJpbmcnKVxuXHQgICAgICAgICAgICAgICAgPyBvYmplY3RbaGFuZGxlck5hbWVdXG5cdCAgICAgICAgICAgICAgICA6IGhhbmRsZXJOYW1lO1xuXHQgICAgICAgICAgICBpZiAoaGFuZGxlcikgaGFuZGxlckluLm9uKGtleSwgaGFuZGxlci5iaW5kKG9iamVjdCkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBhIGhhbmRsZXIgdG8gdGhlIGB0eXBlYCBjaGFubmVsIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb24gYGVtaXRgLlxuXHQgICAgICogIEV4dGVuZHMgRXZlbnRFbWl0dGVyJ3MgYG9uYCBtZXRob2QuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBvblxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gICAgICAgICAgICAgRXZlbnQgY2hhbm5lbCBuYW1lXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgICAgICBIYW5kbGVyXG5cdCAgICAgKi9cblx0ICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbih0eXBlLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy51cHN0cmVhbUxpc3RlbmVycykpIHtcblx0ICAgICAgICAgICAgdmFyIHVwc3RyZWFtTGlzdGVuZXIgPSB0aGlzLnRyaWdnZXIuYmluZCh0aGlzLCB0eXBlKTtcblx0ICAgICAgICAgICAgdGhpcy51cHN0cmVhbUxpc3RlbmVyc1t0eXBlXSA9IHVwc3RyZWFtTGlzdGVuZXI7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy51cHN0cmVhbS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy51cHN0cmVhbVtpXS5vbih0eXBlLCB1cHN0cmVhbUxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlzdGVuIGZvciBldmVudHMgZnJvbSBhbiBhbiB1cHN0cmVhbSBzb3VyY2UuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzdWJzY3JpYmVcblx0ICAgICAqIEBwYXJhbSBzb3VyY2Uge0V2ZW50RW1pdHRlcn0gRXZlbnQgc291cmNlXG5cdCAgICAgKi9cblx0ICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKHNvdXJjZSkge1xuXHQgICAgICAgIHZhciBpbmRleCA9IHRoaXMudXBzdHJlYW0uaW5kZXhPZihzb3VyY2UpO1xuXHQgICAgICAgIGlmIChpbmRleCA8IDApIHtcblx0ICAgICAgICAgICAgdGhpcy51cHN0cmVhbS5wdXNoKHNvdXJjZSk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy51cHN0cmVhbUxpc3RlbmVycykge1xuXHQgICAgICAgICAgICAgICAgc291cmNlLm9uKHR5cGUsIHRoaXMudXBzdHJlYW1MaXN0ZW5lcnNbdHlwZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBzb3VyY2U7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBmcm9tIGFuIHVwc3RyZWFtIHNvdXJjZS5cblx0ICAgICAqICBVbmRvZXMgd29yayBvZiBgc3Vic2NyaWJlYC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHVuc3Vic2NyaWJlXG5cdCAgICAgKiBAcGFyYW0gc291cmNlIHtFdmVudEVtaXR0ZXJ9IEV2ZW50IHNvdXJjZVxuXHQgICAgICovXG5cdCAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoc291cmNlKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy51cHN0cmVhbS5pbmRleE9mKHNvdXJjZSk7XG5cdCAgICAgICAgaWYgKGluZGV4ID49IDApIHtcblx0ICAgICAgICAgICAgdGhpcy51cHN0cmVhbS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMudXBzdHJlYW1MaXN0ZW5lcnMpIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZS5vZmYodHlwZSwgdGhpcy51cHN0cmVhbUxpc3RlbmVyc1t0eXBlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHNvdXJjZTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRIYW5kbGVyO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICAvKipcblx0ICAgICAqIEV2ZW50RW1pdHRlciByZXByZXNlbnRzIGFuIGFzeW5jaHJvbm91cyBjaGFubmVsIGZvciBicm9hZGNhc3RpbmcgYW5kIHJlY2VpdmluZyBldmVudHMuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBldmVudEVtaXR0ZXIub24oJ3NlbmQnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHBheWxvYWQpIC8vIHtkYXRhIDogMH1cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICAvLyBzb21ldGltZSBsYXRlci4uLlxuXHQgICAgICogICAgICBldmVudEVtaXR0ZXIuZW1pdCgnc2VuZCcsIHtkYXRhIDogMH0pO1xuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcblx0ICAgICAqIEBuYW1lc3BhY2UgRXZlbnRzXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuXHQgICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG5cdCAgICAgICAgdGhpcy5fb3duZXIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIEJyb2FkY2FzdCBhbiBldmVudCBvbiB0aGUgYHR5cGVgIGNoYW5uZWwgd2l0aCBhbiBvcHRpb25hbCBwYXlsb2FkLiBUaGlzIHdpbGwgY2FsbCB0aGUgaGFuZGxlcnNcblx0ICAgICAqICBvZiBhbGwgRXZlbnRFbWl0dGVycyBsaXN0ZW5pbmcgb24gdGhlIGB0eXBlYCBjaGFubmVsIHdpdGggdGhlIChvcHRpb25hbCkgZGF0YSBwYXlsb2FkXG5cdCAgICAgKiAgYXMgaXRzIGFyZ3VtZW50LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZW1pdFxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9ICAgICBDaGFubmVsIG5hbWVcblx0ICAgICAqIEBwYXJhbSBkYXRhIHtPYmplY3R9ICAgICBQYXlsb2FkXG5cdCAgICAgKi9cblx0ICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSwgZGF0YSkge1xuXHQgICAgICAgIGlmIChkYXRhID09PSBmYWxzZSkgcmV0dXJuOyAvLyBkbyBub3QgcHJvcGFnYXRlXG5cdCAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG5cdCAgICAgICAgaWYgKGhhbmRsZXJzKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMuX293bmVyLCBkYXRhKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsaWFzIGZvciBlbWl0LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdHJpZ2dlclxuXHQgICAgICovXG5cdCAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiBBZGRzIGEgaGFuZGxlciB0byB0aGUgYHR5cGVgIGNoYW5uZWwgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbiBgZW1pdGAuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBvblxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gICAgICAgICBDaGFubmVsIG5hbWVcblx0ICAgICAqIEBwYXJhbSBoYW5kbGVyIHtGdW5jdGlvbn0gICAgQ2FsbGJhY2tcblx0ICAgICAqL1xuXHQgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHR5cGUsIGhhbmRsZXIpIHtcblx0ICAgICAgICBpZiAoISh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSkgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcblx0ICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGhhbmRsZXIpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCZWhhdmVzIGxpa2UgYEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25gLCBleGNlcHQgdGhlIGhhbmRsZXIgaXMgb25seSBleGVjdXRlZCBvbmNlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgb25jZVxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gICAgICAgICBFdmVudCB0eXBlIGtleSAoZm9yIGV4YW1wbGUsICdjbGljaycpXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgIENhbGxiYWNrXG5cdCAgICAgKi9cblx0ICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgaGFuZGxlcil7XG5cdCAgICAgICAgdmFyIG9uY2VIYW5kbGVyID0gZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZi5jYWxsKHRoaXMsIHR5cGUsIG9uY2VIYW5kbGVyKTtcblx0ICAgICAgICB9LmJpbmQodGhpcyk7XG5cdCAgICAgICAgdGhpcy5vbih0eXBlLCBvbmNlSGFuZGxlcik7XG5cdCAgICB9O1xuXG5cdCAgIC8qKlxuXHQgICAgICogUmVtb3ZlcyB0aGUgYGhhbmRsZXJgIGZyb20gdGhlIGB0eXBlYCBjaGFubmVsLlxuXHQgICAgICogICBUaGlzIHVuZG9lcyB0aGUgd29yayBvZiBgb25gLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgb2ZmXG5cdCAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAgICAgICAgIENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSAgICBDYWxsYmFja1xuXHQgICAgICovXG5cdCAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZih0eXBlLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgaWYgKCF0eXBlKSB7XG5cdCAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcblx0ICAgICAgICBpZiAobGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107IC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9mIGdpdmVuIHR5cGVcblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lci5pbmRleE9mKGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIGxpc3RlbmVyLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY29udmVuaWVuY2UgbWV0aG9kIHRvIGJpbmQgdGhlIHByb3ZpZGVkIG9iamVjdCB0byBhbGwgYWRkZWQgaGFuZGxlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBiaW5kVGhpc1xuXHQgICAgICogQHBhcmFtIG93bmVyIHtPYmplY3R9ICAgICAgICBCb3VuZCBgdGhpc2AgY29udGV4dFxuXHQgICAgICovXG5cdCAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmJpbmRUaGlzID0gZnVuY3Rpb24gYmluZFRoaXMob3duZXIpIHtcblx0ICAgICAgICB0aGlzLl9vd25lciA9IG93bmVyO1xuXHQgICAgfTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIEV2ZW50TWFwcGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdCAgICB2YXIgRXZlbnRGaWx0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0ICAgIHZhciBFdmVudFNwbGl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBTaW1wbGVTdHJlYW0gd3JhcHMgYW4gRXZlbnRIYW5kbGVyIGFuZCBwcm92aWRlcyBjb252ZW5pZW5jZVxuXHQgICAgICogIG1ldGhvZHMgb2YgYG1hcGAsIGBmaWx0ZXJgLCBgc3BsaXRgLCBhbmQgYHBsdWNrYCB0b1xuXHQgICAgICogIHRyYW5zZm9ybSBvbmUgc3RyZWFtIGludG8gYW5vdGhlci5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBTaW1wbGVTdHJlYW1cblx0ICAgICAqIEBleHRlbmRzIENvcmUuRXZlbnRIYW5kbGVyXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQG5hbWVzcGFjZSBTdHJlYW1zXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gU2ltcGxlU3RyZWFtKCl7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLmNhbGwodGhpcyk7XG5cdCAgICB9XG5cblx0ICAgIFNpbXBsZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50SGFuZGxlci5wcm90b3R5cGUpO1xuXHQgICAgU2ltcGxlU3RyZWFtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpbXBsZVN0cmVhbTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNYXAgY29udmVydHMgdGhlIGN1cnJlbnQgc3RyZWFtIGludG8gYSBuZXcgc3RyZWFtXG5cdCAgICAgKiAgd2l0aCBhIG1vZGlmaWVkIChtYXBwZWQpIGRhdGEgcGF5bG9hZC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIG1hcFxuXHQgICAgICogQHBhcmFtIG1hcHBlckZuIHtGdW5jdGlvbn0gICBGdW5jdGlvbiB0byBtYXAgZXZlbnQgcGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBTaW1wbGVTdHJlYW0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG1hcHBlckZuKXtcblx0ICAgICAgICB2YXIgc3RyZWFtID0gbmV3IFNpbXBsZVN0cmVhbSgpO1xuXHQgICAgICAgIHZhciBtYXBwZXIgPSBuZXcgRXZlbnRNYXBwZXIobWFwcGVyRm4pO1xuXHQgICAgICAgIHN0cmVhbS5zdWJzY3JpYmUobWFwcGVyKS5zdWJzY3JpYmUodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIHN0cmVhbTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRmlsdGVyIGNvbnZlcnRzIHRoZSBjdXJyZW50IHN0cmVhbSBpbnRvIGEgbmV3IHN0cmVhbVxuXHQgICAgICogIHRoYXQgb25seSBlbWl0cyBpZiB0aGUgZmlsdGVyIGNvbmRpdGlvbiBpcyBzYXRpc2ZpZWQuXG5cdCAgICAgKiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBCb29sZWFuLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZmlsdGVyXG5cdCAgICAgKiBAcGFyYW0gZmlsdGVyRm4ge0Z1bmN0aW9ufSAgIEZ1bmN0aW9uIHRvIGZpbHRlciBldmVudCBwYXlsb2FkXG5cdCAgICAgKi9cblx0ICAgIFNpbXBsZVN0cmVhbS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyRm4pe1xuXHQgICAgICAgIHZhciBmaWx0ZXIgPSBuZXcgRXZlbnRGaWx0ZXIoZmlsdGVyRm4pO1xuXHQgICAgICAgIHZhciBmaWx0ZXJlZFN0cmVhbSA9IG5ldyBTaW1wbGVTdHJlYW0oKTtcblx0ICAgICAgICBmaWx0ZXJlZFN0cmVhbS5zdWJzY3JpYmUoZmlsdGVyKS5zdWJzY3JpYmUodGhpcyk7XG5cdCAgICAgICAgcmV0dXJuIGZpbHRlcmVkU3RyZWFtO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTcGxpdCBtYXBzIG9uZSBvZiBzZXZlcmFsIHN0cmVhbXMgYmFzZWQgb24gY3VzdG9tIGxvZ2ljLlxuXHQgICAgICogIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFuIEV2ZW50RW1pdHRlci5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNwbGl0XG5cdCAgICAgKiBAcGFyYW0gc3BsaXR0ZXJGbiB7RnVuY3Rpb259ICBTcGxpdHRlciBmdW5jdGlvblxuXHQgICAgICovXG5cdCAgICBTaW1wbGVTdHJlYW0ucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24oc3BsaXR0ZXJGbil7XG5cdCAgICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEV2ZW50U3BsaXR0ZXIoc3BsaXR0ZXJGbik7XG5cdCAgICAgICAgdmFyIHNwbGl0U3RyZWFtID0gbmV3IFNpbXBsZVN0cmVhbSgpO1xuXHQgICAgICAgIHNwbGl0U3RyZWFtLnN1YnNjcmliZShzcGxpdHRlcikuc3Vic2NyaWJlKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiBzcGxpdFN0cmVhbTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGx1Y2sgaXMgYW4gb3BpbmlvbmF0ZWQgbWFwcGVyLiBJdCBwcm9qZWN0cyBhIFN0cmVhbVxuXHQgICAgICogIG9udG8gb25lIG9mIGl0cyByZXR1cm4gdmFsdWVzLlxuXHQgICAgICpcblx0ICAgICAqICBVc2VmdWwgaWYgYSBTdHJlYW0gcmV0dXJucyBhbiBhcnJheSBvciBhbiBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBwbHVja1xuXHQgICAgICogQHBhcmFtIGtleSB7U3RyaW5nfE51bWJlcn0gICBLZXkgdG8gcHJvamVjdCBldmVudCBwYXlsb2FkIG9udG9cblx0ICAgICAqL1xuXHQgICAgU2ltcGxlU3RyZWFtLnByb3RvdHlwZS5wbHVjayA9IGZ1bmN0aW9uKGtleSl7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICAvL1RPRE86IGNhbiB0aGlzIGJlIGluaGVyaXRlZCBieSBvdGhlciBzdHJlYW1zP1xuXHQgICAgU2ltcGxlU3RyZWFtLm1lcmdlID0gZnVuY3Rpb24oKXt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpZnQgaXMgbGlrZSBtYXAsIGV4Y2VwdCBpdCBtYXBzIHNldmVyYWwgZXZlbnQgc291cmNlcyxcblx0ICAgICAqICBub3Qgb25seSBvbmUuXG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgbGlmdGVkU3RyZWFtID0gU2ltcGxlU3RyZWFtLmxpZnQoZnVuY3Rpb24ocGF5bG9hZDEsIHBheWxvYWQyKXtcblx0ICAgICAqICAgICAgICAgIHJldHVybiBwYXlsb2FkMSArIHBheWxvYWQyO1xuXHQgICAgICogICAgICB9LCBbc3RyZWFtMiwgc3RyZWFtMl0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgbGlmdGVkU3RyZWFtLm9uKCduYW1lJyksIGZ1bmN0aW9uKGRhdGEpe1xuXHQgICAgICogICAgICAgICAgLy8gZGF0YSA9IDM7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgc3RyZWFtMi5lbWl0KCduYW1lJywgMSk7XG5cdCAgICAgKiAgICAgIHN0cmVhbTIuZW1pdCgnbmFtZScsIDIpO1xuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgbGlmdFxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIG1hcCB7RnVuY3Rpb259ICAgICAgICAgICAgRnVuY3Rpb24gdG8gbWFwIHN0cmVhbSBwYXlsb2Fkc1xuXHQgICAgICogQHBhcmFtIHN0cmVhbXMge0FycmF5fE9iamVjdH0gICAgU3RyZWFtIHNvdXJjZXNcblx0ICAgICAqL1xuXHQgICAgU2ltcGxlU3RyZWFtLmxpZnQgPSBmdW5jdGlvbihtYXAsIHN0cmVhbXMpe1xuXHQgICAgICAgIC8vVE9ETzogZml4IGNvbW1hIHNlcGFyYXRlZCBhcmd1bWVudHNcblx0ICAgICAgICB2YXIgbWVyZ2VkU3RyZWFtID0gKHN0cmVhbXMgaW5zdGFuY2VvZiBBcnJheSlcblx0ICAgICAgICAgICAgPyB0aGlzLm1lcmdlKHN0cmVhbXMpXG5cdCAgICAgICAgICAgIDogdGhpcy5tZXJnZS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cblx0ICAgICAgICB2YXIgbWFwcGVkU3RyZWFtID0gbmV3IEV2ZW50TWFwcGVyKGZ1bmN0aW9uIGxpZnRNYXAoZGF0YSl7XG5cdCAgICAgICAgICAgIHJldHVybiBtYXAuYXBwbHkobnVsbCwgZGF0YSk7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB2YXIgbGlmdGVkU3RyZWFtID0gbmV3IFNpbXBsZVN0cmVhbSgpO1xuXHQgICAgICAgIGxpZnRlZFN0cmVhbS5zdWJzY3JpYmUobWFwcGVkU3RyZWFtKS5zdWJzY3JpYmUobWVyZ2VkU3RyZWFtKTtcblxuXHQgICAgICAgIHJldHVybiBsaWZ0ZWRTdHJlYW07XG5cdCAgICB9O1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZVN0cmVhbTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIEV2ZW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRXZlbnRNYXBwZXIgbW9kaWZpZXMgdGhlIGRhdGEgcGF5bG9hZCBvZiBhbiBldmVudCBiYXNlZCBvblxuXHQgICAgICogIGEgcHJvdmlkZWQgZnVuY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogIE5vdGU6IGl0IGRvZXMgbm90IG1vZGlmeSB0aGUgZXZlbnQncyBgdHlwZWAuXG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgZXZlbnRNYXBwZXIgPSBuZXcgRXZlbnRNYXBwZXIoZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICByZXR1cm4gcGF5bG9hZC54ICsgcGF5bG9hZC55XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGV2ZW50TWFwcGVyLnN1YnNjcmliZShldmVudEVtaXR0ZXIpO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgZXZlbnRNYXBwZXIub24oJ25hbWUnLCBmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgKiAgICAgICAgICBhbGVydCh2YWx1ZSk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ25hbWUnLCB7eCA6IDEsIHkgOiAyfSk7IC8vIGFsZXJ0cyAzXG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIEV2ZW50TWFwcGVyXG5cdCAgICAgKiBAbmFtZXNwYWNlIEV2ZW50c1xuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcGFyYW0gbWFwIHtGdW5jdGlvbn0gIEZ1bmN0aW9uIHRvIG1vZGlmeSB0aGUgZXZlbnQgcGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBFdmVudE1hcHBlcihtYXApIHtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuY2FsbCh0aGlzKTtcblx0ICAgICAgICB0aGlzLl9tYXBwaW5nRnVuY3Rpb24gPSBtYXA7XG5cdCAgICB9XG5cblx0ICAgIEV2ZW50TWFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cdCAgICBFdmVudE1hcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudE1hcHBlcjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbWl0IG1hcHBlZCBldmVudC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGVtaXRcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGRhdGEge09iamVjdH0gUGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBFdmVudE1hcHBlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSwgZGF0YSkge1xuXHQgICAgICAgIHZhciBtYXBwZWREYXRhID0gdGhpcy5fbWFwcGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIHR5cGUsIG1hcHBlZERhdGEpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGlhcyBvZiBlbWl0LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdHJpZ2dlclxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gQ2hhbm5lbCBuYW1lXG5cdCAgICAgKiBAcGFyYW0gZGF0YSB7T2JqZWN0fSBQYXlsb2FkXG5cdCAgICAgKi9cblx0ICAgIEV2ZW50TWFwcGVyLnByb3RvdHlwZS50cmlnZ2VyID0gRXZlbnRNYXBwZXIucHJvdG90eXBlLmVtaXQ7XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRNYXBwZXI7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDEzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuXHQgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG5cdCAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cdCAqXG5cdCAqIEBsaWNlbnNlIE1QTCAyLjBcblx0ICogQGNvcHlyaWdodCBGYW1vdXMgSW5kdXN0cmllcywgSW5jLiAyMDE0XG5cdCAqL1xuXG5cdC8qIE1vZGlmaWVkIHdvcmsgY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEV2ZW50RmlsdGVyIHJlZ3VsYXRlcyB0aGUgYnJvYWRjYXN0aW5nIG9mIGV2ZW50cyBiYXNlZCBvblxuXHQgICAgICogIGEgc3BlY2lmaWVkIGNvbmRpdGlvbiBwcmVzY3JpYmVkIGJ5IGEgcHJvdmlkZWQgZnVuY3Rpb25cblx0ICAgICAqICB3aXRoIHRoZSBzaWduYXR1cmUgYCh0eXBlLCBkYXRhKSAtPiBCb29sZWFuYFxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGV2ZW50RmlsdGVyID0gbmV3IEV2ZW50RmlsdGVyKGZ1bmN0aW9uKHR5cGUsIHBheWxvYWQpe1xuXHQgICAgICogICAgICAgICAgcmV0dXJuIChwYXlsb2FkLnZhbHVlID09IDApO1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBldmVudEZpbHRlci5zdWJzY3JpYmUoZXZlbnRFbWl0dGVyKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGV2ZW50RmlsdGVyLm9uKCdjbGljaycsIGZ1bmN0aW9uKGRhdGEpe1xuXHQgICAgICogICAgICAgICAgYWxlcnQoJ2ZpcmVkJyk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NsaWNrJywge3ZhbHVlIDogMH0pOyAvLyBmaXJlZFxuXHQgICAgICogICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY2xpY2snLCB7dmFsdWUgOiAxfSk7IC8vIGRvZXNuJ3QgZmlyZVxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBFdmVudEZpbHRlclxuXHQgICAgICogQG5hbWVzcGFjZSBFdmVudHNcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHBhcmFtIGZpbHRlciB7RnVuY3Rpb259ICBGdW5jdGlvbiByZXR1cm5pbmcgYSBCb29sZWFuXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIEV2ZW50RmlsdGVyKGZpbHRlcikge1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX2NvbmRpdGlvbiA9IGZpbHRlcjtcblx0ICAgIH1cblx0ICAgIEV2ZW50RmlsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cdCAgICBFdmVudEZpbHRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFdmVudEZpbHRlcjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbWl0IGV2ZW50IGlmIHRoZSBjb25kaXRpb24gaXMgc2F0aXNmaWVkLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZW1pdFxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gQ2hhbm5lbCBuYW1lXG5cdCAgICAgKiBAcGFyYW0gZGF0YSB7T2JqZWN0fSBQYXlsb2FkXG5cdCAgICAgKi9cblx0ICAgIEV2ZW50RmlsdGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlLCBkYXRhKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9jb25kaXRpb24odHlwZSwgZGF0YSkpIHJldHVybjtcblx0ICAgICAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxpYXMgb2YgZW1pdC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHRyaWdnZXJcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGRhdGEge09iamVjdH0gUGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBFdmVudEZpbHRlci5wcm90b3R5cGUudHJpZ2dlciA9IEV2ZW50RmlsdGVyLnByb3RvdHlwZS5lbWl0O1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RmlsdGVyO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFdmVudFNwbGl0dGVyIHJvdXRlcyBldmVudHMgdG8gdmFyaW91cyBldmVudCBkZXN0aW5hdGlvbnNcblx0ICAgICAqICBiYXNlZCBvbiBjdXN0b20gbG9naWMuIFRoZSByZXR1cm4gb2YgdGhlIHByb3ZpZGVkIHNwbGl0dGVyXG5cdCAgICAgKiAgZnVuY3Rpb24gc2hvdWxkIGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLlxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0ICAgICAqICAgICAgdmFyIGV2ZW50RW1pdHRlclggPSBuZXcgZXZlbnRFbWl0dGVyKCk7XG5cdCAgICAgKiAgICAgIHZhciBldmVudEVtaXR0ZXJZID0gbmV3IGV2ZW50RW1pdHRlcigpO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGV2ZW50U3BsaXR0ZXIgPSBuZXcgRXZlbnRTcGxpdHRlcihmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIHJldHVybiAocGF5bG9hZC54ID4gcGF5bG9hZC55KVxuXHQgICAgICogICAgICAgICAgICAgID8gZXZlbnRFbWl0dGVyWDtcblx0ICAgICAqICAgICAgICAgICAgICA6IGV2ZW50RW1pdHRlclk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgZXZlbnRTcGxpdHRlci5zdWJzY3JpYmUoZXZlbnRFbWl0dGVyKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGV2ZW50RW1pdHRlclgub24oJ21vdmUnLCBmdW5jdGlvbigpe1xuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2coJ3ggaXMgYmlnZ2VyJylcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBldmVudEVtaXR0ZXJZLm9uKCdtb3ZlJywgZnVuY3Rpb24oKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCd5IGlzIGJpZ2dlcicpXG5cdCAgICAgKiAgICAgIH0pXG5cdCAgICAgKlxuXHQgICAgICogICAgICBldmVudEVtaXR0ZXIuZW1pdCgnbW92ZScsIHt4IDogMywgeSA6IDJ9KTsgLy8geCBpcyBiaWdnZXJcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgRXZlbnRTcGxpdHRlclxuXHQgICAgICogQG5hbWVzcGFjZSBFdmVudHNcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHBhcmFtIHNwbGl0dGVyIHtGdW5jdGlvbn1cblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gRXZlbnRTcGxpdHRlcihzcGxpdHRlcikge1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMuX3NwbGl0dGVyID0gc3BsaXR0ZXI7XG5cdCAgICB9XG5cdCAgICBFdmVudFNwbGl0dGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSk7XG5cdCAgICBFdmVudFNwbGl0dGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50U3BsaXR0ZXI7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW1pdCBldmVudC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGVtaXRcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGRhdGEge09iamVjdH0gUGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBFdmVudFNwbGl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlLCBkYXRhKSB7XG5cdCAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NwbGl0dGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuZW1pdCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuXHQgICAgICAgICAgICB0YXJnZXQuZW1pdCh0eXBlLCBkYXRhKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxpYXMgb2YgZW1pdC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHRyaWdnZXJcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGRhdGEge09iamVjdH0gUGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBFdmVudFNwbGl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gRXZlbnRTcGxpdHRlci5wcm90b3R5cGUuZW1pdDtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudFNwbGl0dGVyO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAxNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBFdmVudE1hcHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHQgICAgdmFyIFNpbXBsZVN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdCAgICB2YXIgcHJlVGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0ICAgIHZhciBwb3N0VGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0ICAgIHZhciBkaXJ0eVF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0ICAgIHZhciBTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0ICAgIHZhciBFVkVOVFMgPSB7XG5cdCAgICAgICAgU1RBUlQgOiAnc3RhcnQnLFxuXHQgICAgICAgIFVQREFURSA6ICd1cGRhdGUnLFxuXHQgICAgICAgIEVORCA6ICdlbmQnLFxuXHQgICAgICAgIFJFU0laRSA6ICdyZXNpemUnXG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFN0cmVhbSBsaXN0ZW5zIHRvIGByZXNpemVgLCBgc3RhcnRgLCBgdXBkYXRlYCBhbmQgYGVuZGAgZXZlbnRzIGFuZFxuXHQgICAgICogIGVtaXRzIGBzdGFydGAsIGB1cGRhdGVgIGFuZCBgZW5kYCBldmVudHMuIGBSZXNpemVgIGV2ZW50cyBnZXRcblx0ICAgICAqICB1bmlmaWVkIHdpdGggYHN0YXJ0YCwgYHVwZGF0ZWAsIGFuZCBgZW5kYCBldmVudHMgZGVwZW5kaW5nIG9uXG5cdCAgICAgKiAgd2hlbiB0aGV5IGFyZSBmaXJlZCB3aXRoaW4gU2Ftc2FyYSdzIGVuZ2luZSBjeWNsZS5cblx0ICAgICAqXG5cdCAgICAgKiAgSWYgbGlzdGVuaW5nIHRvIG11bHRpcGxlIHNvdXJjZXMsIFN0cmVhbSBlbWl0cyBhIHNpbmdsZSBldmVudCBwZXJcblx0ICAgICAqICBFbmdpbmUgY3ljbGUuXG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgcG9zaXRpb24gPSBuZXcgVHJhbnNpdGlvbmFibGUoWzAsMF0pO1xuXHQgICAgICogICAgICB2YXIgc2l6ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciB0cmFuc2xhdGlvblN0cmVhbSA9IFN0cmVhbS5saWZ0KGZ1bmN0aW9uKHBvc2l0aW9uLCBzaXplKXtcblx0ICAgICAqICAgICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IFtcblx0ICAgICAqICAgICAgICAgICAgICBwb3NpdGlvblswXSArIHNpemVbMF0sXG5cdCAgICAgKiAgICAgICAgICAgICAgcG9zaXRpb25bMV0gKyBzaXplWzFdXG5cdCAgICAgKiAgICAgICAgICBdO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm0udHJhbnNsYXRlKHRyYW5zbGF0aW9uKTtcblx0ICAgICAqICAgICAgfSwgW3Bvc2l0aW9uU3RyZWFtLCBzaXplU3RyZWFtXSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB0cmFuc2xhdGlvblN0cmVhbS5vbignc3RhcnQnLCBmdW5jdGlvbih0cmFuc2Zvcm0pe1xuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2codHJhbnNmb3JtKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB0cmFuc2xhdGlvblN0cmVhbS5vbigndXBkYXRlJywgZnVuY3Rpb24odHJhbnNmb3JtKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHRyYW5zZm9ybSk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdHJhbnNsYXRpb25TdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKHRyYW5zZm9ybSl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyh0cmFuc2Zvcm0pO1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHBvc2l0aW9uLnNldChbMTAwLCA1MF0sIHtkdXJhdGlvbiA6IDUwMH0pO1xuXHQgICAgICogICAgICBzaXplLmVtaXQoJ3Jlc2l6ZScsIFsxMDAsMTAwXSk7XG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIFN0cmVhbVxuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TaW1wbGVTdHJlYW1cblx0ICAgICAqIEBuYW1lc3BhY2UgU3RyZWFtc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zXSB7T2JqZWN0fSAgICAgICAgICAgIE9wdGlvbnNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5zdGFydF0ge0Z1bmN0aW9ufSAgICBDdXN0b20gbG9naWMgdG8gbWFwIHRoZSBgc3RhcnRgIGV2ZW50XG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMudXBkYXRlXSB7RnVuY3Rpb259ICAgQ3VzdG9tIGxvZ2ljIHRvIG1hcCB0aGUgYHVwZGF0ZWAgZXZlbnRcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5lbmRdIHtGdW5jdGlvbn0gICAgICBDdXN0b20gbG9naWMgdG8gbWFwIHRoZSBgZW5kYCBldmVudFxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIFN0cmVhbShvcHRpb25zKXtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRJbnB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRJbnB1dCk7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRPdXRwdXQpO1xuXG5cdCAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXHQgICAgICAgIHZhciBpc1VwZGF0aW5nID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIGRpcnR5U3RhcnQgPSBmYWxzZTtcblx0ICAgICAgICB2YXIgZGlydHlFbmQgPSBmYWxzZTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHN0YXJ0KGRhdGEpe1xuXHQgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydCA/IG9wdGlvbnMuc3RhcnQoZGF0YSkgOiBkYXRhO1xuXHQgICAgICAgICAgICBpZiAocGF5bG9hZCAhPT0gZmFsc2UpIHRoaXMuZW1pdChFVkVOVFMuU1RBUlQsIHBheWxvYWQpO1xuXHQgICAgICAgICAgICBkaXJ0eVN0YXJ0ID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gdXBkYXRlKGRhdGEpe1xuXHQgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG9wdGlvbnMgJiYgb3B0aW9ucy51cGRhdGUgPyBvcHRpb25zLnVwZGF0ZShkYXRhKSA6IGRhdGE7XG5cdCAgICAgICAgICAgIGlmIChwYXlsb2FkICE9PSBmYWxzZSkgdGhpcy5lbWl0KEVWRU5UUy5VUERBVEUsIHBheWxvYWQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGVuZChkYXRhKXtcblx0ICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5kID8gb3B0aW9ucy5lbmQoZGF0YSkgOiBkYXRhO1xuXHQgICAgICAgICAgICBpZiAocGF5bG9hZCAhPT0gZmFsc2UpIHRoaXMuZW1pdChFVkVOVFMuRU5ELCBwYXlsb2FkKTtcblx0ICAgICAgICAgICAgZGlydHlFbmQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKEVWRU5UUy5TVEFSVCwgZnVuY3Rpb24oZGF0YSl7XG5cdCAgICAgICAgICAgIGNvdW50ZXIrKztcblx0ICAgICAgICAgICAgaWYgKGRpcnR5U3RhcnQgfHwgaXNVcGRhdGluZykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICBkaXJ0eVN0YXJ0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcHJlVGlja1F1ZXVlLnB1c2goc3RhcnQuYmluZCh0aGlzLCBkYXRhKSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oRVZFTlRTLlVQREFURSwgZnVuY3Rpb24oZGF0YSl7XG5cdCAgICAgICAgICAgIGlzVXBkYXRpbmcgPSB0cnVlO1xuXHQgICAgICAgICAgICBwb3N0VGlja1F1ZXVlLnB1c2godXBkYXRlLmJpbmQodGhpcywgZGF0YSkpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKEVWRU5UUy5FTkQsIGZ1bmN0aW9uKGRhdGEpe1xuXHQgICAgICAgICAgICBjb3VudGVyLS07XG5cdCAgICAgICAgICAgIGlmIChpc1VwZGF0aW5nICYmIGNvdW50ZXIgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGUuY2FsbCh0aGlzLCBkYXRhKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpc1VwZGF0aW5nID0gZmFsc2U7XG5cdCAgICAgICAgICAgIGlmIChkaXJ0eUVuZCkgcmV0dXJuO1xuXHQgICAgICAgICAgICBkaXJ0eUVuZCA9IHRydWU7XG5cdCAgICAgICAgICAgIGRpcnR5UXVldWUucHVzaChlbmQuYmluZCh0aGlzLCBkYXRhKSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oRVZFTlRTLlJFU0laRSwgZnVuY3Rpb24oZGF0YSl7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoU3RhdGUuZ2V0KCkpe1xuXHQgICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5TVEFURVMuU1RBUlQ6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKEVWRU5UUy5TVEFSVCwgZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLlNUQVRFUy5VUERBVEU6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKEVWRU5UUy5VUERBVEUsIGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5TVEFURVMuRU5EOlxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihFVkVOVFMuRU5ELCBkYXRhKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9XG5cblx0ICAgIFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpbXBsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHQgICAgU3RyZWFtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0cmVhbTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFeHRlbmRzIFNpbXBsZVN0cmVhbS5saWZ0XG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHJldHVyblxuXHQgICAgICovXG5cdCAgICBTdHJlYW0ubGlmdCA9IFNpbXBsZVN0cmVhbS5saWZ0O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhdGNoZXMgZXZlbnRzIGZvciBwcm92aWRlZCBvYmplY3Qgb2Ygc3RyZWFtcyBpblxuXHQgICAgICogIHtrZXkgOiBzdHJlYW19IHBhaXJzLiBFbWl0cyBvbmUgZXZlbnQgcGVyIEVuZ2luZSBjeWNsZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIG1lcmdlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gc3RyZWFtcyB7T2JqZWN0fSAgRGljdGlvbmFyeSBvZiBgcmVzaXplYCBzdHJlYW1zXG5cdCAgICAgKi9cblx0ICAgIFN0cmVhbS5tZXJnZSA9IGZ1bmN0aW9uKHN0cmVhbU9iail7XG5cdCAgICAgICAgdmFyIG1lcmdlZFN0cmVhbSA9IG5ldyBTdHJlYW0oKTtcblx0ICAgICAgICB2YXIgbWVyZ2VkRGF0YSA9IChzdHJlYW1PYmogaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xuXG5cdCAgICAgICAgbWVyZ2VkU3RyZWFtLmFkZFN0cmVhbSA9IGZ1bmN0aW9uKGtleSwgc3RyZWFtKXtcblx0ICAgICAgICAgICAgdmFyIG1hcHBlciA9IChmdW5jdGlvbihrZXkpe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudE1hcHBlcihmdW5jdGlvbihkYXRhKXtcblx0ICAgICAgICAgICAgICAgICAgICBtZXJnZWREYXRhW2tleV0gPSBkYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZWREYXRhO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0pKGtleSk7XG5cblx0ICAgICAgICAgICAgbWVyZ2VkU3RyZWFtLnN1YnNjcmliZShtYXBwZXIpLnN1YnNjcmliZShzdHJlYW0pO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3RyZWFtT2JqKXtcblx0ICAgICAgICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbU9ialtrZXldO1xuXHQgICAgICAgICAgICBtZXJnZWRTdHJlYW0uYWRkU3RyZWFtKGtleSwgc3RyZWFtKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbWVyZ2VkU3RyZWFtO1xuXHQgICAgfTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdC8qIERvY3VtZW50YXRpb24gaW4gcHJvZ3Jlc3MuIE1heSBiZSBvdXRkYXRlZC4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdCAgICB2YXIgcHJlVGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0ICAgIHZhciBkaXJ0eVF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBPYnNlcnZhYmxlIGlzIGEgc3RyZWFtIGZvciBldmVudHMgc2V0IGRpc2NyZXRlbHkgaW4gdGltZSwgYXMgb3Bwb3NlZCB0byBjb250aW51b3VzbHkuXG5cdCAgICAgKiAgSXQgZW1pdHMgYXBwcm9wcmlhdGUgYHN0YXJ0YCBhbmQgYGVuZGAgZXZlbnRzIHVwb24gY2FsbGluZyB0aGUgYHNldGAgbWV0aG9kLlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBPYnNlcnZhYmxlXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAZXh0ZW5kcyBTdHJlYW1zLlN0cmVhbVxuXHQgICAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXIsIFN0cmluZywgQXJyYXksIE9iamVjdH0gVmFsdWVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gT2JzZXJ2YWJsZSh2YWx1ZSl7XG5cdCAgICAgICAgU2ltcGxlU3RyZWFtLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG5cdCAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHRoaXMuc2V0KHZhbHVlKTtcblx0ICAgIH1cblxuXHQgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpbXBsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHQgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPYnNlcnZhYmxlO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldHRlciBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0XG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXIsIFN0cmluZywgQXJyYXksIE9iamVjdH1cblx0ICAgICAqL1xuXHQgICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKXtcblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2V0dGVyIGZvciB0aGUgcHJvdmlkZWQgdmFsdWUuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRcblx0ICAgICAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyLCBTdHJpbmcsIEFycmF5LCBPYmplY3R9IFZhbHVlXG5cdCAgICAgKi9cblx0ICAgIE9ic2VydmFibGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgcHJlVGlja1F1ZXVlLnB1c2goZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgc2VsZi52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICBzZWxmLmVtaXQoJ3N0YXJ0JywgdmFsdWUpO1xuXG5cdCAgICAgICAgICAgIGRpcnR5UXVldWUucHVzaChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdlbmQnLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBPYnNlcnZhYmxlO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBTaW1wbGVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0ICAgIHZhciBSZXNpemVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0ICAgIHZhciBTaXplT2JzZXJ2YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY2Fwc3VsYXRlcyBhIHN0cmVhbSBvZiBzaXplIGRhdGEgKHNpemUsIHByb3BvcnRpb25zLCBtYXJnaW5zKS5cblx0ICAgICAqICBMaXN0ZW5zIG9uIHN0YXJ0L3VwZGF0ZS9lbmQgZXZlbnRzLCBiYXRjaGVzIHRoZW0sIGFuZCBlbWl0cyByZXNpemUgZXZlbnRzIGRvd25zdHJlYW1cblx0ICAgICAqICB0byBkZXNjZW5kYW50IHNpemUgbm9kZXMuXG5cdCAgICAgKlxuXHQgICAgICogIFNpemUgY2FuIGJlIGRlZmluZWQgd2l0aCBoZWlnaHQgYW5kIHdpZHRoIGdpdmVuIG51bWVyaWNhbGx5LCBidXRcblx0ICAgICAqICB0aGV5IGNhbiBhbHNvIGJlOlxuXHQgICAgICpcblx0ICAgICAqICBgYGBcblx0ICAgICAqICAgICAgYHVuZGVmaW5lZGAgLSB0YWtlcyB0aGUgcGFyZW50IHZhbHVlXG5cdCAgICAgKiAgICAgIGB0cnVlYCAgICAgIC0gdGFrZXMgdGhlIERPTSBjYWxjdWxhdGVkIHZhbHVlXG5cdCAgICAgKiAgICAgIGBmYWxzZWAgICAgIC0gdmFsdWUgZGVmaW5lZCBieSBzZXR0aW5nIGFuIGFzcGVjdCByYXRpb1xuXHQgICAgICogIGBgYFxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGNvbnRleHQgPSBDb250ZXh0KCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgc3VyZmFjZSA9IG5ldyBTdXJmYWNlKHtcblx0ICAgICAqICAgICAgICAgIHNpemUgOiBbMTAwLDEwMF0sXG5cdCAgICAgKiAgICAgICAgICBwcm9wZXJ0aWVzIDoge2JhY2tncm91bmQgOiAncmVkJ31cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgc2l6ZU5vZGUgPSBuZXcgU2l6ZU5vZGUoe1xuXHQgICAgICogICAgICAgICAgc2l6ZSA6IFsxMDAsIHVuZGVmaW5lZF0sXG5cdCAgICAgKiAgICAgICAgICBtYXJnaW5zIDogWzUwLCA1MF1cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBjb250ZXh0LmFkZChzaXplTm9kZSkuYWRkKHN1cmZhY2UpO1xuXHQgICAgICogICAgICBjb250ZXh0Lm1vdW50KGRvY3VtZW50LmJvZHkpXG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIFNpemVOb2RlXG5cdCAgICAgKiBAbmFtZXNwYWNlIENvcmVcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSBzb3VyY2VzIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBvZiBzaXplIHNvdXJjZXNcblx0ICAgICAqIEBwYXJhbSBbc291cmNlcy5zaXplXSB7U3RyZWFtfEFycmF5fSAgICAgICAgIFNpemUgc291cmNlXG5cdCAgICAgKiBAcGFyYW0gW3NvdXJjZXMubWFyZ2luXSB7U3RyZWFtfEFycmF5fSAgICAgICBNYXJnaW4gc291cmNlXG5cdCAgICAgKiBAcGFyYW0gW3NvdXJjZXMucHJvcG9ydGlvbnNdIHtTdHJlYW18QXJyYXl9ICBQcm9wb3J0aW9ucyBzb3VyY2Vcblx0ICAgICAqIEBwYXJhbSBbc291cmNlcy5hc3BlY3RSYXRpb10ge1N0cmVhbXxOdW1iZXJ9IEFzcGVjdCByYXRpbyBzb3VyY2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gU2l6ZU5vZGUoc291cmNlcykge1xuXHQgICAgICAgIHRoaXMuc3RyZWFtID0gX2NyZWF0ZVN0cmVhbShzb3VyY2VzKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0T3V0cHV0SGFuZGxlcih0aGlzLCB0aGlzLnN0cmVhbSk7XG5cblx0ICAgICAgICB0aGlzLnN0cmVhbS5fZXZlbnRJbnB1dC5vbignc3RhcnQnLCBmdW5jdGlvbihkYXRhKXtcblx0ICAgICAgICAgICAgdGhpcy5zdHJlYW0udHJpZ2dlcigncmVzaXplJywgZGF0YSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMuc3RyZWFtLl9ldmVudElucHV0Lm9uKCd1cGRhdGUnLCBmdW5jdGlvbihkYXRhKXtcblx0ICAgICAgICAgICAgdGhpcy5zdHJlYW0udHJpZ2dlcigncmVzaXplJywgZGF0YSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMuc3RyZWFtLl9ldmVudElucHV0Lm9uKCdlbmQnLCBmdW5jdGlvbihkYXRhKXtcblx0ICAgICAgICAgICAgdGhpcy5zdHJlYW0udHJpZ2dlcigncmVzaXplJywgZGF0YSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH1cblxuXHQgICAgLy8gRW51bWVyYXRpb24gb2YgdHlwZXMgb2Ygc2l6ZSBwcm9wZXJ0aWVzXG5cdCAgICBTaXplTm9kZS5LRVlTID0ge1xuXHQgICAgICAgIHNpemUgOiAnc2l6ZScsXG5cdCAgICAgICAgcHJvcG9ydGlvbnMgOiAncHJvcG9ydGlvbnMnLFxuXHQgICAgICAgIG1hcmdpbnMgOiAnbWFyZ2lucycsXG5cdCAgICAgICAgYXNwZWN0UmF0aW8gOiAnYXNwZWN0UmF0aW8nXG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEludHJvZHVjZSBuZXcgZGF0YSBzdHJlYW1zIHRvIHRoZSBzaXplIG5vZGUgaW4ge2tleSA6IHZhbHVlfSBwYWlycy5cblx0ICAgICAqICBIZXJlIHRoZSBga2V5YCBpcyBvbmUgb2YgXCJzaXplXCIsIFwicHJvcG9ydGlvbnNcIiBvciBcIm1hcmluc1wiLlxuXHQgICAgICogIFRoZSBgdmFsdWVgIGlzIGVpdGhlciBhIHN0cmVhbSwgb3IgYSBzaW1wbGUgdHlwZSBsaWtlIGEgYE51bWJlcmAgb3IgYEFycmF5YC5cblx0ICAgICAqICBTaW1wbGUgdHlwZXMgd2lsbCBiZSB3cmFwcGVkIGluIGFuIGBPYnNlcnZlcmFibGVgIHRvIGVtaXQgYXBwcm9wcmlhdGUgZXZlbnRzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0XG5cdCAgICAgKiBAcGFyYW0gb2JqIHtPYmplY3R9ICAgICAgT2JqZWN0IG9mIGRhdGEgc291cmNlc1xuXHQgICAgICovXG5cdCAgICBTaXplTm9kZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob2JqKXtcblx0ICAgICAgICAvLyBUT0RPOiBiZSBhYmxlIHRvIG92ZXJ3cml0ZSBzdHJlYW1zLiBOb3Qgb25seSBhZGRcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKXtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9ICh2YWx1ZSBpbnN0YW5jZW9mIFNpbXBsZVN0cmVhbSlcblx0ICAgICAgICAgICAgICAgID8gdmFsdWVcblx0ICAgICAgICAgICAgICAgIDogbmV3IFNpemVPYnNlcnZhYmxlKHZhbHVlKTtcblxuXHQgICAgICAgICAgICB0aGlzLnN0cmVhbS5hZGRTdHJlYW0oa2V5LCBzb3VyY2UpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIF9jcmVhdGVTdHJlYW0oc291cmNlcyl7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZXMpe1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VzW2tleV07XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7XG5cdCAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gbmV3IFNpemVPYnNlcnZhYmxlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZXNba2V5XSA9IHNvdXJjZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gUmVzaXplU3RyZWFtLm1lcmdlKHNvdXJjZXMpO1xuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFNpemVOb2RlO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdCAgICB2YXIgRXZlbnRNYXBwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cdCAgICB2YXIgcHJlVGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0ICAgIHZhciBwb3N0VGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0ICAgIHZhciBkaXJ0eVF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0ICAgIHZhciBTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0ICAgIHZhciBFVkVOVFMgPSB7XG5cdCAgICAgICAgUkVTSVpFIDogJ3Jlc2l6ZSdcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVzaXplU3RyZWFtIGlzIGEgc3RyZWFtIHRoYXQgbGlzdGVucyB0byBhbmQgZW1pdHMgYHJlc2l6ZWAgZXZlbnRzLlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBSZXNpemVTdHJlYW1cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAZXh0ZW5kcyBTdHJlYW1zLlN0cmVhbVxuXHQgICAgICogQG5hbWVzcGFjZSBTdHJlYW1zXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnNdIHtPYmplY3R9ICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnJlc2l6ZV0ge0Z1bmN0aW9ufSAgIEN1c3RvbSBsb2dpYyB0byBtYXAgdGhlIGByZXNpemVgIGV2ZW50XG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gUmVzaXplU3RyZWFtKG9wdGlvbnMpe1xuXHQgICAgICAgIHZhciBkaXJ0eVJlc2l6ZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gcmVzaXplKGRhdGEpe1xuXHQgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IChvcHRpb25zICYmIG9wdGlvbnMucmVzaXplKVxuXHQgICAgICAgICAgICAgICAgPyBvcHRpb25zLnJlc2l6ZShkYXRhKVxuXHQgICAgICAgICAgICAgICAgOiBkYXRhO1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoRVZFTlRTLlJFU0laRSwgcGF5bG9hZCk7XG5cdCAgICAgICAgICAgIGRpcnR5UmVzaXplID0gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50SW5wdXQpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRPdXRwdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50T3V0cHV0KTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oRVZFTlRTLlJFU0laRSwgZnVuY3Rpb24oZGF0YSl7XG5cdCAgICAgICAgICAgIGlmICghZGlydHlSZXNpemUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBxdWV1ZTtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoU3RhdGUuZ2V0KCkpe1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuU1RBVEVTLlNUQVJUOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IHByZVRpY2tRdWV1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5TVEFURVMuVVBEQVRFOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IHBvc3RUaWNrUXVldWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuU1RBVEVTLkVORDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkaXJ0eVF1ZXVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVzaXplLmJpbmQodGhpcywgZGF0YSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRpcnR5UmVzaXplID0gdHJ1ZTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfVxuXG5cdCAgICBSZXNpemVTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaW1wbGVTdHJlYW0ucHJvdG90eXBlKTtcblx0ICAgIFJlc2l6ZVN0cmVhbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXNpemVTdHJlYW07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRXh0ZW5kcyBTaW1wbGVTdHJlYW0ubGlmdFxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgbGlmdFxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICovXG5cdCAgICBSZXNpemVTdHJlYW0ubGlmdCA9IFNpbXBsZVN0cmVhbS5saWZ0O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhdGNoZXMgcmVzaXplIGV2ZW50cyBmb3IgcHJvdmlkZWQgb2JqZWN0IG9mIHN0cmVhbXMgaW5cblx0ICAgICAqICB7a2V5IDogc3RyZWFtfSBwYWlycy4gRW1pdHMgb25lIGByZXNpemVgIGV2ZW50IHBlciBFbmdpbmUgY3ljbGUuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBtZXJnZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSBzdHJlYW1zIHtPYmplY3R9ICBEaWN0aW9uYXJ5IG9mIGByZXNpemVgIHN0cmVhbXNcblx0ICAgICAqL1xuXHQgICAgUmVzaXplU3RyZWFtLm1lcmdlID0gZnVuY3Rpb24oc3RyZWFtcyl7XG5cdCAgICAgICAgdmFyIG1lcmdlZFN0cmVhbSA9IG5ldyBSZXNpemVTdHJlYW0oKTtcblx0ICAgICAgICB2YXIgbWVyZ2VkRGF0YSA9IChzdHJlYW1zIGluc3RhbmNlb2YgQXJyYXkpID8gW10gOiB7fTtcblxuXHQgICAgICAgIG1lcmdlZFN0cmVhbS5hZGRTdHJlYW0gPSBmdW5jdGlvbihrZXksIHN0cmVhbSl7XG5cdCAgICAgICAgICAgIHZhciBtYXBwZXIgPSAoZnVuY3Rpb24oa2V5KXtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRNYXBwZXIoZnVuY3Rpb24oZGF0YSl7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVyZ2VkRGF0YVtrZXldID0gZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkRGF0YTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KShrZXkpO1xuXG5cdCAgICAgICAgICAgIG1lcmdlZFN0cmVhbS5zdWJzY3JpYmUobWFwcGVyKS5zdWJzY3JpYmUoc3RyZWFtKTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHN0cmVhbXMpe1xuXHQgICAgICAgICAgICB2YXIgc3RyZWFtID0gc3RyZWFtc1trZXldO1xuXHQgICAgICAgICAgICBtZXJnZWRTdHJlYW0uYWRkU3RyZWFtKGtleSwgc3RyZWFtKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbWVyZ2VkU3RyZWFtO1xuXHQgICAgfTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBSZXNpemVTdHJlYW07XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdC8qIERvY3VtZW50YXRpb24gaW4gcHJvZ3Jlc3MuIE1heSBiZSBvdXRkYXRlZC4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdCAgICB2YXIgcHJlVGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0ICAgIHZhciBkaXJ0eVF1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIFNpemVPYnNlcnZhYmxlIGlzIGEgc3RyZWFtIGZvciByZXNpemUgZXZlbnRzIHNldCBkaXNjcmV0ZWx5IGluIHRpbWUsIGFzIG9wcG9zZWQgdG8gY29udGludW91c2x5LlxuXHQgICAgICogIEl0IGVtaXRzIGFwcHJvcHJpYXRlIGByZXNpemVgIGV2ZW50cyB1cG9uIGNhbGxpbmcgdGhlIGBzZXRgIG1ldGhvZC5cblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgT2JzZXJ2YWJsZVxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TaW1wbGVTdHJlYW1cblx0ICAgICAqIEBwYXJhbSB2YWx1ZSB7QXJyYXl9IFNpemVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gU2l6ZU9ic2VydmFibGUodmFsdWUpe1xuXHQgICAgICAgIFNpbXBsZVN0cmVhbS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuXHQgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB0aGlzLnNldCh2YWx1ZSk7XG5cdCAgICB9XG5cblx0ICAgIFNpemVPYnNlcnZhYmxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBTaXplT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaXplT2JzZXJ2YWJsZTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXR0ZXIgZm9yIHRoZSBwcm92aWRlZCBzaXplLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0XG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgU2l6ZU9ic2VydmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldHRlciBmb3IgdGhlIHByb3ZpZGVkIHNpemUuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRcblx0ICAgICAqIEBwYXJhbSB2YWx1ZSB7QXJyYXl9IFNpemVcblx0ICAgICAqL1xuXHQgICAgU2l6ZU9ic2VydmFibGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgcHJlVGlja1F1ZXVlLnB1c2goZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgc2VsZi52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICBzZWxmLmVtaXQoJ3Jlc2l6ZScsIHZhbHVlKTtcblx0ICAgICAgICAgICAgZGlydHlRdWV1ZS5wdXNoKGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgICAgICBzZWxmLmVtaXQoJ3Jlc2l6ZScsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFNpemVPYnNlcnZhYmxlO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAyMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgdGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgdGltaW5nIHV0aWxpdGllcyBtZWFudCB0byB0cmFuc2xhdGUgdGhlIGZhbWlsaWFyIHNldEludGVydmFsLCBzZXRUaW1lb3V0XG5cdCAgICAgKiAgdGltZXJzIHRvIHVzZSBTYW1zYXJhJ3MgaW50ZXJuYWwgY2xvY2ssIHdoaWNoIGlzIGJhY2tlZCBieSBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSAoUkFGKSBsb29wLlxuXHQgICAgICogIEl0IGFsc28gaW5jbHVkZXMgb3RoZXIgaGVscGZ1bCBtZXRob2RzIGZvciBkZWJvdW5jaW5nLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICBUaW1lci5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgKiAgICAgICAgICBhbGVydCgnSSB3aWxsIGV4ZWN1dGUgYWZ0ZXIgMSBzZWNvbmQnKTtcblx0ICAgICAqICAgICAgfSwgMTAwMCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBUaW1lci5hZnRlcihmdW5jdGlvbigpe1xuXHQgICAgICogICAgICAgICAgYWxlcnQoJ0kgd2lsbCBleGVjdXRlIG9uIHRoZSBmb2xsb3dpbmcgUkFGIGxvb3AnKTtcblx0ICAgICAqICAgICAgfSwgMSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgZGVib3VuY2VkUmVzaXplID0gVGltZXIuZGVib3VuY2UoZnVuY3Rpb24oKXtcblx0ICAgICAqICAgICAgICAgIC8vIHRoaXMgY29kZSB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgYHJlc2l6ZWAgZXZlbnRcblx0ICAgICAqICAgICAgICAgIC8vIGhhcyBzdG9wcGVkIGZpcmluZyAoZm9yIHRoZSBsYXN0IDIwMCBtaWxsaXNlY29uZHMpXG5cdCAgICAgKiAgICAgIH0sIDIwMCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBFbmdpbmUub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uKCl7XG5cdCAgICAgKiAgICAgICAgICBkZWJvdW5jZVJlc2l6ZSgpO1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgVGltZXJcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqL1xuXHQgICAgdmFyIFRpbWVyID0ge307XG5cblx0ICAgIHZhciBnZXRUaW1lID0gKHdpbmRvdy5wZXJmb3JtYW5jZSlcblx0ICAgICAgICA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpOyB9XG5cdCAgICAgICAgOiBEYXRlLm5vdztcblxuXHQgICAgZnVuY3Rpb24gX2FkZFRpbWVyRnVuY3Rpb24oZm4pIHtcblx0ICAgICAgICB0aWNrUXVldWUucHVzaChmbik7XG5cdCAgICAgICAgcmV0dXJuIGZuO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfY2xlYXJUaW1lckZ1bmN0aW9uKGZuKXtcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aWNrUXVldWUuaW5kZXhPZihmbik7XG5cdCAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXHQgICAgICAgIHRpY2tRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFdyYXBzIGEgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUuXG5cdCAgICAgKiAgQWZ0ZXIgYSBzZXQgZHVyYXRpb24gaGFzIHBhc3NlZCwgaXQgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0VGltZW91dFxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSAgICBGdW5jdGlvbiB0byBiZSBydW4gYWZ0ZXIgYSBzcGVjaWZpZWQgZHVyYXRpb25cblx0ICAgICAqIEBwYXJhbSBkdXJhdGlvbiB7TnVtYmVyfSAgICAgVGltZSB0byBkZWxheSBleGVjdXRpb24gKGluIG1pbGxpc2Vjb25kcylcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgICAgICovXG5cdCAgICBUaW1lci5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gc2V0VGltZW91dChoYW5kbGVyLCBkdXJhdGlvbikge1xuXHQgICAgICAgIHZhciB0ID0gZ2V0VGltZSgpO1xuXHQgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdDIgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgICAgIGlmICh0MiAtIHQgPj0gZHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIFRpbWVyLmNsZWFyKGNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIF9hZGRUaW1lckZ1bmN0aW9uKGNhbGxiYWNrKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGF0IHJlcGVhdGVkIGludGVydmFscy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldEludGVydmFsXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgIEZ1bmN0aW9uIHRvIGJlIHJ1biBhdCBzcGVjaWZpZWQgaW50ZXJ2YWxzXG5cdCAgICAgKiBAcGFyYW0gaW50ZXJ2YWwge051bWJlcn0gICAgIFRpbWUgaW50ZXJ2YWwgKGluIG1pbGxpc2Vjb25kcylcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgICAgICovXG5cdCAgICBUaW1lci5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uIHNldEludGVydmFsKGhhbmRsZXIsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgdmFyIHQgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0MiA9IGdldFRpbWUoKTtcblx0ICAgICAgICAgICAgaWYgKHQyIC0gdCA+PSBkdXJhdGlvbikge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgdCA9IGdldFRpbWUoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIF9hZGRUaW1lckZ1bmN0aW9uKGNhbGxiYWNrKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIGEgc3BlY2lmaWVkIG51bWJlciBvZiBFbmdpbmUgdGlja3MuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBhZnRlclxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSAgICBGdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuXHQgICAgICogQHBhcmFtIG51bVRpY2tzIHtOdW1iZXJ9ICAgICBOdW1iZXIgb2YgZnJhbWVzIHRvIGRlbGF5IGV4ZWN1dGlvblxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAgICAgKi9cblx0ICAgIFRpbWVyLmFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoaGFuZGxlciwgbnVtVGlja3MpIHtcblx0ICAgICAgICBpZiAobnVtVGlja3MgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgbnVtVGlja3MtLTtcblx0ICAgICAgICAgICAgaWYgKG51bVRpY2tzIDw9IDApIHsgLy9pbiBjYXNlIG51bVRpY2tzIGlzIGZyYWN0aW9uIG9yIG5lZ2F0aXZlXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICBUaW1lci5jbGVhcihjYWxsYmFjayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBfYWRkVGltZXJGdW5jdGlvbihjYWxsYmFjayk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFdyYXBzIGEgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBldmVyeSBzcGVjaWZpZWQgbnVtYmVyIG9mIEVuZ2luZSB0aWNrcy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGV2ZXJ5XG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgIEZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG5cdCAgICAgKiBAcGFyYW0gbnVtVGlja3Mge051bWJlcn0gICAgIE51bWJlciBvZiBmcmFtZXMgcGVyIGV4ZWN1dGlvblxuXHQgICAgICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAgICAgKi9cblx0ICAgIFRpbWVyLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoaGFuZGxlciwgbnVtVGlja3MpIHtcblx0ICAgICAgICBudW1UaWNrcyA9IG51bVRpY2tzIHx8IDE7XG5cdCAgICAgICAgdmFyIGluaXRpYWwgPSBudW1UaWNrcztcblx0ICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgbnVtVGlja3MtLTtcblx0ICAgICAgICAgICAgaWYgKG51bVRpY2tzIDw9IDApIHtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIG51bVRpY2tzID0gaW5pdGlhbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgcmV0dXJuIF9hZGRUaW1lckZ1bmN0aW9uKGNhbGxiYWNrKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2FuY2VsIGEgdGltZXIuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBjbGVhclxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSBIYW5kbGVyXG5cdCAgICAgKi9cblx0ICAgIFRpbWVyLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaGFuZGxlcikge1xuXHQgICAgICAgIF9jbGVhclRpbWVyRnVuY3Rpb24oaGFuZGxlcik7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlYm91bmNlcyBhIGZ1bmN0aW9uIGZvciBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBkZWJvdW5jZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSAgSGFuZGxlclxuXHQgICAgICogQHBhcmFtIGR1cmF0aW9uIHtOdW1iZXJ9ICAgRHVyYXRpb25cblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgICAgICovXG5cdCAgICBUaW1lci5kZWJvdW5jZSA9IGZ1bmN0aW9uIGRlYm91bmNlKGhhbmRsZXIsIGR1cmF0aW9uKSB7XG5cdCAgICAgICAgdmFyIHRpbWVvdXQ7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuXHQgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIFRpbWVyLmNsZWFyKHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cblx0ICAgICAgICAgICAgaWYgKHRpbWVvdXQpIFRpbWVyLmNsZWFyKHRpbWVvdXQpO1xuXHQgICAgICAgICAgICB0aW1lb3V0ID0gVGltZXIuc2V0VGltZW91dChmbiwgZHVyYXRpb24pO1xuXHQgICAgICAgIH07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlYm91bmNlcyBhIGZ1bmN0aW9uIGZvciBhIHNwZWNpZmllZCBudW1iZXIgb2YgRW5naW5lIGZyYW1lcy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGZyYW1lRGVib3VuY2Vcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSBoYW5kbGVyIHtGdW5jdGlvbn0gIEhhbmRsZXJcblx0ICAgICAqIEBwYXJhbSBudW1GcmFtZXMge051bWJlcn0gIE51bWJlciBvZiBmcmFtZXNcblx0ICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgICAgICovXG5cdCAgICBUaW1lci5mcmFtZURlYm91bmNlID0gZnVuY3Rpb24gZnJhbWVEZWJvdW5jZShoYW5kbGVyLCBudW1GcmFtZXMpe1xuXHQgICAgICAgIHZhciB0aW1lb3V0O1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0ICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuXHQgICAgICAgICAgICBpZiAodGltZW91dCkgVGltZXIuY2xlYXIodGltZW91dCk7XG5cdCAgICAgICAgICAgIHRpbWVvdXQgPSBUaW1lci5hZnRlcihmbiwgbnVtRnJhbWVzKTtcblx0ICAgICAgICB9O1xuXHQgICAgfTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBUaW1lcjtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMjEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgbGlicmFyeSBmb3IgY3JlYXRpbmcgYW5kIGNvbXBvc2luZyBDU1MzIG1hdHJpeCB0cmFuc2Zvcm1zLlxuXHQgICAgICogIEEgVHJhbnNmb3JtIGlzIGEgMTYgZWxlbWVudCBmbG9hdCBhcnJheSBgdCA9IFt0MCwgLi4uLCB0MTVdYFxuXHQgICAgICogIHRoYXQgY29ycmVzcG9uZHMgdG8gYSA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4IChpbiByb3ctbWFqb3Igb3JkZXIpXG5cdCAgICAgKlxuXHQgICAgICogIGBgYFxuXHQgICAgICogICAg4pSMICAgICAgICAgICAgICAg4pSQXG5cdCAgICAgKiAgICDilIIgdDAgIHQxICB0MiAgMCDilIJcblx0ICAgICAqICAgIOKUgiB0NCAgdDUgIHQ2ICAwIOKUglxuXHQgICAgICogICAg4pSCIHQ4ICB0OSAgdDEwIDAg4pSCXG5cdCAgICAgKiAgICDilIIgdDEyIHQxMyB0MTQgMSDilIJcblx0ICAgICAqICAgIOKUlCAgICAgICAgICAgICAgIOKUmFxuXHQgICAgICogIGBgYFxuXHQgICAgICpcblx0ICAgICAqICBUaGlzIG1hdHJpeCBpcyBhIGRhdGEgc3RydWN0dXJlIGVuY29kaW5nIGEgY29tYmluYXRpb24gb2YgdHJhbnNsYXRpb24sXG5cdCAgICAgKiAgc2NhbGUsIHNrZXcgYW5kIHJvdGF0aW9uIGNvbXBvbmVudHMuXG5cdCAgICAgKlxuXHQgICAgICogIE5vdGU6IHRoZXNlIG1hdHJpY2VzIGFyZSB0cmFuc3Bvc2VzIGZyb20gdGhlaXIgbWF0aGVtYXRpY2FsIGNvdW50ZXJwYXJ0cy5cblx0ICAgICAqXG5cdCAgICAgKiAgQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBsYXlvdXROb2RlID0gdmFyIExheW91dE5vZGUoe1xuXHQgICAgICogICAgICAgICAgdHJhbnNmb3JtIDogVHJhbnNmb3JtLnRyYW5zbGF0ZShbMTAwLDIwMCw1MF0pXG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHRyYW5zaXRpb25hYmxlID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHRyYW5zZm9ybSA9IHRyYW5zaXRpb25hYmxlLm1hcChmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgKiAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLnNjYWxlWCh2YWx1ZSk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGxheW91dE5vZGUgPSB2YXIgTGF5b3V0Tm9kZSh7XG5cdCAgICAgKiAgICAgICAgICB0cmFuc2Zvcm0gOiB0cmFuc2Zvcm1cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB0cmFuc2l0aW9uYWJsZS5zZXQoMTAwLCB7ZHVyYXRpb24gOiA1MDB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgVHJhbnNmb3JtXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKi9cblx0ICAgIHZhciBUcmFuc2Zvcm0gPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBJZGVudGl0eSB0cmFuc2Zvcm0uXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IGlkZW50aXR5IHtBcnJheX1cblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBmaW5hbFxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0uaWRlbnRpdHkgPSBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG5cblx0ICAgIC8vVE9ETzogd2h5IGRvIGluRnJvbnQvYmVoaW5kIG5lZWQgdG8gdHJhbnNsYXRlIGJ5ID4xIHRvIG92ZXJjb21lIERPTSBvcmRlcj9cblx0ICAgIC8qKlxuXHQgICAgICogVHJhbnNmb3JtIGZvciBtb3ZpbmcgYSByZW5kZXJhYmxlIGluIGZyb250IG9mIGFub3RoZXIgcmVuZGVyYWJsZSBpbiB0aGUgei1kaXJlY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IGluRnJvbnQge0FycmF5fVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQGZpbmFsXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS5pbkZyb250ID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEuMDAxLCAxXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUcmFuc2Zvcm0gZm9yIG1vdmluZyBhIHJlbmRlcmFibGUgYmVoaW5kIGFub3RoZXIgcmVuZGVyYWJsZSBpbiB0aGUgei1kaXJlY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IGJlaGluZCB7QXJyYXl9XG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAZmluYWxcblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmJlaGluZCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAtMS4wMDEsIDFdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbXBvc2UgVHJhbnNmb3JtIGFycmF5cyB2aWEgbWF0cml4IG11bHRpcGxpY2F0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgY29tcG9zZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIHQxIHtUcmFuc2Zvcm19IExlZnQgVHJhbnNmb3JtXG5cdCAgICAgKiBAcGFyYW0gdDIge1RyYW5zZm9ybX0gUmlnaHQgVHJhbnNmb3JtXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmNvbXBvc2UgPSBmdW5jdGlvbiBtdWx0aXBseSh0MSwgdDIpIHtcblx0ICAgICAgICBpZiAodDEgPT09IFRyYW5zZm9ybS5pZGVudGl0eSkgcmV0dXJuIHQyLnNsaWNlKCk7XG5cdCAgICAgICAgaWYgKHQyID09PSBUcmFuc2Zvcm0uaWRlbnRpdHkpIHJldHVybiB0MS5zbGljZSgpO1xuXHQgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgIHQxWzBdICogdDJbMF0gKyB0MVs0XSAqIHQyWzFdICsgdDFbOF0gKiB0MlsyXSxcblx0ICAgICAgICAgICAgdDFbMV0gKiB0MlswXSArIHQxWzVdICogdDJbMV0gKyB0MVs5XSAqIHQyWzJdLFxuXHQgICAgICAgICAgICB0MVsyXSAqIHQyWzBdICsgdDFbNl0gKiB0MlsxXSArIHQxWzEwXSAqIHQyWzJdLFxuXHQgICAgICAgICAgICAwLFxuXHQgICAgICAgICAgICB0MVswXSAqIHQyWzRdICsgdDFbNF0gKiB0Mls1XSArIHQxWzhdICogdDJbNl0sXG5cdCAgICAgICAgICAgIHQxWzFdICogdDJbNF0gKyB0MVs1XSAqIHQyWzVdICsgdDFbOV0gKiB0Mls2XSxcblx0ICAgICAgICAgICAgdDFbMl0gKiB0Mls0XSArIHQxWzZdICogdDJbNV0gKyB0MVsxMF0gKiB0Mls2XSxcblx0ICAgICAgICAgICAgMCxcblx0ICAgICAgICAgICAgdDFbMF0gKiB0Mls4XSArIHQxWzRdICogdDJbOV0gKyB0MVs4XSAqIHQyWzEwXSxcblx0ICAgICAgICAgICAgdDFbMV0gKiB0Mls4XSArIHQxWzVdICogdDJbOV0gKyB0MVs5XSAqIHQyWzEwXSxcblx0ICAgICAgICAgICAgdDFbMl0gKiB0Mls4XSArIHQxWzZdICogdDJbOV0gKyB0MVsxMF0gKiB0MlsxMF0sXG5cdCAgICAgICAgICAgIDAsXG5cdCAgICAgICAgICAgIHQxWzBdICogdDJbMTJdICsgdDFbNF0gKiB0MlsxM10gKyB0MVs4XSAqIHQyWzE0XSArIHQxWzEyXSxcblx0ICAgICAgICAgICAgdDFbMV0gKiB0MlsxMl0gKyB0MVs1XSAqIHQyWzEzXSArIHQxWzldICogdDJbMTRdICsgdDFbMTNdLFxuXHQgICAgICAgICAgICB0MVsyXSAqIHQyWzEyXSArIHQxWzZdICogdDJbMTNdICsgdDFbMTBdICogdDJbMTRdICsgdDFbMTRdLFxuXHQgICAgICAgICAgICAxXG5cdCAgICAgICAgXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIENvbXBvc2Ugc2V2ZXJhbCBUcmFuc2Zvcm0gYXJyYXlzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgY29tcG9zZU1hbnlcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB7Li4uVHJhbnNmb3JtfSAgICBUcmFuc2Zvcm0gYXJyYXlzXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmNvbXBvc2VNYW55ID0gZnVuY3Rpb24gY29tcG9zZU1hbnkoKXtcblx0ICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpe1xuXHQgICAgICAgICAgICB2YXIgZmlyc3QgPSBhcmd1bWVudHNbMF07XG5cdCAgICAgICAgICAgIHZhciBzZWNvbmQgPSBhcmd1bWVudHNbMV07XG5cdCAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zaGlmdC5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIGFyZ3VtZW50c1swXSA9IFRyYW5zZm9ybS5jb21wb3NlKGZpcnN0LCBzZWNvbmQpO1xuXHQgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLmNvbXBvc2VNYW55LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgcmV0dXJuIFRyYW5zZm9ybS5jb21wb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFRyYW5zbGF0ZSBhIFRyYW5zZm9ybSBhZnRlciB0aGUgVHJhbnNmb3JtIGlzIGFwcGxpZWQuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCB0aGVuTW92ZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIHQge1RyYW5zZm9ybX0gICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHBhcmFtIHYge051bWJlcltdfSAgICAgIEFycmF5IG9mIFt4LHksel0gdHJhbnNsYXRpb24gY29tcG9uZW50c1xuXHQgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS50aGVuTW92ZSA9IGZ1bmN0aW9uIHRoZW5Nb3ZlKHQsIHYpIHtcblx0ICAgICAgICBpZiAoIXZbMl0pIHZbMl0gPSAwO1xuXHQgICAgICAgIHJldHVybiBbdFswXSwgdFsxXSwgdFsyXSwgMCwgdFs0XSwgdFs1XSwgdFs2XSwgMCwgdFs4XSwgdFs5XSwgdFsxMF0sIDAsIHRbMTJdICsgdlswXSwgdFsxM10gKyB2WzFdLCB0WzE0XSArIHZbMl0sIDFdO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUcmFuc2xhdGUgYSBUcmFuc2Zvcm0gYmVmb3JlIHRoZSBUcmFuc2Zvcm0gaXMgYXBwbGllZC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIG1vdmVUaGVuXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gdiB7TnVtYmVyW119ICAgICAgQXJyYXkgb2YgW3gseSx6XSB0cmFuc2xhdGlvbiBjb21wb25lbnRzXG5cdCAgICAgKiBAcGFyYW0gdCB7VHJhbnNmb3JtfSAgICAgVHJhbnNmb3JtXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLm1vdmVUaGVuID0gZnVuY3Rpb24gbW92ZVRoZW4odiwgdCkge1xuXHQgICAgICAgIGlmICghdlsyXSkgdlsyXSA9IDA7XG5cdCAgICAgICAgdmFyIHQwID0gdlswXSAqIHRbMF0gKyB2WzFdICogdFs0XSArIHZbMl0gKiB0WzhdO1xuXHQgICAgICAgIHZhciB0MSA9IHZbMF0gKiB0WzFdICsgdlsxXSAqIHRbNV0gKyB2WzJdICogdFs5XTtcblx0ICAgICAgICB2YXIgdDIgPSB2WzBdICogdFsyXSArIHZbMV0gKiB0WzZdICsgdlsyXSAqIHRbMTBdO1xuXHQgICAgICAgIHJldHVybiBUcmFuc2Zvcm0udGhlbk1vdmUodCwgW3QwLCB0MSwgdDJdKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHdoaWNoIHJlcHJlc2VudHMgdHJhbnNsYXRpb24gYnkgYSB0cmFuc2xhdGlvbiB2ZWN0b3IuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCB0cmFuc2xhdGVcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB2IHtOdW1iZXJbXX0gICAgICBUcmFuc2xhdGlvbiB2ZWN0b3IgW3gseSx6XVxuXHQgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUodikge1xuXHQgICAgICAgIHZhciB4ID0gdlswXSB8fCAwO1xuXHQgICAgICAgIHZhciB5ID0gdlsxXSB8fCAwO1xuXHQgICAgICAgIHZhciB6ID0gdlsyXSB8fCAwO1xuXHQgICAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgeCwgeSwgeiwgMV07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiBhIFRyYW5zZm9ybSB3aGljaCByZXByZXNlbnRzIHRyYW5zbGF0aW9uIGluIHRoZSB4LWRpcmVjdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHRyYW5zbGF0ZVhcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB4IHtOdW1iZXJ9ICAgICAgICBUcmFuc2xhdGlvbiBhbW91bnRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnRyYW5zbGF0ZVggPSBmdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcblx0ICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIHgsIDAsIDAsIDFdO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm4gYSBUcmFuc2Zvcm0gd2hpY2ggcmVwcmVzZW50cyB0cmFuc2xhdGlvbiBpbiB0aGUgeS1kaXJlY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCB0cmFuc2xhdGVZXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0geSB7TnVtYmVyfSAgICAgICAgVHJhbnNsYXRpb24gYW1vdW50XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS50cmFuc2xhdGVZID0gZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG5cdCAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCB5LCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHdoaWNoIHJlcHJlc2VudHMgdHJhbnNsYXRpb24gaW4gdGhlIHotZGlyZWN0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdHJhbnNsYXRlWlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIHoge051bWJlcn0gICAgICAgIFRyYW5zbGF0aW9uIGFtb3VudFxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0udHJhbnNsYXRlWiA9IGZ1bmN0aW9uIHRyYW5zbGF0ZVooeikge1xuXHQgICAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgeiwgMV07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiBhIFRyYW5zZm9ybSB3aGljaCByZXByZXNlbnRzIGEgc2NhbGluZyBieSBzcGVjaWZpZWQgYW1vdW50cyBpbiBlYWNoIGRpbWVuc2lvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNjYWxlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gdiB7TnVtYmVyW119ICAgICAgU2NhbGUgdmVjdG9yIFt4LHksel1cblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2KSB7XG5cdCAgICAgICAgdmFyIHggPSAodlswXSAhPT0gdW5kZWZpbmVkKSA/IHZbMF0gOiAxO1xuXHQgICAgICAgIHZhciB5ID0gKHZbMV0gIT09IHVuZGVmaW5lZCkgPyB2WzFdIDogMTtcblx0ICAgICAgICB2YXIgeiA9ICh2WzJdICE9PSB1bmRlZmluZWQpID8gdlsyXSA6IDE7XG5cdCAgICAgICAgcmV0dXJuIFt4LCAwLCAwLCAwLCAwLCB5LCAwLCAwLCAwLCAwLCB6LCAwLCAwLCAwLCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHdoaWNoIHJlcHJlc2VudHMgc2NhbGluZyBpbiB0aGUgeC1kaXJlY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzY2FsZVhcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB4IHtOdW1iZXJ9ICAgICAgICBTY2FsZSBhbW91bnRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnNjYWxlWCA9IGZ1bmN0aW9uIHNjYWxlWCh4KSB7XG5cdCAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCB4LCAwLCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHdoaWNoIHJlcHJlc2VudHMgc2NhbGluZyBpbiB0aGUgeS1kaXJlY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzY2FsZVlcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB5IHtOdW1iZXJ9ICAgICAgICBTY2FsZSBhbW91bnRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnNjYWxlWSA9IGZ1bmN0aW9uIHNjYWxlWSh5KSB7XG5cdCAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCB5LCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHdoaWNoIHJlcHJlc2VudHMgc2NhbGluZyBpbiB0aGUgei1kaXJlY3Rpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzY2FsZVpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB6IHtOdW1iZXJ9ICAgICAgICBTY2FsZSBhbW91bnRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnNjYWxlWiA9IGZ1bmN0aW9uIHNjYWxlWih6KSB7XG5cdCAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCB6LCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2NhbGUgYSBUcmFuc2Zvcm0gYWZ0ZXIgdGhlIFRyYW5zZm9ybSBpcyBhcHBsaWVkLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdGhlblNjYWxlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gdCB7VHJhbnNmb3JtfSAgICAgVHJhbnNmb3JtXG5cdCAgICAgKiBAcGFyYW0gdiB7TnVtYmVyW119ICAgICAgQXJyYXkgb2YgW3gseSx6XSBzY2FsZSBjb21wb25lbnRzXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnRoZW5TY2FsZSA9IGZ1bmN0aW9uIHRoZW5TY2FsZSh0LCB2KSB7XG5cdCAgICAgICAgdmFyIHggPSAodlswXSAhPT0gdW5kZWZpbmVkKSA/IHZbMF0gOiAxO1xuXHQgICAgICAgIHZhciB5ID0gKHZbMV0gIT09IHVuZGVmaW5lZCkgPyB2WzFdIDogMTtcblx0ICAgICAgICB2YXIgeiA9ICh2WzJdICE9PSB1bmRlZmluZWQpID8gdlsyXSA6IDE7XG5cdCAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgeCAqIHRbMF0sICB5ICogdFsxXSwgIHogKiB0WzJdLCAgMCxcblx0ICAgICAgICAgICAgeCAqIHRbNF0sICB5ICogdFs1XSwgIHogKiB0WzZdLCAgMCxcblx0ICAgICAgICAgICAgeCAqIHRbOF0sICB5ICogdFs5XSwgIHogKiB0WzEwXSwgMCxcblx0ICAgICAgICAgICAgeCAqIHRbMTJdLCB5ICogdFsxM10sIHogKiB0WzE0XSwgMVxuXHQgICAgICAgIF07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiBhIFRyYW5zZm9ybSByZXByZXNlbnRpbmcgYSBjbG9ja3dpc2Ugcm90YXRpb24gYXJvdW5kIHRoZSB4LWF4aXMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCByb3RhdGVYXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gYW5nbGUge051bWJlcn0gICAgQW5nbGUgaW4gcmFkaWFuc1xuXHQgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS5yb3RhdGVYID0gZnVuY3Rpb24gcm90YXRlWChhbmdsZSkge1xuXHQgICAgICAgIHZhciBjb3NUaGV0YSA9IE1hdGguY29zKGFuZ2xlKTtcblx0ICAgICAgICB2YXIgc2luVGhldGEgPSBNYXRoLnNpbihhbmdsZSk7XG5cdCAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCBjb3NUaGV0YSwgc2luVGhldGEsIDAsIDAsIC1zaW5UaGV0YSwgY29zVGhldGEsIDAsIDAsIDAsIDAsIDFdO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm4gYSBUcmFuc2Zvcm0gcmVwcmVzZW50aW5nIGEgY2xvY2t3aXNlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeS1heGlzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgcm90YXRlWVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGFuZ2xlIHtOdW1iZXJ9ICAgIEFuZ2xlIGluIHJhZGlhbnNcblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0ucm90YXRlWSA9IGZ1bmN0aW9uIHJvdGF0ZVkoYW5nbGUpIHtcblx0ICAgICAgICB2YXIgY29zVGhldGEgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdCAgICAgICAgdmFyIHNpblRoZXRhID0gTWF0aC5zaW4oYW5nbGUpO1xuXHQgICAgICAgIHJldHVybiBbY29zVGhldGEsIDAsIC1zaW5UaGV0YSwgMCwgMCwgMSwgMCwgMCwgc2luVGhldGEsIDAsIGNvc1RoZXRhLCAwLCAwLCAwLCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHJlcHJlc2VudGluZyBhIGNsb2Nrd2lzZSByb3RhdGlvbiBhcm91bmQgdGhlIHotYXhpcy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJvdGF0ZVhcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSBhbmdsZSB7TnVtYmVyfSAgICBBbmdsZSBpbiByYWRpYW5zXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnJvdGF0ZVogPSBmdW5jdGlvbiByb3RhdGVaKHRoZXRhKSB7XG5cdCAgICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuXHQgICAgICAgIHZhciBzaW5UaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcblx0ICAgICAgICByZXR1cm4gW2Nvc1RoZXRhLCBzaW5UaGV0YSwgMCwgMCwgLXNpblRoZXRhLCBjb3NUaGV0YSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiBhIFRyYW5zZm9ybSByZXByZXNlbnRhdGlvbiBvZiBhIHNrZXcgaW4gdGhlIHgtZGlyZWN0aW9uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBza2V3WFxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGFuZ2xlIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB0b3AgYW5kIGxlZnQgc2lkZXNcblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0uc2tld1ggPSBmdW5jdGlvbiBza2V3WChhbmdsZSkge1xuXHQgICAgICAgIHJldHVybiBbMSwgMCwgMCwgMCwgTWF0aC50YW4oYW5nbGUpLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHJlcHJlc2VudGF0aW9uIG9mIGEgc2tldyBpbiB0aGUgeS1kaXJlY3Rpb25cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNrZXdZXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gYW5nbGUge051bWJlcn0gICAgVGhlIGFuZ2xlIGJldHdlZW4gdGhlIGJvdHRvbSBhbmQgcmlnaHQgc2lkZXNcblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0uc2tld1kgPSBmdW5jdGlvbiBza2V3WShhbmdsZSkge1xuXHQgICAgICAgIHJldHVybiBbMSwgTWF0aC50YW4oYW5nbGUpLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGEgVHJhbnNmb3JtIHdoaWNoIHJlcHJlc2VudHMgYW4gYXhpcy1hbmdsZSByb3RhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJvdGF0ZUF4aXNcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB2IHtOdW1iZXJbXX0gICBVbml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGF4aXMgdG8gcm90YXRlIGFib3V0XG5cdCAgICAgKiBAcGFyYW0gYW5nbGUge051bWJlcn0gUmFkaWFucyB0byByb3RhdGUgY2xvY2t3aXNlIGFib3V0IHRoZSBheGlzXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnJvdGF0ZUF4aXMgPSBmdW5jdGlvbiByb3RhdGVBeGlzKHYsIGFuZ2xlKSB7XG5cdCAgICAgICAgdmFyIHNpblRoZXRhID0gTWF0aC5zaW4oYW5nbGUpO1xuXHQgICAgICAgIHZhciBjb3NUaGV0YSA9IDEgLSBNYXRoLmNvcyhhbmdsZSk7XG5cdCAgICAgICAgdmFyIHZlclRoZXRhID0gMSAtIGNvc1RoZXRhOyAvLyB2ZXJzaW5lIG9mIHRoZXRhXG5cblx0ICAgICAgICB2YXIgeHhWID0gdlswXSAqIHZbMF0gKiB2ZXJUaGV0YTtcblx0ICAgICAgICB2YXIgeHlWID0gdlswXSAqIHZbMV0gKiB2ZXJUaGV0YTtcblx0ICAgICAgICB2YXIgeHpWID0gdlswXSAqIHZbMl0gKiB2ZXJUaGV0YTtcblx0ICAgICAgICB2YXIgeXlWID0gdlsxXSAqIHZbMV0gKiB2ZXJUaGV0YTtcblx0ICAgICAgICB2YXIgeXpWID0gdlsxXSAqIHZbMl0gKiB2ZXJUaGV0YTtcblx0ICAgICAgICB2YXIgenpWID0gdlsyXSAqIHZbMl0gKiB2ZXJUaGV0YTtcblx0ICAgICAgICB2YXIgeHMgPSB2WzBdICogc2luVGhldGE7XG5cdCAgICAgICAgdmFyIHlzID0gdlsxXSAqIHNpblRoZXRhO1xuXHQgICAgICAgIHZhciB6cyA9IHZbMl0gKiBzaW5UaGV0YTtcblxuXHQgICAgICAgIHJldHVybiBbXG5cdCAgICAgICAgICAgIHh4ViArIGNvc1RoZXRhLCB4eVYgKyB6cywgeHpWIC0geXMsIDAsXG5cdCAgICAgICAgICAgIHh5ViAtIHpzLCB5eVYgKyBjb3NUaGV0YSwgeXpWICsgeHMsIDAsXG5cdCAgICAgICAgICAgIHh6ViArIHlzLCB5elYgLSB4cywgenpWICsgY29zVGhldGEsIDAsXG5cdCAgICAgICAgICAgIDAsIDAsIDAsIDFcblx0ICAgICAgICBdO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm4gYSBUcmFuc2Zvcm0gd2hpY2ggcmVwcmVzZW50cyBhIFRyYW5zZm9ybSBhcHBsaWVkIGFib3V0IGFuIG9yaWdpbiBwb2ludC5cblx0ICAgICAqICBVc2VmdWwgZm9yIHJvdGF0aW5nIGFuZCBzY2FsaW5nIHJlbGF0aXZlIHRvIGFuIG9yaWdpbi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGFib3V0T3JpZ2luXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gdiB7TnVtYmVyW119ICAgICAgICAgIE9yaWdpbiBwb2ludCBbeCx5LHpdXG5cdCAgICAgKiBAcGFyYW0gdCB7VHJhbnNmb3JtfSAgICAgICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS5hYm91dE9yaWdpbiA9IGZ1bmN0aW9uIGFib3V0T3JpZ2luKHYsIHQpIHtcblx0ICAgICAgICB2WzJdID0gdlsyXSB8fCAwO1xuXHQgICAgICAgIHZhciB0MCA9IHZbMF0gLSAodlswXSAqIHRbMF0gKyB2WzFdICogdFs0XSArIHZbMl0gKiB0WzhdKTtcblx0ICAgICAgICB2YXIgdDEgPSB2WzFdIC0gKHZbMF0gKiB0WzFdICsgdlsxXSAqIHRbNV0gKyB2WzJdICogdFs5XSk7XG5cdCAgICAgICAgdmFyIHQyID0gdlsyXSAtICh2WzBdICogdFsyXSArIHZbMV0gKiB0WzZdICsgdlsyXSAqIHRbMTBdKTtcblx0ICAgICAgICByZXR1cm4gVHJhbnNmb3JtLnRoZW5Nb3ZlKHQsIFt0MCwgdDEsIHQyXSk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgYSBwZXJzcGVjdGl2ZSBUcmFuc2Zvcm0uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBwZXJzcGVjdGl2ZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGZvY3VzWiB7TnVtYmVyfSAgICAgICB6LWRlcHRoIG9mIGZvY2FsIHBvaW50XG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLnBlcnNwZWN0aXZlID0gZnVuY3Rpb24gcGVyc3BlY3RpdmUoZm9jdXNaKSB7XG5cdCAgICAgICAgcmV0dXJuIFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAtMSAvIGZvY3VzWiwgMCwgMCwgMCwgMV07XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIHRoZSBnaXZlbiBUcmFuc2Zvcm0uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRUcmFuc2xhdGVcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSB0IHtUcmFuc2Zvcm19ICAgICAgICAgVHJhbnNmb3JtXG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmdldFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGdldFRyYW5zbGF0ZSh0KSB7XG5cdCAgICAgICAgcmV0dXJuIFt0WzEyXSwgdFsxM10sIHRbMTRdXTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIGludmVyc2UgVHJhbnNmb3JtIGZvciBnaXZlbiBUcmFuc2Zvcm0uXG5cdCAgICAgKiAgIE5vdGU6IHdpbGwgcHJvdmlkZSBpbmNvcnJlY3QgcmVzdWx0cyBpZiBUcmFuc2Zvcm0gaXMgbm90IGludmVydGlibGUuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBpbnZlcnNlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gdCB7VHJhbnNmb3JtfSBUcmFuc2Zvcm1cblx0ICAgICAqIEByZXR1cm4ge0FycmF5fVxuXHQgICAgICovXG5cdCAgICBUcmFuc2Zvcm0uaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UodCkge1xuXHQgICAgICAgIC8vIG9ubHkgbmVlZCB0byBjb25zaWRlciAzeDMgc2VjdGlvbiBmb3IgYWZmaW5lXG5cdCAgICAgICAgdmFyIGMwID0gdFs1XSAqIHRbMTBdIC0gdFs2XSAqIHRbOV07XG5cdCAgICAgICAgdmFyIGMxID0gdFs0XSAqIHRbMTBdIC0gdFs2XSAqIHRbOF07XG5cdCAgICAgICAgdmFyIGMyID0gdFs0XSAqIHRbOV0gLSB0WzVdICogdFs4XTtcblx0ICAgICAgICB2YXIgYzQgPSB0WzFdICogdFsxMF0gLSB0WzJdICogdFs5XTtcblx0ICAgICAgICB2YXIgYzUgPSB0WzBdICogdFsxMF0gLSB0WzJdICogdFs4XTtcblx0ICAgICAgICB2YXIgYzYgPSB0WzBdICogdFs5XSAtIHRbMV0gKiB0WzhdO1xuXHQgICAgICAgIHZhciBjOCA9IHRbMV0gKiB0WzZdIC0gdFsyXSAqIHRbNV07XG5cdCAgICAgICAgdmFyIGM5ID0gdFswXSAqIHRbNl0gLSB0WzJdICogdFs0XTtcblx0ICAgICAgICB2YXIgYzEwID0gdFswXSAqIHRbNV0gLSB0WzFdICogdFs0XTtcblx0ICAgICAgICB2YXIgZGV0TSA9IHRbMF0gKiBjMCAtIHRbMV0gKiBjMSArIHRbMl0gKiBjMjtcblx0ICAgICAgICB2YXIgaW52RCA9IDEgLyBkZXRNO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXG5cdCAgICAgICAgICAgIGludkQgKiBjMCwgLWludkQgKiBjNCwgaW52RCAqIGM4LCAwLFxuXHQgICAgICAgICAgICAtaW52RCAqIGMxLCBpbnZEICogYzUsIC1pbnZEICogYzksIDAsXG5cdCAgICAgICAgICAgIGludkQgKiBjMiwgLWludkQgKiBjNiwgaW52RCAqIGMxMCwgMCxcblx0ICAgICAgICAgICAgMCwgMCwgMCwgMVxuXHQgICAgICAgIF07XG5cdCAgICAgICAgcmVzdWx0WzEyXSA9IC10WzEyXSAqIHJlc3VsdFswXSAtIHRbMTNdICogcmVzdWx0WzRdIC0gdFsxNF0gKiByZXN1bHRbOF07XG5cdCAgICAgICAgcmVzdWx0WzEzXSA9IC10WzEyXSAqIHJlc3VsdFsxXSAtIHRbMTNdICogcmVzdWx0WzVdIC0gdFsxNF0gKiByZXN1bHRbOV07XG5cdCAgICAgICAgcmVzdWx0WzE0XSA9IC10WzEyXSAqIHJlc3VsdFsyXSAtIHRbMTNdICogcmVzdWx0WzZdIC0gdFsxNF0gKiByZXN1bHRbMTBdO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIHRyYW5zcG9zZSBvZiBhIFRyYW5zZm9ybS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHRyYW5zcG9zZVxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIHQge1RyYW5zZm9ybX0gICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHJldHVybiB7QXJyYXl9XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS50cmFuc3Bvc2UgPSBmdW5jdGlvbiB0cmFuc3Bvc2UodCkge1xuXHQgICAgICAgIHJldHVybiBbdFswXSwgdFs0XSwgdFs4XSwgdFsxMl0sIHRbMV0sIHRbNV0sIHRbOV0sIHRbMTNdLCB0WzJdLCB0WzZdLCB0WzEwXSwgdFsxNF0sIHRbM10sIHRbN10sIHRbMTFdLCB0WzE1XV07XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBfbm9ybVNxdWFyZWQodikge1xuXHQgICAgICAgIHJldHVybiAodi5sZW5ndGggPT09IDIpXG5cdCAgICAgICAgICAgID8gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXVxuXHQgICAgICAgICAgICA6IHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0gKyB2WzJdICogdlsyXTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIF9ub3JtKHYpIHtcblx0ICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KF9ub3JtU3F1YXJlZCh2KSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBfc2lnbihuKSB7XG5cdCAgICAgICAgcmV0dXJuIChuIDwgMCkgPyAtMSA6IDE7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVjb21wb3NlIFRyYW5zZm9ybSBpbnRvIHNlcGFyYXRlIGB0cmFuc2xhdGVgLCBgcm90YXRlYCwgYHNjYWxlYCBhbmQgYHNrZXdgIGNvbXBvbmVudHMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBpbnRlcnByZXRcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0gdCB7VHJhbnNmb3JtfSAgICAgVHJhbnNmb3JtXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zZm9ybS5pbnRlcnByZXQgPSBmdW5jdGlvbiBpbnRlcnByZXQodCkge1xuXHQgICAgICAgIC8vIFFSIGRlY29tcG9zaXRpb24gdmlhIEhvdXNlaG9sZGVyIHJlZmxlY3Rpb25zXG5cdCAgICAgICAgLy8gRklSU1QgSVRFUkFUSU9OXG5cblx0ICAgICAgICAvL2RlZmF1bHQgUTEgdG8gdGhlIGlkZW50aXR5IG1hdHJpeDtcblx0ICAgICAgICB2YXIgeCA9IFt0WzBdLCB0WzFdLCB0WzJdXTsgICAgICAgICAgICAgICAgLy8gZmlyc3QgY29sdW1uIHZlY3RvclxuXHQgICAgICAgIHZhciBzZ24gPSBfc2lnbih4WzBdKTsgICAgICAgICAgICAgICAgICAgICAvLyBzaWduIG9mIGZpcnN0IGNvbXBvbmVudCBvZiB4IChmb3Igc3RhYmlsaXR5KVxuXHQgICAgICAgIHZhciB4Tm9ybSA9IF9ub3JtKHgpOyAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtIG9mIGZpcnN0IGNvbHVtbiB2ZWN0b3Jcblx0ICAgICAgICB2YXIgdiA9IFt4WzBdICsgc2duICogeE5vcm0sIHhbMV0sIHhbMl1dOyAgLy8gdiA9IHggKyBzaWduKHhbMF0pfHh8ZTFcblx0ICAgICAgICB2YXIgbXVsdCA9IDIgLyBfbm9ybVNxdWFyZWQodik7ICAgICAgICAgICAgLy8gbXVsdCA9IDIvdid2XG5cblx0ICAgICAgICAvL2JhaWwgb3V0IGlmIG91ciBNYXRyaXggaXMgc2luZ3VsYXJcblx0ICAgICAgICBpZiAobXVsdCA+PSBJbmZpbml0eSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiBUcmFuc2Zvcm0uZ2V0VHJhbnNsYXRlKHQpLFxuXHQgICAgICAgICAgICAgICAgcm90YXRlOiBbMCwgMCwgMF0sXG5cdCAgICAgICAgICAgICAgICBzY2FsZTogWzAsIDAsIDBdLFxuXHQgICAgICAgICAgICAgICAgc2tldzogWzAsIDAsIDBdXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy9ldmFsdWF0ZSBRMSA9IEkgLSAydnYnL3YndlxuXHQgICAgICAgIHZhciBRMSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxXTtcblxuXHQgICAgICAgIC8vZGlhZ29uYWxzXG5cdCAgICAgICAgUTFbMF0gID0gMSAtIG11bHQgKiB2WzBdICogdlswXTsgICAgLy8gMCwwIGVudHJ5XG5cdCAgICAgICAgUTFbNV0gID0gMSAtIG11bHQgKiB2WzFdICogdlsxXTsgICAgLy8gMSwxIGVudHJ5XG5cdCAgICAgICAgUTFbMTBdID0gMSAtIG11bHQgKiB2WzJdICogdlsyXTsgICAgLy8gMiwyIGVudHJ5XG5cblx0ICAgICAgICAvL3VwcGVyIGRpYWdvbmFsXG5cdCAgICAgICAgUTFbMV0gPSAtbXVsdCAqIHZbMF0gKiB2WzFdOyAgICAgICAgLy8gMCwxIGVudHJ5XG5cdCAgICAgICAgUTFbMl0gPSAtbXVsdCAqIHZbMF0gKiB2WzJdOyAgICAgICAgLy8gMCwyIGVudHJ5XG5cdCAgICAgICAgUTFbNl0gPSAtbXVsdCAqIHZbMV0gKiB2WzJdOyAgICAgICAgLy8gMSwyIGVudHJ5XG5cblx0ICAgICAgICAvL2xvd2VyIGRpYWdvbmFsXG5cdCAgICAgICAgUTFbNF0gPSBRMVsxXTsgICAgICAgICAgICAgICAgICAgICAgLy8gMSwwIGVudHJ5XG5cdCAgICAgICAgUTFbOF0gPSBRMVsyXTsgICAgICAgICAgICAgICAgICAgICAgLy8gMiwwIGVudHJ5XG5cdCAgICAgICAgUTFbOV0gPSBRMVs2XTsgICAgICAgICAgICAgICAgICAgICAgLy8gMiwxIGVudHJ5XG5cblx0ICAgICAgICAvL3JlZHVjZSBmaXJzdCBjb2x1bW4gb2YgTVxuXHQgICAgICAgIHZhciBNUTEgPSBUcmFuc2Zvcm0uY29tcG9zZShRMSwgdCk7XG5cblx0ICAgICAgICAvLyBTRUNPTkQgSVRFUkFUSU9OIG9uICgxLDEpIG1pbm9yXG5cdCAgICAgICAgdmFyIHgyID0gW01RMVs1XSwgTVExWzZdXTtcblx0ICAgICAgICB2YXIgc2duMiA9IF9zaWduKHgyWzBdKTsgICAgICAgICAgICAgICAgICAgIC8vIHNpZ24gb2YgZmlyc3QgY29tcG9uZW50IG9mIHggKGZvciBzdGFiaWxpdHkpXG5cdCAgICAgICAgdmFyIHgyTm9ybSA9IF9ub3JtKHgyKTsgICAgICAgICAgICAgICAgICAgICAvLyBub3JtIG9mIGZpcnN0IGNvbHVtbiB2ZWN0b3Jcblx0ICAgICAgICB2YXIgdjIgPSBbeDJbMF0gKyBzZ24yICogeDJOb3JtLCB4MlsxXV07ICAgIC8vIHYgPSB4ICsgc2lnbih4WzBdKXx4fGUxXG5cdCAgICAgICAgdmFyIG11bHQyID0gMiAvIF9ub3JtU3F1YXJlZCh2Mik7ICAgICAgICAgICAvLyBtdWx0ID0gMi92J3ZcblxuXHQgICAgICAgIC8vZXZhbHVhdGUgUTIgPSBJIC0gMnZ2Jy92J3Zcblx0ICAgICAgICB2YXIgUTIgPSBbMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV07XG5cblx0ICAgICAgICAvL2RpYWdvbmFsXG5cdCAgICAgICAgUTJbNV0gID0gMSAtIG11bHQyICogdjJbMF0gKiB2MlswXTsgLy8gMSwxIGVudHJ5XG5cdCAgICAgICAgUTJbMTBdID0gMSAtIG11bHQyICogdjJbMV0gKiB2MlsxXTsgLy8gMiwyIGVudHJ5XG5cblx0ICAgICAgICAvL29mZiBkaWFnb25hbHNcblx0ICAgICAgICBRMls2XSA9IC1tdWx0MiAqIHYyWzBdICogdjJbMV07ICAgICAvLyAyLDEgZW50cnlcblx0ICAgICAgICBRMls5XSA9IFEyWzZdOyAgICAgICAgICAgICAgICAgICAgICAvLyAxLDIgZW50cnlcblxuXHQgICAgICAgIC8vY2FsYyBRUiBkZWNvbXBvc2l0aW9uLiBRID0gUTEqUTIsIFIgPSBRJypNXG5cdCAgICAgICAgdmFyIFEgPSBUcmFuc2Zvcm0uY29tcG9zZShRMiwgUTEpOyAgICAgIC8vbm90ZTogcmVhbGx5IFEgdHJhbnNwb3NlXG5cdCAgICAgICAgdmFyIFIgPSBUcmFuc2Zvcm0uY29tcG9zZShRLCB0KTtcblxuXHQgICAgICAgIC8vcmVtb3ZlIG5lZ2F0aXZlIHNjYWxpbmdcblx0ICAgICAgICB2YXIgcmVtb3ZlciA9IFRyYW5zZm9ybS5zY2FsZShSWzBdIDwgMCA/IC0xIDogMSwgUls1XSA8IDAgPyAtMSA6IDEsIFJbMTBdIDwgMCA/IC0xIDogMSk7XG5cdCAgICAgICAgUiA9IFRyYW5zZm9ybS5jb21wb3NlKFIsIHJlbW92ZXIpO1xuXHQgICAgICAgIFEgPSBUcmFuc2Zvcm0uY29tcG9zZShyZW1vdmVyLCBRKTtcblxuXHQgICAgICAgIC8vZGVjb21wb3NlIGludG8gcm90YXRlL3NjYWxlL3NrZXcgbWF0cmljZXNcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgcmVzdWx0LnRyYW5zbGF0ZSA9IFRyYW5zZm9ybS5nZXRUcmFuc2xhdGUodCk7XG5cdCAgICAgICAgcmVzdWx0LnJvdGF0ZSA9IFtNYXRoLmF0YW4yKC1RWzZdLCBRWzEwXSksIE1hdGguYXNpbihRWzJdKSwgTWF0aC5hdGFuMigtUVsxXSwgUVswXSldO1xuXHQgICAgICAgIGlmICghcmVzdWx0LnJvdGF0ZVswXSkge1xuXHQgICAgICAgICAgICByZXN1bHQucm90YXRlWzBdID0gMDtcblx0ICAgICAgICAgICAgcmVzdWx0LnJvdGF0ZVsyXSA9IE1hdGguYXRhbjIoUVs0XSwgUVs1XSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5zY2FsZSA9IFtSWzBdLCBSWzVdLCBSWzEwXV07XG5cdCAgICAgICAgcmVzdWx0LnNrZXcgPSBbTWF0aC5hdGFuMihSWzldLCByZXN1bHQuc2NhbGVbMl0pLCBNYXRoLmF0YW4yKFJbOF0sIHJlc3VsdC5zY2FsZVsyXSksIE1hdGguYXRhbjIoUls0XSwgcmVzdWx0LnNjYWxlWzBdKV07XG5cblx0ICAgICAgICAvL2RvdWJsZSByb3RhdGlvbiB3b3JrYXJvdW5kXG5cdCAgICAgICAgaWYgKE1hdGguYWJzKHJlc3VsdC5yb3RhdGVbMF0pICsgTWF0aC5hYnMocmVzdWx0LnJvdGF0ZVsyXSkgPiAxLjUgKiBNYXRoLlBJKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5yb3RhdGVbMV0gPSBNYXRoLlBJIC0gcmVzdWx0LnJvdGF0ZVsxXTtcblx0ICAgICAgICAgICAgaWYgKHJlc3VsdC5yb3RhdGVbMV0gPiBNYXRoLlBJKSByZXN1bHQucm90YXRlWzFdIC09IDIgKiBNYXRoLlBJO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnJvdGF0ZVsxXSA8IC1NYXRoLlBJKSByZXN1bHQucm90YXRlWzFdICs9IDIgKiBNYXRoLlBJO1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnJvdGF0ZVswXSA8IDApIHJlc3VsdC5yb3RhdGVbMF0gKz0gTWF0aC5QSTtcblx0ICAgICAgICAgICAgZWxzZSByZXN1bHQucm90YXRlWzBdIC09IE1hdGguUEk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQucm90YXRlWzJdIDwgMCkgcmVzdWx0LnJvdGF0ZVsyXSArPSBNYXRoLlBJO1xuXHQgICAgICAgICAgICBlbHNlIHJlc3VsdC5yb3RhdGVbMl0gLT0gTWF0aC5QSTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb21wb3NlIC50cmFuc2xhdGUsIC5yb3RhdGUsIC5zY2FsZSBhbmQgLnNrZXcgY29tcG9uZW50cyBpbnRvIGEgVHJhbnNmb3JtIG1hdHJpeC5cblx0ICAgICAqICBUaGUgXCJpbnZlcnNlXCIgb2YgLmludGVycHJldC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGJ1aWxkXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHNwZWMge09iamVjdH0gT2JqZWN0IHdpdGgga2V5cyBcInRyYW5zbGF0ZSwgcm90YXRlLCBzY2FsZSwgc2tld1wiIGFuZCB0aGVpciB2ZWN0b3IgdmFsdWVzXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQoc3BlYykge1xuXHQgICAgICAgIHZhciBzY2FsZU1hdHJpeCA9IFRyYW5zZm9ybS5zY2FsZShzcGVjLnNjYWxlWzBdLCBzcGVjLnNjYWxlWzFdLCBzcGVjLnNjYWxlWzJdKTtcblx0ICAgICAgICB2YXIgc2tld01hdHJpeCA9IFRyYW5zZm9ybS5za2V3KHNwZWMuc2tld1swXSwgc3BlYy5za2V3WzFdLCBzcGVjLnNrZXdbMl0pO1xuXHQgICAgICAgIHZhciByb3RhdGVNYXRyaXggPSBUcmFuc2Zvcm0ucm90YXRlKHNwZWMucm90YXRlWzBdLCBzcGVjLnJvdGF0ZVsxXSwgc3BlYy5yb3RhdGVbMl0pO1xuXHQgICAgICAgIHJldHVybiBUcmFuc2Zvcm0udGhlbk1vdmUoXG5cdCAgICAgICAgICAgIFRyYW5zZm9ybS5jb21wb3NlKFRyYW5zZm9ybS5jb21wb3NlKHJvdGF0ZU1hdHJpeCwgc2tld01hdHJpeCksIHNjYWxlTWF0cml4KSxcblx0ICAgICAgICAgICAgc3BlYy50cmFuc2xhdGVcblx0ICAgICAgICApO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBXZWlnaHRlZCBhdmVyYWdlIGJldHdlZW4gdHdvIG1hdHJpY2VzIGJ5IGF2ZXJhZ2luZyB0aGVpclxuXHQgICAgICogIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIHNrZXcgY29tcG9uZW50cy5cblx0ICAgICAqICBmKE0xLE0yLHQpID0gKDEgLSB0KSAqIE0xICsgdCAqIE0yXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBhdmVyYWdlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gTTEge1RyYW5zZm9ybX0gICAgTTEgPSBmKE0xLE0yLDApIFRyYW5zZm9ybVxuXHQgICAgICogQHBhcmFtIE0yIHtUcmFuc2Zvcm19ICAgIE0yID0gZihNMSxNMiwxKSBUcmFuc2Zvcm1cblx0ICAgICAqIEBwYXJhbSBbdD0xLzJdIHtOdW1iZXJ9XG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmF2ZXJhZ2UgPSBmdW5jdGlvbiBhdmVyYWdlKE0xLCBNMiwgdCkge1xuXHQgICAgICAgIHQgPSAodCA9PT0gdW5kZWZpbmVkKSA/IDAuNSA6IHQ7XG5cdCAgICAgICAgdmFyIHNwZWNNMSA9IFRyYW5zZm9ybS5pbnRlcnByZXQoTTEpO1xuXHQgICAgICAgIHZhciBzcGVjTTIgPSBUcmFuc2Zvcm0uaW50ZXJwcmV0KE0yKTtcblxuXHQgICAgICAgIHZhciBzcGVjQXZnID0ge1xuXHQgICAgICAgICAgICB0cmFuc2xhdGU6IFswLCAwLCAwXSxcblx0ICAgICAgICAgICAgcm90YXRlOiBbMCwgMCwgMF0sXG5cdCAgICAgICAgICAgIHNjYWxlOiBbMCwgMCwgMF0sXG5cdCAgICAgICAgICAgIHNrZXc6IFswLCAwLCAwXVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHQgICAgICAgICAgICBzcGVjQXZnLnRyYW5zbGF0ZVtpXSA9ICgxIC0gdCkgKiBzcGVjTTEudHJhbnNsYXRlW2ldICsgdCAqIHNwZWNNMi50cmFuc2xhdGVbaV07XG5cdCAgICAgICAgICAgIHNwZWNBdmcucm90YXRlW2ldID0gKDEgLSB0KSAqIHNwZWNNMS5yb3RhdGVbaV0gKyB0ICogc3BlY00yLnJvdGF0ZVtpXTtcblx0ICAgICAgICAgICAgc3BlY0F2Zy5zY2FsZVtpXSA9ICgxIC0gdCkgKiBzcGVjTTEuc2NhbGVbaV0gKyB0ICogc3BlY00yLnNjYWxlW2ldO1xuXHQgICAgICAgICAgICBzcGVjQXZnLnNrZXdbaV0gPSAoMSAtIHQpICogc3BlY00xLnNrZXdbaV0gKyB0ICogc3BlY00yLnNrZXdbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5idWlsZChzcGVjQXZnKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGV0ZXJtaW5lIGlmIHR3byBUcmFuc2Zvcm1zIGFyZSBjb21wb25lbnQtd2lzZSBlcXVhbC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGVxdWFsc1xuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGEge1RyYW5zZm9ybX0gICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHBhcmFtIGIge1RyYW5zZm9ybX0gICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG5cdCAgICAgICAgcmV0dXJuICFUcmFuc2Zvcm0ubm90RXF1YWxzKGEsIGIpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXRlcm1pbmUgaWYgdHdvIFRyYW5zZm9ybXMgYXJlIGNvbXBvbmVudC13aXNlIHVuZXF1YWxcblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIG5vdEVxdWFsc1xuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIGEge1RyYW5zZm9ybX0gICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHBhcmFtIGIge1RyYW5zZm9ybX0gICAgIFRyYW5zZm9ybVxuXHQgICAgICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICAgICAqL1xuXHQgICAgVHJhbnNmb3JtLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhhLCBiKSB7XG5cdCAgICAgICAgaWYgKGEgPT09IGIpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICAgIHJldHVybiAhKGEgJiYgYikgfHxcblx0ICAgICAgICAgICAgYVsxMl0gIT09IGJbMTJdIHx8IGFbMTNdICE9PSBiWzEzXSB8fCBhWzE0XSAhPT0gYlsxNF0gfHxcblx0ICAgICAgICAgICAgYVswXSAhPT0gYlswXSB8fCBhWzFdICE9PSBiWzFdIHx8IGFbMl0gIT09IGJbMl0gfHxcblx0ICAgICAgICAgICAgYVs0XSAhPT0gYls0XSB8fCBhWzVdICE9PSBiWzVdIHx8IGFbNl0gIT09IGJbNl0gfHxcblx0ICAgICAgICAgICAgYVs4XSAhPT0gYls4XSB8fCBhWzldICE9PSBiWzldIHx8IGFbMTBdICE9PSBiWzEwXTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAyMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIGRpcnR5UXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHQgICAgdmFyIHByZVRpY2tRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdCAgICB2YXIgdGlja1F1ZXVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIFNpbXBsZVN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXHQgICAgdmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5cdCAgICB2YXIgVHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblx0ICAgIHZhciBTcHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblx0ICAgIHZhciBJbmVydGlhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cblx0ICAgIHZhciB0cmFuc2l0aW9uTWV0aG9kcyA9IHtcblx0ICAgICAgICB0d2VlbjogVHdlZW4sXG5cdCAgICAgICAgc3ByaW5nOiBTcHJpbmcsXG5cdCAgICAgICAgaW5lcnRpYTogSW5lcnRpYVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHdheSB0byB0cmFuc2l0aW9uIG51bWVyaWMgdmFsdWVzIGFuZCBhcnJheXMgb2YgbnVtYmVycyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgc3RhdGVzLlxuXHQgICAgICogIFRyYW5zaXRpb25zIGFyZSBnaXZlbiBhbiBlYXNpbmcgY3VydmUgYW5kIGEgZHVyYXRpb24uXG5cdCAgICAgKiAgTm9uLW51bWVyaWMgdmFsdWVzIGFyZSBpZ25vcmVkLlxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHRyYW5zaXRpb25hYmxlID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdHJhbnNpdGlvbmFibGUuc2V0KDEwMCwge2R1cmF0aW9uIDogMTAwMCwgY3VydmUgOiAnZWFzZUluJ30pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdHJhbnNpdGlvbmFibGUub24oJ3N0YXJ0JywgZnVuY3Rpb24odmFsdWUpe1xuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2codmFsdWUpOyAvLyAwXG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdHJhbnNpdGlvbmFibGUub24oJ3VwZGF0ZScsIGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gbnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEwMFxuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHRyYW5zaXRpb25hYmxlLm9uKCdlbmQnLCBmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDEwMFxuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgVHJhbnNpdGlvbmFibGVcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TaW1wbGVTdHJlYW1cblx0ICAgICAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfE51bWJlcltdfSAgIFN0YXJ0aW5nIHZhbHVlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25hYmxlKHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlIHx8IDA7XG5cdCAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG5cdCAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLl9jdXJyZW50QWN0aXZlID0gZmFsc2U7XG5cblx0ICAgICAgICB2YXIgaGFzVXBkYXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMudXBkYXRlTWV0aG9kID0gdW5kZWZpbmVkO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50SW5wdXQpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRPdXRwdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50T3V0cHV0KTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3RpdmUgPSB0cnVlO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbigndXBkYXRlJywgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGhhc1VwZGF0ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLl9lbmdpbmVJbnN0YW5jZS5nZXRWZWxvY2l0eSgpO1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHZhbHVlKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbignZW5kJywgZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGl2ZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2s7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRBY3RpdmUpe1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBoYXNVcGRhdGVkID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbmdpbmVJbnN0YW5jZSlcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5fZW5naW5lSW5zdGFuY2UuZ2V0VmVsb2NpdHkoKTtcblxuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgICAgIHByZVRpY2tRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc3RhcnQnLCB2YWx1ZSk7XG5cblx0ICAgICAgICAgICAgICAgIGRpcnR5UXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1VwZGF0ZWQpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuZCcsIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpbXBsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHQgICAgVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNpdGlvbmFibGU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29uc3RydWN0b3IgbWV0aG9kLiBBIHdheSBvZiByZWdpc3RlcmluZyBvdGhlciBlbmdpbmVzIHRoYXQgY2FuIGludGVycG9sYXRlXG5cdCAgICAgKiAgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlcy4gRm9yIGluc3RhbmNlLCBhIHBoeXNpY3MgZW5naW5lLlxuXHQgICAgICpcblx0ICAgICAqICBAbWV0aG9kIHJlZ2lzdGVyXG5cdCAgICAgKiAgQHBhcmFtIG5hbWUge3N0cmluZ30gICAgSWRlbnRpZmllciBmb3IgdGhlIGVuZ2luZVxuXHQgICAgICogIEBwYXJhbSBjb25zdHJ1Y3RvciAgICAgIENvbnN0cnVjdG9yIGZvciB0aGUgZW5naW5lXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb25hYmxlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgY29uc3RydWN0b3IpIHtcblx0ICAgICAgICBpZiAoIShuYW1lIGluIHRyYW5zaXRpb25NZXRob2RzKSlcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbk1ldGhvZHNbbmFtZV0gPSBjb25zdHJ1Y3Rvcjtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29uc3RydWN0b3IgbWV0aG9kLiBVbnJlZ2lzdGVyIGFuIGludGVycG9sYXRpbmcgZW5naW5lLlxuXHQgICAgICogIFVuZG9lcyB3b3JrIG9mIGByZWdpc3RlcmAuXG5cdCAgICAgKlxuXHQgICAgICogIEBtZXRob2QgdW5yZWdpc3RlclxuXHQgICAgICogIEBwYXJhbSBuYW1lIHtzdHJpbmd9ICAgIElkZW50aWZpZXIgZm9yIHRoZSBlbmdpbmVcblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbmFibGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIobmFtZSkge1xuXHQgICAgICAgIGlmIChuYW1lIGluIHRyYW5zaXRpb25NZXRob2RzKSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2l0aW9uTWV0aG9kc1tuYW1lXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZWZpbmUgYSBuZXcgZW5kIHZhbHVlIHRoYXQgd2lsbCBiZSB0cmFuc2l0aW9uZWQgdG93YXJkcyB3aXRoIHRoZSBwcmVzY3JpYmVkXG5cdCAgICAgKiAgdHJhbnNpdGlvbi4gQW4gb3B0aW9uYWwgY2FsbGJhY2sgY2FuIGZpcmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBjb21wbGV0ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRcblx0ICAgICAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfE51bWJlcltdfSAgICAgICAgICAgRW5kIHZhbHVlXG5cdCAgICAgKiBAcGFyYW0gW3RyYW5zaXRpb25dIHtPYmplY3R9ICAgICAgICAgICAgIFRyYW5zaXRpb24gZGVmaW5pdGlvblxuXHQgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uLmN1cnZlXSB7c3RyaW5nfSAgICAgICBFYXNpbmcgY3VydmUgbmFtZSwgZS5nLiwgXCJlYXNlSW5cIlxuXHQgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uLmR1cmF0aW9uXSB7c3RyaW5nfSAgICBEdXJhdGlvbiBvZiB0cmFuc2l0aW9uXG5cdCAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSB7RnVuY3Rpb259ICAgICAgICAgICAgIENhbGxiYWNrXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKCF0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzdGFydCcsIHZhbHVlKTtcblxuXHQgICAgICAgICAgICBkaXJ0eVF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmQnLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY2FsbGJhY2spIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0ICAgICAgICB2YXIgY3VydmUgPSB0cmFuc2l0aW9uLmN1cnZlO1xuXG5cdCAgICAgICAgdmFyIG1ldGhvZCA9IChjdXJ2ZSAmJiB0cmFuc2l0aW9uTWV0aG9kc1tjdXJ2ZV0pXG5cdCAgICAgICAgICAgID8gdHJhbnNpdGlvbk1ldGhvZHNbY3VydmVdXG5cdCAgICAgICAgICAgIDogVHdlZW47XG5cblx0ICAgICAgICBpZiAodGhpcy5fbWV0aG9kICE9PSBtZXRob2QpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2VuZ2luZUluc3RhbmNlKXtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZU1ldGhvZCl7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGlja1F1ZXVlLmluZGV4T2YodGhpcy51cGRhdGVNZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB0aWNrUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUodGhpcy5fZW5naW5lSW5zdGFuY2UpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLnZhbHVlLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZUluc3RhbmNlID0gKGRpbWVuc2lvbnMgPCBtZXRob2QuRElNRU5TSU9OUylcblx0ICAgICAgICAgICAgICAgICAgICA/IG5ldyBtZXRob2QodGhpcy52YWx1ZSlcblx0ICAgICAgICAgICAgICAgICAgICA6IG5ldyBORFRyYW5zaXRpb25hYmxlKHRoaXMudmFsdWUsIG1ldGhvZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB0aGlzLl9lbmdpbmVJbnN0YW5jZSA9IG5ldyBtZXRob2QodGhpcy52YWx1ZSk7XG5cblx0ICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUodGhpcy5fZW5naW5lSW5zdGFuY2UpO1xuXHQgICAgICAgICAgICB0aGlzLnVwZGF0ZU1ldGhvZCA9IHRoaXMuX2VuZ2luZUluc3RhbmNlLnVwZGF0ZS5iaW5kKHRoaXMuX2VuZ2luZUluc3RhbmNlKTtcblx0ICAgICAgICAgICAgdGlja1F1ZXVlLnB1c2godGhpcy51cGRhdGVNZXRob2QpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXRyYW5zaXRpb24udmVsb2NpdHkpIHRyYW5zaXRpb24udmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5O1xuXG5cdCAgICAgICAgdGhpcy5fZW5naW5lSW5zdGFuY2Uuc2V0KHZhbHVlLCB0cmFuc2l0aW9uKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmFuc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0XG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8TnVtYmVyW119ICAgIEN1cnJlbnQgc3RhdGVcblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHZlbG9jaXR5IG9mIHRoZSB0cmFuc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0VmVsb2NpdHlcblx0ICAgICAqIEByZXR1cm4ge051bWJlcnxOdW1iZXJbXX0gICAgQ3VycmVudCBzdGF0ZVxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiBnZXRWZWxvY2l0eSgpe1xuXHQgICAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhbmQgdmVsb2NpdHkgb2YgdGhlIHRyYW5zaXRpb24gd2l0aG91dCBmaXJpbmcgYW55IGV2ZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJlc2V0XG5cdCAgICAgKiBAcGFyYW0gdmFsdWUge051bWJlcnxOdW1iZXJbXX0gICAgICAgTmV3IHZhbHVlXG5cdCAgICAgKiBAcGFyYW0gW3ZlbG9jaXR5XSB7TnVtYmVyfE51bWJlcltdfSAgTmV3IHZlbG9jaXR5XG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KHZhbHVlLCB2ZWxvY2l0eSl7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCAwO1xuXHQgICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9tZXRob2QgPSBudWxsO1xuXHQgICAgICAgIGlmICh0aGlzLl9lbmdpbmVJbnN0YW5jZSkgdGhpcy5fZW5naW5lSW5zdGFuY2UucmVzZXQodmFsdWUsIHZlbG9jaXR5KTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5kcyB0aGUgdHJhbnNpdGlvbiBpbiBwbGFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGhhbHRcblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdGhpcy5yZXNldCh0aGlzLmdldCgpKTtcblx0ICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuZCcsIHRoaXMudmFsdWUpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZXRlcm1pbmUgaXMgdGhlIHRyYW5zaXRpb24gaXMgb25nb2luZywgb3IgaGFzIGNvbXBsZXRlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGlzQWN0aXZlXG5cdCAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBJdGVyYXRlIHRocm91Z2ggdGhlIHByb3ZpZGVkIHZhbHVlcyB3aXRoIHRoZSBwcm92aWRlZCB0cmFuc2l0aW9ucy4gRmlyaW5nIGFuXG5cdCAgICAgKiAgb3B0aW9uYWwgY2FsbGJhY2sgd2hlbiB0aGUgc2VyaWVzIG9mIHRyYW5zaXRpb25zIGNvbXBsZXRlcy5cblx0ICAgICAqICBPbmUgdHJhbnNpdGlvbiBtYXkgYmUgcHJvdmlkZWQgYXMgb3Bwb3NlZCB0byBhbiBhcnJheSB3aGVuIHlvdSB3YW50IGFsbCB0aGVcblx0ICAgICAqICB0cmFuc2l0aW9ucyB0byBiZWhhdmUgdGhlIHNhbWUgd2F5LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgaXRlcmF0ZVxuXHQgICAgICogQHBhcmFtIHZhbHVlcyB7QXJyYXl9ICAgICAgICAgICAgICAgICAgICBBcnJheSBvZiB2YWx1ZXNcblx0ICAgICAqIEBwYXJhbSB0cmFuc2l0aW9ucyB7T2JqZWN0fE9iamVjdFtdfSAgICAgQXJyYXkgb2YgdHJhbnNpdGlvbnNcblx0ICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIHtGdW5jdGlvbn0gICAgICAgICAgICAgQ2FsbGJhY2tcblx0ICAgICAqL1xuXHQgICAgVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbiBpdGVyYXRlKHZhbHVlcywgdHJhbnNpdGlvbnMsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gc3VnYXIgZm9yIHNhbWUgdHJhbnNpdGlvbiBhY3Jvc3MgdmFsdWUgY2hhbmdlc1xuXHQgICAgICAgIHZhciB0cmFuc2l0aW9uID0gKHRyYW5zaXRpb25zIGluc3RhbmNlb2YgQXJyYXkpXG5cdCAgICAgICAgICAgID8gdHJhbnNpdGlvbnMuc2hpZnQoKVxuXHQgICAgICAgICAgICA6IHRyYW5zaXRpb25zO1xuXG5cdCAgICAgICAgdGhpcy5zZXQodmFsdWVzLnNoaWZ0KCksIHRyYW5zaXRpb24sIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5pdGVyYXRlKHZhbHVlcywgdHJhbnNpdGlvbnMsIGNhbGxiYWNrKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb21iaW5lIG11bHRpcGxlIHRyYW5zaXRpb25zIHRvIGJlIGV4ZWN1dGVkIHNlcXVlbnRpYWxseS4gUHJvdmlkZSB0aGVcblx0ICAgICAqICB0cmFuc2l0aW9ucyBhcyBhbiBhcnJheSBvZiB0cmFuc2l0aW9uIGRlZmluaXRpb25zLlxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICB0cmFuc2l0aW9uYWJsZS5zZXRNYW55KFtcblx0ICAgICAqICAgICAge3ZhbHVlIDogMCwgdHJhbnNpdGlvbiA6IHtjdXJ2ZSA6ICdlYXNlT3V0JywgZHVyYXRpb24gOiA1MDB9fSxcblx0ICAgICAqICAgICAge3ZhbHVlIDogMSwgdHJhbnNpdGlvbiA6IHtjdXJ2ZSA6ICdzcHJpbmcnLCBwZXJpb2QgOiAxMDAsIGRhbXBpbmcgOiAwLjV9fVxuXHQgICAgICogIF0pO1xuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0TWFueVxuXHQgICAgICogQHBhcmFtIHRyYW5zaXRpb25zIHtBcnJheX0gICBBcnJheSBvZiB0cmFuc2l0aW9uc1xuXHQgICAgICovXG5cdCAgICBUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0TWFueSA9IGZ1bmN0aW9uICh0cmFuc2l0aW9ucykge1xuXHQgICAgICAgIHZhciBmaXJzdCA9IHRyYW5zaXRpb25zLnNoaWZ0KCk7XG5cdCAgICAgICAgaWYgKHRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICB0aGlzLnNldChmaXJzdC52YWx1ZSwgZmlyc3QudHJhbnNpdGlvbiwgZmlyc3QuY2FsbGJhY2spXG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLnNldChmaXJzdC52YWx1ZSwgZmlyc3QudHJhbnNpdGlvbiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXRNYW55KHRyYW5zaXRpb25zKTtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExvb3AgaW5kZWZpbml0ZWx5IGJldHdlZW4gdmFsdWVzIHdpdGggcHJvdmlkZWQgdHJhbnNpdGlvbnMgYXJyYXkuXG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogIHRyYW5zaXRpb25hYmxlLmxvb3AoW1xuXHQgICAgICogICAgICB7dmFsdWUgOiAwLCB0cmFuc2l0aW9uIDoge2N1cnZlIDogJ2Vhc2VPdXQnLCBkdXJhdGlvbiA6IDUwMH19LFxuXHQgICAgICogICAgICB7dmFsdWUgOiAxLCB0cmFuc2l0aW9uIDoge2N1cnZlIDogJ3NwcmluZycsIHBlcmlvZCA6IDEwMCwgZGFtcGluZyA6IDAuNX19XG5cdCAgICAgKiAgXSk7XG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBsb29wXG5cdCAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbnMge0FycmF5fSAgIEFycmF5IG9mIHRyYW5zaXRpb25zXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gKHRyYW5zaXRpb25zKSB7XG5cdCAgICAgICAgdmFyIGFycmF5Q2xvbmUgPSB0cmFuc2l0aW9ucy5zbGljZSgwKTtcblx0ICAgICAgICB0aGlzLnNldE1hbnkodHJhbnNpdGlvbnMsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5sb29wKGFycmF5Q2xvbmUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBvc3Rwb25lIGEgdHJhbnNpdGlvbiwgYW5kIGZpcmUgaXQgYnkgcHJvdmlkaW5nIGl0IGluIHRoZSBjYWxsYmFjayBwYXJhbWV0ZXIuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBkZWxheVxuXHQgICAgICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn0gICBDYWxsYmFja1xuXHQgICAgICogQHBhcmFtIGR1cmF0aW9uIHtOdW1iZXJ9ICAgICBEdXJhdGlvbiBvZiBkZWxheSAoaW4gbWlsbGlzZWNvbnMpXG5cdCAgICAgKi9cblx0ICAgIFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KGNhbGxiYWNrLCBkdXJhdGlvbikge1xuXHQgICAgICAgIHRoaXMuc2V0KHRoaXMuZ2V0KCksIHtcblx0ICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcblx0ICAgICAgICAgICAgICAgIGN1cnZlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGNhbGxiYWNrXG5cdCAgICAgICAgKTtcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIE5EVHJhbnNpdGlvbmFibGUodmFsdWUsIG1ldGhvZCkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRPdXRwdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50T3V0cHV0KTtcblxuXHQgICAgICAgIHRoaXMuc291cmNlcyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBtZXRob2QodmFsdWVbaV0pO1xuXHQgICAgICAgICAgICB0aGlzLnNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuc3RyZWFtID0gU3RyZWFtLm1lcmdlKHRoaXMuc291cmNlcyk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuc3Vic2NyaWJlKHRoaXMuc3RyZWFtKTtcblx0ICAgIH1cblxuXHQgICAgTkRUcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCB0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgdGhpcy5zb3VyY2VzW2ldLnNldCh2YWx1ZVtpXSwgdHJhbnNpdGlvbik7XG5cdCAgICB9O1xuXG5cdCAgICBORFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmVsb2NpdHkgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc291cmNlcy5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgdmVsb2NpdHlbaV0gPSB0aGlzLnNvdXJjZXNbaV0uZ2V0VmVsb2NpdHkoKTtcblx0ICAgICAgICByZXR1cm4gdmVsb2NpdHk7XG5cdCAgICB9O1xuXG5cdCAgICBORFRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyBpKyspXG5cdCAgICAgICAgICAgIHRoaXMuc291cmNlc1tpXS51cGRhdGUoKTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbmFibGU7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDIzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIFNpbXBsZVN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdCAgICB2YXIgbm93ID0gRGF0ZS5ub3c7XG5cdCAgICB2YXIgZXBzID0gMWUtOTsgLy8gZm9yIGNhbGN1bGF0aW5nIHZlbG9jaXR5IHVzaW5nIGZpbml0ZSBkaWZmZXJlbmNlXG5cdCAgICB2YXIgcmVnaXN0ZXJlZEN1cnZlcyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgbWV0aG9kIG9mIGludGVycG9sYXRpbmcgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlcyB3aXRoXG5cdCAgICAgKiAgYW4gZWFzaW5nIGN1cnZlLlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBUd2VlblxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lc3BhY2UgVHJhbnNpdGlvbnNcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9ICAgIEluaXRpYWwgdmFsdWVcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gVHdlZW4odmFsdWUpIHtcblx0ICAgICAgICBTaW1wbGVTdHJlYW0uY2FsbCh0aGlzKTtcblxuXHQgICAgICAgIHRoaXMuc3RhdGUgPSB2YWx1ZSB8fCAwO1xuXHQgICAgICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB2YWx1ZSB8fCAwO1xuXHQgICAgICAgIHRoaXMuX2VuZFZhbHVlID0gMDtcblx0ICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBub3coKTtcblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0T3V0cHV0SGFuZGxlcih0aGlzLCB0aGlzLl9ldmVudE91dHB1dCk7XG5cdCAgICB9XG5cblx0ICAgIFR3ZWVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBUd2Vlbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUd2VlbjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZWZhdWx0IGVhc2luZyBjdXJ2ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IENVUlZFUyB7b2JqZWN0fVxuXHQgICAgICogQHByb3BlcnR5IENVUlZFUy5saW5lYXIge0Z1bmN0aW9ufSAgICAgICAgICAgTGluZWFyIGludGVycG9sYXRpb25cblx0ICAgICAqIEBwcm9wZXJ0eSBDVVJWRVMuZWFzZUluIHtGdW5jdGlvbn0gICAgICAgICAgIEVhc2VJbiBpbnRlcnBvbGF0aW9uLiBEZWNlbGVyYXRpb24gZnJvbSB6ZXJvIHZlbG9jaXR5LlxuXHQgICAgICogQHByb3BlcnR5IENVUlZFUy5lYXNlSW5DdWJpYyB7RnVuY3Rpb259ICAgICAgQ3ViaWMgaW50ZXJwb2xhdGlvbi4gQWNjZWxlcmF0aW9uIGZyb20gemVybyB2ZWxvY2l0eS5cblx0ICAgICAqIEBwcm9wZXJ0eSBDVVJWRVMuZWFzZU91dCB7RnVuY3Rpb259ICAgICAgICAgIEVhc2VPdXQgaW50ZXJwb2xhdGlvbi4gQWNjZWxlcmF0aW9uIGZyb20gemVybyB2ZWxvY2l0eS5cblx0ICAgICAqIEBwcm9wZXJ0eSBDVVJWRVMuZWFzZU91dEN1YmljIHtGdW5jdGlvbn0gICAgIEN1YmljIGludGVycG9sYXRpb24uIERlY2VsZXJhdGlvbiBmcm9tIHplcm8gdmVsb2NpdHkuXG5cdCAgICAgKiBAcHJvcGVydHkgQ1VSVkVTLmVhc2VPdXRXYWxsICAgICAgICAgICAgICAgICBJbnRlcnBvbGF0aW9uIHdpdGggd2FsbCBib3VuZGFyeS5cblx0ICAgICAqIEBwcm9wZXJ0eSBDVVJWRVMuZWFzZUluT3V0IHtGdW5jdGlvbn0gICAgICAgIEVhc2VJbk91dCBpbnRlcnBvbGF0aW9uLiBBY2NlbGVyYXRpb24gdGhlbiBkZWNlbGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkgQ1VSVkVTLmVhc2VJbk91dEN1YmljIHtGdW5jdGlvbn0gICBDdWJpYyBpbnRlcnBvbGF0aW9uLiBBY2NlbGVyYXRpb24gdGhlbiBkZWNlbGVyYXRpb24uXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKi9cblx0ICAgIFR3ZWVuLkNVUlZFUyA9IHtcblx0ICAgICAgICBsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlYXNlSW46IGZ1bmN0aW9uKHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHQgKiB0O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZWFzZU91dDogZnVuY3Rpb24odCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdCAqICgyIC0gdCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlYXNlSW5PdXQ6IGZ1bmN0aW9uKHQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICh0IDw9IDAuNSlcblx0ICAgICAgICAgICAgICAgID8gIDIgKiB0ICogdFxuXHQgICAgICAgICAgICAgICAgOiAtMiAqIHQgKiB0ICsgNCAqIHQgLSAxO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZWFzZU91dEJvdW5jZTogZnVuY3Rpb24odCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdCAqICgzIC0gMiAqIHQpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0ICogdCAqIHQ7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAxICsgTWF0aC5wb3codCAtIDEsIDMpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZWFzZUluT3V0Q3ViaWM6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIHQgKj0gMjtcblx0ICAgICAgICAgICAgcmV0dXJuICh0IDwgMSlcblx0ICAgICAgICAgICAgICAgID8gLjUgKiB0ICogdCAqIHRcblx0ICAgICAgICAgICAgICAgIDogLjUgKiBNYXRoLnBvdyh0IC0gMiwgMykgKyAxO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZWFzZU91dFdhbGw6IGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIGlmICh0IDwgKDEgLyAyLjc1KSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUgKiB0ICogdCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAuNzUpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMi41IC8gMi43NSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgLjkzNzUpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgLjk4NDM3NSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBUd2Vlbi5ESU1FTlNJT05TID0gSW5maW5pdHk7XG5cblx0ICAgIFR3ZWVuLkRFRkFVTFRfT1BUSU9OUyA9IHtcblx0ICAgICAgICBjdXJ2ZTogVHdlZW4uQ1VSVkVTLmxpbmVhcixcblx0ICAgICAgICBkdXJhdGlvbjogNTAwXG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgd2F5IG9mIHJlZ2lzdGVyaW5nIGN1c3RvbSBlYXNpbmcgY3VydmVzIGJ5IG5hbWUuXG5cdCAgICAgKiAgQ3VydmVzIGFyZSBmdW5jdGlvbnMgdGhhdCB0YWtlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBhbmQgcmV0dXJuXG5cdCAgICAgKiAgYSBudW1iZXIgKG9mdGVuIGJldHdlZW4gMCBhbmQgMSwgYnV0IGNhbiBvdmVyL3VuZGVyIHNob290KS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSAgICAgICAgIElkZW50aWZ5aW5nIG5hbWVcblx0ICAgICAqIEBwYXJhbSBjdXJ2ZSB7RnVuY3Rpb259ICAgICAgRnVuY3Rpb24gZGVmaW5lZCBvbiB0aGUgZG9tYWluIFswLDFdXG5cdCAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIEZhbHNlIGlmIGtleSBpcyB0YWtlbiwgZWxzZSB0cnVlXG5cdCAgICAgKi9cblx0ICAgIFR3ZWVuLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIobmFtZSwgY3VydmUpIHtcblx0ICAgICAgICBpZiAoIXJlZ2lzdGVyZWRDdXJ2ZXNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgcmVnaXN0ZXJlZEN1cnZlc1tuYW1lXSA9IGN1cnZlO1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZSBjdXJ2ZSBmcm9tIGludGVybmFsIHJlZ2lzdHJ5LiBVbmRvZXMgd29yayBvZiBgcmVnaXN0ZXJgLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZGVyZWdpc3RlclxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICogQHBhcmFtIG5hbWUge1N0cmluZ30gICAgIE5hbWUgZGljdGlvbmFyeSBrZXlcblx0ICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBGYWxzZSBpZiBrZXkgZG9lc24ndCBleGlzdFxuXHQgICAgICovXG5cdCAgICBUd2Vlbi5kZXJlZ2lzdGVyID0gZnVuY3Rpb24gZGVyZWdpc3RlcihuYW1lKSB7XG5cdCAgICAgICAgaWYgKHJlZ2lzdGVyZWRDdXJ2ZXNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgZGVsZXRlIHJlZ2lzdGVyZWRDdXJ2ZXNbbmFtZV07XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0cmlldmUgYWxsIHJlZ2lzdGVyZWQgY3VydmVzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0Q3VydmVzXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAgICAgKi9cblx0ICAgIFR3ZWVuLmdldEN1cnZlcyA9IGZ1bmN0aW9uIGdldEN1cnZlcygpIHtcblx0ICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEN1cnZlcztcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2V0IG5ldyB2YWx1ZSB0byB0cmFuc2l0aW9uIHRvLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0XG5cdCAgICAgKiBAcGFyYW0gZW5kVmFsdWUge051bWJlcnxOdW1iZXJbXX0gICAgRW5kIHZhbHVlXG5cdCAgICAgKiBAcGFyYW0gW3RyYW5zaXRpb25dIHtPYmplY3R9ICAgICAgICAgVHJhbnNpdGlvbiBvYmplY3Qgb2YgdHlwZVxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtkdXJhdGlvbjogbnVtYmVyLCBjdXJ2ZTogbmFtZX1cblx0ICAgICAqL1xuXHQgICAgVHdlZW4ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChlbmRWYWx1ZSwgdHJhbnNpdGlvbikge1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLmdldCgpO1xuXG5cdCAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIHRoaXMuX3N0YXJ0VmFsdWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kVmFsdWU7XG5cdCAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbm93KCk7XG5cblx0ICAgICAgICB2YXIgY3VydmUgPSB0cmFuc2l0aW9uLmN1cnZlO1xuXHQgICAgICAgIGlmICghcmVnaXN0ZXJlZEN1cnZlc1tjdXJ2ZV0gJiYgVHdlZW4uQ1VSVkVTW2N1cnZlXSlcblx0ICAgICAgICAgICAgVHdlZW4ucmVnaXN0ZXIoY3VydmUsIFR3ZWVuLkNVUlZFU1tjdXJ2ZV0pO1xuXG5cdCAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRyYW5zaXRpb24udmVsb2NpdHk7XG5cdCAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB0cmFuc2l0aW9uLmR1cmF0aW9uIHx8IFR3ZWVuLkRFRkFVTFRfT1BUSU9OUy5kdXJhdGlvbjtcblx0ICAgICAgICB0aGlzLl9jdXJ2ZSA9IGN1cnZlXG5cdCAgICAgICAgICAgID8gKGN1cnZlIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gY3VydmUgOiBnZXRDdXJ2ZShjdXJ2ZSlcblx0ICAgICAgICAgICAgOiBUd2Vlbi5ERUZBVUxUX09QVElPTlMuY3VydmU7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCBjdXJyZW50IHZhbHVlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0XG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8TnVtYmVyW119XG5cdCAgICAgKi9cblx0ICAgIFR3ZWVuLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCBjdXJyZW50IHZlbG9jaXR5XG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eVxuXHQgICAgICogQHJldHVybnMge051bWJlcnxOdW1iZXJbXX1cblx0ICAgICAqL1xuXHQgICAgVHdlZW4ucHJvdG90eXBlLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gZ2V0VmVsb2NpdHkoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlc2V0IHRoZSB2YWx1ZSBhbmQgdmVsb2NpdHkgb2YgdGhlIHRyYW5zaXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCByZXNldFxuXHQgICAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ8TnVtYmVyW119ICAgICAgIFZhbHVlXG5cdCAgICAgKiBAcGFyYW0gW3ZlbG9jaXR5XSB7TnVtYmVyfE51bWJlcltdfSAgVmVsb2NpdHlcblx0ICAgICAqL1xuXHQgICAgVHdlZW4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQodmFsdWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGhpcy5zdGF0ZSA9IHZhbHVlO1xuXHQgICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCAwO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIYWx0IHRyYW5zaXRpb24gYXQgY3VycmVudCBzdGF0ZSBhbmQgZXJhc2UgYWxsIHBlbmRpbmcgYWN0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGhhbHRcblx0ICAgICAqL1xuXHQgICAgVHdlZW4ucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0KCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG5cdCAgICAgICAgdGhpcy5yZXNldCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdlbmQnLCB2YWx1ZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVwZGF0ZSB0aGUgdHJhbnNpdGlvbiBpbiB0aW1lLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdXBkYXRlXG5cdCAgICAgKi9cblx0ICAgIFR3ZWVuLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHJldHVybjtcblxuXHQgICAgICAgIHZhciB0aW1lU2luY2VTdGFydCA9IG5vdygpIC0gdGhpcy5fc3RhcnRUaW1lO1xuXG5cdCAgICAgICAgdGhpcy52ZWxvY2l0eSA9IF9jYWxjdWxhdGVWZWxvY2l0eSh0aGlzLnN0YXRlLCB0aGlzLl9zdGFydFZhbHVlLCB0aGlzLl9jdXJ2ZSwgdGhpcy5fZHVyYXRpb24sIDEpO1xuXG5cdCAgICAgICAgaWYgKHRpbWVTaW5jZVN0YXJ0IDwgdGhpcy5fZHVyYXRpb24pIHtcblx0ICAgICAgICAgICAgdmFyIHQgPSB0aW1lU2luY2VTdGFydCAvIHRoaXMuX2R1cmF0aW9uO1xuXHQgICAgICAgICAgICB0aGlzLnN0YXRlID0gX2ludGVycG9sYXRlKHRoaXMuX3N0YXJ0VmFsdWUsIHRoaXMuX2VuZFZhbHVlLCB0aGlzLl9jdXJ2ZSh0KSk7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5zdGF0ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuX2VuZFZhbHVlKTtcblxuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KHRoaXMuX2VuZFZhbHVlKTtcblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJywgdGhpcy5fZW5kVmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGdldEN1cnZlKGN1cnZlTmFtZSkge1xuXHQgICAgICAgIHZhciBjdXJ2ZSA9IHJlZ2lzdGVyZWRDdXJ2ZXNbY3VydmVOYW1lXTtcblx0ICAgICAgICBpZiAoY3VydmUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGN1cnZlO1xuXHQgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdjdXJ2ZSBub3QgcmVnaXN0ZXJlZCcpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfaW50ZXJwb2xhdGUoYSwgYiwgdCkge1xuXHQgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSl7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspe1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJylcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfaW50ZXJwb2xhdGUxRChhW2ldLCBiW2ldLCB0KSk7XG5cdCAgICAgICAgICAgICAgICBlbHNlIHJlc3VsdC5wdXNoKGFbaV0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSByZXN1bHQgPSBfaW50ZXJwb2xhdGUxRChhLCBiLCB0KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfaW50ZXJwb2xhdGUxRChhLCBiLCB0KXtcblx0ICAgICAgICByZXR1cm4gKCgxIC0gdCkgKiBhKSArICh0ICogYik7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIF9jYWxjdWxhdGVWZWxvY2l0eTFEKGN1cnJlbnQsIHN0YXJ0LCBjdXJ2ZSwgZHVyYXRpb24sIHQpIHtcblx0ICAgICAgICByZXR1cm4gKGN1cnJlbnQgLSBzdGFydCkgKiAoY3VydmUodCArIGVwcykgLSBjdXJ2ZSh0IC0gZXBzKSkgLyAoMiAqIGVwcyAqIGR1cmF0aW9uKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX2NhbGN1bGF0ZVZlbG9jaXR5KGN1cnJlbnQsIHN0YXJ0LCBjdXJ2ZSwgZHVyYXRpb24sIHQpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0O1xuXHQgICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgQXJyYXkpe1xuXHQgICAgICAgICAgICByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKXtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudFtpXSA9PT0gJ251bWJlcicpXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX2NhbGN1bGF0ZVZlbG9jaXR5MUQoY3VycmVudFtpXSwgc3RhcnRbaV0sIGN1cnZlLCBkdXJhdGlvbiwgdCkpO1xuXHQgICAgICAgICAgICAgICAgZWxzZSByZXN1bHQucHVzaChjdXJyZW50W2ldKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHJlc3VsdCA9IF9jYWxjdWxhdGVWZWxvY2l0eTFEKGN1cnJlbnQsIHN0YXJ0LCBjdXJ2ZSwgZHVyYXRpb24sIHQpO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gVHdlZW47XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDI0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBTaW1wbGVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHQgICAgdmFyIG5vdyA9IERhdGUubm93O1xuXHQgICAgdmFyIGVwcyA9IDFlLTY7IC8vIGZvciBjYWxjdWxhdGluZyB2ZWxvY2l0eSB1c2luZyBmaW5pdGUgZGlmZmVyZW5jZVxuXHQgICAgdmFyIHRvbGVyYW5jZSA9IDFlLTk7IC8vIGVuZXJneSBtaW5pbXVtXG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBtZXRob2Qgb2YgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIHdpdGhcblx0ICAgICAqICBhIHNwcmluZyB0cmFuc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBUd2VlblxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBuYW1lc3BhY2UgVHJhbnNpdGlvbnNcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9ICAgIEluaXRpYWwgdmFsdWVcblx0ICAgICAqIEBwYXJhbSB2ZWxvY2l0eSB7TnVtYmVyfSBJbml0aWFsIHZlbG9jaXR5XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIFNwcmluZyh2YWx1ZSwgdmVsb2NpdHkpIHtcblx0ICAgICAgICBTaW1wbGVTdHJlYW0uY2FsbCh0aGlzKTtcblxuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZSB8fCAwO1xuXHQgICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCAwO1xuXG5cdCAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XG5cdCAgICAgICAgdGhpcy5jdXJ2ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5lbmVyZ3kgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuZW5lcmd5VG9sZXJhbmNlID0gdG9sZXJhbmNlO1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRPdXRwdXQpO1xuXHQgICAgfVxuXG5cdCAgICBTcHJpbmcuRElNRU5TSU9OUyA9IDE7XG5cblx0ICAgIFNwcmluZy5ERUZBVUxUX09QVElPTlMgPSB7XG5cdCAgICAgICAgdmVsb2NpdHk6IDAsXG5cdCAgICAgICAgZGFtcGluZzogMC41LFxuXHQgICAgICAgIHBlcmlvZCA6IDEwMFxuXHQgICAgfTtcblxuXHQgICAgU3ByaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBTcHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaW5nO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldCBuZXcgdmFsdWUgdG8gdHJhbnNpdGlvbiB0by5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldFxuXHQgICAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9ICAgICAgICAgICAgICAgIEVuZCB2YWx1ZVxuXHQgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uXSB7T2JqZWN0fSAgICAgICAgIFRyYW5zaXRpb24gZGVmaW5pdGlvblxuXHQgICAgICovXG5cdCAgICBTcHJpbmcucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgdHJhbnNpdGlvbikge1xuXHQgICAgICAgIHZhciB4MCA9IHRoaXMuZ2V0KCk7XG5cblx0ICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSl7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCB4MCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGRhbXBpbmcgPSB0cmFuc2l0aW9uLmRhbXBpbmcgfHwgU3ByaW5nLkRFRkFVTFRfT1BUSU9OUy5kYW1waW5nO1xuXHQgICAgICAgIHZhciBwZXJpb2QgPSB0cmFuc2l0aW9uLnBlcmlvZCB8fCBTcHJpbmcuREVGQVVMVF9PUFRJT05TLnBlcmlvZDtcblx0ICAgICAgICB2YXIgdjAgPSB0cmFuc2l0aW9uLnZlbG9jaXR5IHx8IHRoaXMudmVsb2NpdHk7XG5cblx0ICAgICAgICB0aGlzLmN1cnZlID0gZ2V0Q3VydmUoZGFtcGluZywgcGVyaW9kLCB4MCwgdmFsdWUsIHYwKTtcblx0ICAgICAgICB0aGlzLmVuZXJneSA9IGNhbGN1bGF0ZUVuZXJneShwZXJpb2QpO1xuXG5cdCAgICAgICAgdmFyIHNwcmVhZCA9IGdldFNwcmVhZCh2YWx1ZSwgeDApO1xuXHQgICAgICAgIHRoaXMuZW5lcmd5VG9sZXJhbmNlID0gdG9sZXJhbmNlICogTWF0aC5wb3coc3ByZWFkLCAyKTtcblxuXHQgICAgICAgIHRoaXMudGFyZ2V0ID0gdmFsdWU7XG5cdCAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBub3coKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0IGN1cnJlbnQgdmFsdWUuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRcblx0ICAgICAqIEByZXR1cm4ge051bWJlcn1cblx0ICAgICAqL1xuXHQgICAgU3ByaW5nLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCBjdXJyZW50IHZlbG9jaXR5XG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eVxuXHQgICAgICogQHJldHVybnMge051bWJlcn1cblx0ICAgICAqL1xuXHQgICAgU3ByaW5nLnByb3RvdHlwZS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVzZXQgdGhlIHZhbHVlIGFuZCB2ZWxvY2l0eSBvZiB0aGUgdHJhbnNpdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJlc2V0XG5cdCAgICAgKiBAcGFyYW0gdmFsdWUge051bWJlcn0gICAgICAgVmFsdWVcblx0ICAgICAqIEBwYXJhbSBbdmVsb2NpdHldIHtOdW1iZXJ9ICBWZWxvY2l0eVxuXHQgICAgICovXG5cdCAgICBTcHJpbmcucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHkgfHwgMDtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGFsdCB0cmFuc2l0aW9uIGF0IGN1cnJlbnQgc3RhdGUgYW5kIGVyYXNlIGFsbCBwZW5kaW5nIGFjdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBoYWx0XG5cdCAgICAgKi9cblx0ICAgIFNwcmluZy5wcm90b3R5cGUuaGFsdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuXHQgICAgICAgIHRoaXMucmVzZXQodmFsdWUpO1xuXHQgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuZW1pdCgnZW5kJywgdmFsdWUpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVcGRhdGUgdGhlIHRyYW5zaXRpb24gaW4gdGltZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuXHQgICAgICovXG5cdCAgICBTcHJpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgdmFyIHRpbWVTaW5jZVN0YXJ0ID0gbm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcblxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY3VydmUodGltZVNpbmNlU3RhcnQpO1xuXHQgICAgICAgIHZhciBuZXh0ID0gdGhpcy5jdXJ2ZSh0aW1lU2luY2VTdGFydCArIGVwcyk7XG5cdCAgICAgICAgdmFyIHByZXYgPSB0aGlzLmN1cnZlKHRpbWVTaW5jZVN0YXJ0IC0gZXBzKTtcblxuXHQgICAgICAgIHRoaXMudmVsb2NpdHkgPSAobmV4dCAtIHByZXYpIC8gKDIgKiBlcHMpO1xuXG5cdCAgICAgICAgdmFyIGVuZXJneSA9IHRoaXMuZW5lcmd5KHRoaXMudGFyZ2V0LCB2YWx1ZSwgdGhpcy52ZWxvY2l0eSk7XG5cblx0ICAgICAgICBpZiAoZW5lcmd5ID49IHRoaXMuZW5lcmd5VG9sZXJhbmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMudGFyZ2V0KTtcblxuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KHRoaXMudGFyZ2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kJywgdGhpcy50YXJnZXQpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGdldFNwcmVhZCh4MCwgdmFsdWUpe1xuXHQgICAgICAgIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLmFicyh2YWx1ZSAtIHgwKSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGdldEN1cnZlKGRhbXBpbmcsIHBlcmlvZCwgeDAsIHZhbHVlLCB2MCl7XG5cdCAgICAgICAgaWYgKGRhbXBpbmcgPCAxKVxuXHQgICAgICAgICAgICByZXR1cm4gY3JlYXRlVW5kZXJEYW1wZWRTcHJpbmcoZGFtcGluZywgcGVyaW9kLCB4MCwgdmFsdWUsIHYwKTtcblx0ICAgICAgICBlbHNlIGlmIChkYW1waW5nID09PSAxKVxuXHQgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ3JpdGljYWxseURhbXBlZFNwcmluZyhkYW1waW5nLCBwZXJpb2QsIHgwLCB2YWx1ZSwgdjApO1xuXHQgICAgICAgIGVsc2Vcblx0ICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU92ZXJEYW1wZWRTcHJpbmcoZGFtcGluZywgcGVyaW9kLCB4MCwgdmFsdWUsIHYwKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY2FsY3VsYXRlRW5lcmd5KHBlcmlvZCl7XG5cdCAgICAgICAgdmFyIG9tZWdhID0gMiAqIE1hdGguUEkgLyBwZXJpb2Q7XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24ob3JpZ2luLCBwb3NpdGlvbiwgdmVsb2NpdHkpe1xuXHQgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBvcmlnaW4gLSBwb3NpdGlvbjtcblx0ICAgICAgICAgICAgdmFyIHBvdGVudGlhbEVuZXJneSA9IG9tZWdhICogb21lZ2EgKiBkaXN0YW5jZSAqIGRpc3RhbmNlO1xuXHQgICAgICAgICAgICB2YXIga2luZXRpY0VuZXJneSA9IHZlbG9jaXR5ICogdmVsb2NpdHk7XG5cdCAgICAgICAgICAgIHJldHVybiBraW5ldGljRW5lcmd5ICsgcG90ZW50aWFsRW5lcmd5O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlVW5kZXJEYW1wZWRTcHJpbmcoZGFtcGluZywgcGVyaW9kLCB4MCwgeDEsIHYwKSB7XG5cdCAgICAgICAgdmFyIHdfZCA9ICBNYXRoLnNxcnQoMSAtIGRhbXBpbmcgKiBkYW1waW5nKSAvIHBlcmlvZDsgLy8gZGFtcGVkIGZyZXF1ZW5jeVxuXHQgICAgICAgIHZhciBBID0geDAgLSB4MTtcblx0ICAgICAgICB2YXIgQiA9IChkYW1waW5nIC8gcGVyaW9kICogQSArIHYwKSAvICh3X2QpO1xuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB4MSArIE1hdGguZXhwKC1kYW1waW5nICogdCAvIHBlcmlvZCkgKlxuXHQgICAgICAgICAgICAgICAgKEEgKiBNYXRoLmNvcyh3X2QgKiB0KSArIEIgKiBNYXRoLnNpbih3X2QgKiB0KSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVDcml0aWNhbGx5RGFtcGVkU3ByaW5nKGRhbXBpbmcsIHBlcmlvZCwgeDAsIHgxLCB2MCkge1xuXHQgICAgICAgIHZhciBBID0geDAgLSB4MTtcblx0ICAgICAgICB2YXIgQiA9IHYwICsgQSAvIHBlcmlvZDtcblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuXHQgICAgICAgICAgICByZXR1cm4geDEgKyBNYXRoLmV4cCgtZGFtcGluZyAqIHQgLyBwZXJpb2QpICogKEEgKyBCICogdCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjcmVhdGVPdmVyRGFtcGVkU3ByaW5nKGRhbXBpbmcsIHBlcmlvZCwgeDAsIHgxLCB2MCkge1xuXHQgICAgICAgIHZhciB3X2QgPSBNYXRoLnNxcnQoZGFtcGluZyAqIGRhbXBpbmcgLSAxKSAvIHBlcmlvZDsgLy8gZGFtcGVkIGZyZXF1ZW5jeVxuXHQgICAgICAgIHZhciByMSA9IC1kYW1waW5nIC8gcGVyaW9kICsgd19kO1xuXHQgICAgICAgIHZhciByMiA9IC1kYW1waW5nIC8gcGVyaW9kIC0gd19kO1xuXHQgICAgICAgIHZhciBMID0geDAgLSB4MTtcblx0ICAgICAgICB2YXIgY29uc3QxID0gKHIxICogTCAtIHYwKSAvIChyMiAtIHIxKTtcblx0ICAgICAgICB2YXIgQSA9IEwgKyBjb25zdDE7XG5cdCAgICAgICAgdmFyIEIgPSAtY29uc3QxO1xuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB4MSArIEEgKiBNYXRoLmV4cChyMSAqIHQpICsgQiAqIE1hdGguZXhwKHIyICogdCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuLyoqKi8gfSxcbi8qIDI1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBTaW1wbGVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXHQgICAgdmFyIG5vdyA9IERhdGUubm93O1xuXHQgICAgdmFyIHRvbGVyYW5jZSA9IDFlLTI7IC8vIGVuZXJneSBtaW5pbXVtXG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVmaW5lcyBhbiBpbmVydGlhbCB0cmFuc2l0aW9uLCB3aGljaCBkZWNyZWFzZXNcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgVHdlZW5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAbmFtZXNwYWNlIFRyYW5zaXRpb25zXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfSAgICBJbml0aWFsIHZhbHVlXG5cdCAgICAgKiBAcGFyYW0gdmVsb2NpdHkge051bWJlcn0gSW5pdGlhbCB2ZWxvY2l0eVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBJbmVydGlhKHZhbHVlLCB2ZWxvY2l0eSkge1xuXHQgICAgICAgIFNpbXBsZVN0cmVhbS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlIHx8IDA7XG5cdCAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5IHx8IDA7XG5cdCAgICAgICAgdGhpcy5kYW1waW5nID0gMDtcblxuXHQgICAgICAgIHRoaXMuZW5lcmd5ID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLl9wcmV2aW91c1RpbWUgPSBub3coKTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRPdXRwdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50T3V0cHV0KTtcblx0ICAgIH1cblxuXHQgICAgSW5lcnRpYS5ESU1FTlNJT05TID0gMTtcblxuXHQgICAgSW5lcnRpYS5ERUZBVUxUX09QVElPTlMgPSB7XG5cdCAgICAgICAgdmVsb2NpdHk6IDAsXG5cdCAgICAgICAgZGFtcGluZzogMC4xXG5cdCAgICB9O1xuXG5cdCAgICBJbmVydGlhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBJbmVydGlhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluZXJ0aWE7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2V0IG5ldyB2YWx1ZSB0byB0cmFuc2l0aW9uIHRvLCB3aXRoIGEgdHJhbnNpdGlvbiBkZWZpbml0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0XG5cdCAgICAgKiBAcGFyYW0gdmFsdWUge051bWJlcn0gICAgICAgICAgICAgICAgU3RhcnRpbmcgdmFsdWVcblx0ICAgICAqIEBwYXJhbSBbdHJhbnNpdGlvbl0ge09iamVjdH0gICAgICAgICBUcmFuc2l0aW9uIGRlZmluaXRpb25cblx0ICAgICAqL1xuXHQgICAgSW5lcnRpYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCB0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIHZhbHVlKTtcblx0ICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG5cblx0ICAgICAgICB0aGlzLmRhbXBpbmcgPSAodHJhbnNpdGlvbi5kYW1waW5nID09IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgPyBJbmVydGlhLkRFRkFVTFRfT1BUSU9OUy5kYW1waW5nXG5cdCAgICAgICAgICAgIDogTWF0aC5wb3coTWF0aC5taW4odHJhbnNpdGlvbi5kYW1waW5nLCAxKSwgMyk7XG5cblx0ICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdHJhbnNpdGlvbi52ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXQgY3VycmVudCB2YWx1ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGdldFxuXHQgICAgICogQHJldHVybiB7TnVtYmVyfVxuXHQgICAgICovXG5cdCAgICBJbmVydGlhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCBjdXJyZW50IHZlbG9jaXR5XG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRWZWxvY2l0eVxuXHQgICAgICogQHJldHVybnMge051bWJlcn1cblx0ICAgICAqL1xuXHQgICAgSW5lcnRpYS5wcm90b3R5cGUuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudmVsb2NpdHk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlc2V0IHRoZSB2YWx1ZSBhbmQgdmVsb2NpdHkgb2YgdGhlIHRyYW5zaXRpb24uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCByZXNldFxuXHQgICAgICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ9ICAgICAgIFZhbHVlXG5cdCAgICAgKiBAcGFyYW0gW3ZlbG9jaXR5XSB7TnVtYmVyfSAgVmVsb2NpdHlcblx0ICAgICAqL1xuXHQgICAgSW5lcnRpYS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIHZlbG9jaXR5KSB7XG5cdCAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgIC8vdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5IHx8IDA7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgaGFsdFxuXHQgICAgICovXG5cdCAgICBJbmVydGlhLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG5cdCAgICAgICAgdGhpcy5yZXNldCh2YWx1ZSk7XG5cdCAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5lbWl0KCdlbmQnLCB2YWx1ZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVwZGF0ZSB0aGUgdHJhbnNpdGlvbiBpbiB0aW1lLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdXBkYXRlXG5cdCAgICAgKi9cblx0ICAgIEluZXJ0aWEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gbm93KCk7XG5cdCAgICAgICAgdmFyIGR0ID0gY3VycmVudFRpbWUgLSB0aGlzLl9wcmV2aW91c1RpbWU7XG5cdCAgICAgICAgdGhpcy5fcHJldmlvdXNUaW1lID0gY3VycmVudFRpbWU7XG5cblx0ICAgICAgICB0aGlzLnZlbG9jaXR5ICo9ICgxIC0gdGhpcy5kYW1waW5nKTtcblx0ICAgICAgICB0aGlzLnZhbHVlICs9IGR0ICogdGhpcy52ZWxvY2l0eTtcblxuXHQgICAgICAgIHZhciBlbmVyZ3kgPSAwLjUgKiB0aGlzLnZlbG9jaXR5ICogdGhpcy52ZWxvY2l0eTtcblxuXHQgICAgICAgIGlmIChlbmVyZ3kgPj0gdG9sZXJhbmNlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy52YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMudmFsdWUpO1xuXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQodGhpcy52YWx1ZSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ2VuZCcsIHRoaXMudmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gSW5lcnRpYTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuLyoqKi8gfSxcbi8qIDI2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBSZW5kZXJUcmVlTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXHQgICAgdmFyIENvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblx0ICAgIHZhciBTaXplTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXHQgICAgdmFyIExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHQgICAgdmFyIFRyYW5zaXRpb25hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICAgIHZhciBSZXNpemVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0ICAgIHZhciBTaXplT2JzZXJ2YWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHQgICAgdmFyIGxheW91dEFsZ2VicmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0ICAgIHZhciBzaXplQWxnZWJyYSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgVmlldyBwcm92aWRlcyBlbmNhcHN1bGF0aW9uIGZvciBhIHN1YnRyZWUgb2YgdGhlIHJlbmRlciB0cmVlLiBZb3UgY2FuIGJ1aWxkXG5cdCAgICAgKiAgY29tcGxpY2F0ZWQgdmlzdWFsIGNvbXBvbmVudHMgYW5kIGFkZCB0aGVtIHRvIGEgcmVuZGVyIHRyZWUgYXMgeW91IHdvdWxkIGEgYFN1cmZhY2VgLlxuXHQgICAgICpcblx0ICAgICAqICBDdXN0b20gYFZpZXdzYCBhcmUgY3JlYXRlZCBieSBjYWxsaW5nIGBleHRlbmRgIG9uIHRoZSBgVmlld2AgY29uc3RydWN0b3IuXG5cdCAgICAgKlxuXHQgICAgICogIEluIGFkZGl0aW9uIHRvIHdoYXQgYSBgQ29udHJvbGxlcmAgcHJvdmlkZXMsIGEgVmlldyBwcm92aWRlczpcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIFJlbmRlciBUcmVlIG1ldGhvZDogYC5hZGRgXG5cdCAgICAgKiAgICAgIFNpemUgbWV0aG9kczogYHNldFNpemVgLCBgc2V0UHJvcG9ydGlvbnNgXG5cdCAgICAgKiAgICAgIExheW91dCBtZXRob2RzOiBgc2V0T3BhY2l0eWAsIGBzZXRPcmlnaW5gXG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgTXlWaWV3ID0gVmlldy5leHRlbmQoe1xuXHQgICAgICogICAgICAgICAgZGVmYXVsdHMgOiB7XG5cdCAgICAgKiAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbjEgOiAnJyxcblx0ICAgICAqICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uMiA6IDQyXG5cdCAgICAgKiAgICAgICAgICB9LFxuXHQgICAgICogICAgICAgICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHQgICAgICogICAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIGNhbGxlZCBvbiBpbnN0YW50aWF0aW9uXG5cdCAgICAgKiAgICAgICAgICAgICAgLy8gb3B0aW9ucyBhcmUgcGFzc2VkIGluIGFmdGVyIGJlaW5nIHBhdGNoZWQgYnkgdGhlIHNwZWNpZmllZCBkZWZhdWx0c1xuXHQgICAgICpcblx0ICAgICAqICAgICAgICAgICAgICB2YXIgc3VyZmFjZSA9IG5ldyBTdXJmYWNlKHtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgY29udGVudCA6IG9wdGlvbnMuZGVmYXVsdE9wdGlvbjEsXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgIHNpemUgOiBbb3B0aW9ucy5kZWZhdWx0T3B0aW9uMiwxMDBdLFxuXHQgICAgICogICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzIDoge2JhY2tncm91bmQgOiAncmVkJ31cblx0ICAgICAqICAgICAgICAgICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgICAgICAgICAgdGhpcy5hZGQoc3VyZmFjZSk7XG5cdCAgICAgKiAgICAgICAgICB9XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIG15VmlldyA9IG5ldyBteVZpZXcoe2RlZmF1bHRPcHRpb24xIDogJ2hlbGxvJ30pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIGNvbnRleHQgPSBDb250ZXh0KCk7XG5cdCAgICAgKiAgICAgIGNvbnRleHQuYWRkKG15Vmlldyk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBjb250ZXh0Lm1vdW50KGRvY3VtZW50LmJvZHkpO1xuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBWaWV3XG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBleHRlbmRzIENvcmUuQ29udHJvbGxlclxuXHQgICAgICogQHVzZXMgQ29yZS5TaXplTm9kZVxuXHQgICAgICogQHVzZXMgQ29yZS5MYXlvdXROb2RlXG5cdCAgICAgKiBAdXNlcyBDb3JlLlNpbXBsZVN0cmVhbVxuXHQgICAgICovXG5cdCAgICB2YXIgVmlldyA9IENvbnRyb2xsZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfaXNWaWV3IDogdHJ1ZSxcblx0ICAgICAgICBkZWZhdWx0cyA6IHtcblx0ICAgICAgICAgICAgc2l6ZSA6IG51bGwsXG5cdCAgICAgICAgICAgIG9yaWdpbiA6IG51bGwsXG5cdCAgICAgICAgICAgIG9wYWNpdHkgOiAxXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBldmVudHMgOiB7XG5cdCAgICAgICAgICAgIGNoYW5nZSA6IHNldE9wdGlvbnNcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNvbnN0cnVjdG9yIDogZnVuY3Rpb24gVmlldyhvcHRpb25zKXtcblx0ICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX3NpemVOb2RlID0gbmV3IFNpemVOb2RlKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX2xheW91dE5vZGUgPSBuZXcgTGF5b3V0Tm9kZSgpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX25vZGUgPSBuZXcgUmVuZGVyVHJlZU5vZGUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbm9kZS50ZW1wUm9vdCA9IHRoaXMuX25vZGU7XG5cblx0ICAgICAgICAgICAgdGhpcy5zaXplID0gUmVzaXplU3RyZWFtLmxpZnQoXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBWaWV3U2l6ZUFsZ2VicmEgKHNpemVTcGVjLCBwYXJlbnRTaXplKXtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFNpemUpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNpemVTcGVjKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IHNpemVBbGdlYnJhKHNpemVTcGVjLCBwYXJlbnRTaXplKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudFNpemU7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgW3RoaXMuX3NpemVOb2RlLCB0aGlzLl9zaXplXVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2NhY2hlZFNpemUgPSBbMCwwXTtcblx0ICAgICAgICAgICAgdGhpcy5zaXplLm9uKCdyZXNpemUnLCBmdW5jdGlvbihzaXplKXtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFNpemUgPSBzaXplO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG5cdCAgICAgICAgICAgIHZhciBsYXlvdXQgPSBTdHJlYW0ubGlmdChcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFZpZXdMYXlvdXRBbGdlYnJhIChwYXJlbnRTcGVjLCBvYmplY3RTcGVjLCBzaXplKXtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFNwZWMgfHwgIXNpemUpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9iamVjdFNwZWMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gbGF5b3V0QWxnZWJyYShvYmplY3RTcGVjLCBwYXJlbnRTcGVjLCBzaXplKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudFNwZWM7XG5cdCAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgICAgICBbdGhpcy5fbGF5b3V0LCB0aGlzLl9sYXlvdXROb2RlLCB0aGlzLnNpemVdXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgdGhpcy5fbm9kZS5fc2l6ZS5zdWJzY3JpYmUodGhpcy5zaXplKTtcblx0ICAgICAgICAgICAgdGhpcy5fbm9kZS5fbGF5b3V0LnN1YnNjcmliZShsYXlvdXQpO1xuXG5cdCAgICAgICAgICAgIENvbnRyb2xsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucykgc2V0T3B0aW9ucy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFeHRlbmRzIHRoZSByZW5kZXIgdHJlZSBzdWJ0cmVlIHdpdGggYSBuZXcgbm9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2QgYWRkXG5cdCAgICAgICAgICogQHBhcmFtIG9iamVjdCB7U2l6ZU5vZGV8TGF5b3V0Tm9kZXxTdXJmYWNlfSBOb2RlXG5cdCAgICAgICAgICogQHJldHVybiB7UmVuZGVyVHJlZU5vZGV9XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgYWRkIDogZnVuY3Rpb24gYWRkKCl7XG5cdCAgICAgICAgICAgIHJldHVybiBSZW5kZXJUcmVlTm9kZS5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMuX25vZGUsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBHZXR0ZXIgZm9yIHNpemUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIGdldFNpemVcblx0ICAgICAgICAgKiBAcmV0dXJuIHNpemUge051bWJlcltdfVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGdldFNpemUgOiBmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2l6ZTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNldHRlciBmb3Igc2l6ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2Qgc2V0U2l6ZVxuXHQgICAgICAgICAqIEBwYXJhbSBzaXplIHtOdW1iZXJbXXxTdHJlYW19IFNpemUgYXMgW3dpZHRoLCBoZWlnaHRdIGluIHBpeGVscywgb3IgYSBzdHJlYW0uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc2V0U2l6ZSA6IGZ1bmN0aW9uIHNldFNpemUoc2l6ZSl7XG5cdCAgICAgICAgICAgIHRoaXMuX3NpemVOb2RlLnNldCh7c2l6ZSA6IHNpemV9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNldHRlciBmb3IgcHJvcG9ydGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIHNldFByb3BvcnRpb25zXG5cdCAgICAgICAgICogQHBhcmFtIHByb3BvcnRpb25zIHtOdW1iZXJbXXxTdHJlYW19IFByb3BvcnRpb25zIGFzIFt4LHldLCBvciBhIHN0cmVhbS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzZXRQcm9wb3J0aW9ucyA6IGZ1bmN0aW9uIHNldFByb3BvcnRpb25zKHByb3BvcnRpb25zKXtcblx0ICAgICAgICAgICAgdGhpcy5fc2l6ZU5vZGUuc2V0KHtwcm9wb3J0aW9ucyA6IHByb3BvcnRpb25zfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXR0ZXIgZm9yIG9yaWdpbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2Qgc2V0T3JpZ2luXG5cdCAgICAgICAgICogQHBhcmFtIG9yaWdpbiB7TnVtYmVyW118U3RyZWFtfSBPcmlnaW4gYXMgW3gseV0sIG9yIGEgc3RyZWFtLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNldE9yaWdpbiA6IGZ1bmN0aW9uIHNldE9yaWdpbihvcmlnaW4pe1xuXHQgICAgICAgICAgICB0aGlzLl9sYXlvdXROb2RlLnNldCh7b3JpZ2luIDogb3JpZ2lufSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXR0ZXIgZm9yIG9wYWNpdHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIHNldE9wYWNpdHlcblx0ICAgICAgICAgKiBAcGFyYW0gb3BhY2l0eSB7TnVtYmVyfFN0cmVhbX0gT3BhY2l0eVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNldE9wYWNpdHkgOiBmdW5jdGlvbiBzZXRPcGFjaXR5KG9wYWNpdHkpe1xuXHQgICAgICAgICAgICB0aGlzLl9sYXlvdXROb2RlLnNldCh7b3BhY2l0eSA6IG9wYWNpdHl9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKXtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucyl7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcblx0ICAgICAgICAgICAgc3dpdGNoIChrZXkpe1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnc2l6ZSc6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaXplKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ3Byb3BvcnRpb25zJzpcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BvcnRpb25zKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgJ29yaWdpbic6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPcmlnaW4odmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRPcGFjaXR5KHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAyNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0ICAgIHZhciBTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICAgIHZhciBSZXNpemVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0ICAgIHZhciBTaXplTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXHQgICAgdmFyIExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHQgICAgdmFyIGxheW91dEFsZ2VicmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblx0ICAgIHZhciBzaXplQWxnZWJyYSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG5cdCAgICB2YXIgU0laRV9LRVlTID0gU2l6ZU5vZGUuS0VZUztcblx0ICAgIHZhciBMQVlPVVRfS0VZUyA9IExheW91dE5vZGUuS0VZUztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIG5vZGUgaW4gdGhlIHJlbmRlciB0cmVlLiBBcyBzdWNoLCBpdCB3cmFwcyBhIGxheW91dCBvciBzaXplIG5vZGUsXG5cdCAgICAgKiAgcHJvdmlkaW5nIHRoZW0gd2l0aCBhbiBgYWRkYCBtZXRob2QuIEJ5IGFkZGluZyBub2RlcywgdGhlIHJlbmRlciB0cmVlXG5cdCAgICAgKiAgaXMgY29uc3RydWN0ZWQsIHRoZSBsZWF2ZXMgb2Ygd2hpY2ggYXJlIGBTdXJmYWNlc2AuXG5cdCAgICAgKlxuXHQgICAgICogIEBjb25zdHJ1Y3RvclxuXHQgICAgICogIEBjbGFzcyBSZW5kZXJUcmVlTm9kZVxuXHQgICAgICogIEBwcml2YXRlXG5cdCAgICAgKiAgQHBhcmFtIG9iamVjdCB7T2JqZWN0fFNpemVOb2RlfExheW91dE5vZGV8U3VyZmFjZXxWaWV3fVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBSZW5kZXJUcmVlTm9kZShvYmplY3QpIHtcblx0ICAgICAgICAvLyBsYXlvdXQgYW5kIHNpemUgaW5wdXRzXG5cdCAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIHRoaXMuX3NpemUgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG5cblx0ICAgICAgICAvLyBsYXlvdXQgYW5kIHNpemUgc3RyZWFtc1xuXHQgICAgICAgIHRoaXMuc2l6ZSA9IG51bGw7XG5cdCAgICAgICAgdGhpcy5sYXlvdXQgPSBudWxsO1xuXG5cdCAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcblxuXHQgICAgICAgIGlmIChvYmplY3QpIF9zZXQuY2FsbCh0aGlzLCBvYmplY3QpO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIEV4dGVuZHMgdGhlIHJlbmRlciB0cmVlIHdpdGggYSBuZXcgbm9kZS4gU2ltaWxhciB0byBob3cgYSB0cmVlIGRhdGEgc3RydWN0dXJlXG5cdCAgICAgKiAgaXMgY3JlYXRlZCwgYnV0IGluc3RlYWQgb2YgYSBub2RlIHdpdGggYW4gYXJyYXkgb2YgY2hpbGRyZW4sIGNoaWxkcmVuIHN1YnNjcmliZVxuXHQgICAgICogIHRvIG5vdGlmaWNhdGlvbnMgZnJvbSB0aGUgcGFyZW50LlxuXHQgICAgICpcblx0ICAgICAqICBOb2RlcyBjYW4gYmUgaW5zdGFuY2VzIG9mIGBMYXlvdXROb2RlYCwgYFNpemVOb2RlYCwgb3IgT2JqZWN0IGxpdGVyYWxzIHdpdGhcblx0ICAgICAqICBzaXplIGFuZCBsYXlvdXQgcHJvcGVydGllcywgaW4gd2hpY2ggY2FzZSwgYXBwcm9wcmlhdGUgbm9kZXMgd2lsbCBiZSBjcmVhdGVkLlxuXHQgICAgICpcblx0ICAgICAqICBUaGlzIG1ldGhvZCBhbHNvIHRha2VzIGBWaWV3c2AgKHN1YnRyZWVzKSBhbmQgYFN1cmZhY2VzYCAobGVhdmVzKS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGFkZFxuXHQgICAgICogQGNoYWluYWJsZVxuXHQgICAgICogQHBhcmFtIG5vZGUge09iamVjdHxTaXplTm9kZXxMYXlvdXROb2RlfFN1cmZhY2V8Vmlld30gTm9kZVxuXHQgICAgICogQHJldHVybiB7UmVuZGVyVHJlZU5vZGV9XG5cdCAgICAgKi9cblx0ICAgIFJlbmRlclRyZWVOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQobm9kZSkge1xuXHQgICAgICAgIHZhciBjaGlsZE5vZGU7XG5cblx0ICAgICAgICBpZiAobm9kZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KXtcblx0ICAgICAgICAgICAgLy8gT2JqZWN0IGxpdGVyYWwgY2FzZVxuXHQgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZU5vZGVGcm9tT2JqZWN0TGl0ZXJhbC5jYWxsKHRoaXMsIG5vZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChub2RlLl9pc1ZpZXcpe1xuXHQgICAgICAgICAgICAvLyBWaWV3IGNhc2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMucm9vdClcblx0ICAgICAgICAgICAgICAgIG5vZGUuX25vZGUucm9vdCA9IHRoaXMucm9vdDtcblx0ICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50ZW1wUm9vdClcblx0ICAgICAgICAgICAgICAgIG5vZGUuX25vZGUudGVtcFJvb3QgPSB0aGlzLnRlbXBSb290O1xuXHQgICAgICAgICAgICBjaGlsZE5vZGUgPSBub2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gTm9kZSBjYXNlXG5cdCAgICAgICAgICAgIGNoaWxkTm9kZSA9IG5ldyBSZW5kZXJUcmVlTm9kZShub2RlKTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMudGVtcFJvb3QpXG5cdCAgICAgICAgICAgICAgICBjaGlsZE5vZGUudGVtcFJvb3QgPSB0aGlzLnRlbXBSb290O1xuXHQgICAgICAgICAgICBlbHNlIGNoaWxkTm9kZS5yb290ID0gX2dldFJvb3ROb2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY2hpbGROb2RlLl9sYXlvdXQuc3Vic2NyaWJlKHRoaXMubGF5b3V0IHx8IHRoaXMuX2xheW91dCk7XG5cdCAgICAgICAgY2hpbGROb2RlLl9zaXplLnN1YnNjcmliZSh0aGlzLnNpemUgfHwgdGhpcy5fc2l6ZSk7XG5cblx0ICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gX2NyZWF0ZU5vZGVGcm9tT2JqZWN0TGl0ZXJhbChvYmplY3Qpe1xuXHQgICAgICAgIHZhciBzaXplS2V5cyA9IHt9O1xuXHQgICAgICAgIHZhciBsYXlvdXRLZXlzID0ge307XG5cblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KXtcblx0ICAgICAgICAgICAgaWYgKFNJWkVfS0VZU1trZXldKSBzaXplS2V5c1trZXldID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKExBWU9VVF9LRVlTW2tleV0pIGxheW91dEtleXNba2V5XSA9IG9iamVjdFtrZXldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBub2RlID0gdGhpcztcblx0ICAgICAgICB2YXIgbmVlZHNTaXplID0gT2JqZWN0LmtleXMoc2l6ZUtleXMpLmxlbmd0aCA+IDA7XG5cdCAgICAgICAgdmFyIG5lZWRzTGF5b3V0ID0gT2JqZWN0LmtleXMobGF5b3V0S2V5cykubGVuZ3RoID4gMDtcblxuXHQgICAgICAgIC8vIGNyZWF0ZSBleHRyYSBhbGlnbiBub2RlIGlmIG5lZWRlZFxuXHQgICAgICAgIGlmIChuZWVkc1NpemUgJiYgbGF5b3V0S2V5cy5hbGlnbil7XG5cdCAgICAgICAgICAgIHZhciBhbGlnbk5vZGUgPSBuZXcgTGF5b3V0Tm9kZSh7XG5cdCAgICAgICAgICAgICAgICBhbGlnbiA6IGxheW91dEtleXMuYWxpZ25cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIGRlbGV0ZSBsYXlvdXRLZXlzLmFsaWduO1xuXHQgICAgICAgICAgICBub2RlID0gbm9kZS5hZGQoYWxpZ25Ob2RlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBjcmVhdGUgc2l6ZSBub2RlIGZpcnN0IGlmIG5lZWRlZFxuXHQgICAgICAgIGlmIChuZWVkc1NpemUpXG5cdCAgICAgICAgICAgIG5vZGUgPSBub2RlLmFkZChuZXcgU2l6ZU5vZGUoc2l6ZUtleXMpKTtcblxuXHQgICAgICAgIC8vIGNyZWF0ZSBsYXlvdXQgbm9kZSBpZiBuZWVkZWRcblx0ICAgICAgICBpZiAobmVlZHNMYXlvdXQpXG5cdCAgICAgICAgICAgIG5vZGUgPSBub2RlLmFkZChuZXcgTGF5b3V0Tm9kZShsYXlvdXRLZXlzKSk7XG5cblx0ICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX2dldFJvb3ROb2RlKCl7XG5cdCAgICAgICAgaWYgKHRoaXMucm9vdCkgcmV0dXJuIHRoaXMucm9vdDtcblx0ICAgICAgICBpZiAodGhpcy50ZW1wUm9vdCkgcmV0dXJuIF9nZXRSb290Tm9kZS5jYWxsKHRoaXMudGVtcFJvb3QpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfc2V0KG9iamVjdCkge1xuXHQgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTaXplTm9kZSl7XG5cdCAgICAgICAgICAgIHRoaXMuc2l6ZSA9IFJlc2l6ZVN0cmVhbS5saWZ0KFxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gU0dTaXplQWxnZWJyYSAob2JqZWN0U3BlYywgcGFyZW50U2l6ZSl7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRTaXplKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChvYmplY3RTcGVjKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IHNpemVBbGdlYnJhKG9iamVjdFNwZWMsIHBhcmVudFNpemUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50U2l6ZTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBbb2JqZWN0LCB0aGlzLl9zaXplXVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExheW91dE5vZGUpe1xuXHQgICAgICAgICAgICB0aGlzLmxheW91dCA9IFN0cmVhbS5saWZ0KFxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gU0dMYXlvdXRBbGdlYnJhIChvYmplY3RTcGVjLCBwYXJlbnRTcGVjLCBzaXplKXtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFNwZWMgfHwgIXNpemUpIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9iamVjdFNwZWMpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gbGF5b3V0QWxnZWJyYShvYmplY3RTcGVjLCBwYXJlbnRTcGVjLCBzaXplKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudFNwZWM7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgW29iamVjdCwgdGhpcy5fbGF5b3V0LCB0aGlzLl9zaXplXVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gb2JqZWN0IGlzIGEgbGVhZiBub2RlXG5cdCAgICAgICAgb2JqZWN0Ll9zaXplLnN1YnNjcmliZSh0aGlzLl9zaXplKTtcblx0ICAgICAgICBvYmplY3QuX2xheW91dC5zdWJzY3JpYmUodGhpcy5fbGF5b3V0KTtcblx0ICAgICAgICBvYmplY3QuX2dldFJvb3QgPSBfZ2V0Um9vdE5vZGUuYmluZCh0aGlzKTtcblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJUcmVlTm9kZTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMjggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5cdCAgICB2YXIgREVGQVVMVCA9IHtcblx0ICAgICAgICBPUEFDSVRZIDogMSxcblx0ICAgICAgICBUUkFOU0ZPUk0gOiBUcmFuc2Zvcm0uaWRlbnRpdHksXG5cdCAgICAgICAgT1JJR0lOIDogbnVsbCxcblx0ICAgICAgICBBTElHTiA6IG51bGxcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVmaW5lcyB0aGUgcnVsZXMgZm9yIGNvbXBvc2luZyBsYXlvdXQgc3BlY3M6IHRyYW5zZm9ybSwgYWxpZ24sIG9yaWdpbiBhbmQgb3BhY2l0eS5cblx0ICAgICAqICBUcmFuc2Zvcm0gaXMgbXVsdGlwbGllZCBieSB0aGUgcGFyZW50J3MgdHJhbnNmb3JtIChtYXRyaXggbXVsdGlwbGljYXRpb24pLlxuXHQgICAgICogIEFsaWduIGlzIGEgcHJvcG9ydGlvbmFsIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHNpemUuXG5cdCAgICAgKiAgT3JpZ2luIGlzIGEgcHJvcG9ydGlvbmFsIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBzaXplLlxuXHQgICAgICogIE9wYWNpdHkgaXMgbXVsdGlwbGllZCBieSB0aGUgcGFyZW50J3Mgb3BhY2l0eS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGNvbXBvc2Vcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAcGFyYW0gc3BlYyB7b2JqZWN0fSAgICAgICAgICAgT2JqZWN0IGxheW91dCBzcGVjXG5cdCAgICAgKiBAcGFyYW0gcGFyZW50U3BlYyB7b2JqZWN0fSAgICAgUGFyZW50IGxheW91dCBzcGVjXG5cdCAgICAgKiBAcGFyYW0gc2l6ZSB7QXJyYXl9ICAgICAgICAgICAgT2JqZWN0IHNpemVcblx0ICAgICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICBUaGUgY29tcG9zZWQgbGF5b3V0IHNwZWNcblx0ICAgICAqL1xuXG5cdCAgICBmdW5jdGlvbiBjb21wb3NlKHNwZWMsIHBhcmVudFNwZWMsIHNpemUpe1xuXHQgICAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gKHBhcmVudFNwZWMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSA/IHBhcmVudFNwZWMub3BhY2l0eSA6IERFRkFVTFQuT1BBQ0lUWTtcblx0ICAgICAgICB2YXIgcGFyZW50VHJhbnNmb3JtID0gcGFyZW50U3BlYy50cmFuc2Zvcm0gfHwgREVGQVVMVC5UUkFOU0ZPUk07XG5cblx0ICAgICAgICB2YXIgb3JpZ2luID0gc3BlYy5vcmlnaW4gfHwgREVGQVVMVC5PUklHSU47XG5cdCAgICAgICAgdmFyIGFsaWduID0gc3BlYy5hbGlnbiB8fCBERUZBVUxULkFMSUdOO1xuXG5cdCAgICAgICAgdmFyIG9wYWNpdHkgPSAoc3BlYy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgID8gcGFyZW50T3BhY2l0eSAqIHNwZWMub3BhY2l0eVxuXHQgICAgICAgICAgICA6IHBhcmVudE9wYWNpdHk7XG5cblx0ICAgICAgICB2YXIgdHJhbnNmb3JtID0gKHNwZWMudHJhbnNmb3JtKVxuXHQgICAgICAgICAgICA/IFRyYW5zZm9ybS5jb21wb3NlKHBhcmVudFRyYW5zZm9ybSwgc3BlYy50cmFuc2Zvcm0pXG5cdCAgICAgICAgICAgIDogcGFyZW50VHJhbnNmb3JtO1xuXG5cdCAgICAgICAgdmFyIG5leHRTaXplVHJhbnNmb3JtID0gKHNwZWMub3JpZ2luKVxuXHQgICAgICAgICAgICA/IHBhcmVudFRyYW5zZm9ybVxuXHQgICAgICAgICAgICA6IHBhcmVudFNwZWMubmV4dFNpemVUcmFuc2Zvcm0gfHwgcGFyZW50VHJhbnNmb3JtO1xuXG5cdCAgICAgICAgaWYgKHNwZWMuc2l6ZSlcblx0ICAgICAgICAgICAgbmV4dFNpemVUcmFuc2Zvcm0gPSBwYXJlbnRUcmFuc2Zvcm07XG5cblx0ICAgICAgICBpZiAob3JpZ2luICYmIChvcmlnaW5bMF0gfHwgb3JpZ2luWzFdKSl7XG5cdCAgICAgICAgICAgIC8vVE9ETzogYWxsb3cgb3JpZ2luIHRvIHByb3BvZ2F0ZSB3aGVuIHNpemUgaXMgbm9uLW51bWVyaWNcblx0ICAgICAgICAgICAgdmFyIHR4ID0gICh0eXBlb2Ygc2l6ZVswXSA9PT0gJ251bWJlcicpID8gLW9yaWdpblswXSAqIHNpemVbMF0gOiAwO1xuXHQgICAgICAgICAgICB2YXIgdHkgPSAgKHR5cGVvZiBzaXplWzFdID09PSAnbnVtYmVyJykgPyAtb3JpZ2luWzFdICogc2l6ZVsxXSA6IDA7XG5cdCAgICAgICAgICAgIHRyYW5zZm9ybSA9IFRyYW5zZm9ybS5tb3ZlVGhlbihbdHgsIHR5LCAwXSwgdHJhbnNmb3JtKTtcblx0ICAgICAgICAgICAgb3JpZ2luID0gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc2l6ZSAmJiBhbGlnbiAmJiAoYWxpZ25bMF0gfHwgYWxpZ25bMV0pKSB7XG5cdCAgICAgICAgICAgIHZhciBzaGlmdCA9IF92ZWNJbkNvbnRleHQoW2FsaWduWzBdICogc2l6ZVswXSwgYWxpZ25bMV0gKiBzaXplWzFdLCAwXSwgbmV4dFNpemVUcmFuc2Zvcm0pO1xuXHQgICAgICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0udGhlbk1vdmUodHJhbnNmb3JtLCBzaGlmdCk7XG5cdCAgICAgICAgICAgIGFsaWduID0gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB0cmFuc2Zvcm0gOiB0cmFuc2Zvcm0sXG5cdCAgICAgICAgICAgIG9wYWNpdHkgOiBvcGFjaXR5LFxuXHQgICAgICAgICAgICBvcmlnaW4gOiBvcmlnaW4sXG5cdCAgICAgICAgICAgIGFsaWduIDogYWxpZ24sXG5cdCAgICAgICAgICAgIG5leHRTaXplVHJhbnNmb3JtIDogbmV4dFNpemVUcmFuc2Zvcm1cblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfdmVjSW5Db250ZXh0KHYsIG0pIHtcblx0ICAgICAgICByZXR1cm4gW1xuXHQgICAgICAgICAgICB2WzBdICogbVswXSArIHZbMV0gKiBtWzRdICsgdlsyXSAqIG1bOF0sXG5cdCAgICAgICAgICAgIHZbMF0gKiBtWzFdICsgdlsxXSAqIG1bNV0gKyB2WzJdICogbVs5XSxcblx0ICAgICAgICAgICAgdlswXSAqIG1bMl0gKyB2WzFdICogbVs2XSArIHZbMl0gKiBtWzEwXVxuXHQgICAgICAgIF07XG5cdCAgICB9XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gY29tcG9zZTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlZmluZXMgdGhlIHJ1bGVzIGZvciBjb21wb3Npbmcgc2l6ZSBzcGVjcyAoc2l6ZSwgbWFyZ2luLCBwcm9wb3J0aW9ucykgaW50byBhIG5ldyBzaXplLlxuXHQgICAgICogIEEgbWFyZ2luIGFycmF5IHJlZHVjZXMgdGhlIHBhcmVudCBzaXplIGJ5IGFuIGFtb3VudCBzcGVjaWZpZWQgaW4gcGl4ZWxzLlxuXHQgICAgICogIEEgcHJvcG9ydGlvbnMgYXJyYXkgc2NhbGVzIHRoZSBwYXJlbnQgc2l6ZSBieSBhIHByb3ZpZGVkIHJhdGlvLlxuXHQgICAgICogIEEgc2l6ZSBhcnJheSBbd2lkdGgsIGhlaWdodF0gY2FuIHRha2UgYHRydWVgLCBgdW5kZWZpbmVkYCwgb3IgbnVtZXJpYyB2YWx1ZXMuXG5cdCAgICAgKiAgICAgIGB1bmRlZmluZWRgIHRha2VzIHRoZSBwYXJlbnQgdmFsdWVcblx0ICAgICAqICAgICAgYHRydWVgIHRha2VzIHRoZSB2YWx1ZSBkZWZpbmVkIGJ5IHRoZSBET01cblx0ICAgICAqICAgICAgbnVtZXJpYyB2YWx1ZXMgb3ZlcnJpZGUgcGFyZW50IHZhbHVlc1xuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgY29tcG9zZVxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSBzcGVjIHtvYmplY3R9ICAgICAgICAgICBPYmplY3Qgc2l6ZSBzcGVjXG5cdCAgICAgKiBAcGFyYW0gcGFyZW50U2l6ZSB7b2JqZWN0fSAgICAgUGFyZW50IHNpemVcblx0ICAgICAqIEByZXR1cm4gc2l6ZSB7b2JqZWN0fSAgICAgICAgICBDb21wb3NlZCBzaXplXG5cdCAgICAgKi9cblxuXHQgICAgZnVuY3Rpb24gY29tcG9zZShzcGVjLCBwYXJlbnRTaXplKXtcblx0ICAgICAgICBpZiAoIXNwZWMpIHJldHVybiBwYXJlbnRTaXplO1xuXG5cdCAgICAgICAgdmFyIHNpemUgPSBuZXcgQXJyYXkoMik7XG5cblx0ICAgICAgICBpZiAoc3BlYy5zaXplKSB7XG5cdCAgICAgICAgICAgIC8vIGluaGVyaXRhbmNlXG5cdCAgICAgICAgICAgIGlmIChzcGVjLnNpemVbMF0gPT09IHVuZGVmaW5lZCkgc2l6ZVswXSA9IHBhcmVudFNpemVbMF07XG5cdCAgICAgICAgICAgIGlmIChzcGVjLnNpemVbMV0gPT09IHVuZGVmaW5lZCkgc2l6ZVsxXSA9IHBhcmVudFNpemVbMV07XG5cblx0ICAgICAgICAgICAgLy8gb3ZlcnJpZGVcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjLnNpemVbMF0gPT09ICdudW1iZXInKSBzaXplWzBdID0gc3BlYy5zaXplWzBdO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMuc2l6ZVsxXSA9PT0gJ251bWJlcicpIHNpemVbMV0gPSBzcGVjLnNpemVbMV07XG5cblx0ICAgICAgICAgICAgaWYgKHNwZWMuc2l6ZVswXSA9PT0gdHJ1ZSkgc2l6ZVswXSA9IHRydWU7XG5cdCAgICAgICAgICAgIGlmIChzcGVjLnNpemVbMV0gPT09IHRydWUpIHNpemVbMV0gPSB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vVE9ETzogd2hhdCBpcyBwYXJlbnRTaXplIGlzbid0IG51bWVyaWM/IENvbXBvc2UgbWFyZ2luL3Byb3BvcnRpb25zP1xuXHQgICAgICAgIGlmIChzcGVjLm1hcmdpbnMpe1xuXHQgICAgICAgICAgICBzaXplWzBdID0gcGFyZW50U2l6ZVswXSAtICgyICogc3BlYy5tYXJnaW5zWzBdKTtcblx0ICAgICAgICAgICAgc2l6ZVsxXSA9IHBhcmVudFNpemVbMV0gLSAoMiAqIHNwZWMubWFyZ2luc1sxXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHNwZWMucHJvcG9ydGlvbnMpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzcGVjLnByb3BvcnRpb25zWzBdID09PSAnbnVtYmVyJykgc2l6ZVswXSA9IHNwZWMucHJvcG9ydGlvbnNbMF0gKiBwYXJlbnRTaXplWzBdO1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMucHJvcG9ydGlvbnNbMV0gPT09ICdudW1iZXInKSBzaXplWzFdID0gc3BlYy5wcm9wb3J0aW9uc1sxXSAqIHBhcmVudFNpemVbMV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHNwZWMuYXNwZWN0UmF0aW8pIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzaXplWzBdID09PSAnbnVtYmVyJykgc2l6ZVsxXSA9IHNwZWMuYXNwZWN0UmF0aW8gKiBzaXplWzBdO1xuXHQgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2l6ZVsxXSA9PT0gJ251bWJlcicpIHNpemVbMF0gPSBzcGVjLmFzcGVjdFJhdGlvICogc2l6ZVsxXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc2l6ZVswXSA9PT0gdW5kZWZpbmVkKSBzaXplWzBdID0gcGFyZW50U2l6ZVswXTtcblx0ICAgICAgICBpZiAoc2l6ZVsxXSA9PT0gdW5kZWZpbmVkKSBzaXplWzFdID0gcGFyZW50U2l6ZVsxXTtcblxuXHQgICAgICAgIHJldHVybiBzaXplO1xuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbXBvc2U7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187Lypcblx0ICogY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hblxuXHQgKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgT3B0aW9uc01hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIFNpbXBsZVN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgdXRpbGl0eSBjbGFzcyB3aGljaCBjYW4gYmUgZXh0ZW5kZWQgYnkgY3VzdG9tIGNsYXNzZXMuIFRoZXNlIGNsYXNzZXMgd2lsbCB0aGVuXG5cdCAgICAgKiAgaW5jbHVkZSBldmVudCBpbnB1dCBhbmQgb3V0cHV0IHN0cmVhbXMsIGEgb3B0aW9uc01hbmFnZXIgZm9yIGhhbmRsaW5nIG9wdGlvbmFsXG5cdCAgICAgKiAgcGFyYW1ldGVycyB3aXRoIGRlZmF1bHRzLCBhbmQgdGFrZSBhbiBldmVudCBkaWN0aW9uYXJ5LlxuXHQgICAgICpcblx0ICAgICAqICBTcGVjaWZpY2FsbHksIGluc3RhbnRpYXRpb25zIHdpbGwgaGF2ZSBhbiBgb3B0aW9uc2AgZGljdGlvbmFyeSBwcm9wZXJ0eSxcblx0ICAgICAqICBgaW5wdXRgLCBgb3V0cHV0YCBzdHJlYW0gcHJvcGVydGllcywgYW5kXG5cdCAgICAgKiAgYG9uYCwgYG9mZmAsIGBlbWl0YCwgYHRyaWdnZXJgLCBgc3Vic2NyaWJlYCwgYHVuc3Vic2NyaWJlYCBtZXRob2RzLlxuXHQgICAgICpcblx0ICAgICAqICBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIE15Q2xhc3MgPSBDb250cm9sbGVyLmV4dGVuZCh7XG5cdCAgICAgKiAgICAgICAgICBkZWZhdWx0cyA6IHtcblx0ICAgICAqICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uMSA6IHZhbHVlMSxcblx0ICAgICAqICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uMiA6IHZhbHVlMlxuXHQgICAgICogICAgICAgICAgfSxcblx0ICAgICAqICAgICAgICAgIGV2ZW50cyA6IHtcblx0ICAgICAqICAgICAgICAgICAgICAnY2hhbmdlJyA6IG15VXBkYXRlT3B0aW9uc0Z1bmN0aW9uXG5cdCAgICAgKiAgICAgICAgICB9LFxuXHQgICAgICogICAgICAgICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHQgICAgICogICAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIGNhbGxlZCBvbiBpbnN0YW50aWF0aW9uXG5cdCAgICAgKiAgICAgICAgICAgICAgLy8gb3B0aW9ucyBhcmUgcGFzc2VkIGluIGFmdGVyIGJlaW5nIHBhdGNoZWQgYnkgdGhlIHNwZWNpZmllZCBkZWZhdWx0c1xuXHQgICAgICpcblx0ICAgICAqICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9uKCd0ZXN0JywgZnVuY3Rpb24oKXtcblx0ICAgICAqICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Rlc3QgZmlyZWQnKTtcblx0ICAgICAqICAgICAgICAgICAgICB9KTtcblx0ICAgICAqICAgICAgICAgIH1cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgbXlJbnN0YW5jZSA9IG5ldyBNeUNsYXNzKHtcblx0ICAgICAqICAgICAgICAgIGRlZmF1bHRPcHRpb24xIDogdmFsdWUzXG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgLy8gbXlJbnN0YW5jZS5vcHRpb25zID0ge1xuXHQgICAgICogICAgICAvLyAgICAgZGVmYXVsdE9wdGlvbjEgOiB2YWx1ZTMsXG5cdCAgICAgKiAgICAgIC8vICAgICBkZWZhdWx0T3B0aW9uMiA6IHZhbHVlMlxuXHQgICAgICogICAgICAvLyB9XG5cdCAgICAgKlxuXHQgICAgICogICAgICBteUluc3RhbmNlLnN1YnNjcmliZShhbm90aGVyU3RyZWFtKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGFub3RoZXJTdHJlYW0uZW1pdCgndGVzdCcpOyAvLyBcInRlc3QgZmlyZWRcIiBpbiBjb25zb2xlXG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIENvbnRyb2xsZXJcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQG5hbWVzcGFjZSBDb3JlXG5cdCAgICAgKiBAdXNlcyBDb3JlLk9wdGlvbnNNYW5hZ2VyXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBJbnN0YW5jZSBvcHRpb25zXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIENvbnRyb2xsZXIob3B0aW9ucykge1xuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IF9jbG9uZSh0aGlzLmNvbnN0cnVjdG9yLkRFRkFVTFRfT1BUSU9OUyB8fCBDb250cm9sbGVyLkRFRkFVTFRfT1BUSU9OUyk7XG5cdCAgICAgICAgdGhpcy5fb3B0aW9uc01hbmFnZXIgPSBuZXcgT3B0aW9uc01hbmFnZXIodGhpcy5vcHRpb25zKTtcblx0ICAgICAgICBpZiAob3B0aW9ucykgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG5cdCAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBTaW1wbGVTdHJlYW0oKTtcblx0ICAgICAgICB0aGlzLm91dHB1dCA9IG5ldyBTaW1wbGVTdHJlYW0oKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRIYW5kbGVyKHRoaXMsIHRoaXMuaW5wdXQpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRPdXRwdXRIYW5kbGVyKHRoaXMsIHRoaXMub3V0cHV0KTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRFdmVudHModGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMgfHwgQ29udHJvbGxlci5FVkVOVFMsIHRoaXMuaW5wdXQpO1xuXG5cdCAgICAgICAgdGhpcy5pbnB1dC5iaW5kVGhpcyh0aGlzKTtcblx0ICAgICAgICB0aGlzLmlucHV0LnN1YnNjcmliZSh0aGlzLl9vcHRpb25zTWFuYWdlcik7XG5cblx0ICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplKSB0aGlzLmluaXRpYWxpemUodGhpcy5vcHRpb25zKTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBPdmVyd3JpdGUgdGhlIERFRkFVTFRfT1BUSU9OUyBkaWN0aW9uYXJ5IG9uIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY2xhc3MgeW91IHdpc2ggdG8gZXh0ZW5kXG5cdCAgICAgKiAgd2l0aCB0aGUgQ29udHJvbGxlciB0byBwYXRjaCBhbnkgb3B0aW9ucyB0aGF0IGFyZSBub3QgcHJlc2NyaWJlZCBvbiBpbnN0YW50aWF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEBhdHRyaWJ1dGUgREVGQVVMVF9PUFRJT05TXG5cdCAgICAgKiBAcmVhZE9ubHlcblx0ICAgICAqL1xuXHQgICAgQ29udHJvbGxlci5ERUZBVUxUX09QVElPTlMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPdmVyd3JpdGUgdGhlIEVWRU5UUyBkaWN0aW9uYXJ5IG9uIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgY2xhc3MgeW91IHdpc2ggdG8gZXh0ZW5kXG5cdCAgICAgKiAgd2l0aCB0aGUgQ29udHJvbGxlciB0byBpbmNsdWRlIGV2ZW50cyBpbiB7a2V5IDogdmFsdWV9IHBhaXJzIHdoZXJlIHRoZSBrZXlzIGFyZVxuXHQgICAgICogIGV2ZW50IGNoYW5uZWwgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAYXR0cmlidXRlIEVWRU5UU1xuXHQgICAgICogQHJlYWRPbmx5XG5cdCAgICAgKi9cblx0ICAgIENvbnRyb2xsZXIuRVZFTlRTID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3B0aW9ucyBnZXR0ZXIuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRPcHRpb25zXG5cdCAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9ICAgICAgS2V5XG5cdCAgICAgKiBAcmV0dXJuIG9iamVjdCB7T2JqZWN0fSAgT3B0aW9ucyB2YWx1ZSBmb3IgdGhlIGtleVxuXHQgICAgICovXG5cdCAgICBDb250cm9sbGVyLnByb3RvdHlwZS5nZXRPcHRpb25zID0gZnVuY3Rpb24gZ2V0T3B0aW9ucyhrZXkpIHtcblx0ICAgICAgICByZXR1cm4gT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmdldE9wdGlvbnMuYXBwbHkodGhpcy5fb3B0aW9uc01hbmFnZXIsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqICBPcHRpb25zIHNldHRlci5cblx0ICAgICAqXG5cdCAgICAgKiAgQG1ldGhvZCBzZXRPcHRpb25zXG5cdCAgICAgKiAgQHBhcmFtIG9wdGlvbnMge09iamVjdH0gT3B0aW9uc1xuXHQgICAgICovXG5cdCAgICBDb250cm9sbGVyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcblx0ICAgICAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuc2V0T3B0aW9ucy5hcHBseSh0aGlzLl9vcHRpb25zTWFuYWdlciwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBSRVNFUlZFRF9LRVlTID0ge1xuXHQgICAgICAgIERFRkFVTFRTIDogJ2RlZmF1bHRzJyxcblx0ICAgICAgICBFVkVOVFMgOiAnZXZlbnRzJ1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gX2Nsb25lKG9iaikge1xuXHQgICAgICAgIHZhciBjb3B5O1xuXHQgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICBjb3B5ID0gKG9iaiBpbnN0YW5jZW9mIEFycmF5KSA/IFtdIDoge307XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlba2V5XVtpXSA9IF9jbG9uZSh2YWx1ZVtpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgY29weVtrZXldID0gX2Nsb25lKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgY29weVtrZXldID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBjb3B5ID0gb2JqO1xuXG5cdCAgICAgICAgcmV0dXJuIGNvcHk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGV4dGVuZChwcm90b09iaiwgY29uc3RhbnRzKXtcblx0ICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuXHQgICAgICAgIHZhciBjaGlsZCA9IChwcm90b09iai5oYXNPd25Qcm9wZXJ0eSgnY29uc3RydWN0b3InKSlcblx0ICAgICAgICAgICAgPyBmdW5jdGlvbigpeyBwcm90b09iai5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cdCAgICAgICAgICAgIDogZnVuY3Rpb24oKXsgcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG5cblx0ICAgICAgICBjaGlsZC5leHRlbmQgPSBleHRlbmQ7XG5cdCAgICAgICAgY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcblx0ICAgICAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm90b09iail7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3RvT2JqW2tleV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFJFU0VSVkVEX0tFWVMuREVGQVVMVFM6XG5cdCAgICAgICAgICAgICAgICAgICAgY2hpbGQuREVGQVVMVF9PUFRJT05TID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFJFU0VSVkVEX0tFWVMuRVZFTlRTOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuRVZFTlRTKSBjaGlsZC5FVkVOVFMgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLkVWRU5UU1trZXldID0gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgY2hpbGQucHJvdG90eXBlW2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbnN0YW50cylcblx0ICAgICAgICAgICAgY2hpbGRba2V5XSA9IGNvbnN0YW50c1trZXldO1xuXG5cdCAgICAgICAgcmV0dXJuIGNoaWxkO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIEFsbG93cyBhIGNsYXNzIHRvIGV4dGVuZCBDb250cm9sbGVyLlxuXHQgICAgICogIE5vdGU6IHRoaXMgaXMgYSBtZXRob2QgZGVmaW5lZCBvbiB0aGUgQ29udHJvbGxlciBjb25zdHJ1Y3RvclxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZXh0ZW5kXG5cdCAgICAgKiBAcGFyYW0gcHJvdG9PYmoge09iamVjdH0gICAgIFByb3RvdHlwZSBwcm9wZXJ0aWVzIG9mIHRoZSBleHRlbmRlZCBjbGFzc1xuXHQgICAgICogQHBhcmFtIGNvbnN0YW50cyB7T2JqZWN0fSAgICBDb25zdGFudHMgdG8gYmUgYWRkZWQgdG8gdGhlIGV4dGVuZGVkIGNsYXNzJ3MgY29uc3RydWN0b3Jcblx0ICAgICAqL1xuXHQgICAgQ29udHJvbGxlci5leHRlbmQgPSBleHRlbmQ7XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gQ29udHJvbGxlcjtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMzEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIEV2ZW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogIEEgdXRpbGl0eSBmb3Igc2V0dGluZyBvcHRpb25zIGluIGEgY2xhc3MgdGhhdCBlbmFibGVzIHBhdGNoaW5nIG9wdGlvbnNcblx0ICAgICAqICAgd2l0aCBwcmVzY3JpYmVkIGRlZmF1bHRzIGFuZCBlbWl0dGluZyBgY2hhbmdlYCBldmVudHMgd2hlbiBvcHRpb25zIGFyZSBjaGFuZ2VkLlxuXHQgICAgICogICBSZWN1cnNpdmVseSBkZWZpbmVkIGZvciBuZXN0ZWQgb3B0aW9ucyBvYmplY3RzLlxuXHQgICAgICpcblx0ICAgICAqICAgTm90ZTogb25seSBKU09OYWJsZSBvYmplY3RzIGFyZSBhbGxvd2VkLCBzbyBubyBmdW5jdGlvbnMuXG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIE9wdGlvbnNNYW5hZ2VyXG5cdCAgICAgKiBAbmFtZXNwYWNlIENvcmVcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEB1c2VzIENvcmUuRXZlbnRIYW5kbGVyXG5cdCAgICAgKiBAcGFyYW0gdmFsdWUge09iamVjdH0gT3B0aW9ucyBvYmplY3QgbGl0ZXJhbFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBPcHRpb25zTWFuYWdlcih2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb25zdHJ1Y3RvciBtZXRob2QuIENyZWF0ZSBPcHRpb25zTWFuYWdlciBmcm9tIHNvdXJjZSBkaWN0aW9uYXJ5IHdpdGggYXJndW1lbnRzIG92ZXJyaWRlbiBieSBwYXRjaCBkaWN0aW9uYXJ5LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgT3B0aW9uc01hbmFnZXIucGF0Y2hcblx0ICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9ICAgICAgICAgIE9wdGlvbnMgdG8gYmUgcGF0Y2hlZFxuXHQgICAgICogQHBhcmFtIHBhdGNoIHsuLi5PYmplY3R9ICAgICAgICAgT3B0aW9ucyB0byBvdmVyd3JpdGVcblx0ICAgICAqIEByZXR1cm4gc291cmNlIHtPYmplY3R9XG5cdCAgICAgKi9cblx0ICAgIE9wdGlvbnNNYW5hZ2VyLnBhdGNoID0gZnVuY3Rpb24gcGF0Y2gob3B0aW9ucywgcGF0Y2gpIHtcblx0ICAgICAgICB2YXIgbWFuYWdlciA9IG5ldyBPcHRpb25zTWFuYWdlcihvcHRpb25zKTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgbWFuYWdlci5wYXRjaChhcmd1bWVudHNbaV0pO1xuXHQgICAgICAgIHJldHVybiBvcHRpb25zO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb25zdHJ1Y3RvciBtZXRob2QuIENvbnZlbmllbmNlIG1ldGhvZCB0byBzZXQgb3B0aW9ucyB3aXRoIGRlZmF1bHRzIG9uIGFuIG9iamVjdCBpbnN0YW5jZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIE9wdGlvbnNNYW5hZ2VyLnBhdGNoXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSAgICAgICAgICBPcHRpb25zIHRvIGJlIHBhdGNoZWRcblx0ICAgICAqIEBwYXJhbSBvdmVycmlkZXMgey4uLk9iamVjdH0gICAgIE9wdGlvbnMgdG8gb3ZlcndyaXRlXG5cdCAgICAgKiBAcmV0dXJuIHNvdXJjZSB7T2JqZWN0fVxuXHQgICAgICovXG5cdCAgICBPcHRpb25zTWFuYWdlci5zZXRPcHRpb25zID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9wdGlvbnMsIGRlZmF1bHRzKXtcblx0ICAgICAgICBkZWZhdWx0cyA9IGRlZmF1bHRzIHx8IF9jbG9uZShpbnN0YW5jZS5jb25zdHJ1Y3Rvci5ERUZBVUxUX09QVElPTlMpIHx8IHt9O1xuXHQgICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IG5ldyBPcHRpb25zTWFuYWdlcihkZWZhdWx0cyk7XG5cdCAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyA9IE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zLmJpbmQob3B0aW9uc01hbmFnZXIpO1xuXHQgICAgICAgIGluc3RhbmNlLmdldE9wdGlvbnMgPSBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuZ2V0T3B0aW9ucy5iaW5kKG9wdGlvbnNNYW5hZ2VyKTtcblx0ICAgICAgICBpZiAob3B0aW9ucykgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0ICAgICAgICByZXR1cm4gb3B0aW9uc01hbmFnZXIuZ2V0KCk7XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBfY3JlYXRlRXZlbnRIYW5kbGVyKCkge1xuXHQgICAgICAgIGlmICghdGhpcy5fZXZlbnRIYW5kbGVyKSB0aGlzLl9ldmVudEhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGF0Y2ggb3B0aW9ucyB3aXRoIHByb3ZpZGVkIHBhdGNoZXMuIFRyaWdnZXJzIGBjaGFuZ2VgIGV2ZW50IG9uIHRoZSBvYmplY3QuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBwYXRjaFxuXHQgICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gICAgICAgICAgUGF0Y2ggb3B0aW9uc1xuXHQgICAgICogQHJldHVybiB0aGlzIHtPcHRpb25zTWFuYWdlcn1cblx0ICAgICAqL1xuXHQgICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gcGF0Y2gob3B0aW9ucywgY2xvbmUpIHtcblx0ICAgICAgICB2YXIgbXlTdGF0ZSA9IHRoaXMuX3ZhbHVlO1xuXHQgICAgICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuXHQgICAgICAgICAgICBpZiAoKGsgaW4gbXlTdGF0ZSkgJiYgKG9wdGlvbnNba10gJiYgb3B0aW9uc1trXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSAmJiAobXlTdGF0ZVtrXSAmJiBteVN0YXRlW2tdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW15U3RhdGUuaGFzT3duUHJvcGVydHkoaykpIG15U3RhdGVba10gPSBPYmplY3QuY3JlYXRlKG15U3RhdGVba10pO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5rZXkoaykucGF0Y2gob3B0aW9uc1trXSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyKSB0aGlzLl9ldmVudEhhbmRsZXIuZW1pdCgnY2hhbmdlJywge2tleTogaywgdmFsdWU6IHRoaXMua2V5KGspLnZhbHVlKCl9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHRoaXMuc2V0KGssIG9wdGlvbnNba10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxpYXMgZm9yIHBhdGNoXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRPcHRpb25zXG5cdCAgICAgKi9cblx0ICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLnBhdGNoO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybiBPcHRpb25zTWFuYWdlciBiYXNlZCBvbiBzdWItb2JqZWN0IHJldHJpZXZlZCBieSBga2V5YC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGtleVxuXHQgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSAgICAgIEtleVxuXHQgICAgICogQHJldHVybiB7T3B0aW9uc01hbmFnZXJ9IFZhbHVlXG5cdCAgICAgKi9cblx0ICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiBrZXkoa2V5KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBPcHRpb25zTWFuYWdlcih0aGlzLl92YWx1ZVtrZXldKTtcblx0ICAgICAgICBpZiAoIShyZXN1bHQuX3ZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB8fCByZXN1bHQuX3ZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHJlc3VsdC5fdmFsdWUgPSB7fTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMb29rIHVwIG9wdGlvbnMgdmFsdWUgYnkga2V5IG9yIGdldCB0aGUgZnVsbCBvcHRpb25zIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRcblx0ICAgICAqIEBwYXJhbSBrZXkge3N0cmluZ30gIEtleVxuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgQXNzb2NpYXRlZCBvYmplY3Qgb3IgZnVsbCBvcHRpb25zIGhhc2hcblx0ICAgICAqL1xuXHQgICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcblx0ICAgICAgICByZXR1cm4ga2V5ID8gdGhpcy5fdmFsdWVba2V5XSA6IHRoaXMuX3ZhbHVlO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGlhcyBmb3IgZ2V0XG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRPcHRpb25zXG5cdCAgICAgKi9cblx0ICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5nZXRPcHRpb25zID0gT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmdldDtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXQga2V5IHRvIHZhbHVlLiBPdXRwdXRzIGBjaGFuZ2VgIGV2ZW50IGlmIGEgdmFsdWUgaXMgb3ZlcndyaXR0ZW4uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRcblx0ICAgICAqIEBwYXJhbSBrZXkge3N0cmluZ30gICAgICAgICAgS2V5XG5cdCAgICAgKiBAcGFyYW0gdmFsdWUge09iamVjdH0gICAgICAgIFZhbHVlXG5cdCAgICAgKiBAcmV0dXJuIHtPcHRpb25zTWFuYWdlcn0gICAgIFVwZGF0ZWQgT3B0aW9uc01hbmFnZXJcblx0ICAgICAqL1xuXHQgICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWUgPSB0aGlzLmdldChrZXkpO1xuXHQgICAgICAgIHRoaXMuX3ZhbHVlW2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICBpZiAodGhpcy5fZXZlbnRIYW5kbGVyICYmIHZhbHVlICE9PSBvcmlnaW5hbFZhbHVlKSB0aGlzLl9ldmVudEhhbmRsZXIuZW1pdCgnY2hhbmdlJywge2tleToga2V5LCB2YWx1ZTogdmFsdWV9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBhIGhhbmRsZXIgdG8gdGhlIGB0eXBlYCBjaGFubmVsIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb24gYGVtaXRgLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgXCJvblwiXG5cdCAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAgICAgICAgIENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSAgICBDYWxsYmFja1xuXHQgICAgICovXG5cdCAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbih0eXBlLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgX2NyZWF0ZUV2ZW50SGFuZGxlci5jYWxsKHRoaXMpO1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUub24uYXBwbHkodGhpcy5fZXZlbnRIYW5kbGVyLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIHRoZSBgaGFuZGxlcmAgZnJvbSB0aGUgYHR5cGVgIGNoYW5uZWwuXG5cdCAgICAgKiAgIFRoaXMgdW5kb2VzIHRoZSB3b3JrIG9mIGBvbmAuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBvZmZcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9ICAgICAgICAgQ2hhbm5lbCBuYW1lXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgIENhbGxiYWNrXG5cdCAgICAgKi9cblx0ICAgIE9wdGlvbnNNYW5hZ2VyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYodHlwZSwgaGFuZGxlcikge1xuXHQgICAgICAgIF9jcmVhdGVFdmVudEhhbmRsZXIuY2FsbCh0aGlzKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9mZi5hcHBseSh0aGlzLl9ldmVudEhhbmRsZXIsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBfY2xvbmUob2JqKSB7XG5cdCAgICAgICAgdmFyIGNvcHk7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgICAgIGNvcHkgPSAob2JqIGluc3RhbmNlb2YgQXJyYXkpID8gW10gOiB7fTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weVtrZXldW2ldID0gX2Nsb25lKHZhbHVlW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBjb3B5W2tleV0gPSBfY2xvbmUodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBjb3B5W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGNvcHkgPSBvYmo7XG5cblx0ICAgICAgICByZXR1cm4gY29weTtcblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zTWFuYWdlcjtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMzIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICAgICAgICBTdXJmYWNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSxcblx0ICAgICAgICBDb250YWluZXJTdXJmYWNlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSxcblx0ICAgICAgICBDb250ZXh0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxuXHQgICAgfTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IFNhbXNhcmEgSW5kdXN0cmllcywgSW5jLiAyMDE0XG5cdCAqL1xuXG5cdC8qIE1vZGlmaWVkIHdvcmsgY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFbGVtZW50T3V0cHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG5cdCAgICB2YXIgZGlydHlRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cblx0ICAgIHZhciBpc1RvdWNoRW5hYmxlZCA9IFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFN1cmZhY2UgaXMgYSB3cmFwcGVyIGZvciBhIERPTSBlbGVtZW50IGFuaW1hdGVkIGJ5IFNhbXNhcmEuXG5cdCAgICAgKiAgU2Ftc2FyYSB3aWxsIGNvbW1pdCBvcGFjaXR5LCBzaXplIGFuZCBDU1MzIGB0cmFuc2Zvcm1gIHByb3BlcnRpZXMgaW50byB0aGUgU3VyZmFjZS5cblx0ICAgICAqICBDU1MgY2xhc3NlcywgcHJvcGVydGllcyBhbmQgRE9NIGF0dHJpYnV0ZXMgY2FuIGFsc28gYmUgYWRkZWQgYW5kIGR5bmFtaWNhbGx5IGNoYW5nZWQuXG5cdCAgICAgKiAgU3VyZmFjZXMgYWxzbyBhY3QgYXMgc291cmNlcyBmb3IgRE9NIGV2ZW50cyBzdWNoIGFzIGBjbGlja2AuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQoKVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHN1cmZhY2UgPSBuZXcgU3VyZmFjZSh7XG5cdCAgICAgKiAgICAgICAgICBjb250ZW50IDogJ0hlbGxvIHdvcmxkIScsXG5cdCAgICAgKiAgICAgICAgICBzaXplIDogW3RydWUsMTAwXSxcblx0ICAgICAqICAgICAgICAgIG9wYWNpdHkgOiAuNSxcblx0ICAgICAqICAgICAgICAgIGNsYXNzZXMgOiBbJ215Q2xhc3MxJywgJ215Q2xhc3MyJ10sXG5cdCAgICAgKiAgICAgICAgICBwcm9wZXJ0aWVzIDoge2JhY2tncm91bmQgOiAncmVkJ31cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBjb250ZXh0LmFkZChzdXJmYWNlKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGNvbnRleHQubW91bnQoZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCBjcmVhdGUgYW4gaW1hZ2UgaW5zdGVhZFxuXHQgICAgICogICAgICB2YXIgc3VyZmFjZSA9IG5ldyBTdXJmYWNlKHtcblx0ICAgICAqICAgICAgICAgIGF0dHJpYnV0ZXMgOiB7XG5cdCAgICAgKiAgICAgICAgICAgICAgc3JjIDogJ2NhdC5qcGcnXG5cdCAgICAgKiAgICAgICAgICB9LFxuXHQgICAgICogICAgICAgICAgc2l6ZSA6IFsxMDAsMTAwXSxcblx0ICAgICAqICAgICAgICAgIHRhZ05hbWUgOiAnaW1nJ1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgU3VyZmFjZVxuXHQgICAgICogQG5hbWVzcGFjZSBET01cblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQGV4dGVuZHMgQ29yZS5FbGVtZW50T3V0cHV0XG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnNdIHtPYmplY3R9ICAgICAgICAgICAgICAgIE9wdGlvbnNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5zaXplXSB7TnVtYmVyW119ICAgICAgICAgU2l6ZSAod2lkdGgsIGhlaWdodCkgaW4gcGl4ZWxzLiBUaGVzZSBjYW4gYWxzbyBiZSBgdHJ1ZWAgb3IgYHVuZGVmaW5lZGAuXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMuY2xhc3Nlc10ge1N0cmluZ1tdfSAgICAgIENTUyBjbGFzc2VzXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMucHJvcGVydGllc10ge09iamVjdH0gICAgIERpY3Rpb25hcnkgb2YgQ1NTIHByb3BlcnRpZXNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5hdHRyaWJ1dGVzXSB7T2JqZWN0fSAgICAgRGljdGlvbmFyeSBvZiBIVE1MIGF0dHJpYnV0ZXNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5jb250ZW50XSBTc3RyaW5nfSAgICAgICAgSW5uZXJIVE1MIGNvbnRlbnRcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5vcmlnaW5dIHtOdW1iZXJbXX0gICAgICAgT3JpZ2luICh4LHkpLCB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDFcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5tYXJnaW5zXSB7TnVtYmVyW119ICAgICAgTWFyZ2lucyAoeCx5KSBpbiBwaXhlbHNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5wcm9wb3J0aW9uc10ge051bWJlcltdfSAgUHJvcG9ydGlvbnMgKHgseSkgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMuYXNwZWN0UmF0aW9dIHtOdW1iZXJ9ICAgIEFzcGVjdCByYXRpb1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLm9wYWNpdHk9MV0ge051bWJlcn0gICAgICBPcGFjaXR5XG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMudGFnTmFtZT1cImRpdlwiXSB7U3RyaW5nfSAgSFRNTCB0YWdOYW1lXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMuZW5hYmxlU2Nyb2xsXSB7Qm9vbGVhbn0gIEFsbG93cyBhIFN1cmZhY2UgdG8gc3VwcG9ydCBuYXRpdmUgc2Nyb2xsIGJlaGF2aW9yXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIFN1cmZhY2Uob3B0aW9ucykge1xuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuXHQgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXHQgICAgICAgIHRoaXMuY29udGVudCA9ICcnO1xuXHQgICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gW107XG5cblx0ICAgICAgICB0aGlzLl9jb250ZW50RGlydHkgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuX2RpcnR5Q2xhc3NlcyA9IFtdO1xuXHQgICAgICAgIHRoaXMuX2NsYXNzZXNEaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5fc3R5bGVzRGlydHkgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNEaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLl9jYWNoZWRTaXplID0gbnVsbDtcblxuXHQgICAgICAgIGlmIChvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gRE9NIHNpemUgZm9yIHByb3ZpZGVkIGVsZW1lbnRzXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmVsICYmICFvcHRpb25zLnNpemUpe1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY29udGVudERpcnR5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnNpemUgPSBbdHJ1ZSwgdHJ1ZV07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBFbGVtZW50T3V0cHV0LmNhbGwodGhpcywgb3B0aW9ucy5lbCk7XG5cdCAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBFbGVtZW50T3V0cHV0LmNhbGwodGhpcyk7XG5cdCAgICB9XG5cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbGVtZW50T3V0cHV0LnByb3RvdHlwZSk7XG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1cmZhY2U7XG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5lbGVtZW50VHlwZSA9ICdkaXYnOyAvLyBEZWZhdWx0IHRhZ05hbWUuIENhbiBiZSBvdmVycmlkZGVuIGluIG9wdGlvbnMuXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSAnc2Ftc2FyYS1zdXJmYWNlJztcblxuXHQgICAgZnVuY3Rpb24gX3NldERpcnR5KCl7XG5cdCAgICAgICAgaWYgKHRoaXMuX2RpcnR5IHx8ICF0aGlzLl9jdXJyZW50VGFyZ2V0KSByZXR1cm47XG5cblx0ICAgICAgICBkaXJ0eVF1ZXVlLnB1c2goZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2NsYXNzZXNEaXJ0eSkge1xuXHQgICAgICAgICAgICAgICAgX3JlbW92ZUNsYXNzZXMuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgX2FwcGx5Q2xhc3Nlcy5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzRGlydHkpIF9hcHBseVByb3BlcnRpZXMuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzRGlydHkpIF9hcHBseUF0dHJpYnV0ZXMuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9jb250ZW50RGlydHkpIHRoaXMuZGVwbG95KHRhcmdldCk7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIF9hcHBseUNsYXNzZXModGFyZ2V0KSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsYXNzTGlzdC5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc0xpc3RbaV0pO1xuXHQgICAgICAgIHRoaXMuX2NsYXNzZXNEaXJ0eSA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfYXBwbHlQcm9wZXJ0aWVzKHRhcmdldCkge1xuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BlcnRpZXMpXG5cdCAgICAgICAgICAgIHRhcmdldC5zdHlsZVtrZXldID0gdGhpcy5wcm9wZXJ0aWVzW2tleV07XG5cdCAgICAgICAgdGhpcy5fc3R5bGVzRGlydHkgPSBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX2FwcGx5QXR0cmlidXRlcyh0YXJnZXQpIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKVxuXHQgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKGtleSwgdGhpcy5hdHRyaWJ1dGVzW2tleV0pO1xuXHQgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNEaXJ0eSA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfcmVtb3ZlQ2xhc3Nlcyh0YXJnZXQpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RpcnR5Q2xhc3Nlcy5sZW5ndGg7IGkrKykgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fZGlydHlDbGFzc2VzW2ldKTtcblx0ICAgICAgICB0aGlzLl9kaXJ0eUNsYXNzZXMgPSBbXTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX3JlbW92ZVByb3BlcnRpZXModGFyZ2V0KSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcGVydGllcylcblx0ICAgICAgICAgICAgdGFyZ2V0LnN0eWxlW2tleV0gPSAnJztcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZXModGFyZ2V0KSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXR0cmlidXRlcylcblx0ICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwcmV2ZW50RHJhZygpe1xuXHQgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KXtcblx0ICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIH0sIGZhbHNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRoaXMub24oJ2RlcGxveScsIGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZW5hYmxlU2Nyb2xsKCl7XG5cdCAgICAgICAgdGhpcy5hZGRDbGFzcygnc2Ftc2FyYS1zY3JvbGxhYmxlJyk7XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIC8qKlxuXHQgICAgICogU2V0dGVyIGZvciBIVE1MIGF0dHJpYnV0ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRBdHRyaWJ1dGVzXG5cdCAgICAgKiBAY2hhaW5hYmxlXG5cdCAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyB7T2JqZWN0fSAgIEhUTUwgQXR0cmlidXRlc1xuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgIT0gdW5kZWZpbmVkKSB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fYXR0cmlidXRlc0RpcnR5ID0gdHJ1ZTtcblx0ICAgICAgICBfc2V0RGlydHkuY2FsbCh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0dGVyIGZvciBIVE1MIGF0dHJpYnV0ZXMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRBdHRyaWJ1dGVzXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldHRlciBmb3IgQ1NTIHByb3BlcnRpZXMuXG5cdCAgICAgKiAgTm90ZTogcHJvcGVydGllcyBhcmUgY2FtZWxDYXNlZCwgbm90IGh5cGhlbmF0ZWQuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRQcm9wZXJ0aWVzXG5cdCAgICAgKiBAY2hhaW5hYmxlXG5cdCAgICAgKiBAcGFyYW0gcHJvcGVydGllcyB7T2JqZWN0fSAgIENTUyBwcm9wZXJ0aWVzXG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcylcblx0ICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzW2tleV0gPSBwcm9wZXJ0aWVzW2tleV07XG5cdCAgICAgICAgdGhpcy5fc3R5bGVzRGlydHkgPSB0cnVlO1xuXHQgICAgICAgIF9zZXREaXJ0eS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBHZXR0ZXIgZm9yIENTUyBwcm9wZXJ0aWVzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0UHJvcGVydGllc1xuXHQgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICBEaWN0aW9uYXJ5IG9mIHRoaXMgU3VyZmFjZSdzIHByb3BlcnRpZXMuXG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLmdldFByb3BlcnRpZXMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFkZCBDU1MgY2xhc3MgdG8gdGhlIGxpc3Qgb2YgY2xhc3NlcyBvbiB0aGlzIFN1cmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBhZGRDbGFzc1xuXHQgICAgICogQGNoYWluYWJsZVxuXHQgICAgICogQHBhcmFtIGNsYXNzTmFtZSB7U3RyaW5nfSAgICBDbGFzcyBuYW1lXG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuY2xhc3NMaXN0LmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QucHVzaChjbGFzc05hbWUpO1xuXHQgICAgICAgICAgICB0aGlzLl9jbGFzc2VzRGlydHkgPSB0cnVlO1xuXHQgICAgICAgICAgICBfc2V0RGlydHkuY2FsbCh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlbW92ZSBDU1MgY2xhc3MgZnJvbSB0aGUgbGlzdCBvZiBjbGFzc2VzIG9uIHRoaXMgU3VyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJlbW92ZUNsYXNzXG5cdCAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIHtzdHJpbmd9ICAgIENsYXNzIG5hbWVcblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHtcblx0ICAgICAgICB2YXIgaSA9IHRoaXMuY2xhc3NMaXN0LmluZGV4T2YoY2xhc3NOYW1lKTtcblx0ICAgICAgICBpZiAoaSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RpcnR5Q2xhc3Nlcy5wdXNoKHRoaXMuY2xhc3NMaXN0LnNwbGljZShpLCAxKVswXSk7XG5cdCAgICAgICAgICAgIHRoaXMuX2NsYXNzZXNEaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgICAgIF9zZXREaXJ0eS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVG9nZ2xlIENTUyBjbGFzcyBmb3IgdGhpcyBTdXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdG9nZ2xlQ2xhc3Ncblx0ICAgICAqIEBwYXJhbSAgY2xhc3NOYW1lIHtTdHJpbmd9ICAgQ2xhc3MgbmFtZVxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGNsYXNzTmFtZSkge1xuXHQgICAgICAgIHZhciBpID0gdGhpcy5jbGFzc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpO1xuXHQgICAgICAgIChpID09IC0xKVxuXHQgICAgICAgICAgICA/IHRoaXMuYWRkQ2xhc3MoY2xhc3NOYW1lKVxuXHQgICAgICAgICAgICA6IHRoaXMucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVzZXQgY2xhc3NsaXN0LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0Q2xhc3Nlc1xuXHQgICAgICogQGNoYWluYWJsZVxuXHQgICAgICogQHBhcmFtIGNsYXNzbGlzdCB7U3RyaW5nW119ICBDbGFzc0xpc3Rcblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIHNldENsYXNzZXMoY2xhc3NMaXN0KSB7XG5cdCAgICAgICAgdmFyIHJlbW92YWwgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChjbGFzc0xpc3QuaW5kZXhPZih0aGlzLmNsYXNzTGlzdFtpXSkgPCAwKSByZW1vdmFsLnB1c2godGhpcy5jbGFzc0xpc3RbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3ZhbC5sZW5ndGg7IGkrKykgdGhpcy5yZW1vdmVDbGFzcyhyZW1vdmFsW2ldKTtcblx0ICAgICAgICAvLyBkdXBsaWNhdGVzIGFyZSBhbHJlYWR5IGNoZWNrZWQgYnkgYWRkQ2xhc3MoKVxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHRoaXMuYWRkQ2xhc3MoY2xhc3NMaXN0W2ldKTtcblx0ICAgICAgICBfc2V0RGlydHkuY2FsbCh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogR2V0IGFycmF5IG9mIENTUyBjbGFzc2VzIGF0dGFjaGVkIHRvIHRoaXMgU3VyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGdldENsYXNzbGlzdFxuXHQgICAgICogQHJldHVybiB7U3RyaW5nW119XG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLmdldENsYXNzTGlzdCA9IGZ1bmN0aW9uIGdldENsYXNzTGlzdCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0xpc3Q7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldCBvciBvdmVyd3JpdGUgaW5uZXJIVE1MIGNvbnRlbnQgb2YgdGhpcyBTdXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0Q29udGVudFxuXHQgICAgICogQGNoYWluYWJsZVxuXHQgICAgICogQHBhcmFtIGNvbnRlbnQge1N0cmluZ3xEb2N1bWVudEZyYWdtZW50fSBIVE1MIGNvbnRlbnRcblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCkge1xuXHQgICAgICAgIGlmICh0aGlzLmNvbnRlbnQgIT09IGNvbnRlbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcblx0ICAgICAgICAgICAgdGhpcy5fY29udGVudERpcnR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgX3NldERpcnR5LmNhbGwodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm4gaW5uZXJIVE1MIGNvbnRlbnQgb2YgdGhpcyBTdXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0Q29udGVudFxuXHQgICAgICogQHJldHVybiB7U3RyaW5nfVxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5nZXRDb250ZW50ID0gZnVuY3Rpb24gZ2V0Q29udGVudCgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXQgb3B0aW9ucyBmb3IgdGhpcyBzdXJmYWNlXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRPcHRpb25zXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPdmVycmlkZXMgZm9yIGRlZmF1bHQgb3B0aW9ucy4gU2VlIGNvbnN0cnVjdG9yLlxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMudGFnTmFtZSAhPT0gdW5kZWZpbmVkKSB0aGlzLmVsZW1lbnRUeXBlID0gb3B0aW9ucy50YWdOYW1lO1xuXHQgICAgICAgIGlmIChvcHRpb25zLm9wYWNpdHkgIT09IHVuZGVmaW5lZCkgdGhpcy5zZXRPcGFjaXR5KG9wdGlvbnMub3BhY2l0eSk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkKSB0aGlzLnNldFNpemUob3B0aW9ucy5zaXplKTtcblx0ICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW4gIT09IHVuZGVmaW5lZCkgdGhpcy5zZXRPcmlnaW4ob3B0aW9ucy5vcmlnaW4pO1xuXHQgICAgICAgIGlmIChvcHRpb25zLnByb3BvcnRpb25zICE9PSB1bmRlZmluZWQpIHRoaXMuc2V0UHJvcG9ydGlvbnMob3B0aW9ucy5wcm9wb3J0aW9ucyk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMubWFyZ2lucyAhPT0gdW5kZWZpbmVkKSB0aGlzLnNldE1hcmdpbnMob3B0aW9ucy5tYXJnaW5zKTtcblx0ICAgICAgICBpZiAob3B0aW9ucy5jbGFzc2VzICE9PSB1bmRlZmluZWQpIHRoaXMuc2V0Q2xhc3NlcyhvcHRpb25zLmNsYXNzZXMpO1xuXHQgICAgICAgIGlmIChvcHRpb25zLnByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkgdGhpcy5zZXRQcm9wZXJ0aWVzKG9wdGlvbnMucHJvcGVydGllcyk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB0aGlzLnNldEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcblx0ICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50ICE9PSB1bmRlZmluZWQpIHRoaXMuc2V0Q29udGVudChvcHRpb25zLmNvbnRlbnQpO1xuXHQgICAgICAgIGlmIChvcHRpb25zLmFzcGVjdFJhdGlvICE9PSB1bmRlZmluZWQpIHRoaXMuc2V0QXNwZWN0UmF0aW8ob3B0aW9ucy5hc3BlY3RSYXRpbyk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlU2Nyb2xsKSBlbmFibGVTY3JvbGwuY2FsbCh0aGlzKTtcblx0ICAgICAgICBlbHNlIGlmIChpc1RvdWNoRW5hYmxlZCkgcHJldmVudERyYWcuY2FsbCh0aGlzKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxsb2NhdGVzIHRoZSBlbGVtZW50LXR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdXJmYWNlLCBhZGRzIGl0cyBnaXZlblxuXHQgICAgICogIGVsZW1lbnQgY2xhc3NlcywgYW5kIHByZXBhcmVzIGl0IGZvciBmdXR1cmUgY29tbWl0dGluZy5cblx0ICAgICAqXG5cdCAgICAgKiAgVGhpcyBtZXRob2QgaXMgY2FsbGVkIHVwb24gdGhlIGZpcnN0IGBzdGFydGAgb3IgYHJlc2l6ZWBcblx0ICAgICAqICBldmVudCB0aGUgU3VyZmFjZSBnZXRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAbWV0aG9kIHNldHVwXG5cdCAgICAgKiBAcGFyYW0gYWxsb2NhdG9yIHtFbGVtZW50QWxsb2NhdG9yfSBBbGxvY2F0b3Jcblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChhbGxvY2F0b3IpIHtcblx0ICAgICAgICAvLyBjcmVhdGUgZWxlbWVudCBvZiBzcGVjaWZpYyB0eXBlXG5cdCAgICAgICAgdmFyIHRhcmdldCA9IGFsbG9jYXRvci5hbGxvY2F0ZSh0aGlzLmVsZW1lbnRUeXBlKTtcblxuXHQgICAgICAgIC8vIGFkZCBhbnkgZWxlbWVudCBjbGFzc2VzXG5cdCAgICAgICAgaWYgKHRoaXMuZWxlbWVudENsYXNzKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRDbGFzcyBpbnN0YW5jZW9mIEFycmF5KVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRDbGFzcy5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZENsYXNzKHRoaXMuZWxlbWVudENsYXNzW2ldKTtcblx0ICAgICAgICAgICAgZWxzZSB0aGlzLmFkZENsYXNzKHRoaXMuZWxlbWVudENsYXNzKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBzZXQgdGhlIGN1cnJlbnRUYXJnZXQgYW5kIGFueSBib3VuZCBsaXN0ZW5lcnNcblx0ICAgICAgICB0aGlzLmF0dGFjaCh0YXJnZXQpO1xuXG5cdCAgICAgICAgX2FwcGx5Q2xhc3Nlcy5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdCAgICAgICAgX2FwcGx5UHJvcGVydGllcy5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdCAgICAgICAgX2FwcGx5QXR0cmlidXRlcy5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdCAgICAgICAgdGhpcy5kZXBsb3kodGFyZ2V0KTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVtb3ZlIGFsbCBTYW1zYXJhLXJlbGV2YW50IGRhdGEgZnJvbSB0aGUgU3VyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQG1ldGhvZCByZW1vdmVcblx0ICAgICAqIEBwYXJhbSBhbGxvY2F0b3Ige0VsZW1lbnRBbGxvY2F0b3J9IEFsbG9jYXRvclxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoYWxsb2NhdG9yKSB7XG5cdCAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG5cblx0ICAgICAgICAvLyBjYWNoZSB0aGUgdGFyZ2V0J3MgY29udGVudHMgZm9yIGxhdGVyIGRlcGxveW1lbnRcblx0ICAgICAgICB0aGlzLnJlY2FsbCh0YXJnZXQpO1xuXG5cdCAgICAgICAgLy8gaGlkZSB0aGUgZWxlbWVudFxuXHQgICAgICAgIHRhcmdldC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHQgICAgICAgIHRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJyc7XG5cdCAgICAgICAgdGFyZ2V0LnN0eWxlLndpZHRoID0gJyc7XG5cdCAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICcnO1xuXG5cdCAgICAgICAgLy8gY2xlYXIgYWxsIHN0eWxlcywgY2xhc3NlcyBhbmQgYXR0cmlidXRlc1xuXHQgICAgICAgIF9yZW1vdmVQcm9wZXJ0aWVzLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0ICAgICAgICBfcmVtb3ZlQXR0cmlidXRlcy5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdCAgICAgICAgX3JlbW92ZUNsYXNzZXMuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXG5cdCAgICAgICAgLy8gZ2FyYmFnZSBjb2xsZWN0IGN1cnJlbnQgdGFyZ2V0IGFuZCByZW1vdmUgYm91bmQgZXZlbnQgbGlzdGVuZXJzXG5cdCAgICAgICAgdGhpcy5kZXRhY2goKTtcblxuXHQgICAgICAgIC8vIHN0b3JlIGFsbG9jYXRlZCBub2RlIGluIGNhY2hlIGZvciByZWN5Y2xpbmdcblx0ICAgICAgICBhbGxvY2F0b3IuZGVhbGxvY2F0ZSh0YXJnZXQpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBJbnNlcnQgdGhlIFN1cmZhY2UncyBjb250ZW50IGludG8gdGhlIGN1cnJlbnRUYXJnZXQuXG5cdCAgICAgKlxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBtZXRob2QgZGVwbG95XG5cdCAgICAgKiBAcGFyYW0gdGFyZ2V0IHtOb2RlfSBET00gZWxlbWVudCB0byBzZXQgY29udGVudCBpbnRvXG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSh0YXJnZXQpIHtcblx0ICAgICAgICAvL1RPRE86IG1ha2Ugc3VyZSB0YXJnZXQudGFnTmFtZSBpcyBvZiBjb3JyZWN0IHR5cGUhIFRhZyBwb29scyBtdXN0IGJlIGltcGxlbWVudGVkLlxuXHQgICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG5cdCAgICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKTtcblx0ICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIE5vZGUpIHtcblx0ICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5oYXNDaGlsZE5vZGVzKCkpIHRhcmdldC5yZW1vdmVDaGlsZCh0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdCAgICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChjb250ZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB0YXJnZXQuaW5uZXJIVE1MID0gY29udGVudDtcblxuXHQgICAgICAgIHRoaXMuX2NvbnRlbnREaXJ0eSA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ2RlcGxveScsIHRhcmdldCk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIENhY2hlIHRoZSBjb250ZW50IG9mIHRoZSBTdXJmYWNlIGluIGEgZG9jdW1lbnQgZnJhZ21lbnQgZm9yIGZ1dHVyZSBkZXBsb3ltZW50LlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAbWV0aG9kIHJlY2FsbFxuXHQgICAgICogQHBhcmFtIHRhcmdldCB7Tm9kZX1cblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24gcmVjYWxsKHRhcmdldCkge1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ3JlY2FsbCcpO1xuXHQgICAgICAgIHZhciBkZiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0ICAgICAgICB3aGlsZSAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkgZGYuYXBwZW5kQ2hpbGQodGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHQgICAgICAgIHRoaXMuc2V0Q29udGVudChkZik7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldHRlciBmb3Igc2l6ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGdldFNpemVcblx0ICAgICAqIEByZXR1cm4ge051bWJlcltdfVxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcblx0ICAgICAgICAvLyBUT0RPOiByZW1vdmUgY2FjaGVkU2l6ZVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRTcGVjLnNpemUgfHwgdGhpcy5fY2FjaGVkU2l6ZTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2V0dGVyIGZvciBzaXplLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0U2l6ZVxuXHQgICAgICogQHBhcmFtIHNpemUge051bWJlcltdfFN0cmVhbX0gU2l6ZSBhcyBbd2lkdGgsIGhlaWdodF0gaW4gcGl4ZWxzLCBvciBhIHN0cmVhbS5cblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUoc2l6ZSkge1xuXHQgICAgICAgIHRoaXMuX2NhY2hlZFNpemUgPSBzaXplO1xuXHQgICAgICAgIHRoaXMuX3NpemVOb2RlLnNldCh7c2l6ZSA6IHNpemV9KTtcblx0ICAgICAgICBfc2V0RGlydHkuY2FsbCh0aGlzKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2V0dGVyIGZvciBwcm9wb3J0aW9ucy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldFByb3BvcnRpb25zXG5cdCAgICAgKiBAcGFyYW0gcHJvcG9ydGlvbnMge051bWJlcltdfFN0cmVhbX0gUHJvcG9ydGlvbnMgYXMgW3gseV0sIG9yIGEgc3RyZWFtLlxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9ucyA9IGZ1bmN0aW9uIHNldFByb3BvcnRpb25zKHByb3BvcnRpb25zKSB7XG5cdCAgICAgICAgdGhpcy5fc2l6ZU5vZGUuc2V0KHtwcm9wb3J0aW9ucyA6IHByb3BvcnRpb25zfSk7XG5cdCAgICAgICAgX3NldERpcnR5LmNhbGwodGhpcyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldHRlciBmb3IgbWFyZ2lucy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldE1hcmdpbnNcblx0ICAgICAqIEBwYXJhbSBtYXJnaW5zIHtOdW1iZXJbXXxTdHJlYW19IE1hcmdpbnMgYXMgW3dpZHRoLCBoZWlnaHRdIGluIHBpeGVscywgb3IgYSBzdHJlYW0uXG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLnNldE1hcmdpbnMgPSBmdW5jdGlvbiBzZXRNYXJnaW5zKG1hcmdpbnMpIHtcblx0ICAgICAgICB0aGlzLl9zaXplTm9kZS5zZXQoe21hcmdpbnMgOiBtYXJnaW5zfSk7XG5cdCAgICAgICAgX3NldERpcnR5LmNhbGwodGhpcyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldHRlciBmb3IgYXNwZWN0IHJhdGlvLiBJZiBvbmx5IG9uZSBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc3BlY2lmaWVkLFxuXHQgICAgICogIHRoZSBhc3BlY3QgcmF0aW8gd2lsbCByZXBsYWNlIHRoZSB1bnNwZWNpZmllZCBkaW1lbnNpb24gYnkgc2NhbGluZ1xuXHQgICAgICogIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uIGJ5IHRoZSB2YWx1ZSBwcm92aWRlZC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldEFzcGVjdFJhdGlvXG5cdCAgICAgKiBAcGFyYW0gYXNwZWN0UmF0aW8ge051bWJlcnxTdHJlYW19IEFzcGVjdCByYXRpby5cblx0ICAgICAqL1xuXHQgICAgU3VyZmFjZS5wcm90b3R5cGUuc2V0QXNwZWN0UmF0aW8gPSBmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbykge1xuXHQgICAgICAgIHRoaXMuX3NpemVOb2RlLnNldCh7YXNwZWN0UmF0aW8gOiBhc3BlY3RSYXRpb30pO1xuXHQgICAgICAgIF9zZXREaXJ0eS5jYWxsKHRoaXMpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXR0ZXIgZm9yIG9yaWdpbi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldE9yaWdpblxuXHQgICAgICogQHBhcmFtIG9yaWdpbiB7TnVtYmVyW118U3RyZWFtfSBPcmlnaW4gYXMgW3gseV0sIG9yIGEgc3RyZWFtLlxuXHQgICAgICovXG5cdCAgICBTdXJmYWNlLnByb3RvdHlwZS5zZXRPcmlnaW4gPSBmdW5jdGlvbiBzZXRPcmlnaW4ob3JpZ2luKXtcblx0ICAgICAgICB0aGlzLl9sYXlvdXROb2RlLnNldCh7b3JpZ2luIDogb3JpZ2lufSk7XG5cdCAgICAgICAgdGhpcy5fb3JpZ2luRGlydHkgPSB0cnVlO1xuXHQgICAgICAgIF9zZXREaXJ0eS5jYWxsKHRoaXMpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTZXR0ZXIgZm9yIG9wYWNpdHkuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRPcGFjaXR5XG5cdCAgICAgKiBAcGFyYW0gb3BhY2l0eSB7TnVtYmVyfSBPcGFjaXR5XG5cdCAgICAgKi9cblx0ICAgIFN1cmZhY2UucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiBzZXRPcGFjaXR5KG9wYWNpdHkpe1xuXHQgICAgICAgIHRoaXMuX2xheW91dE5vZGUuc2V0KHtvcGFjaXR5IDogb3BhY2l0eX0pO1xuXHQgICAgICAgIHRoaXMuX29wYWNpdHlEaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgX3NldERpcnR5LmNhbGwodGhpcyk7XG5cdCAgICB9O1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFN1cmZhY2U7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDM0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuXHQgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG5cdCAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cdCAqXG5cdCAqIEBsaWNlbnNlIE1QTCAyLjBcblx0ICogQGNvcHlyaWdodCBGYW1vdXMgSW5kdXN0cmllcywgSW5jLiAyMDE0XG5cdCAqL1xuXG5cdC8qIE1vZGlmaWVkIHdvcmsgY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHQgICAgdmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHQgICAgdmFyIFJlc2l6ZVN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXHQgICAgdmFyIFNpemVOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdCAgICB2YXIgTGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdCAgICB2YXIgc2l6ZUFsZ2VicmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblx0ICAgIHZhciBsYXlvdXRBbGdlYnJhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cblx0ICAgIHZhciB1c2VQcmVmaXggPSAhKCd0cmFuc2Zvcm0nIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG5cdCAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdCAgICB2YXIgaW52RGV2aWNlUGl4ZWxSYXRpbyA9IDEgLyBkZXZpY2VQaXhlbFJhdGlvO1xuXHQgICAgdmFyIE1JTl9PUEFDSVRZID0gMC4wMDAxO1xuXHQgICAgdmFyIE1BWF9PUEFDSVRZID0gMC45OTk5O1xuXHQgICAgdmFyIEVQU0lMT04gPSAxZS01O1xuXHQgICAgdmFyIF96ZXJvWmVybyA9IFswLDBdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJlc3BvbnNpYmxlIGZvciBjb21taXR0aW5nIENTUzMgcHJvcGVydGllcyB0byB0aGUgRE9NIGFuZCBwcm92aWRpbmcgRE9NIGV2ZW50IGhvb2tzXG5cdCAgICAgKiAgZnJvbSBhIHByb3ZpZGVkIERPTSBlbGVtZW50LiBXaGVyZSBTdXJmYWNlJ3MgQVBJIGhhbmRsZXMgaW5wdXRzIGZyb20gdGhlIGRldmVsb3BlclxuXHQgICAgICogIGZyb20gd2l0aGluIFNhbXNhcmEsIEVsZW1lbnRPdXRwdXQgaGFuZGxlcyB0aGUgRE9NIGludGVyYWN0aW9uIGxheWVyLlxuXHQgICAgICpcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgRWxlbWVudE91dHB1dFxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAbmFtZXNwYWNlIENvcmVcblx0ICAgICAqIEB1c2VzIENvcmUuTGF5b3V0Tm9kZVxuXHQgICAgICogQHVzZXMgQ29yZS5TaXplTm9kZVxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxlbWVudCBkb2N1bWVudCBwYXJlbnQgb2YgdGhpcyBjb250YWluZXJcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gRWxlbWVudE91dHB1dChlbGVtZW50KSB7XG5cdCAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XG5cblx0ICAgICAgICB0aGlzLl9jYWNoZWRTcGVjID0ge1xuXHQgICAgICAgICAgICB0cmFuc2Zvcm0gOiBudWxsLFxuXHQgICAgICAgICAgICBvcGFjaXR5IDogMSxcblx0ICAgICAgICAgICAgb3JpZ2luIDogbnVsbCxcblx0ICAgICAgICAgICAgc2l6ZSA6IG51bGxcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRPdXRwdXQpO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRGb3J3YXJkZXIgPSBmdW5jdGlvbiBfZXZlbnRGb3J3YXJkZXIoZXZlbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdChldmVudC50eXBlLCBldmVudCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG5cdCAgICAgICAgdGhpcy5fc2l6ZU5vZGUgPSBuZXcgU2l6ZU5vZGUoKTtcblx0ICAgICAgICB0aGlzLl9sYXlvdXROb2RlID0gbmV3IExheW91dE5vZGUoKTtcblxuXHQgICAgICAgIHRoaXMuX3NpemUgPSBuZXcgRXZlbnRIYW5kbGVyKCk7XG5cdCAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG5cdCAgICAgICAgdGhpcy5zaXplID0gUmVzaXplU3RyZWFtLmxpZnQoZnVuY3Rpb24gZWxlbWVudFNpemVMaWZ0KHNpemVTcGVjLCBwYXJlbnRTaXplKXtcblx0ICAgICAgICAgICAgaWYgKCFwYXJlbnRTaXplKSByZXR1cm4gZmFsc2U7IC8vIG9jY3VycyB3aGVuIHN1cmZhY2UgaXMgbmV2ZXIgYWRkZWRcblx0ICAgICAgICAgICAgcmV0dXJuIHNpemVBbGdlYnJhKHNpemVTcGVjLCBwYXJlbnRTaXplKTtcblx0ICAgICAgICB9LCBbdGhpcy5fc2l6ZU5vZGUsIHRoaXMuX3NpemVdKTtcblxuXHQgICAgICAgIHRoaXMubGF5b3V0ID0gU3RyZWFtLmxpZnQoZnVuY3Rpb24ocGFyZW50U3BlYywgb2JqZWN0U3BlYywgc2l6ZSl7XG5cdCAgICAgICAgICAgIGlmICghcGFyZW50U3BlYyB8fCAhc2l6ZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICByZXR1cm4gKG9iamVjdFNwZWMpXG5cdCAgICAgICAgICAgICAgICA/IGxheW91dEFsZ2VicmEob2JqZWN0U3BlYywgcGFyZW50U3BlYywgc2l6ZSlcblx0ICAgICAgICAgICAgICAgIDogcGFyZW50U3BlYztcblx0ICAgICAgICB9LCBbdGhpcy5fbGF5b3V0LCB0aGlzLl9sYXlvdXROb2RlLCB0aGlzLnNpemVdKTtcblxuXHQgICAgICAgIHRoaXMubGF5b3V0Lm9uKCdzdGFydCcsIGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudFRhcmdldCl7XG5cdCAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX2dldFJvb3QoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0dXAocm9vdC5hbGxvY2F0b3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMubGF5b3V0Lm9uKCd1cGRhdGUnLCBjb21taXRMYXlvdXQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5sYXlvdXQub24oJ2VuZCcsIGNvbW1pdExheW91dC5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMuc2l6ZS5vbigncmVzaXplJywgZnVuY3Rpb24oc2l6ZSl7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudFRhcmdldCl7XG5cdCAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX2dldFJvb3QoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2V0dXAocm9vdC5hbGxvY2F0b3IpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNvbW1pdFNpemUuY2FsbCh0aGlzLCBzaXplKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXG5cdCAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XG5cblx0ICAgICAgICB0aGlzLl9vcGFjaXR5RGlydHkgPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuX29yaWdpbkRpcnR5ID0gdHJ1ZTtcblx0ICAgICAgICB0aGlzLl90cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgdGhpcy5faXNWaXNpYmxlID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChlbGVtZW50KSB0aGlzLmF0dGFjaChlbGVtZW50KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5fZXZlbnRPdXRwdXQubGlzdGVuZXJzKVxuXHQgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihpLCB0aGlzLl9ldmVudEZvcndhcmRlcik7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQpIHtcblx0ICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuX2V2ZW50T3V0cHV0Lmxpc3RlbmVycylcblx0ICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaSwgdGhpcy5fZXZlbnRGb3J3YXJkZXIpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfZm9ybWF0Q1NTVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSAnbWF0cml4M2QoJztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRyYW5zZm9ybVtpXSkgPCBFUFNJTE9OKSB0cmFuc2Zvcm1baV0gPSAwO1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gKGkgPT09IDEyIHx8IGkgPT09IDEzKVxuXHQgICAgICAgICAgICAgICAgPyBNYXRoLnJvdW5kKHRyYW5zZm9ybVtpXSAqIGRldmljZVBpeGVsUmF0aW8pICogaW52RGV2aWNlUGl4ZWxSYXRpbyArICcsJ1xuXHQgICAgICAgICAgICAgICAgOiB0cmFuc2Zvcm1baV0gKyAnLCc7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQgKyB0cmFuc2Zvcm1bMTVdICsgJyknO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfZm9ybWF0Q1NTT3JpZ2luKG9yaWdpbikge1xuXHQgICAgICAgIHJldHVybiAoMTAwICogb3JpZ2luWzBdKSArICclICcgKyAoMTAwICogb3JpZ2luWzFdKSArICclJztcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX3h5Tm90RXF1YWxzKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gKGEgJiYgYikgPyAoYVswXSAhPT0gYlswXSB8fCBhWzFdICE9PSBiWzFdKSA6IGEgIT09IGI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBfc2V0T3JpZ2luID0gdXNlUHJlZml4XG5cdCAgICAgICAgPyBmdW5jdGlvbiBfc2V0T3JpZ2luKGVsZW1lbnQsIG9yaWdpbikge1xuXHQgICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gX2Zvcm1hdENTU09yaWdpbihvcmlnaW4pO1xuXHQgICAgfVxuXHQgICAgICAgIDogZnVuY3Rpb24gX3NldE9yaWdpbihlbGVtZW50LCBvcmlnaW4pIHtcblx0ICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IF9mb3JtYXRDU1NPcmlnaW4ob3JpZ2luKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBfc2V0VHJhbnNmb3JtID0gKHVzZVByZWZpeClcblx0ICAgICAgICA/IGZ1bmN0aW9uIF9zZXRUcmFuc2Zvcm0oZWxlbWVudCwgdHJhbnNmb3JtKSB7XG5cdCAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBfZm9ybWF0Q1NTVHJhbnNmb3JtKHRyYW5zZm9ybSk7XG5cdCAgICB9XG5cdCAgICAgICAgOiBmdW5jdGlvbiBfc2V0VHJhbnNmb3JtKGVsZW1lbnQsIG1hdHJpeCkge1xuXHQgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gX2Zvcm1hdENTU1RyYW5zZm9ybShtYXRyaXgpO1xuXHQgICAgfTtcblxuXHQgICAgdmFyIF9zZXRTaXplID0gZnVuY3Rpb24gX3NldFNpemUodGFyZ2V0LCBzaXplKXtcblx0ICAgICAgICBpZiAoc2l6ZVswXSA9PT0gdHJ1ZSkgc2l6ZVswXSA9IHRhcmdldC5vZmZzZXRXaWR0aDtcblx0ICAgICAgICBlbHNlIHRhcmdldC5zdHlsZS53aWR0aCA9IE1hdGguY2VpbChzaXplWzBdICogZGV2aWNlUGl4ZWxSYXRpbykgKiBpbnZEZXZpY2VQaXhlbFJhdGlvICsgJ3B4JztcblxuXHQgICAgICAgIGlmIChzaXplWzFdID09PSB0cnVlKSBzaXplWzFdID0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcblx0ICAgICAgICBlbHNlIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBNYXRoLmNlaWwoc2l6ZVsxXSAqIGRldmljZVBpeGVsUmF0aW8pICogaW52RGV2aWNlUGl4ZWxSYXRpbyArICdweCc7XG5cdCAgICB9O1xuXG5cdCAgICAvLyB7VmlzaWJpbGl0eSA6IGhpZGRlbn0gYWxsb3dzIGZvciBET00gZXZlbnRzIHRvIHBhc3MgdGhyb3VnaCB0aGUgZWxlbWVudFxuXHQgICAgLy8gVE9ETzogdXNlIHBvaW50ZXJFdmVudHMgaW5zdGVhZC4gSG93ZXZlciwgdGhlcmUgaXMgYSBidWcgaW4gQ2hyb21lIGZvciBBbmRyb2lkXG5cdCAgICAvLyB0aWNrZXQgaGVyZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU2OTY1NFxuXHQgICAgdmFyIF9zZXRPcGFjaXR5ID0gZnVuY3Rpb24gX3NldE9wYWNpdHkoZWxlbWVudCwgb3BhY2l0eSkge1xuXHQgICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlICYmIG9wYWNpdHkgPiBNSU5fT1BBQ0lUWSkge1xuXHQgICAgICAgICAgICAvL2VsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcblx0ICAgICAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXHQgICAgICAgICAgICB0aGlzLl9pc1Zpc2libGUgPSB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChvcGFjaXR5ID4gTUFYX09QQUNJVFkpIG9wYWNpdHkgPSBNQVhfT1BBQ0lUWTtcblx0ICAgICAgICBlbHNlIGlmIChvcGFjaXR5IDwgTUlOX09QQUNJVFkpIHtcblx0ICAgICAgICAgICAgb3BhY2l0eSA9IE1JTl9PUEFDSVRZO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5faXNWaXNpYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAvL2VsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXNWaXNpYmxlID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodGhpcy5faXNWaXNpYmxlKSBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBZGRzIGEgaGFuZGxlciB0byB0aGUgYHR5cGVgIGNoYW5uZWwgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbiBgZW1pdGAuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBvblxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9ICAgICAgICAgRE9NIGV2ZW50IGNoYW5uZWwgbmFtZSwgZS5nLiwgXCJjbGlja1wiLCBcInRvdWNobW92ZVwiXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgIEhhbmRsZXIuIEl0J3Mgb25seSBhcmd1bWVudCB3aWxsIGJlIGFuIGVtaXR0ZWQgZGF0YSBwYXlsb2FkLlxuXHQgICAgICovXG5cdCAgICBFbGVtZW50T3V0cHV0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHR5cGUsIGhhbmRsZXIpIHtcblx0ICAgICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldClcblx0ICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuX2V2ZW50Rm9yd2FyZGVyKTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9uLmFwcGx5KHRoaXMuX2V2ZW50T3V0cHV0LCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBoYW5kbGVyIHRvIHRoZSBgdHlwZWAgY2hhbm5lbC5cblx0ICAgICAqICBVbmRvZXMgdGhlIHdvcmsgb2YgYG9uYC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJlbW92ZUxpc3RlbmVyXG5cdCAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAgICAgICAgIERPTSBldmVudCBjaGFubmVsIG5hbWUgZS5nLiwgXCJjbGlja1wiLCBcInRvdWNobW92ZVwiXG5cdCAgICAgKiBAcGFyYW0gaGFuZGxlciB7RnVuY3Rpb259ICAgIEhhbmRsZXJcblx0ICAgICAqL1xuXHQgICAgRWxlbWVudE91dHB1dC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKHR5cGUsIGhhbmRsZXIpIHtcblx0ICAgICAgICBFdmVudEhhbmRsZXIucHJvdG90eXBlLm9mZi5hcHBseSh0aGlzLl9ldmVudE91dHB1dCwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW1pdCBhbiBldmVudCB3aXRoIG9wdGlvbmFsIGRhdGEgcGF5bG9hZC4gVGhpcyB3aWxsIGV4ZWN1dGUgYWxsIGxpc3RlbmluZ1xuXHQgICAgICogIHRvIHRoZSBjaGFubmVsIG5hbWUgd2l0aCB0aGUgcGF5bG9hZCBhcyBvbmx5IGFyZ3VtZW50LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZW1pdFxuXHQgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gICAgICAgICBFdmVudCBjaGFubmVsIG5hbWVcblx0ICAgICAqIEBwYXJhbSBbcGF5bG9hZF0ge09iamVjdH0gICAgVXNlciBkZWZpbmVkIGRhdGEgcGF5bG9hZFxuXHQgICAgICovXG5cdCAgICBFbGVtZW50T3V0cHV0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlLCBwYXlsb2FkKSB7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMuX2V2ZW50T3V0cHV0LCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBc3NpZ25zIHRoZSBET00gZWxlbWVudCBmb3IgY29tbWl0dGluZyBhbmQgdG8gYW5kIGF0dGFjaGVzIGV2ZW50IGxpc3RlbmVycy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQG1ldGhvZCBhdHRhY2hcblx0ICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IGRvY3VtZW50IHBhcmVudCBvZiB0aGlzIGNvbnRhaW5lclxuXHQgICAgICovXG5cdCAgICBFbGVtZW50T3V0cHV0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2godGFyZ2V0KSB7XG5cdCAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHRhcmdldDtcblx0ICAgICAgICBfYWRkRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSZW1vdmVzIHRoZSBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGluIG1lbW9yeSBhbmQgZGV0YWNoZWQgZXZlbnQgbGlzdGVuZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAbWV0aG9kIGRldGFjaFxuXHQgICAgICovXG5cdCAgICBFbGVtZW50T3V0cHV0LnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG5cdCAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG5cdCAgICAgICAgaWYgKHRhcmdldCkge1xuXHQgICAgICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHQgICAgICAgICAgICB0YXJnZXQuc3R5bGUuZGlzcGxheSA9ICcnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGNvbW1pdExheW91dChsYXlvdXQpIHtcblx0ICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fY3VycmVudFRhcmdldDtcblx0ICAgICAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuXG5cdCAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGVkU3BlYztcblxuXHQgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBsYXlvdXQudHJhbnNmb3JtIHx8IFRyYW5zZm9ybS5pZGVudGl0eTtcblx0ICAgICAgICB2YXIgb3BhY2l0eSA9IChsYXlvdXQub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBsYXlvdXQub3BhY2l0eTtcblx0ICAgICAgICB2YXIgb3JpZ2luID0gbGF5b3V0Lm9yaWdpbiB8fCBfemVyb1plcm87XG5cblx0ICAgICAgICB0aGlzLl90cmFuc2Zvcm1EaXJ0eSA9IFRyYW5zZm9ybS5ub3RFcXVhbHMoY2FjaGUudHJhbnNmb3JtLCB0cmFuc2Zvcm0pO1xuXHQgICAgICAgIHRoaXMuX29wYWNpdHlEaXJ0eSA9IHRoaXMuX29wYWNpdHlEaXJ0eSB8fCAoY2FjaGUub3BhY2l0eSAhPT0gb3BhY2l0eSk7XG5cdCAgICAgICAgdGhpcy5fb3JpZ2luRGlydHkgPSB0aGlzLl9vcmlnaW5EaXJ0eSB8fCAob3JpZ2luICYmIF94eU5vdEVxdWFscyhjYWNoZS5vcmlnaW4sIG9yaWdpbikpO1xuXG5cdCAgICAgICAgaWYgKHRoaXMuX29wYWNpdHlEaXJ0eSkge1xuXHQgICAgICAgICAgICBjYWNoZS5vcGFjaXR5ID0gb3BhY2l0eTtcblx0ICAgICAgICAgICAgX3NldE9wYWNpdHkuY2FsbCh0aGlzLCB0YXJnZXQsIG9wYWNpdHkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0aGlzLl9vcmlnaW5EaXJ0eSl7XG5cdCAgICAgICAgICAgIGNhY2hlLm9yaWdpbiA9IG9yaWdpbjtcblx0ICAgICAgICAgICAgX3NldE9yaWdpbih0YXJnZXQsIG9yaWdpbik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybURpcnR5KSB7XG5cdCAgICAgICAgICAgIGNhY2hlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblx0ICAgICAgICAgICAgX3NldFRyYW5zZm9ybSh0YXJnZXQsIHRyYW5zZm9ybSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fb3JpZ2luRGlydHkgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLl90cmFuc2Zvcm1EaXJ0eSA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuX29wYWNpdHlEaXJ0eSA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb21taXRTaXplKHNpemUpe1xuXHQgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9jdXJyZW50VGFyZ2V0O1xuXHQgICAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG5cblx0ICAgICAgICBpZiAoX3h5Tm90RXF1YWxzKHRoaXMuX2NhY2hlZFNwZWMuc2l6ZSwgc2l6ZSkpe1xuXHQgICAgICAgICAgICB0aGlzLl9jYWNoZWRTcGVjLnNpemUgPSBzaXplO1xuXHQgICAgICAgICAgICBfc2V0U2l6ZSh0YXJnZXQsIHNpemUpO1xuXHQgICAgICAgICAgICB0aGlzLmVtaXQoJ3Jlc2l6ZScsIHNpemUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50T3V0cHV0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgU3VyZmFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXHQgICAgdmFyIENvbnRleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb250YWluZXJTdXJmYWNlIGVuYWJsZXMgbmVzdGluZyBvZiBET00uIEEgQ29udGFpbmVyU3VyZmFjZSBtYW5hZ2VzXG5cdCAgICAgKiAgaXRzIG93biByZW5kZXIgdHJlZSB0aGF0IGl0IGluc2VydHMgaW5zaWRlIGEgRE9NIG5vZGUuIFR5cGljYWxseVxuXHQgICAgICogIHRoaXMgaXMgdXNlZCBmb3IgY2xpcHBpbmcgYnkgc2V0dGluZ3MgYHtvdmVyZmxvdyA6IGhpZGRlbn1gIGFzIGEgQ1NTXG5cdCAgICAgKiAgcHJvcGVydHkuXG5cdCAgICAgKlxuXHQgICAgICogIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgbXlDb250YWluZXIgPSBuZXcgQ29udGFpbmVyU3VyZmFjZSh7XG5cdCAgICAgKiAgICAgICAgICBzaXplIDogWzEwMCwxMDBdLFxuXHQgICAgICogICAgICAgICAgcHJvcGVydGllcyA6IHtvdmVyZmxvdyA6IGhpZGRlbn1cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgc3VyZmFjZSA9IG5ldyBTdXJmYWNlKHtcblx0ICAgICAqICAgICAgICAgIHNpemUgOiBbMjAwLDIwMF0sXG5cdCAgICAgKiAgICAgICAgICBwcm9wZXJ0aWVzIDoge2JhY2tncm91bmQgOiAncmVkJ31cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBteUNvbnRhaW5lci5hZGQoc3VyZmFjZSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBjb250ZXh0LmFkZChteUNvbnRhaW5lcik7XG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIENvbnRhaW5lclN1cmZhY2Vcblx0ICAgICAqIEBleHRlbmRzIERPTS5TdXJmYWNlXG5cdCAgICAgKiBAbmFtZXNwYWNlIERPTVxuXHQgICAgICogQHVzZXMgRE9NLkNvbnRleHRcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9uc10ge09iamVjdH0gICAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnNpemVdIHtOdW1iZXJbXX0gICAgICAgICBTaXplICh3aWR0aCwgaGVpZ2h0KSBpbiBwaXhlbHMuIFRoZXNlIGNhbiBhbHNvIGJlIGB0cnVlYCBvciBgdW5kZWZpbmVkYC5cblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5jbGFzc2VzXSB7U3RyaW5nW119ICAgICAgQ1NTIGNsYXNzZXNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5wcm9wZXJ0aWVzXSB7T2JqZWN0fSAgICAgRGljdGlvbmFyeSBvZiBDU1MgcHJvcGVydGllc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLmF0dHJpYnV0ZXNdIHtPYmplY3R9ICAgICBEaWN0aW9uYXJ5IG9mIEhUTUwgYXR0cmlidXRlc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLmNvbnRlbnRdIHtTdHJpbmd9ICAgICAgICBJbm5lckhUTUwgY29udGVudFxuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLm9yaWdpbl0ge051bWJlcltdfSAgICAgICBPcmlnaW4gKHgseSksIHdpdGggdmFsdWVzIGJldHdlZW4gMCBhbmQgMVxuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnByb3BvcnRpb25zXSB7TnVtYmVyW119ICBQcm9wb3J0aW9ucyAoeCx5KSB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDFcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5tYXJnaW5zXSB7TnVtYmVyW119ICAgICAgTWFyZ2lucyAoeCx5KSBpbiBwaXhlbHNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5vcGFjaXR5XSB7TnVtYmVyfSAgICAgICAgT3BhY2l0eVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBDb250YWluZXJTdXJmYWNlKG9wdGlvbnMpIHtcblx0ICAgICAgICBTdXJmYWNlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cdCAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IENvbnRleHQoKTtcblx0ICAgICAgICB0aGlzLmNvbnRleHQuX3NpemUuc3Vic2NyaWJlKHRoaXMuc2l6ZSk7XG5cblx0ICAgICAgICB0aGlzLm9uKCdkZXBsb3knLCBmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRleHQubW91bnQodGhpcy5fY3VycmVudFRhcmdldCwgdHJ1ZSk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgIH1cblxuXHQgICAgQ29udGFpbmVyU3VyZmFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cmZhY2UucHJvdG90eXBlKTtcblx0ICAgIENvbnRhaW5lclN1cmZhY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGFpbmVyU3VyZmFjZTtcblx0ICAgIENvbnRhaW5lclN1cmZhY2UucHJvdG90eXBlLmVsZW1lbnRUeXBlID0gJ2Rpdic7XG5cdCAgICBDb250YWluZXJTdXJmYWNlLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBbJ3NhbXNhcmEtc3VyZmFjZScsICdzYW1zYXJhLWNvbnRhaW5lciddO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCBjdXJyZW50IHBlcnNwZWN0aXZlIGluIHBpeGVscy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGdldFBlcnNwZWN0aXZlXG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFBlcnNwZWN0aXZlIGluIHBpeGVsc1xuXHQgICAgICovXG5cdCAgICBDb250YWluZXJTdXJmYWNlLnByb3RvdHlwZS5nZXRQZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIGdldFBlcnNwZWN0aXZlKCkge1xuXHQgICAgICAgIHJldHVybiBDb250ZXh0LnByb3RvdHlwZS5nZXRQZXJzcGVjdGl2ZS5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldCBjdXJyZW50IHBlcnNwZWN0aXZlIGluIHBpeGVscy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldFBlcnNwZWN0aXZlXG5cdCAgICAgKiBAcGFyYW0gcGVyc3BlY3RpdmUge051bWJlcn0gIFBlcnNwZWN0aXZlIGluIHBpeGVsc1xuXHQgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uXSB7T2JqZWN0fSBUcmFuc2l0aW9uIGRlZmluaXRpb25cblx0ICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIHtGdW5jdGlvbn0gQ2FsbGJhY2sgZXhlY3V0ZWQgb24gY29tcGxldGlvbiBvZiB0cmFuc2l0aW9uXG5cdCAgICAgKi9cblx0ICAgIENvbnRhaW5lclN1cmZhY2UucHJvdG90eXBlLnNldFBlcnNwZWN0aXZlID0gZnVuY3Rpb24gc2V0UGVyc3BlY3RpdmUoKXtcblx0ICAgICAgICBDb250ZXh0LnByb3RvdHlwZS5zZXRQZXJzcGVjdGl2ZS5hcHBseSh0aGlzLmNvbnRleHQsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEV4dGVuZHMgdGhlIHJlbmRlciB0cmVlIHdpdGggYSBwcm92aWRlZCBub2RlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgYWRkXG5cdCAgICAgKiBAcGFyYW0gbm9kZSB7T2JqZWN0fSAgICAgTm9kZSwgU3VyZmFjZSwgb3IgVmlld1xuXHQgICAgICogQHJldHVybiB7UmVuZGVyVHJlZU5vZGV9XG5cdCAgICAgKi9cblx0ICAgIENvbnRhaW5lclN1cmZhY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCgpIHtcblx0ICAgICAgICByZXR1cm4gQ29udGV4dC5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMuY29udGV4dCwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gQ29udGFpbmVyU3VyZmFjZTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblx0Ly8gVE9ETzogRW5hYmxlIENTUyBwcm9wZXJ0aWVzIG9uIENvbnRleHRcblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIEVuZ2luZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdCAgICB2YXIgUm9vdE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblx0ICAgIHZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0ICAgIHZhciBFbGVtZW50QWxsb2NhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cdCAgICB2YXIgVHJhbnNpdGlvbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblx0ICAgIHZhciBTaW1wbGVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIHByZVRpY2tRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdCAgICB2YXIgZGlydHlRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cblx0ICAgIHZhciBlbGVtZW50VHlwZSA9ICdkaXYnO1xuXHQgICAgdmFyIGVsZW1lbnRDbGFzcyA9ICdzYW1zYXJhLWNvbnRleHQnO1xuXHQgICAgdmFyIHJhZlN0YXJ0ZWQgPSBmYWxzZTtcblxuXHQgICAgdmFyIGxheW91dFNwZWMgPSB7XG5cdCAgICAgICAgdHJhbnNmb3JtIDogVHJhbnNmb3JtLmlkZW50aXR5LFxuXHQgICAgICAgIG9wYWNpdHkgOiAxLFxuXHQgICAgICAgIG9yaWdpbiA6IG51bGwsXG5cdCAgICAgICAgYWxpZ24gOiBudWxsLFxuXHQgICAgICAgIG5leHRTaXplVHJhbnNmb3JtIDogVHJhbnNmb3JtLmlkZW50aXR5XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgQ29udGV4dCBkZWZpbmVzIGEgdG9wLWxldmVsIERPTSBlbGVtZW50IGluc2lkZSB3aGljaCBvdGhlciBub2RlcyAobGlrZSBTdXJmYWNlcykgYXJlIHJlbmRlcmVkLlxuXHQgICAgICpcblx0ICAgICAqICBUaGUgQ1NTIGNsYXNzIGBzYW1zYXJhLWNvbnRleHRgIGlzIGFwcGxpZWQsIHdoaWNoIHByb3ZpZGVzIHRoZSBtaW5pbWFsIENTUyBuZWNlc3Nhcnlcblx0ICAgICAqICB0byBjcmVhdGUgYSBwZXJmb3JtYW50IDNEIGNvbnRleHQgKHNwZWNpZmljYWxseSBgcHJlc2VydmUtM2RgKS5cblx0ICAgICAqXG5cdCAgICAgKiAgVGhlIENvbnRleHQgbXVzdCBiZSBtb3VudGVkIHRvIGEgRE9NIG5vZGUgdmlhIHRoZSBgbW91bnRgIG1ldGhvZC4gSWYgbm8gbm9kZSBpcyBzcGVjaWZpZWRcblx0ICAgICAqICBpdCBpcyBtb3VudGVkIHRvIGBkb2N1bWVudC5ib2R5YC5cblx0ICAgICAqXG5cdCAgICAgKiAgQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBjb250ZXh0ID0gQ29udGV4dCgpO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHN1cmZhY2UgPSBuZXcgU3VyZmFjZSh7XG5cdCAgICAgKiAgICAgICAgICBzaXplIDogWzEwMCwxMDBdLFxuXHQgICAgICogICAgICAgICAgcHJvcGVydGllcyA6IHtiYWNrZ3JvdW5kIDogJ3JlZCd9XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgY29udGV4dC5hZGQoc3VyZmFjZSk7XG5cdCAgICAgKiAgICAgIGNvbnRleHQubW91bnQoZG9jdW1lbnQuYm9keSlcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgQ29udGV4dFxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAbmFtZXNwYWNlIERPTVxuXHQgICAgICogQHVzZXMgQ29yZS5Sb290Tm9kZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBDb250ZXh0KCkge1xuXHQgICAgICAgIHRoaXMuX25vZGUgPSBuZXcgUm9vdE5vZGUoKTtcblxuXHQgICAgICAgIHRoaXMuX3NpemUgPSBuZXcgU2ltcGxlU3RyZWFtKCk7XG5cdCAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IFNpbXBsZVN0cmVhbSgpO1xuXG5cdCAgICAgICAgdGhpcy5zaXplID0gdGhpcy5fc2l6ZS5tYXAoZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgdmFyIHNpemUgPSBbdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsIHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodF07XG5cdCAgICAgICAgICAgIHRoaXMuZW1pdCgncmVzaXplJywgc2l6ZSk7XG5cdCAgICAgICAgICAgIHJldHVybiBzaXplO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl9ub2RlLl9zaXplLnN1YnNjcmliZSh0aGlzLnNpemUpO1xuXHQgICAgICAgIHRoaXMuX25vZGUuX2xheW91dC5zdWJzY3JpYmUodGhpcy5fbGF5b3V0KTtcblxuXHQgICAgICAgIHRoaXMuX3BlcnNwZWN0aXZlID0gbmV3IFRyYW5zaXRpb25hYmxlKCk7XG5cblx0ICAgICAgICB0aGlzLl9wZXJzcGVjdGl2ZS5vbigndXBkYXRlJywgZnVuY3Rpb24ocGVyc3BlY3RpdmUpe1xuXHQgICAgICAgICAgICBzZXRQZXJzcGVjdGl2ZSh0aGlzLmNvbnRhaW5lciwgcGVyc3BlY3RpdmUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl9wZXJzcGVjdGl2ZS5vbignZW5kJywgZnVuY3Rpb24ocGVyc3BlY3RpdmUpe1xuXHQgICAgICAgICAgICBzZXRQZXJzcGVjdGl2ZSh0aGlzLmNvbnRhaW5lciwgcGVyc3BlY3RpdmUpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudEZvcndhcmRlciA9IGZ1bmN0aW9uIF9ldmVudEZvcndhcmRlcihldmVudCkge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcblx0ICAgICAgICB9LmJpbmQodGhpcyk7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogRXh0ZW5kcyB0aGUgcmVuZGVyIHRyZWUgYmVnaW5uaW5nIHdpdGggdGhlIENvbnRleHQncyBSb290Tm9kZSB3aXRoIGEgbmV3IG5vZGUuXG5cdCAgICAgKiAgRGVsZWdhdGVzIHRvIFJvb3ROb2RlJ3MgYGFkZGAgbWV0aG9kLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgYWRkXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICAgIFJlbmRlcmFibGVcblx0ICAgICAqIEByZXR1cm4ge1JlbmRlclRyZWVOb2RlfSBXcmFwcGVkIG5vZGVcblx0ICAgICAqL1xuXHQgICAgQ29udGV4dC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuXHQgICAgICAgIHJldHVybiBSb290Tm9kZS5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMuX25vZGUsIGFyZ3VtZW50cyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEdldCBjdXJyZW50IHBlcnNwZWN0aXZlIG9mIHRoaXMgQ29udGV4dCBpbiBwaXhlbHMuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBnZXRQZXJzcGVjdGl2ZVxuXHQgICAgICogQHJldHVybiB7TnVtYmVyfSBQZXJzcGVjdGl2ZSBpbiBwaXhlbHNcblx0ICAgICAqL1xuXHQgICAgQ29udGV4dC5wcm90b3R5cGUuZ2V0UGVyc3BlY3RpdmUgPSBmdW5jdGlvbiBnZXRQZXJzcGVjdGl2ZSgpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fcGVyc3BlY3RpdmUuZ2V0KCk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNldCBjdXJyZW50IHBlcnNwZWN0aXZlIG9mIHRoZSBgY29udGV4dGAgaW4gcGl4ZWxzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0UGVyc3BlY3RpdmVcblx0ICAgICAqIEBwYXJhbSBwZXJzcGVjdGl2ZSB7TnVtYmVyfSAgUGVyc3BlY3RpdmUgaW4gcGl4ZWxzXG5cdCAgICAgKiBAcGFyYW0gW3RyYW5zaXRpb25dIHtPYmplY3R9IFRyYW5zaXRpb24gZGVmaW5pdGlvblxuXHQgICAgICogQHBhcmFtIFtjYWxsYmFja10ge0Z1bmN0aW9ufSBDYWxsYmFjayBleGVjdXRlZCBvbiBjb21wbGV0aW9uIG9mIHRyYW5zaXRpb25cblx0ICAgICAqL1xuXHQgICAgQ29udGV4dC5wcm90b3R5cGUuc2V0UGVyc3BlY3RpdmUgPSBmdW5jdGlvbiBzZXRQZXJzcGVjdGl2ZShwZXJzcGVjdGl2ZSwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcblx0ICAgICAgICB0aGlzLl9wZXJzcGVjdGl2ZS5zZXQocGVyc3BlY3RpdmUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxsb2NhdGUgY29udGVudHMgb2YgdGhlIGBjb250ZXh0YCB0byBhIERPTSBub2RlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgbW91bnRcblx0ICAgICAqIEBwYXJhbSBub2RlIHtOb2RlfSAgRE9NIGVsZW1lbnRcblx0ICAgICAqL1xuXHQgICAgQ29udGV4dC5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbiBtb3VudChub2RlLCByZXNpemVMaXN0ZW5GbGFnKXtcblx0ICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5vZGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZSk7XG5cdCAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChlbGVtZW50Q2xhc3MpO1xuXG5cdCAgICAgICAgdmFyIGFsbG9jYXRvciA9IG5ldyBFbGVtZW50QWxsb2NhdG9yKHRoaXMuY29udGFpbmVyKTtcblx0ICAgICAgICB0aGlzLl9ub2RlLnNldEFsbG9jYXRvcihhbGxvY2F0b3IpO1xuXG5cdCAgICAgICAgdGhpcy5lbWl0KCdkZXBsb3knLCB0aGlzLmNvbnRhaW5lcik7XG5cblx0ICAgICAgICBpZiAoIW5vZGUpXG5cdCAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXG5cdCAgICAgICAgaWYgKCFyZXNpemVMaXN0ZW5GbGFnKVxuXHQgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcblxuXHQgICAgICAgIHByZVRpY2tRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpe1xuXHQgICAgICAgICAgICBoYW5kbGVSZXNpemUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnRyaWdnZXIoJ3N0YXJ0JywgbGF5b3V0U3BlYyk7XG5cdCAgICAgICAgICAgIGRpcnR5UXVldWUucHVzaChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0LnRyaWdnZXIoJ2VuZCcsIGxheW91dFNwZWMpO1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICBpZiAoIXJhZlN0YXJ0ZWQpIHtcblx0ICAgICAgICAgICAgcmFmU3RhcnRlZCA9IHRydWU7XG5cdCAgICAgICAgICAgIEVuZ2luZS5zdGFydCgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBhIGhhbmRsZXIgdG8gdGhlIGB0eXBlYCBjaGFubmVsIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb24gYGVtaXRgLlxuXHQgICAgICogIFRoZXNlIGV2ZW50cyBzaG91bGQgYmUgRE9NIGV2ZW50cyB0aGF0IG9jY3VyIG9uIHRoZSBET00gbm9kZSB0aGVcblx0ICAgICAqICBjb250ZXh0IGhhcyBiZWVuIG1vdW50ZWQgdG8uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBvblxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gICAgICAgICBDaGFubmVsIG5hbWVcblx0ICAgICAqIEBwYXJhbSBoYW5kbGVyIHtGdW5jdGlvbn0gICAgQ2FsbGJhY2tcblx0ICAgICAqL1xuXHQgICAgQ29udGV4dC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbih0eXBlLCBoYW5kbGVyKXtcblx0ICAgICAgICBpZiAodGhpcy5jb250YWluZXIpXG5cdCAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5fZXZlbnRGb3J3YXJkZXIpO1xuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5vbignZGVwbG95JywgZnVuY3Rpb24odGFyZ2V0KXtcblx0ICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuX2V2ZW50Rm9yd2FyZGVyKTtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnByb3RvdHlwZS5vbi5hcHBseSh0aGlzLl9ldmVudE91dHB1dCwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVtb3ZlcyB0aGUgYGhhbmRsZXJgIGZyb20gdGhlIGB0eXBlYC5cblx0ICAgICAqICBVbmRvZXMgdGhlIHdvcmsgb2YgYG9uYC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIG9uXG5cdCAgICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSAgICAgICAgIENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGhhbmRsZXIge0Z1bmN0aW9ufSAgICBDYWxsYmFja1xuXHQgICAgICovXG5cdCAgICBDb250ZXh0LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYodHlwZSwgaGFuZGxlcikge1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUub2ZmLmFwcGx5KHRoaXMuX2V2ZW50T3V0cHV0LCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVc2VkIGludGVybmFsbHkgd2hlbiBjb250ZXh0IGlzIHN1YnNjcmliZWQgdG8uXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBlbWl0XG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQHBhcmFtIHR5cGUge1N0cmluZ30gICAgIENoYW5uZWwgbmFtZVxuXHQgICAgICogQHBhcmFtIGRhdGEge09iamVjdH0gICAgIFBheWxvYWRcblx0ICAgICAqL1xuXHQgICAgQ29udGV4dC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSwgcGF5bG9hZCkge1xuXHQgICAgICAgIEV2ZW50SGFuZGxlci5wcm90b3R5cGUuZW1pdC5hcHBseSh0aGlzLl9ldmVudE91dHB1dCwgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciB1c2VQcmVmaXggPSAhKCdwZXJzcGVjdGl2ZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcblxuXHQgICAgdmFyIHNldFBlcnNwZWN0aXZlID0gdXNlUHJlZml4XG5cdCAgICAgICAgPyBmdW5jdGlvbiBzZXRQZXJzcGVjdGl2ZShlbGVtZW50LCBwZXJzcGVjdGl2ZSkge1xuXHQgICAgICAgICAgICBlbGVtZW50LnN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmUgPyAocGVyc3BlY3RpdmUgfCAwKSArICdweCcgOiAnMHB4Jztcblx0ICAgICAgICB9XG5cdCAgICAgICAgOiBmdW5jdGlvbiBzZXRQZXJzcGVjdGl2ZShlbGVtZW50LCBwZXJzcGVjdGl2ZSkge1xuXHQgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmUgPyAocGVyc3BlY3RpdmUgfCAwKSArICdweCcgOiAnMHB4Jztcblx0ICAgICAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XG5cdCAgICAgICAgdGhpcy5fc2l6ZS5lbWl0KCdyZXNpemUnKTtcblx0ICAgICAgICBkaXJ0eVF1ZXVlLnB1c2goZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgdGhpcy5fc2l6ZS5lbWl0KCdyZXNpemUnKTtcblx0ICAgICAgICB9LmJpbmQodGhpcykpO1xuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDM3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBSZW5kZXJUcmVlTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgUm9vdE5vZGUgaXMgYSBmaXJzdCBub2RlIGluIHRoZSBSZW5kZXIgVHJlZS4gSXQgaXMgbGlrZSBhbnkgb3RoZXJcblx0ICAgICAqICBSZW5kZXJUcmVlTm9kZSBidXQgd2l0aCB0aGUgYWRkaXRpb25hbCByZXNwb25zaWJpbGl0eSBvZiBkZWZpbmluZ1xuXHQgICAgICogIGFuIGFsbG9jYXRpbmcgRE9NIG5vZGUgdG8gcmVuZGVyIHRvLlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBSb290Tm9kZVxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcHJpdmF0ZVxuXHQgICAgICogQGV4dGVuZHMgQ29yZS5SZW5kZXJUcmVlTm9kZVxuXHQgICAgICogQHBhcmFtIFthbGxvY2F0b3JdIHtFbGVtZW50QWxsb2NhdG9yfSBFbGVtZW50QWxsb2NhdG9yXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIFJvb3ROb2RlKGFsbG9jYXRvcikge1xuXHQgICAgICAgIFJlbmRlclRyZWVOb2RlLmNhbGwodGhpcyk7XG5cdCAgICAgICAgdGhpcy5yb290ID0gdGhpcztcblx0ICAgICAgICBpZiAoYWxsb2NhdG9yKSB0aGlzLnNldEFsbG9jYXRvcihhbGxvY2F0b3IpO1xuXHQgICAgfVxuXG5cdCAgICBSb290Tm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlbmRlclRyZWVOb2RlLnByb3RvdHlwZSk7XG5cdCAgICBSb290Tm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb290Tm9kZTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZWZpbmUgYW4gYWxsb2NhdG9yXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBzZXRBbGxvY2F0b3Jcblx0ICAgICAqIEBwYXJhbSBhbGxvY2F0b3Ige0FsbG9jYXRvcn0gQWxsb2NhdG9yXG5cdCAgICAgKi9cblx0ICAgIFJvb3ROb2RlLnByb3RvdHlwZS5zZXRBbGxvY2F0b3IgPSBmdW5jdGlvbiBzZXRBbGxvY2F0b3IoYWxsb2NhdG9yKXtcblx0ICAgICAgICB0aGlzLmFsbG9jYXRvciA9IGFsbG9jYXRvcjtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gUm9vdE5vZGU7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDM4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuXHQgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG5cdCAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cdCAqXG5cdCAqIEBsaWNlbnNlIE1QTCAyLjBcblx0ICogQGNvcHlyaWdodCBGYW1vdXMgSW5kdXN0cmllcywgSW5jLiAyMDE0XG5cdCAqL1xuXG5cdC8qIE1vZGlmaWVkIHdvcmsgY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIYW5kbGVzIGNyZWF0aW5nLCBhbGxvY2F0aW5nIGFuZCByZW1vdmluZyBET00gZWxlbWVudHMgd2l0aGluIGEgcHJvdmlkZWQgRE9NIGVsZW1lbnQuXG5cdCAgICAgKiAgTWFuYWdlcyBhIHBvb2wgb2Ygbm9kZXMgYmFzZWQgb24gRE9NIHRhZ05hbWUgZm9yIERPTSBub2RlIHJldXNlLlxuXHQgICAgICogIFdoZW4gYSBTdXJmYWNlIGlzIGRlYWxsb2NhdGVkLCBpdHMgZWxlbWVudCBpcyBjbGVhcmVkIGFuZCBwdXQgYmFjayBpbiB0aGUgcG9vbC5cblx0ICAgICAqICBXaGVuIGEgU3VyZmFjZSBpcyBhbGxvY2F0ZWQsIGFuIGV4aXN0aW5nIGNsZWFyZWQgZWxlbWVudCBvZiB0aGUgc2FtZSB0YWdOYW1lIGlzXG5cdCAgICAgKiAgbG9va2VkIGZvci4gSWYgaXQgaXMgbm90IGZvdW5kLCBhIG5ldyBET00gZWxlbWVudCBpcyBjcmVhdGVkLlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBFbGVtZW50QWxsb2NhdG9yXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBuYW1lc3BhY2UgQ29yZVxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEBwYXJhbSBjb250YWluZXIge05vZGV9IERPTSBlbGVtZW50XG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIEVsZW1lbnRBbGxvY2F0b3IoY29udGFpbmVyKSB7XG5cdCAgICAgICAgaWYgKCFjb250YWluZXIpIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0ICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0ICAgICAgICB0aGlzLmRldGFjaGVkTm9kZXMgPSB7fTtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb3ZlIHRoZSBET00gZWxlbWVudHMgZnJvbSB0aGVpciBvcmlnaW5hbCBjb250YWluZXIgdG8gYSBuZXcgb25lLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgbWlncmF0ZVxuXHQgICAgICogQHBhcmFtIGNvbnRhaW5lciB7Tm9kZX0gRE9NIGVsZW1lbnRcblx0ICAgICAqL1xuXHQgICAgRWxlbWVudEFsbG9jYXRvci5wcm90b3R5cGUubWlncmF0ZSA9IGZ1bmN0aW9uIG1pZ3JhdGUoY29udGFpbmVyKSB7XG5cdCAgICAgICAgdmFyIG9sZENvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuXHQgICAgICAgIGlmIChjb250YWluZXIgPT09IG9sZENvbnRhaW5lcikgcmV0dXJuO1xuXG5cdCAgICAgICAgaWYgKG9sZENvbnRhaW5lciBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpXG5cdCAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvbGRDb250YWluZXIpO1xuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB3aGlsZSAob2xkQ29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSlcblx0ICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvbGRDb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGxvY2F0ZSBhbiBlbGVtZW50IG9mIHNwZWNpZmllZCB0eXBlIGZyb20gdGhlIHBvb2wuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBhbGxvY2F0ZVxuXHQgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gRE9NIHRhZ05hbWUsIGUuZy4sIFwiZGl2XCJcblx0ICAgICAqIEByZXR1cm4ge05vZGV9XG5cdCAgICAgKi9cblx0ICAgIEVsZW1lbnRBbGxvY2F0b3IucHJvdG90eXBlLmFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUodHlwZSkge1xuXHQgICAgICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmRldGFjaGVkTm9kZXMpKSB0aGlzLmRldGFjaGVkTm9kZXNbdHlwZV0gPSBbXTtcblx0ICAgICAgICB2YXIgbm9kZVN0b3JlID0gdGhpcy5kZXRhY2hlZE5vZGVzW3R5cGVdO1xuXHQgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgaWYgKG5vZGVTdG9yZS5sZW5ndGggPT09IDApe1xuXHQgICAgICAgICAgICByZXN1bHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXHQgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChyZXN1bHQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHJlc3VsdCA9IG5vZGVTdG9yZS5wb3AoKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBEZS1hbGxvY2F0ZSBhbiBlbGVtZW50IG9mIHNwZWNpZmllZCB0eXBlIHRvIHRoZSBwb29sIGZvciByZWN5Y2xpbmcuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZCBkZWFsbG9jYXRlXG5cdCAgICAgKiBAcGFyYW0gZWxlbWVudCB7Tm9kZX0gRE9NIGVsZW1lbnRcblx0ICAgICAqL1xuXHQgICAgRWxlbWVudEFsbG9jYXRvci5wcm90b3R5cGUuZGVhbGxvY2F0ZSA9IGZ1bmN0aW9uIGRlYWxsb2NhdGUoZWxlbWVudCkge1xuXHQgICAgICAgIHZhciBub2RlVHlwZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB2YXIgbm9kZVN0b3JlID0gdGhpcy5kZXRhY2hlZE5vZGVzW25vZGVUeXBlXTtcblx0ICAgICAgICBub2RlU3RvcmUucHVzaChlbGVtZW50KTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gRWxlbWVudEFsbG9jYXRvcjtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogMzkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICAgICAgICBFdmVudEVtaXR0ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTApLFxuXHQgICAgICAgIEV2ZW50SGFuZGxlcjogX193ZWJwYWNrX3JlcXVpcmVfXyg5KSxcblx0ICAgICAgICBFdmVudE1hcHBlcjogX193ZWJwYWNrX3JlcXVpcmVfXygxMiksXG5cdCAgICAgICAgRXZlbnRGaWx0ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTMpLFxuXHQgICAgICAgIEV2ZW50U3BsaXR0ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMTQpXG5cdCAgICB9O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXHQgICAgICAgIEdlbmVyaWNJbnB1dDogX193ZWJwYWNrX3JlcXVpcmVfXyg0MSksXG5cdCAgICAgICAgTW91c2VJbnB1dDogX193ZWJwYWNrX3JlcXVpcmVfXyg0MiksXG5cdCAgICAgICAgVG91Y2hJbnB1dDogX193ZWJwYWNrX3JlcXVpcmVfXyg0MyksXG5cdCAgICAgICAgU2Nyb2xsSW5wdXQ6IF9fd2VicGFja19yZXF1aXJlX18oNDUpLFxuXHQgICAgICAgIFNjYWxlSW5wdXQ6IF9fd2VicGFja19yZXF1aXJlX18oNDYpLFxuXHQgICAgICAgIFJvdGF0ZUlucHV0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSxcblx0ICAgICAgICBQaW5jaElucHV0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KVxuXHQgICAgfTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIEV2ZW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblx0ICAgIC8vIEdsb2JhbCByZWdpc3RyeSBvZiBpbnB1dCBjb25zdHJ1Y3RvcnMuIEFwcGVuZCBvbmx5LlxuXHQgICAgdmFyIHJlZ2lzdHJ5ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29tYmluZXMgbXVsdGlwbGUgaW5wdXRzIChlLmcuLCBtb3VzZSwgdG91Y2gsIHNjcm9sbCkgaW50byBvbmUgdW5pZmllZCBpbnB1dC5cblx0ICAgICAqICBJbnB1dHMgbXVzdCBmaXJzdCBiZSByZWdpc3RlcmVkIG9uIHRoZSBjb25zdHJ1Y3RvciBieSBhIHVuaXF1ZSBpZGVudGlmaWVyLFxuXHQgICAgICogIHRoZW4gdGhleSBjYW4gYmUgYWNjZXNzZWQgb24gaW5zdGFudGlhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiAgICAgIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICAvLyBJbiBtYWluLmpzXG5cdCAgICAgKiAgICAgIEdlbmVyaWNJbnB1dC5yZWdpc3Rlcih7XG5cdCAgICAgKiAgICAgICAgICBcIm1vdXNlXCIgOiBNb3VzZUlucHV0LFxuXHQgICAgICogICAgICAgICAgXCJ0b3VjaFwiIDogVG91Y2hJbnB1dFxuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIC8vIGluIG15RmlsZS5qc1xuXHQgICAgICogICAgICB2YXIgaW5wdXQgPSBuZXcgR2VuZXJpY0lucHV0KFsnbW91c2UnLCAndG91Y2gnXSwgb3B0aW9ucyk7XG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIEdlbmVyaWNJbnB1dFxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAbmFtZXNwYWNlIElucHV0c1xuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TaW1wbGVTdHJlYW1cblx0ICAgICAqIEBwYXJhbSBpbnB1dHMge09iamVjdHxTdHJpbmdbXX0gIERpY3Rpb25hcnkgd2l0aCB7aWRlbnRpZmllciA6IG9wdGlvbn0gcGFpcnNcblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGFuIGFycmF5IG9mIGlkZW50aWZpZXIgc3RyaW5nc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zXSB7T2JqZWN0fSBPcHRpb25zIGZvciBhbGwgaW5wdXRzXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIEdlbmVyaWNJbnB1dChpbnB1dHMsIG9wdGlvbnMpIHtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldElucHV0SGFuZGxlcih0aGlzLCB0aGlzLl9ldmVudElucHV0KTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0T3V0cHV0SGFuZGxlcih0aGlzLCB0aGlzLl9ldmVudE91dHB1dCk7XG5cblx0ICAgICAgICB0aGlzLl9pbnB1dHMgPSB7fTtcblx0ICAgICAgICBpZiAoaW5wdXRzKSB0aGlzLmFkZElucHV0KGlucHV0cyk7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMpIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0ICAgIH1cblxuXHQgICAgR2VuZXJpY0lucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBHZW5lcmljSW5wdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJpY0lucHV0O1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbnN0cmFpbiB0aGUgaW5wdXQgYWxvbmcgYSBzcGVjaWZpYyBheGlzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSBESVJFQ1RJT04ge09iamVjdH1cblx0ICAgICAqIEBwcm9wZXJ0eSBESVJFQ1RJT04uWCB7TnVtYmVyfSAgIHgtYXhpc1xuXHQgICAgICogQHByb3BlcnR5IERJUkVDVElPTi5ZIHtOdW1iZXJ9ICAgeS1heGlzXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKi9cblx0ICAgIEdlbmVyaWNJbnB1dC5ESVJFQ1RJT04gPSB7XG5cdCAgICAgICAgWCA6IDAsXG5cdCAgICAgICAgWSA6IDFcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVnaXN0ZXIgYSBnbG9iYWwgaW5wdXQgY2xhc3Mgd2l0aCBhbiBpZGVudGlmeWluZyBrZXlcblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gaW5wdXRPYmplY3Qge09iamVjdH0gYW4gb2JqZWN0IG9mIHtpbnB1dCBrZXkgOiBpbnB1dCBvcHRpb25zfSBmaWVsZHNcblx0ICAgICAqL1xuXHQgICAgR2VuZXJpY0lucHV0LnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoaW5wdXRPYmplY3QpIHtcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXRPYmplY3Qpe1xuXHQgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSl7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnlba2V5XSA9PT0gaW5wdXRPYmplY3Rba2V5XSkgcmV0dXJuOyAvLyByZWR1bmRhbnQgcmVnaXN0cmF0aW9uXG5cdCAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcigndGhpcyBrZXkgaXMgcmVnaXN0ZXJlZCB0byBhIGRpZmZlcmVudCBpbnB1dCBjbGFzcycpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgcmVnaXN0cnlba2V5XSA9IGlucHV0T2JqZWN0W2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZWxwZXIgdG8gc2V0IG9wdGlvbnMgb24gYWxsIGlucHV0IGluc3RhbmNlc1xuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc2V0T3B0aW9uc1xuXHQgICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gb3B0aW9ucyBvYmplY3Rcblx0ICAgICAqL1xuXHQgICAgR2VuZXJpY0lucHV0LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9pbnB1dHMpXG5cdCAgICAgICAgICAgIHRoaXMuX2lucHV0c1trZXldLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFN1YnNjcmliZSBldmVudHMgZnJvbSBhbiBpbnB1dCBjbGFzc1xuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Qgc3Vic2NyaWJlSW5wdXRcblx0ICAgICAqIEBwYXJhbSBrZXkge1N0cmluZ30gaWRlbnRpZmllciBmb3IgaW5wdXQgY2xhc3Ncblx0ICAgICAqL1xuXHQgICAgR2VuZXJpY0lucHV0LnByb3RvdHlwZS5zdWJzY3JpYmVJbnB1dCA9IGZ1bmN0aW9uIHN1YnNjcmliZUlucHV0KGtleSkge1xuXHQgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0c1trZXldO1xuXHQgICAgICAgIGlucHV0LnN1YnNjcmliZSh0aGlzLl9ldmVudElucHV0KTtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5zdWJzY3JpYmUoaW5wdXQpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVbnN1YnNjcmliZSBldmVudHMgZnJvbSBhbiBpbnB1dCBjbGFzc1xuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgdW5zdWJzY3JpYmVJbnB1dFxuXHQgICAgICogQHBhcmFtIGtleSB7U3RyaW5nfSBpZGVudGlmaWVyIGZvciBpbnB1dCBjbGFzc1xuXHQgICAgICovXG5cdCAgICBHZW5lcmljSW5wdXQucHJvdG90eXBlLnVuc3Vic2NyaWJlSW5wdXQgPSBmdW5jdGlvbiB1bnN1YnNjcmliZUlucHV0KGtleSkge1xuXHQgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0c1trZXldO1xuXHQgICAgICAgIGlucHV0LnVuc3Vic2NyaWJlKHRoaXMuX2V2ZW50SW5wdXQpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LnVuc3Vic2NyaWJlKGlucHV0KTtcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIF9hZGRTaW5nbGVJbnB1dChrZXksIG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAoIXJlZ2lzdHJ5W2tleV0pIHJldHVybjtcblx0ICAgICAgICB0aGlzLl9pbnB1dHNba2V5XSA9IG5ldyAocmVnaXN0cnlba2V5XSkob3B0aW9ucyk7XG5cdCAgICAgICAgdGhpcy5zdWJzY3JpYmVJbnB1dChrZXkpO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIEFkZCBhbiBpbnB1dCBjbGFzcyB0byBmcm9tIHRoZSByZWdpc3RlcmVkIGNsYXNzZXNcblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGFkZElucHV0XG5cdCAgICAgKiBAcGFyYW0gaW5wdXRzIHtPYmplY3R8QXJyYXkuU3RyaW5nfSBhbiBhcnJheSBvZiByZWdpc3RlcmVkIGlucHV0IGtleXNcblx0ICAgICAqICAgIG9yIGFuIG9iamVjdCB3aXRoIGZpZWxkcyB7aW5wdXQga2V5IDogaW5wdXQgb3B0aW9uc31cblx0ICAgICAqL1xuXHQgICAgR2VuZXJpY0lucHV0LnByb3RvdHlwZS5hZGRJbnB1dCA9IGZ1bmN0aW9uIGFkZElucHV0KGlucHV0cykge1xuXHQgICAgICAgIGlmIChpbnB1dHMgaW5zdGFuY2VvZiBBcnJheSlcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspXG5cdCAgICAgICAgICAgICAgICBfYWRkU2luZ2xlSW5wdXQuY2FsbCh0aGlzLCBpbnB1dHNbaV0pO1xuXHQgICAgICAgIGVsc2UgaWYgKGlucHV0cyBpbnN0YW5jZW9mIE9iamVjdClcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0cylcblx0ICAgICAgICAgICAgICAgIF9hZGRTaW5nbGVJbnB1dC5jYWxsKHRoaXMsIGtleSwgaW5wdXRzW2tleV0pO1xuXHQgICAgfTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBHZW5lcmljSW5wdXQ7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuXHQgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG5cdCAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG5cdCAqXG5cdCAqIEBsaWNlbnNlIE1QTCAyLjBcblx0ICogQGNvcHlyaWdodCBGYW1vdXMgSW5kdXN0cmllcywgSW5jLiAyMDE0XG5cdCAqL1xuXG5cdC8qIE1vZGlmaWVkIHdvcmsgY29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIE9wdGlvbnNNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblx0ICAgIHZhciBNSU5JTVVNX1RJQ0tfVElNRSA9IDg7XG5cdCAgICB2YXIgX25vdyA9IERhdGUubm93O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFdyYXBwZXIgZm9yIERPTSBtb3VzZSBldmVudHMuIENvbnZlcnRzXG5cdCAgICAgKlxuXHQgICAgICogICAgICBgbW91c2Vkb3duYCAtPiBgc3RhcnRgXG5cdCAgICAgKiAgICAgIGBtb3VzZW1vdmVgIC0+IGB1cGRhdGVgXG5cdCAgICAgKiAgICAgIGBtb3VzZXVwYCAgIC0+IGBlbmRgXG5cdCAgICAgKlxuXHQgICAgICogTW91c2VJbnB1dCBlbWl0cyB0aGVzZSBldmVudHMgd2l0aCB0aGUgZm9sbG93aW5nIHBheWxvYWQgZGF0YTpcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGB2YWx1ZWAgICAgIC0gRGlzcGxhY2VtZW50IGluIHBpeGVscyBmcm9tIGBtb3VzZWRvd25gXG5cdCAgICAgKiAgICAgIGBkZWx0YWAgICAgIC0gRGlmZmVyZW50aWFsIGluIHBpeGVscyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgbW91c2UgcG9zaXRpb25zXG5cdCAgICAgKiAgICAgIGB2ZWxvY2l0eWAgIC0gVmVsb2NpdHkgb2YgbW91c2UgbW92ZW1lbnQgaW4gcGl4ZWxzIHBlciBzZWNvbmRcblx0ICAgICAqICAgICAgYGNsaWVudFhgICAgLSBET00gZXZlbnQgY2xpZW50WCBwcm9wZXJ0eVxuXHQgICAgICogICAgICBgY2xpZW50WWAgICAtIERPTSBldmVudCBjbGllbnRZIHByb3BlcnR5XG5cdCAgICAgKiAgICAgIGBvZmZzZXRYYCAgIC0gRE9NIGV2ZW50IG9mZnNldFggcHJvcGVydHlcblx0ICAgICAqICAgICAgYG9mZnNldFlgICAgLSBET00gZXZlbnQgb2Zmc2V0WSBwcm9wZXJ0eVxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgc3VyZmFjZSA9IG5ldyBTdXJmYWNlKHtcblx0ICAgICAqICAgICAgICAgIHNpemUgOiBbMTAwLDEwMF0sXG5cdCAgICAgKiAgICAgICAgICBwcm9wZXJ0aWVzIDoge2JhY2tncm91bmQgOiAncmVkJ31cblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB2YXIgbW91c2VJbnB1dCA9IG5ldyBNb3VzZUlucHV0KHtcblx0ICAgICAqICAgICAgICAgIGRpcmVjdGlvbiA6IE1vdXNlSW5wdXQuRElSRUNUSU9OLlhcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBtb3VzZUlucHV0LnN1YnNjcmliZShzdXJmYWNlKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIG1vdXNlSW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICAvLyBmaXJlZCBvbiBtb3VzZSBkb3duXG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBtb3VzZUlucHV0Lm9uKCd1cGRhdGUnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIC8vIGZpcmVkIG9uIG1vdXNlIG1vdmVcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGUnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBtb3VzZUlucHV0Lm9uKCdlbmQnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIC8vIGZpcmVkIG9uIG1vdXNlIHVwXG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygnZW5kJywgcGF5bG9hZCk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBNb3VzZUlucHV0XG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBleHRlbmQgU2ltcGxlU3RyZWFtXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnNdIHtPYmplY3R9ICAgICAgICAgICAgICAgIE9wdGlvbnNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5kaXJlY3Rpb25dIHtOdW1iZXJ9ICAgICAgRGlyZWN0aW9uIHRvIHByb2plY3QgbW92ZW1lbnQgb250by5cblx0ICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBmb3VuZCBpbiBNb3VzZUlucHV0LkRJUkVDVElPTi5cblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5zY2FsZT0xXSB7TnVtYmVyfSAgICAgICAgU2NhbGUgdGhlIHJlc3BvbnNlIHRvIHRoZSBtb3VzZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBNb3VzZUlucHV0KG9wdGlvbnMpIHtcblx0ICAgICAgICB0aGlzLm9wdGlvbnMgPSBPcHRpb25zTWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblxuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRJbnB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRJbnB1dCk7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRPdXRwdXQpO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbignbW91c2Vkb3duJywgICAgaGFuZGxlU3RhcnQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbignbW91c2Vtb3ZlJywgICAgaGFuZGxlTW92ZS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCdtb3VzZXVwJywgICAgICBoYW5kbGVFbmQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbignbW91c2VsZWF2ZScsICAgaGFuZGxlTGVhdmUuYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl9wYXlsb2FkID0ge1xuXHQgICAgICAgICAgICBkZWx0YSAgICA6IG51bGwsXG5cdCAgICAgICAgICAgIHZhbHVlICAgIDogbnVsbCxcblx0ICAgICAgICAgICAgdmVsb2NpdHkgOiBudWxsLFxuXHQgICAgICAgICAgICBjbGllbnRYICA6IDAsXG5cdCAgICAgICAgICAgIGNsaWVudFkgIDogMCxcblx0ICAgICAgICAgICAgb2Zmc2V0WCAgOiAwLFxuXHQgICAgICAgICAgICBvZmZzZXRZICA6IDBcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsOyAgICAgIC8vIHRvIGJlIGRlcHJlY2F0ZWRcblx0ICAgICAgICB0aGlzLl9wcmV2Q29vcmQgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fcHJldlRpbWUgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgdGhpcy5fZG93biA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMuX21vdmUgPSBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgTW91c2VJbnB1dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpbXBsZVN0cmVhbS5wcm90b3R5cGUpO1xuXHQgICAgTW91c2VJbnB1dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3VzZUlucHV0O1xuXG5cdCAgICBNb3VzZUlucHV0LkRFRkFVTFRfT1BUSU9OUyA9IHtcblx0ICAgICAgICBkaXJlY3Rpb246IHVuZGVmaW5lZCxcblx0ICAgICAgICBzY2FsZTogMVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDb25zdHJhaW4gdGhlIGlucHV0IGFsb25nIGEgc3BlY2lmaWMgYXhpcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkgRElSRUNUSU9OIHtPYmplY3R9XG5cdCAgICAgKiBAcHJvcGVydHkgRElSRUNUSU9OLlgge051bWJlcn0gICB4LWF4aXNcblx0ICAgICAqIEBwcm9wZXJ0eSBESVJFQ1RJT04uWSB7TnVtYmVyfSAgIHktYXhpc1xuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICovXG5cdCAgICBNb3VzZUlucHV0LkRJUkVDVElPTiA9IHtcblx0ICAgICAgICBYIDogMCxcblx0ICAgICAgICBZIDogMVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gaGFuZGxlU3RhcnQoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgZGVsdGE7XG5cdCAgICAgICAgdmFyIHZlbG9jaXR5O1xuXG5cdCAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBkcmFnXG5cblx0ICAgICAgICB2YXIgeCA9IGV2ZW50LmNsaWVudFg7XG5cdCAgICAgICAgdmFyIHkgPSBldmVudC5jbGllbnRZO1xuXG5cdCAgICAgICAgdGhpcy5fcHJldkNvb3JkID0gW3gsIHldO1xuXHQgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gX25vdygpO1xuXHQgICAgICAgIHRoaXMuX2Rvd24gPSB0cnVlO1xuXHQgICAgICAgIHRoaXMuX21vdmUgPSBmYWxzZTtcblxuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpe1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdCAgICAgICAgICAgIGRlbHRhID0gMDtcblx0ICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBbMCwgMF07XG5cdCAgICAgICAgICAgIGRlbHRhID0gWzAsIDBdO1xuXHQgICAgICAgICAgICB2ZWxvY2l0eSA9IFswLCAwXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGF5bG9hZCA9IHRoaXMuX3BheWxvYWQ7XG5cdCAgICAgICAgcGF5bG9hZC5kZWx0YSA9IGRlbHRhO1xuXHQgICAgICAgIHBheWxvYWQudmFsdWUgPSB0aGlzLl9wb3NpdGlvbjtcblx0ICAgICAgICBwYXlsb2FkLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG5cdCAgICAgICAgcGF5bG9hZC5jbGllbnRYID0geDtcblx0ICAgICAgICBwYXlsb2FkLmNsaWVudFkgPSB5O1xuXHQgICAgICAgIHBheWxvYWQub2Zmc2V0WCA9IGV2ZW50Lm9mZnNldFg7XG5cdCAgICAgICAgcGF5bG9hZC5vZmZzZXRZID0gZXZlbnQub2Zmc2V0WTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ3N0YXJ0JywgcGF5bG9hZCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGhhbmRsZU1vdmUoZXZlbnQpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2Rvd24pIHJldHVybiBmYWxzZTtcblxuXHQgICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsZTtcblxuXHQgICAgICAgIHZhciBwcmV2Q29vcmQgPSB0aGlzLl9wcmV2Q29vcmQ7XG5cdCAgICAgICAgdmFyIHByZXZUaW1lID0gdGhpcy5fcHJldlRpbWU7XG5cblx0ICAgICAgICB2YXIgeCA9IGV2ZW50LmNsaWVudFg7XG5cdCAgICAgICAgdmFyIHkgPSBldmVudC5jbGllbnRZO1xuXG5cdCAgICAgICAgdmFyIGN1cnJUaW1lID0gX25vdygpO1xuXG5cdCAgICAgICAgdmFyIGRpZmZYID0gc2NhbGUgKiAoeCAtIHByZXZDb29yZFswXSk7XG5cdCAgICAgICAgdmFyIGRpZmZZID0gc2NhbGUgKiAoeSAtIHByZXZDb29yZFsxXSk7XG5cblx0ICAgICAgICB2YXIgZHQgPSBNYXRoLm1heChjdXJyVGltZSAtIHByZXZUaW1lLCBNSU5JTVVNX1RJQ0tfVElNRSk7IC8vIG1pbmltdW0gdGljayB0aW1lXG5cdCAgICAgICAgdmFyIGludl9kdCA9IDEgLyBkdDtcblxuXHQgICAgICAgIHZhciB2ZWxYID0gZGlmZlggKiBpbnZfZHQ7XG5cdCAgICAgICAgdmFyIHZlbFkgPSBkaWZmWSAqIGludl9kdDtcblxuXHQgICAgICAgIHZhciBuZXh0VmVsO1xuXHQgICAgICAgIHZhciBuZXh0RGVsdGE7XG5cblx0ICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gTW91c2VJbnB1dC5ESVJFQ1RJT04uWCkge1xuXHQgICAgICAgICAgICBuZXh0RGVsdGEgPSBkaWZmWDtcblx0ICAgICAgICAgICAgbmV4dFZlbCA9IHZlbFg7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uICs9IG5leHREZWx0YTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gTW91c2VJbnB1dC5ESVJFQ1RJT04uWSkge1xuXHQgICAgICAgICAgICBuZXh0RGVsdGEgPSBkaWZmWTtcblx0ICAgICAgICAgICAgbmV4dFZlbCA9IHZlbFk7XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uICs9IG5leHREZWx0YTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIG5leHREZWx0YSA9IFtkaWZmWCwgZGlmZlldO1xuXHQgICAgICAgICAgICBuZXh0VmVsID0gW3ZlbFgsIHZlbFldO1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblswXSArPSBuZXh0RGVsdGFbMF07XG5cdCAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uWzFdICs9IG5leHREZWx0YVsxXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGF5bG9hZCAgICAgID0gdGhpcy5fcGF5bG9hZDtcblx0ICAgICAgICBwYXlsb2FkLmRlbHRhICAgID0gbmV4dERlbHRhO1xuXHQgICAgICAgIHBheWxvYWQudmFsdWUgICAgPSB0aGlzLl9wb3NpdGlvbjtcblx0ICAgICAgICBwYXlsb2FkLnZlbG9jaXR5ID0gbmV4dFZlbDtcblx0ICAgICAgICBwYXlsb2FkLmNsaWVudFggID0geDtcblx0ICAgICAgICBwYXlsb2FkLmNsaWVudFkgID0geTtcblx0ICAgICAgICBwYXlsb2FkLm9mZnNldFggID0gZXZlbnQub2Zmc2V0WDtcblx0ICAgICAgICBwYXlsb2FkLm9mZnNldFkgID0gZXZlbnQub2Zmc2V0WTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ3VwZGF0ZScsIHBheWxvYWQpO1xuXG5cdCAgICAgICAgdGhpcy5fcHJldkNvb3JkID0gW3gsIHldO1xuXHQgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gY3VyclRpbWU7XG5cdCAgICAgICAgdGhpcy5fbW92ZSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGhhbmRsZUVuZCgpIHtcblx0ICAgICAgICBpZiAoIXRoaXMuX2Rvd24pIHJldHVybiBmYWxzZTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ2VuZCcsIHRoaXMuX3BheWxvYWQpO1xuXHQgICAgICAgIHRoaXMuX3ByZXZDb29yZCA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB0aGlzLl9wcmV2VGltZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB0aGlzLl9kb3duID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy5fbW92ZSA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBoYW5kbGVMZWF2ZShldmVudCkge1xuXHQgICAgICAgIGlmICghdGhpcy5fZG93biB8fCAhdGhpcy5fbW92ZSkgcmV0dXJuO1xuXG5cdCAgICAgICAgdmFyIGJvdW5kTW92ZSA9IGhhbmRsZU1vdmUuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYm91bmRFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHQgICAgICAgICAgICBoYW5kbGVFbmQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW92ZSk7XG5cdCAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBib3VuZEVuZCk7XG5cdCAgICAgICAgfS5iaW5kKHRoaXMsIGV2ZW50KTtcblxuXHQgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGJvdW5kTW92ZSk7XG5cdCAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGJvdW5kRW5kKTtcblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBNb3VzZUlucHV0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG4vKioqLyB9LFxuLyogNDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIFRvdWNoVHJhY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXHQgICAgdmFyIEV2ZW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdCAgICB2YXIgT3B0aW9uc01hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxuXHQgICAgdmFyIE1JTklNVU1fVElDS19USU1FID0gODtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBXcmFwcGVyIGZvciBET00gdG91Y2ggZXZlbnRzLiBDb252ZXJ0c1xuXHQgICAgICpcblx0ICAgICAqICAgICAgYHRvdWNoc3RhcnRgIC0+IGBzdGFydGBcblx0ICAgICAqICAgICAgYHRvdWNobW92ZWAgIC0+IGB1cGRhdGVgXG5cdCAgICAgKiAgICAgIGB0b3VjaGVuZGAgICAtPiBgZW5kYFxuXHQgICAgICpcblx0ICAgICAqIFRvdWNoSW5wdXQgZW1pdHMgdGhlc2UgZXZlbnRzIHdpdGggdGhlIGZvbGxvd2luZyBwYXlsb2FkIGRhdGE6XG5cdCAgICAgKlxuXHQgICAgICogICAgICBgdmFsdWVgICAgICAtIERpc3BsYWNlbWVudCBpbiBwaXhlbHMgZnJvbSBgdG91Y2hzdGFydGBcblx0ICAgICAqICAgICAgYGRlbHRhYCAgICAgLSBEaWZmZXJlbnRpYWwgaW4gcGl4ZWxzIGJldHdlZW4gc3VjY2Vzc2l2ZSBtb3VzZSBwb3NpdGlvbnNcblx0ICAgICAqICAgICAgYHZlbG9jaXR5YCAgLSBWZWxvY2l0eSBvZiBtb3VzZSBtb3ZlbWVudCBpbiBwaXhlbHMgcGVyIHNlY29uZFxuXHQgICAgICogICAgICBgY2xpZW50WGAgICAtIERPTSBldmVudCBjbGllbnRYIHByb3BlcnR5XG5cdCAgICAgKiAgICAgIGBjbGllbnRZYCAgIC0gRE9NIGV2ZW50IGNsaWVudFkgcHJvcGVydHlcblx0ICAgICAqICAgICAgYGNvdW50YCAgICAgLSBET00gZXZlbnQgZm9yIG51bWJlciBvZiBzaW11bHRhbmVvdXMgdG91Y2hlc1xuXHQgICAgICogICAgICBgdG91Y2hgICAgICAtIERPTSB0b3VjaCBldmVudCBpZGVudGlmaWVyXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciB0b3VjaElucHV0ID0gbmV3IFRvdWNoSW5wdXQoe1xuXHQgICAgICogICAgICAgICAgZGlyZWN0aW9uIDogVG91Y2hJbnB1dC5ESVJFQ1RJT04uWVxuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHRvdWNoSW5wdXQuc3Vic2NyaWJlKEVuZ2luZSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICB0b3VjaElucHV0Lm9uKCdzdGFydCcsIGZ1bmN0aW9uKHBheWxvYWQpe1xuXHQgICAgICogICAgICAgICAgLy8gZmlyZWQgb24gbW91c2UgZG93blxuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2coJ3N0YXJ0JywgcGF5bG9hZCk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdG91Y2hJbnB1dC5vbigndXBkYXRlJywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICAvLyBmaXJlZCBvbiBtb3VzZSBtb3ZlXG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygndXBkYXRlJywgcGF5bG9hZCk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgdG91Y2hJbnB1dC5vbignZW5kJywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICAvLyBmaXJlZCBvbiBtb3VzZSB1cFxuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2coJ2VuZCcsIHBheWxvYWQpO1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgVG91Y2hJbnB1dFxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAZXh0ZW5kcyBTdHJlYW1zLlNpbXBsZVN0cmVhbVxuXHQgICAgICogQHVzZXMgSW5wdXRzLlRvdWNoVHJhY2tlclxuXHQgICAgICogQHVzZXMgQ29yZS5PcHRpb25zTWFuYWdlclxuXHQgICAgICogQHBhcmFtIFtvcHRpb25zXSB7T2JqZWN0fSAgICAgICAgICAgICAgICBPcHRpb25zXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMuZGlyZWN0aW9uXSB7TnVtYmVyfSAgICAgIERpcmVjdGlvbiB0byBwcm9qZWN0IG1vdmVtZW50IG9udG8uXG5cdCAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgZm91bmQgaW4gVG91Y2hJbnB1dC5ESVJFQ1RJT04uXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMuc2NhbGU9MV0ge051bWJlcn0gICAgICAgIFNjYWxlIHRoZSByZXNwb25zZSB0byB0aGUgbW91c2Vcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gVG91Y2hJbnB1dChvcHRpb25zKSB7XG5cdCAgICAgICAgdGhpcy5vcHRpb25zID0gT3B0aW9uc01hbmFnZXIuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIHRoaXMuX3RvdWNoVHJhY2tlciA9IG5ldyBUb3VjaFRyYWNrZXIoKTtcblxuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRPdXRwdXRIYW5kbGVyKHRoaXMsIHRoaXMuX2V2ZW50T3V0cHV0KTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0SW5wdXRIYW5kbGVyKHRoaXMsIHRoaXMuX3RvdWNoVHJhY2tlcik7XG5cblx0ICAgICAgICB0aGlzLl90b3VjaFRyYWNrZXIub24oJ3RyYWNrc3RhcnQnLCBoYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl90b3VjaFRyYWNrZXIub24oJ3RyYWNrbW92ZScsIGhhbmRsZU1vdmUuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fdG91Y2hUcmFja2VyLm9uKCd0cmFja2VuZCcsIGhhbmRsZUVuZC5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgIHRoaXMuX3BheWxvYWQgPSB7XG5cdCAgICAgICAgICAgIGRlbHRhICAgIDogbnVsbCxcblx0ICAgICAgICAgICAgdmFsdWUgICAgOiBudWxsLFxuXHQgICAgICAgICAgICB2ZWxvY2l0eSA6IG51bGwsXG5cdCAgICAgICAgICAgIGNsaWVudFggIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgICBjbGllbnRZICA6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgY291bnQgICAgOiAwLFxuXHQgICAgICAgICAgICB0b3VjaCAgICA6IHVuZGVmaW5lZFxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG51bGw7XG5cdCAgICB9XG5cblx0ICAgIFRvdWNoSW5wdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaW1wbGVTdHJlYW0ucHJvdG90eXBlKTtcblx0ICAgIFRvdWNoSW5wdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG91Y2hJbnB1dDtcblxuXHQgICAgVG91Y2hJbnB1dC5ERUZBVUxUX09QVElPTlMgPSB7XG5cdCAgICAgICAgZGlyZWN0aW9uOiB1bmRlZmluZWQsXG5cdCAgICAgICAgc2NhbGU6IDFcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29uc3RyYWluIHRoZSBpbnB1dCBhbG9uZyBhIHNwZWNpZmljIGF4aXMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IERJUkVDVElPTiB7T2JqZWN0fVxuXHQgICAgICogQHByb3BlcnR5IERJUkVDVElPTi5YIHtOdW1iZXJ9ICAgeC1heGlzXG5cdCAgICAgKiBAcHJvcGVydHkgRElSRUNUSU9OLlkge051bWJlcn0gICB5LWF4aXNcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqL1xuXHQgICAgVG91Y2hJbnB1dC5ESVJFQ1RJT04gPSB7XG5cdCAgICAgICAgWCA6IDAsXG5cdCAgICAgICAgWSA6IDFcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0KGRhdGEpIHtcblx0ICAgICAgICB2YXIgdmVsb2NpdHk7XG5cdCAgICAgICAgdmFyIGRlbHRhO1xuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpe1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG5cdCAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcblx0ICAgICAgICAgICAgZGVsdGEgPSAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBbMCwgMF07XG5cdCAgICAgICAgICAgIHZlbG9jaXR5ID0gWzAsIDBdO1xuXHQgICAgICAgICAgICBkZWx0YSA9IFswLCAwXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGF5bG9hZCA9IHRoaXMuX3BheWxvYWQ7XG5cdCAgICAgICAgcGF5bG9hZC5kZWx0YSA9IGRlbHRhO1xuXHQgICAgICAgIHBheWxvYWQudmFsdWUgPSB0aGlzLl9wb3NpdGlvbjtcblx0ICAgICAgICBwYXlsb2FkLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG5cdCAgICAgICAgcGF5bG9hZC5jbGllbnRYID0gZGF0YS54O1xuXHQgICAgICAgIHBheWxvYWQuY2xpZW50WSA9IGRhdGEueTtcblx0ICAgICAgICBwYXlsb2FkLmNvdW50ID0gZGF0YS5jb3VudDtcblx0ICAgICAgICBwYXlsb2FkLnRvdWNoID0gZGF0YS5pZGVudGlmaWVyO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaGFuZGxlTW92ZShkYXRhKSB7XG5cdCAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxlO1xuXHQgICAgICAgIHZhciBoaXN0b3J5ID0gZGF0YS5oaXN0b3J5O1xuXG5cdCAgICAgICAgdmFyIGN1cnJIaXN0b3J5ID0gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xuXHQgICAgICAgIHZhciBwcmV2SGlzdG9yeSA9IGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAyXTtcblxuXHQgICAgICAgIHZhciBwcmV2VGltZSA9IHByZXZIaXN0b3J5LnRpbWVzdGFtcDtcblx0ICAgICAgICB2YXIgY3VyclRpbWUgPSBjdXJySGlzdG9yeS50aW1lc3RhbXA7XG5cblx0ICAgICAgICB2YXIgZGlmZlggPSBzY2FsZSAqIChjdXJySGlzdG9yeS54IC0gcHJldkhpc3RvcnkueCk7XG5cdCAgICAgICAgdmFyIGRpZmZZID0gc2NhbGUgKiAoY3Vyckhpc3RvcnkueSAtIHByZXZIaXN0b3J5LnkpO1xuXG5cdCAgICAgICAgdmFyIGR0ID0gTWF0aC5tYXgoY3VyclRpbWUgLSBwcmV2VGltZSwgTUlOSU1VTV9USUNLX1RJTUUpO1xuXHQgICAgICAgIHZhciBpbnZfZHQgPSAxIC8gZHQ7XG5cblx0ICAgICAgICB2YXIgdmVsWCA9IGRpZmZYICogaW52X2R0O1xuXHQgICAgICAgIHZhciB2ZWxZID0gZGlmZlkgKiBpbnZfZHQ7XG5cblx0ICAgICAgICB2YXIgbmV4dFZlbDtcblx0ICAgICAgICB2YXIgbmV4dERlbHRhO1xuXHQgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSBUb3VjaElucHV0LkRJUkVDVElPTi5YKSB7XG5cdCAgICAgICAgICAgIG5leHREZWx0YSA9IGRpZmZYO1xuXHQgICAgICAgICAgICBuZXh0VmVsID0gdmVsWDtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gKz0gZGlmZlg7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09IFRvdWNoSW5wdXQuRElSRUNUSU9OLlkpIHtcblx0ICAgICAgICAgICAgbmV4dERlbHRhID0gZGlmZlk7XG5cdCAgICAgICAgICAgIG5leHRWZWwgPSB2ZWxZO1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiArPSBuZXh0RGVsdGE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBuZXh0RGVsdGEgPSBbZGlmZlgsIGRpZmZZXTtcblx0ICAgICAgICAgICAgbmV4dFZlbCA9IFt2ZWxYLCB2ZWxZXTtcblx0ICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25bMF0gKz0gbmV4dERlbHRhWzBdO1xuXHQgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblsxXSArPSBuZXh0RGVsdGFbMV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHBheWxvYWQgPSB0aGlzLl9wYXlsb2FkO1xuXHQgICAgICAgIHBheWxvYWQuZGVsdGEgICAgICA9IG5leHREZWx0YTtcblx0ICAgICAgICBwYXlsb2FkLnZlbG9jaXR5ICAgPSBuZXh0VmVsO1xuXHQgICAgICAgIHBheWxvYWQudmFsdWUgICAgICA9IHRoaXMuX3Bvc2l0aW9uO1xuXHQgICAgICAgIHBheWxvYWQuY2xpZW50WCAgICA9IGRhdGEueDtcblx0ICAgICAgICBwYXlsb2FkLmNsaWVudFkgICAgPSBkYXRhLnk7XG5cdCAgICAgICAgcGF5bG9hZC5jb3VudCAgICAgID0gZGF0YS5jb3VudDtcblx0ICAgICAgICBwYXlsb2FkLnRvdWNoICAgICAgPSBkYXRhLmlkZW50aWZpZXI7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5lbWl0KCd1cGRhdGUnLCBwYXlsb2FkKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaGFuZGxlRW5kKGRhdGEpIHtcblx0ICAgICAgICB0aGlzLl9wYXlsb2FkLmNvdW50ID0gZGF0YS5jb3VudDtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5lbWl0KCdlbmQnLCB0aGlzLl9wYXlsb2FkKTtcblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBUb3VjaElucHV0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA0NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQvL1RPRE86IGRlcHJlY2F0ZSBpbiBmYXZvciBvZiBnZW5lcmljIGhpc3Rvcnkgc3RyZWFtXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIE9wdGlvbnNNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdCAgICB2YXIgRXZlbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHQgICAgdmFyIF9ub3cgPSBEYXRlLm5vdztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDYXRhbG9ndWVzIGEgaGlzdG9yeSBvZiB0b3VjaCBldmVudHMuIFVzZWZ1bCBmb3IgY3JlYXRpbmcgbW9yZSBjb21wbGV4XG5cdCAgICAgKiAgdG91Y2ggcmVjb2duaXRpb24gZm9yIGdlc3R1cmVzLiBDdXJyZW50bHkgb25seSB1c2VkIGJ5IFRvdWNoSW5wdXQgdG9cblx0ICAgICAqICB0cmFjayBwcmV2aW91cyB0b3VjaGVzIHRvIGNvbXB1dGUgdmVsb2NpdHkuXG5cdCAgICAgKlxuXHQgICAgICogVG91Y2hUcmFja2VyIGVtaXRzIHRoZXNlIGV2ZW50cyB3aXRoIHRoZSBmb2xsb3dpbmcgcGF5bG9hZCBkYXRhOlxuXHQgICAgICpcblx0ICAgICAqICAgICAgYHhgICAgICAgICAgICAgIC0gRGlzcGxhY2VtZW50IGluIHgtZGlyZWN0aW9uXG5cdCAgICAgKiAgICAgIGB5YCAgICAgICAgICAgICAtIERpc3BsYWNlbWVudCBpbiB5LWRpcmVjdGlvblxuXHQgICAgICogICAgICBgaWRlbnRpZmllcmAgICAgLSBET00gZXZlbnQgdG91Y2ggaWRlbnRpZmllclxuXHQgICAgICogICAgICBgdGltZXN0YW1wYCAgICAgLSBUaW1lc3RhbXBcblx0ICAgICAqICAgICAgYGNvdW50YCAgICAgICAgIC0gRE9NIGV2ZW50IGZvciBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzIHRvdWNoZXNcblx0ICAgICAqICAgICAgYGhpc3RvcnlgICAgICAgIC0gSGlzdG9yeSBvZiB0b3VjaGVzIGZvciB0aGUgZ2VzdHVyZVxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBUb3VjaFRyYWNrZXJcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQHByaXZhdGVcblx0ICAgICAqIEB1c2VzIENvcmUuT3B0aW9uc01hbmFnZXJcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9uc10ge09iamVjdH0gICAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLmxpbWl0XSB7TnVtYmVyfSAgICAgICAgICBOdW1iZXIgb2YgdG91Y2hlcyB0byByZWNvcmRcblx0ICAgICAqL1xuXG5cdCAgICBmdW5jdGlvbiBUb3VjaFRyYWNrZXIob3B0aW9ucykge1xuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IE9wdGlvbnNNYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0ICAgICAgICB0aGlzLnRvdWNoSGlzdG9yeSA9IHt9O1xuXHQgICAgICAgIHRoaXMuX2lzVG91Y2hlZCA9IGZhbHNlO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblxuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRJbnB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRJbnB1dCk7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRPdXRwdXQpO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbigndG91Y2hzdGFydCcsIF9oYW5kbGVTdGFydC5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCd0b3VjaG1vdmUnLCBfaGFuZGxlTW92ZS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCd0b3VjaGVuZCcsIF9oYW5kbGVFbmQuYmluZCh0aGlzKSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbigndG91Y2hjYW5jZWwnLCBfaGFuZGxlRW5kLmJpbmQodGhpcykpO1xuXHQgICAgfVxuXG5cdCAgICBUb3VjaFRyYWNrZXIuREVGQVVMVF9PUFRJT05TID0ge1xuXHQgICAgICAgIGxpbWl0IDogMSAvLyBudW1iZXIgb2Ygc2ltdWx0YW5lb3VzIHRvdWNoZXNcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmVjb3JkIHRvdWNoIGRhdGEsIGlmIHNlbGVjdGl2ZSBpcyBmYWxzZS5cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAbWV0aG9kIHRyYWNrXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0b3VjaCBkYXRhXG5cdCAgICAgKi9cblx0ICAgIFRvdWNoVHJhY2tlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiB0cmFjayhkYXRhKSB7XG5cdCAgICAgICAgdGhpcy50b3VjaEhpc3RvcnlbZGF0YS5pZGVudGlmaWVyXSA9IFtkYXRhXTtcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIF90aW1lc3RhbXBUb3VjaCh0b3VjaCwgZXZlbnQsIGhpc3RvcnkpIHtcblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB4OiB0b3VjaC5jbGllbnRYLFxuXHQgICAgICAgICAgICB5OiB0b3VjaC5jbGllbnRZLFxuXHQgICAgICAgICAgICBpZGVudGlmaWVyIDogdG91Y2guaWRlbnRpZmllcixcblx0ICAgICAgICAgICAgdGltZXN0YW1wOiBfbm93KCksXG5cdCAgICAgICAgICAgIGNvdW50OiBldmVudC50b3VjaGVzLmxlbmd0aCxcblx0ICAgICAgICAgICAgaGlzdG9yeTogaGlzdG9yeVxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIF9oYW5kbGVTdGFydChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5saW1pdCkgcmV0dXJuO1xuXHQgICAgICAgIHRoaXMuX2lzVG91Y2hlZCA9IHRydWU7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldO1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IF90aW1lc3RhbXBUb3VjaCh0b3VjaCwgZXZlbnQsIG51bGwpO1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5lbWl0KCd0cmFja3N0YXJ0JywgZGF0YSk7XG5cdCAgICAgICAgICAgIGlmICghdGhpcy50b3VjaEhpc3RvcnlbdG91Y2guaWRlbnRpZmllcl0pIHRoaXMudHJhY2soZGF0YSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfaGFuZGxlTW92ZShldmVudCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG5cdCAgICAgICAgICAgIHZhciBoaXN0b3J5ID0gdGhpcy50b3VjaEhpc3RvcnlbdG91Y2guaWRlbnRpZmllcl07XG5cdCAgICAgICAgICAgIGlmIChoaXN0b3J5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF90aW1lc3RhbXBUb3VjaCh0b3VjaCwgZXZlbnQsIGhpc3RvcnkpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b3VjaEhpc3RvcnlbdG91Y2guaWRlbnRpZmllcl0ucHVzaChkYXRhKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ3RyYWNrbW92ZScsIGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfaGFuZGxlRW5kKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9pc1RvdWNoZWQpIHJldHVybjtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG5cdCAgICAgICAgICAgIHZhciBoaXN0b3J5ID0gdGhpcy50b3VjaEhpc3RvcnlbdG91Y2guaWRlbnRpZmllcl07XG5cdCAgICAgICAgICAgIGlmIChoaXN0b3J5KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF90aW1lc3RhbXBUb3VjaCh0b3VjaCwgZXZlbnQsIGhpc3RvcnkpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgndHJhY2tlbmQnLCBkYXRhKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRvdWNoSGlzdG9yeVt0b3VjaC5pZGVudGlmaWVyXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2lzVG91Y2hlZCA9IGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFRvdWNoVHJhY2tlcjtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0LyogRG9jdW1lbnRhdGlvbiBpbiBwcm9ncmVzcy4gTWF5IGJlIG91dGRhdGVkLiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBFdmVudEhhbmRsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHQgICAgdmFyIE9wdGlvbnNNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdCAgICB2YXIgVGltZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXHQgICAgdmFyIE1JTklNVU1fVElDS19USU1FID0gODtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBXcmFwcGVyIGZvciBET00gd2hlZWwvbW91c2V3aGVlbCBldmVudHMuIENvbnZlcnRzIGBzY3JvbGxgIGV2ZW50c1xuXHQgICAgICogIHRvIGBzdGFydGAsIGB1cGRhdGVgIGFuZCBgZW5kYCBldmVudHMgYW5kIGVtaXRzIHRoZW0gd2l0aCB0aGUgcGF5bG9hZDpcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGB2YWx1ZWAgICAgIC0gU2Nyb2xsIGRpc3BsYWNlbWVudCBpbiBwaXhlbHMgZnJvbSBzdGFydFxuXHQgICAgICogICAgICBgZGVsdGFgICAgICAtIFNjcm9sbCBkaWZmZXJlbnRpYWwgaW4gcGl4ZWxzIGJldHdlZW4gc3Vic2VxdWVudCBldmVudHNcblx0ICAgICAqICAgICAgYHZlbG9jaXR5YCAgLSBWZWxvY2l0eSBvZiBzY3JvbGxcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHNjcm9sbElucHV0ID0gbmV3IFNjcm9sbElucHV0KCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBzY3JvbGxJbnB1dC5zdWJzY3JpYmUoRW5naW5lKSAvLyBsaXN0ZW5zIG9uIGB3aW5kb3dgIGV2ZW50c1xuXHQgICAgICpcblx0ICAgICAqICAgICAgc2Nyb2xsSW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBzY3JvbGxJbnB1dC5vbigndXBkYXRlJywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygndXBkYXRlJywgcGF5bG9hZCk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgc2Nyb2xsSW5wdXQub24oJ2VuZCcsIGZ1bmN0aW9uKHBheWxvYWQpe1xuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2coJ2VuZCcsIHBheWxvYWQpO1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgU2Nyb2xsSW5wdXRcblx0ICAgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TaW1wbGVTdHJlYW1cblx0ICAgICAqIEB1c2VzIElucHV0cy5Ub3VjaFRyYWNrZXJcblx0ICAgICAqIEB1c2VzIENvcmUuT3B0aW9uc01hbmFnZXJcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9uc10ge09iamVjdH0gICAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLmRpcmVjdGlvbl0ge051bWJlcn0gICAgICBEaXJlY3Rpb24gdG8gcHJvamVjdCBtb3ZlbWVudCBvbnRvLlxuXHQgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zIGZvdW5kIGluIFRvdWNoSW5wdXQuRElSRUNUSU9OLlxuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnNjYWxlPTFdIHtOdW1iZXJ9ICAgICAgICBTY2FsZSB0aGUgcmVzcG9uc2UgdG8gdGhlIG1vdXNlXG5cdCAgICAgKi9cblx0ICAgIGZ1bmN0aW9uIFNjcm9sbElucHV0KG9wdGlvbnMpIHtcblx0ICAgICAgICB0aGlzLm9wdGlvbnMgPSBPcHRpb25zTWFuYWdlci5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdCAgICAgICAgdGhpcy5fcGF5bG9hZCA9IHtcblx0ICAgICAgICAgICAgZGVsdGEgICAgOiBudWxsLFxuXHQgICAgICAgICAgICB2YWx1ZSAgICA6IG51bGwsXG5cdCAgICAgICAgICAgIHZlbG9jaXR5IDogbnVsbFxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0ID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldElucHV0SGFuZGxlcih0aGlzLCB0aGlzLl9ldmVudElucHV0KTtcblx0ICAgICAgICBFdmVudEhhbmRsZXIuc2V0T3V0cHV0SGFuZGxlcih0aGlzLCB0aGlzLl9ldmVudE91dHB1dCk7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCdtb3VzZXdoZWVsJywgaGFuZGxlTW92ZS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCd3aGVlbCcsIGhhbmRsZU1vdmUuYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl92YWx1ZSA9ICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9uID09PSB1bmRlZmluZWQpID8gWzAsMF0gOiAwO1xuXHQgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIHRoaXMuX2luUHJvZ3Jlc3MgPSBmYWxzZTtcblxuXHQgICAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgICB0aGlzLl9zY3JvbGxFbmQgPSBUaW1lci5kZWJvdW5jZShmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICBzZWxmLl9pblByb2dyZXNzID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHNlbGYuX2V2ZW50T3V0cHV0LmVtaXQoJ2VuZCcsIHNlbGYuX3BheWxvYWQpO1xuXHQgICAgICAgIH0sIDEwMCk7XG5cdCAgICB9XG5cblx0ICAgIFNjcm9sbElucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBTY3JvbGxJbnB1dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY3JvbGxJbnB1dDtcblxuXHQgICAgU2Nyb2xsSW5wdXQuREVGQVVMVF9PUFRJT05TID0ge1xuXHQgICAgICAgIGRpcmVjdGlvbjogdW5kZWZpbmVkLFxuXHQgICAgICAgIHNjYWxlOiAxXG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbnN0cmFpbiB0aGUgaW5wdXQgYWxvbmcgYSBzcGVjaWZpYyBheGlzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSBESVJFQ1RJT04ge09iamVjdH1cblx0ICAgICAqIEBwcm9wZXJ0eSBESVJFQ1RJT04uWCB7TnVtYmVyfSAgIHgtYXhpc1xuXHQgICAgICogQHByb3BlcnR5IERJUkVDVElPTi5ZIHtOdW1iZXJ9ICAgeS1heGlzXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKi9cblx0ICAgIFNjcm9sbElucHV0LkRJUkVDVElPTiA9IHtcblx0ICAgICAgICBYIDogMCxcblx0ICAgICAgICBZIDogMVxuXHQgICAgfTtcblxuXHQgICAgdmFyIF9ub3cgPSBEYXRlLm5vdztcblxuXHQgICAgZnVuY3Rpb24gaGFuZGxlTW92ZShldmVudCkge1xuXHQgICAgICAgIC8vIHByZXZlbnQgc2Nyb2xsaW5nIG9mIHBhZ2Ugc2ltdWx0YW5lb3VzbHlcblx0ICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdCAgICAgICAgaWYgKCF0aGlzLl9pblByb2dyZXNzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gKHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkgPyBbMCwwXSA6IDA7XG5cdCAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLl9wYXlsb2FkO1xuXHQgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdGhpcy5fdmFsdWU7XG5cdCAgICAgICAgICAgIHBheWxvYWQuY2xpZW50WCA9IGV2ZW50LmNsaWVudFg7XG5cdCAgICAgICAgICAgIHBheWxvYWQuY2xpZW50WSA9IGV2ZW50LmNsaWVudFk7XG5cdCAgICAgICAgICAgIHBheWxvYWQub2Zmc2V0WCA9IGV2ZW50Lm9mZnNldFg7XG5cdCAgICAgICAgICAgIHBheWxvYWQub2Zmc2V0WSA9IGV2ZW50Lm9mZnNldFk7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgICAgICAgICAgdGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY3VyclRpbWUgPSBfbm93KCk7XG5cdCAgICAgICAgdmFyIHByZXZUaW1lID0gdGhpcy5fcHJldlRpbWUgfHwgY3VyclRpbWU7XG5cblx0ICAgICAgICB2YXIgZGlmZlggPSAoZXZlbnQud2hlZWxEZWx0YVggIT09IHVuZGVmaW5lZCkgPyBldmVudC53aGVlbERlbHRhWCA6IC1ldmVudC5kZWx0YVg7XG5cdCAgICAgICAgdmFyIGRpZmZZID0gKGV2ZW50LndoZWVsRGVsdGFZICE9PSB1bmRlZmluZWQpID8gZXZlbnQud2hlZWxEZWx0YVkgOiAtZXZlbnQuZGVsdGFZO1xuXG5cdCAgICAgICAgdmFyIGludkRlbHRhVCA9IDEgLyBNYXRoLm1heChjdXJyVGltZSAtIHByZXZUaW1lLCBNSU5JTVVNX1RJQ0tfVElNRSk7IC8vIG1pbmltdW0gdGljayB0aW1lXG5cdCAgICAgICAgdGhpcy5fcHJldlRpbWUgPSBjdXJyVGltZTtcblxuXHQgICAgICAgIHZhciB2ZWxYID0gZGlmZlggKiBpbnZEZWx0YVQ7XG5cdCAgICAgICAgdmFyIHZlbFkgPSBkaWZmWSAqIGludkRlbHRhVDtcblxuXHQgICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsZTtcblx0ICAgICAgICB2YXIgbmV4dFZlbDtcblx0ICAgICAgICB2YXIgbmV4dERlbHRhO1xuXG5cdCAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09IFNjcm9sbElucHV0LkRJUkVDVElPTi5YKSB7XG5cdCAgICAgICAgICAgIG5leHREZWx0YSA9IHNjYWxlICogZGlmZlg7XG5cdCAgICAgICAgICAgIG5leHRWZWwgPSBzY2FsZSAqIHZlbFg7XG5cdCAgICAgICAgICAgIHRoaXMuX3ZhbHVlICs9IG5leHREZWx0YTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmRpcmVjdGlvbiA9PT0gU2Nyb2xsSW5wdXQuRElSRUNUSU9OLlkpIHtcblx0ICAgICAgICAgICAgbmV4dERlbHRhID0gc2NhbGUgKiBkaWZmWTtcblx0ICAgICAgICAgICAgbmV4dFZlbCA9IHNjYWxlICogdmVsWTtcblx0ICAgICAgICAgICAgdGhpcy5fdmFsdWUgKz0gbmV4dERlbHRhO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbmV4dERlbHRhID0gW3NjYWxlICogZGlmZlgsIHNjYWxlICogZGlmZlldO1xuXHQgICAgICAgICAgICBuZXh0VmVsID0gW3NjYWxlICogdmVsWCwgc2NhbGUgKiB2ZWxZXTtcblx0ICAgICAgICAgICAgdGhpcy5fdmFsdWVbMF0gKz0gbmV4dERlbHRhWzBdO1xuXHQgICAgICAgICAgICB0aGlzLl92YWx1ZVsxXSArPSBuZXh0RGVsdGFbMV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHBheWxvYWQgPSB0aGlzLl9wYXlsb2FkO1xuXHQgICAgICAgIHBheWxvYWQuZGVsdGEgICAgPSBuZXh0RGVsdGE7XG5cdCAgICAgICAgcGF5bG9hZC52ZWxvY2l0eSA9IG5leHRWZWw7XG5cdCAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgndXBkYXRlJywgcGF5bG9hZCk7XG5cblx0ICAgICAgICAvLyBkZWJvdW5jZSBgZW5kYCBldmVudFxuXHQgICAgICAgIHRoaXMuX3Njcm9sbEVuZCgpO1xuXHQgICAgfVxuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFNjcm9sbElucHV0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA0NiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgVHdvRmluZ2VySW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblx0ICAgIHZhciBPcHRpb25zTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERldGVjdHMgdHdvLWZpbmdlciBwaW5jaGluZyBtb3Rpb24gYW5kIGVtaXRzIGBzdGFydGAsIGB1cGRhdGVgIGFuZFxuXHQgICAgICogIGBlbmRgIGV2ZW50cyB3aXRoIHRoZSBwYXlsb2FkIGRhdGE6XG5cdCAgICAgKlxuXHQgICAgICogICAgICBgdmFsdWVgICAgICAgICAgLSBEaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gdG91Y2hlc1xuXHQgICAgICogICAgICBgZGVsdGFgICAgICAgICAgLSBEaWZmZXJlbnRpYWwgaW4gc3VjY2Vzc2l2ZSBkaXN0YW5jZXNcblx0ICAgICAqICAgICAgYHZlbG9jaXR5YCAgICAgIC0gUmVsYXRpdmUgdmVsb2NpdHkgYmV0d2VlbiB0d28gdG91Y2hlc1xuXHQgICAgICogICAgICBgZGlzcGxhY2VtZW50YCAgLSBUb3RhbCBhY2N1bXVsYXRlZCBkaXNwbGFjZW1lbnRcblx0ICAgICAqICAgICAgYGNlbnRlcmAgICAgICAgIC0gTWlkcG9pbnQgYmV0d2VlbiB0aGUgdHdvIHRvdWNoZXNcblx0ICAgICAqICAgICAgYHRvdWNoZXNgICAgICAgIC0gQXJyYXkgb2YgRE9NIGV2ZW50IHRvdWNoIGlkZW50aWZpZXJzXG5cdCAgICAgKlxuXHQgICAgICogIE5vdGU6IFVubGlrZSBQaW5jaElucHV0LCB3aGljaCBwcm9kdWNlcyBwaXhlbCB2YWx1ZXMgb2YgZGlzcGxhY2VtZW50XG5cdCAgICAgKiAgYmV0d2VlbiB0d28gdG91Y2hlcywgU2NhbGVJbnB1dCBwcm9kdWNlcyBkaW1lbnNpb25sZXNzIHZhbHVlcyBjb3JyZXNwb25kaW5nXG5cdCAgICAgKiAgdG8gc2NhbGluZyBvZiB0aGUgaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0b3VjaGVzLiBGb3IgZXhhbXBsZSwgaWYgdHdvXG5cdCAgICAgKiAgdG91Y2hlcyBiZWdpbiBhdCAxMDAgcHggYXBhcnQsIGFuZCBtb3ZlIHRvIDIwMCBweCBhcGFydCwgU2NhbGVJbnB1dCB3aWxsIGVtaXRcblx0ICAgICAqICBhIHZhbHVlIG9mIDIgKGZvciAyeCBtYWduaWZpY2F0aW9uKSwgd2hpbGUgUGluY2hJbnB1dCB3aWxsIGVtaXQgYSB2YWx1ZSBvZiAxMDAuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBzY2FsZUlucHV0ID0gbmV3IFNjYWxlSW5wdXQoKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHNjYWxlSW5wdXQuc3Vic2NyaWJlKEVuZ2luZSkgLy8gbGlzdGVucyBvbiBgd2luZG93YCBldmVudHNcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHNjYWxlSW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBzY2FsZUlucHV0Lm9uKCd1cGRhdGUnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGUnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBzY2FsZUlucHV0Lm9uKCdlbmQnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCdlbmQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIFNjYWxlSW5wdXRcblx0ICAgICAqIEBleHRlbmRzIElucHV0cy5Ud29GaW5nZXJJbnB1dFxuXHQgICAgICogQHVzZXMgQ29yZS5PcHRpb25zTWFuYWdlclxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnNjYWxlPTFdIHtOdW1iZXJ9ICAgIFNjYWxlIHRoZSByZXNwb25zZSB0byBwaW5jaFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBTY2FsZUlucHV0KG9wdGlvbnMpIHtcblx0ICAgICAgICBUd29GaW5nZXJJbnB1dC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgdGhpcy5vcHRpb25zID0gT3B0aW9uc01hbmFnZXIuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHQgICAgICAgIHRoaXMuX3N0YXJ0RGlzdCA9IDA7XG5cdCAgICAgICAgdGhpcy5fc2NhbGVGYWN0b3IgPSAxO1xuXHQgICAgfVxuXG5cdCAgICBTY2FsZUlucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHdvRmluZ2VySW5wdXQucHJvdG90eXBlKTtcblx0ICAgIFNjYWxlSW5wdXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NhbGVJbnB1dDtcblxuXHQgICAgU2NhbGVJbnB1dC5ERUZBVUxUX09QVElPTlMgPSB7XG5cdCAgICAgICAgc2NhbGUgOiAxXG5cdCAgICB9O1xuXG5cdCAgICAvLyBoYW5kbGVzIGluaXRpYWwgdG91Y2ggb2YgdHdvIGZpbmdlcnNcblx0ICAgIFNjYWxlSW5wdXQucHJvdG90eXBlLl9zdGFydFVwZGF0ZSA9IGZ1bmN0aW9uIF9zdGFydFVwZGF0ZShldmVudCkge1xuXHQgICAgICAgIHRoaXMuX3N0YXJ0RGlzdCA9IFR3b0ZpbmdlcklucHV0LmNhbGN1bGF0ZURpc3RhbmNlKHRoaXMucG9zQSwgdGhpcy5wb3NCKTtcblx0ICAgICAgICB2YXIgY2VudGVyID0gVHdvRmluZ2VySW5wdXQuY2FsY3VsYXRlQ2VudGVyKHRoaXMucG9zQSwgdGhpcy5wb3NCKTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ3N0YXJ0Jywge1xuXHQgICAgICAgICAgICBjb3VudDogZXZlbnQudG91Y2hlcy5sZW5ndGgsXG5cdCAgICAgICAgICAgIHRvdWNoZXM6IFt0aGlzLnRvdWNoQUlkLCB0aGlzLnRvdWNoQklkXSxcblx0ICAgICAgICAgICAgZGlzdGFuY2U6IHRoaXMuX3N0YXJ0RGlzdCxcblx0ICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIC8vIGhhbmRsZXMgbW92ZW1lbnQgb2YgdHdvIGZpbmdlcnNcblx0ICAgIFNjYWxlSW5wdXQucHJvdG90eXBlLl9tb3ZlVXBkYXRlID0gZnVuY3Rpb24gX21vdmVVcGRhdGUoZGlmZlRpbWUpIHtcblx0ICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGU7XG5cblx0ICAgICAgICB2YXIgY3VyckRpc3QgPSBUd29GaW5nZXJJbnB1dC5jYWxjdWxhdGVEaXN0YW5jZSh0aGlzLnBvc0EsIHRoaXMucG9zQik7XG5cdCAgICAgICAgdmFyIGNlbnRlciA9IFR3b0ZpbmdlcklucHV0LmNhbGN1bGF0ZUNlbnRlcih0aGlzLnBvc0EsIHRoaXMucG9zQik7XG5cblx0ICAgICAgICB2YXIgZGVsdGEgPSAoY3VyckRpc3QgLSB0aGlzLl9zdGFydERpc3QpIC8gdGhpcy5fc3RhcnREaXN0O1xuXHQgICAgICAgIHZhciBuZXdTY2FsZUZhY3RvciA9IE1hdGgubWF4KDEgKyBzY2FsZSAqIGRlbHRhLCAwKTtcblx0ICAgICAgICB2YXIgdmVsb1NjYWxlID0gKG5ld1NjYWxlRmFjdG9yIC0gdGhpcy5fc2NhbGVGYWN0b3IpIC8gZGlmZlRpbWU7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5lbWl0KCd1cGRhdGUnLCB7XG5cdCAgICAgICAgICAgIGRlbHRhIDogZGVsdGEsXG5cdCAgICAgICAgICAgIHNjYWxlOiBuZXdTY2FsZUZhY3Rvcixcblx0ICAgICAgICAgICAgdmVsb2NpdHk6IHZlbG9TY2FsZSxcblx0ICAgICAgICAgICAgZGlzdGFuY2U6IGN1cnJEaXN0LFxuXHQgICAgICAgICAgICBjZW50ZXIgOiBjZW50ZXIsXG5cdCAgICAgICAgICAgIHRvdWNoZXM6IFt0aGlzLnRvdWNoQUlkLCB0aGlzLnRvdWNoQklkXVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBuZXdTY2FsZUZhY3Rvcjtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gU2NhbGVJbnB1dDtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG5cdCAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcblx0ICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cblx0ICpcblx0ICogQGxpY2Vuc2UgTVBMIDIuMFxuXHQgKiBAY29weXJpZ2h0IEZhbW91cyBJbmR1c3RyaWVzLCBJbmMuIDIwMTRcblx0ICovXG5cblx0LyogTW9kaWZpZWQgd29yayBjb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0Ly8gVE9ETzogZW1pdCBzdGFydCwgdXBkYXRlLCBlbmQgZXZlbnRzIGluc3RlYWRcblx0Ly8gb2YgY2FsbGluZyBwcm90ZWN0ZWQgX3N0YXJ0VXBkYXRlIGV0YyBtZXRob2RzXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIEV2ZW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cdCAgICB2YXIgU2ltcGxlU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblx0ICAgIHZhciBfbm93ID0gRGF0ZS5ub3c7XG5cblx0ICAgIC8qKlxuXHQgICAgICogR2VuZXJhbGl6ZXMgaGFuZGxpbmcgb2YgdHdvLWZpbmdlciB0b3VjaCBldmVudHMuXG5cdCAgICAgKiAgSGVscGVyIHRvIFBpbmNoSW5wdXQsIFJvdGF0ZUlucHV0LCBhbmQgU2NhbGVJbnB1dC5cblx0ICAgICAqICBUaGlzIGNsYXNzIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gYW5kIG5vdCB1c2VkIGRpcmVjdGx5LlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBUd29GaW5nZXJJbnB1dFxuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TaW1wbGVTdHJlYW1cblx0ICAgICAqIEBwcml2YXRlXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gVHdvRmluZ2VySW5wdXQoKSB7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblx0ICAgICAgICB0aGlzLl9ldmVudE91dHB1dCA9IG5ldyBFdmVudEhhbmRsZXIoKTtcblxuXHQgICAgICAgIEV2ZW50SGFuZGxlci5zZXRJbnB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRJbnB1dCk7XG5cdCAgICAgICAgRXZlbnRIYW5kbGVyLnNldE91dHB1dEhhbmRsZXIodGhpcywgdGhpcy5fZXZlbnRPdXRwdXQpO1xuXG5cdCAgICAgICAgdGhpcy50b3VjaEFFbmFibGVkID0gZmFsc2U7XG5cdCAgICAgICAgdGhpcy50b3VjaEFJZCA9IDA7XG5cdCAgICAgICAgdGhpcy5wb3NBID0gbnVsbDtcblx0ICAgICAgICB0aGlzLnRpbWVzdGFtcEEgPSAwO1xuXHQgICAgICAgIHRoaXMudG91Y2hCRW5hYmxlZCA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMudG91Y2hCSWQgPSAwO1xuXHQgICAgICAgIHRoaXMucG9zQiA9IG51bGw7XG5cdCAgICAgICAgdGhpcy50aW1lc3RhbXBCID0gMDtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVN0YXJ0LmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW92ZS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlRW5kLmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oJ3RvdWNoY2FuY2VsJywgdGhpcy5oYW5kbGVFbmQuYmluZCh0aGlzKSk7XG5cdCAgICB9XG5cblx0ICAgIFR3b0ZpbmdlcklucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBUd29GaW5nZXJJbnB1dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUd29GaW5nZXJJbnB1dDtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDYWxjdWxhdGVzIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB0b3VjaGVzIHJlbGF0aXZlIHRvIFswLDFdLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgY2FsY3VsYXRlQW5nbGVcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqIEBwYXJhbSBwb3NBIHtBcnJheX0gIEZpcnN0IHRvdWNoIGxvY2F0aW9uICh4LHkpXG5cdCAgICAgKiBAcGFyYW0gcG9zQiB7QXJyYXl9ICBTZWNvbmQgdG91Y2ggbG9jYXRpb24gKHgseSlcblx0ICAgICAqIEByZXR1cm4ge051bWJlcn1cblx0ICAgICAqL1xuXHQgICAgVHdvRmluZ2VySW5wdXQuY2FsY3VsYXRlQW5nbGUgPSBmdW5jdGlvbihwb3NBLCBwb3NCKSB7XG5cdCAgICAgICAgdmFyIGRpZmZYID0gcG9zQlswXSAtIHBvc0FbMF07XG5cdCAgICAgICAgdmFyIGRpZmZZID0gcG9zQlsxXSAtIHBvc0FbMV07XG5cdCAgICAgICAgcmV0dXJuIE1hdGguYXRhbjIoZGlmZlksIGRpZmZYKTtcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdG91Y2hlcy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIGNhbGN1bGF0ZURpc3RhbmNlXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gcG9zQSB7QXJyYXl9ICBGaXJzdCB0b3VjaCBsb2NhdGlvbiAoeCx5KVxuXHQgICAgICogQHBhcmFtIHBvc0Ige0FycmF5fSAgU2Vjb25kIHRvdWNoIGxvY2F0aW9uICh4LHkpXG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAgICAgKi9cblx0ICAgIFR3b0ZpbmdlcklucHV0LmNhbGN1bGF0ZURpc3RhbmNlID0gZnVuY3Rpb24ocG9zQSwgcG9zQikge1xuXHQgICAgICAgIHZhciBkaWZmWCA9IHBvc0JbMF0gLSBwb3NBWzBdO1xuXHQgICAgICAgIHZhciBkaWZmWSA9IHBvc0JbMV0gLSBwb3NBWzFdO1xuXHQgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZGlmZlggKiBkaWZmWCArIGRpZmZZICogZGlmZlkpO1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDYWxjdWxhdGVzIHRoZSBtaWRwb2ludCBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgY2FsY3VsYXRlQ2VudGVyXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKiBAcGFyYW0gcG9zQSB7QXJyYXl9ICBGaXJzdCB0b3VjaCBsb2NhdGlvbiAoeCx5KVxuXHQgICAgICogQHBhcmFtIHBvc0Ige0FycmF5fSAgU2Vjb25kIHRvdWNoIGxvY2F0aW9uICh4LHkpXG5cdCAgICAgKiBAcmV0dXJuIHtBcnJheX1cblx0ICAgICAqL1xuXHQgICAgVHdvRmluZ2VySW5wdXQuY2FsY3VsYXRlQ2VudGVyID0gZnVuY3Rpb24ocG9zQSwgcG9zQikge1xuXHQgICAgICAgIHJldHVybiBbKHBvc0FbMF0gKyBwb3NCWzBdKSAvIDIuMCwgKHBvc0FbMV0gKyBwb3NCWzFdKSAvIDIuMF07XG5cdCAgICB9O1xuXG5cdCAgICAvLyBwcml2YXRlXG5cdCAgICBUd29GaW5nZXJJbnB1dC5wcm90b3R5cGUuaGFuZGxlU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVTdGFydChldmVudCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG5cdCAgICAgICAgICAgIGlmICghdGhpcy50b3VjaEFFbmFibGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQUlkID0gdG91Y2guaWRlbnRpZmllcjtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBRW5hYmxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnBvc0EgPSBbdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wQSA9IF9ub3coKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b3VjaEJFbmFibGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQklkID0gdG91Y2guaWRlbnRpZmllcjtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG91Y2hCRW5hYmxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnBvc0IgPSBbdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wQiA9IF9ub3coKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VXBkYXRlKGV2ZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8vIHByaXZhdGVcblx0ICAgIFR3b0ZpbmdlcklucHV0LnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW92ZShldmVudCkge1xuXHQgICAgICAgIGlmICghKHRoaXMudG91Y2hBRW5hYmxlZCAmJiB0aGlzLnRvdWNoQkVuYWJsZWQpKSByZXR1cm47XG5cdCAgICAgICAgdmFyIHByZXZUaW1lQSA9IHRoaXMudGltZXN0YW1wQTtcblx0ICAgICAgICB2YXIgcHJldlRpbWVCID0gdGhpcy50aW1lc3RhbXBCO1xuXHQgICAgICAgIHZhciBkaWZmVGltZTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldO1xuXHQgICAgICAgICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy50b3VjaEFJZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wb3NBID0gW3RvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWV07XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcEEgPSBfbm93KCk7XG5cdCAgICAgICAgICAgICAgICBkaWZmVGltZSA9IHRoaXMudGltZXN0YW1wQSAtIHByZXZUaW1lQTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnRvdWNoQklkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnBvc0IgPSBbdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudGltZXN0YW1wQiA9IF9ub3coKTtcblx0ICAgICAgICAgICAgICAgIGRpZmZUaW1lID0gdGhpcy50aW1lc3RhbXBCIC0gcHJldlRpbWVCO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChkaWZmVGltZSkgdGhpcy5fbW92ZVVwZGF0ZShkaWZmVGltZSk7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBwcml2YXRlXG5cdCAgICBUd29GaW5nZXJJbnB1dC5wcm90b3R5cGUuaGFuZGxlRW5kID0gZnVuY3Rpb24gaGFuZGxlRW5kKGV2ZW50KSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXTtcblx0ICAgICAgICAgICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMudG91Y2hBSWQgfHwgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy50b3VjaEJJZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMudG91Y2hBRW5hYmxlZCAmJiB0aGlzLnRvdWNoQkVuYWJsZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudE91dHB1dC5lbWl0KCdlbmQnLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoZXMgOiBbdGhpcy50b3VjaEFJZCwgdGhpcy50b3VjaEJJZF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlICAgOiB0aGlzLl9hbmdsZVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy50b3VjaEFFbmFibGVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvdWNoQUlkID0gMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudG91Y2hCRW5hYmxlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b3VjaEJJZCA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFR3b0ZpbmdlcklucHV0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA0OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgVHdvRmluZ2VySW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblx0ICAgIHZhciBPcHRpb25zTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERldGVjdHMgdHdvLWZpbmdlciByb3RhdGlvbmFsIG1vdGlvbiBhbmQgZW1pdHMgYHN0YXJ0YCwgYHVwZGF0ZWAgYW5kXG5cdCAgICAgKiAgYGVuZGAgZXZlbnRzIHdpdGggdGhlIHBheWxvYWQgZGF0YTpcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGB2YWx1ZWAgICAgICAgICAtIEFuZ2xlIG9mIHJvdGF0aW9uXG5cdCAgICAgKiAgICAgIGBkZWx0YWAgICAgICAgICAtIERpZmZlcmVudGlhbCBvZiBzdWNjZXNzaXZlIGFuZ2xlc1xuXHQgICAgICogICAgICBgdmVsb2NpdHlgICAgICAgLSBWZWxvY2l0eSBvZiByb3RhdGlvblxuXHQgICAgICogICAgICBgY2VudGVyYCAgICAgICAgLSBNaWRwb2ludCBiZXR3ZWVuIHRoZSB0d28gdG91Y2hlc1xuXHQgICAgICogICAgICBgdG91Y2hlc2AgICAgICAgLSBBcnJheSBvZiBET00gZXZlbnQgdG91Y2ggaWRlbnRpZmllcnNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICAgdmFyIHJvdGF0ZUlucHV0ID0gbmV3IFJvdGF0ZUlucHV0KCk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICByb3RhdGVJbnB1dC5zdWJzY3JpYmUoRW5naW5lKSAvLyBsaXN0ZW5zIG9uIGB3aW5kb3dgIGV2ZW50c1xuXHQgICAgICpcblx0ICAgICAqICAgICAgcm90YXRlSW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICByb3RhdGVJbnB1dC5vbigndXBkYXRlJywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygndXBkYXRlJywgcGF5bG9hZCk7XG5cdCAgICAgKiAgICAgIH0pO1xuXHQgICAgICpcblx0ICAgICAqICAgICAgcm90YXRlSW5wdXQub24oJ2VuZCcsIGZ1bmN0aW9uKHBheWxvYWQpe1xuXHQgICAgICogICAgICAgICAgY29uc29sZS5sb2coJ2VuZCcsIHBheWxvYWQpO1xuXHQgICAgICogICAgICB9KTtcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgUm90YXRlSW5wdXRcblx0ICAgICAqIEBleHRlbmRzIElucHV0cy5Ud29GaW5nZXJJbnB1dFxuXHQgICAgICogQHVzZXMgQ29yZS5PcHRpb25zTWFuYWdlclxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnNjYWxlPTFdIHtOdW1iZXJ9ICAgIFNjYWxlIHRoZSByZXNwb25zZSB0byBwaW5jaFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBSb3RhdGVJbnB1dChvcHRpb25zKSB7XG5cdCAgICAgICAgVHdvRmluZ2VySW5wdXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IE9wdGlvbnNNYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0ICAgICAgICB0aGlzLl9hbmdsZSA9IDA7XG5cdCAgICAgICAgdGhpcy5fcHJldmlvdXNBbmdsZSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIFJvdGF0ZUlucHV0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHdvRmluZ2VySW5wdXQucHJvdG90eXBlKTtcblx0ICAgIFJvdGF0ZUlucHV0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0ZUlucHV0O1xuXG5cdCAgICBSb3RhdGVJbnB1dC5ERUZBVUxUX09QVElPTlMgPSB7XG5cdCAgICAgICAgc2NhbGUgOiAxXG5cdCAgICB9O1xuXG5cdCAgICBSb3RhdGVJbnB1dC5wcm90b3R5cGUuX3N0YXJ0VXBkYXRlID0gZnVuY3Rpb24gX3N0YXJ0VXBkYXRlKGV2ZW50KSB7XG5cdCAgICAgICAgdGhpcy5fcHJldmlvdXNBbmdsZSA9IFR3b0ZpbmdlcklucHV0LmNhbGN1bGF0ZUFuZ2xlKHRoaXMucG9zQSwgdGhpcy5wb3NCKTtcblx0ICAgICAgICB2YXIgY2VudGVyID0gVHdvRmluZ2VySW5wdXQuY2FsY3VsYXRlQ2VudGVyKHRoaXMucG9zQSwgdGhpcy5wb3NCKTtcblxuXHQgICAgICAgIHRoaXMuX2FuZ2xlID0gMDtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50T3V0cHV0LmVtaXQoJ3N0YXJ0Jywge1xuXHQgICAgICAgICAgICBjb3VudDogZXZlbnQudG91Y2hlcy5sZW5ndGgsXG5cdCAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9hbmdsZSxcblx0ICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG5cdCAgICAgICAgICAgIHRvdWNoZXM6IFt0aGlzLnRvdWNoQUlkLCB0aGlzLnRvdWNoQklkXVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblxuXHQgICAgUm90YXRlSW5wdXQucHJvdG90eXBlLl9tb3ZlVXBkYXRlID0gZnVuY3Rpb24gX21vdmVVcGRhdGUoZGlmZlRpbWUpIHtcblx0ICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGU7XG5cblx0ICAgICAgICB2YXIgY3VyckFuZ2xlID0gVHdvRmluZ2VySW5wdXQuY2FsY3VsYXRlQW5nbGUodGhpcy5wb3NBLCB0aGlzLnBvc0IpO1xuXHQgICAgICAgIHZhciBjZW50ZXIgPSBUd29GaW5nZXJJbnB1dC5jYWxjdWxhdGVDZW50ZXIodGhpcy5wb3NBLCB0aGlzLnBvc0IpO1xuXG5cdCAgICAgICAgdmFyIGRpZmZUaGV0YSA9IHNjYWxlICogKGN1cnJBbmdsZSAtIHRoaXMuX3ByZXZpb3VzQW5nbGUpO1xuXHQgICAgICAgIHZhciB2ZWxUaGV0YSA9IGRpZmZUaGV0YSAvIGRpZmZUaW1lO1xuXG5cdCAgICAgICAgdGhpcy5fYW5nbGUgKz0gZGlmZlRoZXRhO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgndXBkYXRlJywge1xuXHQgICAgICAgICAgICBkZWx0YSA6IGRpZmZUaGV0YSxcblx0ICAgICAgICAgICAgdmVsb2NpdHk6IHZlbFRoZXRhLFxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5fYW5nbGUsXG5cdCAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuXHQgICAgICAgICAgICB0b3VjaGVzOiBbdGhpcy50b3VjaEFJZCwgdGhpcy50b3VjaEJJZF1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHRoaXMuX3ByZXZpb3VzQW5nbGUgPSBjdXJyQW5nbGU7XG5cdCAgICB9O1xuXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IFJvdGF0ZUlucHV0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA0OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcblx0ICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuXHQgKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuXHQgKlxuXHQgKiBAbGljZW5zZSBNUEwgMi4wXG5cdCAqIEBjb3B5cmlnaHQgRmFtb3VzIEluZHVzdHJpZXMsIEluYy4gMjAxNFxuXHQgKi9cblxuXHQvKiBNb2RpZmllZCB3b3JrIGNvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgVHdvRmluZ2VySW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblx0ICAgIHZhciBPcHRpb25zTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERldGVjdHMgdHdvLWZpbmdlciBwaW5jaGluZyBtb3Rpb24gYW5kIGVtaXRzIGBzdGFydGAsIGB1cGRhdGVgIGFuZFxuXHQgICAgICogIGBlbmRgIGV2ZW50cyB3aXRoIHRoZSBwYXlsb2FkIGRhdGE6XG5cdCAgICAgKlxuXHQgICAgICogICAgICBgdmFsdWVgICAgICAgICAgLSBEaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gdG91Y2hlc1xuXHQgICAgICogICAgICBgZGVsdGFgICAgICAgICAgLSBEaWZmZXJlbnRpYWwgaW4gc3VjY2Vzc2l2ZSBkaXN0YW5jZXNcblx0ICAgICAqICAgICAgYHZlbG9jaXR5YCAgICAgIC0gUmVsYXRpdmUgdmVsb2NpdHkgYmV0d2VlbiB0d28gdG91Y2hlc1xuXHQgICAgICogICAgICBgZGlzcGxhY2VtZW50YCAgLSBUb3RhbCBhY2N1bXVsYXRlZCBkaXNwbGFjZW1lbnRcblx0ICAgICAqICAgICAgYGNlbnRlcmAgICAgICAgIC0gTWlkcG9pbnQgYmV0d2VlbiB0aGUgdHdvIHRvdWNoZXNcblx0ICAgICAqICAgICAgYHRvdWNoZXNgICAgICAgIC0gQXJyYXkgb2YgRE9NIGV2ZW50IHRvdWNoIGlkZW50aWZpZXJzXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBwaW5jaElucHV0ID0gbmV3IFBpbmNoSW5wdXQoKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHBpbmNoSW5wdXQuc3Vic2NyaWJlKEVuZ2luZSkgLy8gbGlzdGVucyBvbiBgd2luZG93YCBldmVudHNcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHBpbmNoSW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24ocGF5bG9hZCl7XG5cdCAgICAgKiAgICAgICAgICBjb25zb2xlLmxvZygnc3RhcnQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBwaW5jaElucHV0Lm9uKCd1cGRhdGUnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGUnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogICAgICBwaW5jaElucHV0Lm9uKCdlbmQnLCBmdW5jdGlvbihwYXlsb2FkKXtcblx0ICAgICAqICAgICAgICAgIGNvbnNvbGUubG9nKCdlbmQnLCBwYXlsb2FkKTtcblx0ICAgICAqICAgICAgfSk7XG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIFBpbmNoSW5wdXRcblx0ICAgICAqIEBleHRlbmRzIElucHV0cy5Ud29GaW5nZXJJbnB1dFxuXHQgICAgICogQHVzZXMgQ29yZS5PcHRpb25zTWFuYWdlclxuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLnNjYWxlPTFdIHtOdW1iZXJ9ICAgIFNjYWxlIHRoZSByZXNwb25zZSB0byBwaW5jaFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBQaW5jaElucHV0KG9wdGlvbnMpIHtcblx0ICAgICAgICBUd29GaW5nZXJJbnB1dC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgdGhpcy5vcHRpb25zID0gT3B0aW9uc01hbmFnZXIuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHQgICAgICAgIHRoaXMuX2Rpc3BsYWNlbWVudCA9IDA7XG5cdCAgICAgICAgdGhpcy5fcHJldmlvdXNEaXN0YW5jZSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIFBpbmNoSW5wdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUd29GaW5nZXJJbnB1dC5wcm90b3R5cGUpO1xuXHQgICAgUGluY2hJbnB1dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQaW5jaElucHV0O1xuXG5cdCAgICBQaW5jaElucHV0LkRFRkFVTFRfT1BUSU9OUyA9IHtcblx0ICAgICAgICBzY2FsZSA6IDFcblx0ICAgIH07XG5cblx0ICAgIFBpbmNoSW5wdXQucHJvdG90eXBlLl9zdGFydFVwZGF0ZSA9IGZ1bmN0aW9uIF9zdGFydFVwZGF0ZShldmVudCkge1xuXHQgICAgICAgIHZhciBjZW50ZXIgPSBUd29GaW5nZXJJbnB1dC5jYWxjdWxhdGVDZW50ZXIodGhpcy5wb3NBLCB0aGlzLnBvc0IpO1xuXHQgICAgICAgIHRoaXMuX3ByZXZpb3VzRGlzdGFuY2UgPSBUd29GaW5nZXJJbnB1dC5jYWxjdWxhdGVEaXN0YW5jZSh0aGlzLnBvc0EsIHRoaXMucG9zQik7XG5cblx0ICAgICAgICB0aGlzLl9kaXNwbGFjZW1lbnQgPSAwO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgnc3RhcnQnLCB7XG5cdCAgICAgICAgICAgIGNvdW50OiBldmVudC50b3VjaGVzLmxlbmd0aCxcblx0ICAgICAgICAgICAgdG91Y2hlczogW3RoaXMudG91Y2hBSWQsIHRoaXMudG91Y2hCSWRdLFxuXHQgICAgICAgICAgICB2YWx1ZTogdGhpcy5fcHJldmlvdXNEaXN0YW5jZSxcblx0ICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIFBpbmNoSW5wdXQucHJvdG90eXBlLl9tb3ZlVXBkYXRlID0gZnVuY3Rpb24gX21vdmVVcGRhdGUoZGlmZlRpbWUpIHtcblx0ICAgICAgICB2YXIgY3VyckRpc3QgPSBUd29GaW5nZXJJbnB1dC5jYWxjdWxhdGVEaXN0YW5jZSh0aGlzLnBvc0EsIHRoaXMucG9zQik7XG5cdCAgICAgICAgdmFyIGNlbnRlciA9IFR3b0ZpbmdlcklucHV0LmNhbGN1bGF0ZUNlbnRlcih0aGlzLnBvc0EsIHRoaXMucG9zQik7XG5cblx0ICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGU7XG5cdCAgICAgICAgdmFyIGRlbHRhID0gc2NhbGUgKiAoY3VyckRpc3QgLSB0aGlzLl9wcmV2aW91c0Rpc3RhbmNlKTtcblx0ICAgICAgICB2YXIgdmVsb2NpdHkgPSBkZWx0YSAvIGRpZmZUaW1lO1xuXG5cdCAgICAgICAgdGhpcy5fZGlzcGxhY2VtZW50ICs9IGRlbHRhO1xuXG5cdCAgICAgICAgdGhpcy5fZXZlbnRPdXRwdXQuZW1pdCgndXBkYXRlJywge1xuXHQgICAgICAgICAgICBkZWx0YSA6IGRlbHRhLFxuXHQgICAgICAgICAgICB2ZWxvY2l0eTogdmVsb2NpdHksXG5cdCAgICAgICAgICAgIHZhbHVlOiBjdXJyRGlzdCxcblx0ICAgICAgICAgICAgZGlzcGxhY2VtZW50OiB0aGlzLl9kaXNwbGFjZW1lbnQsXG5cdCAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuXHQgICAgICAgICAgICB0b3VjaGVzOiBbdGhpcy50b3VjaEFJZCwgdGhpcy50b3VjaEJJZF1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHRoaXMuX3ByZXZpb3VzRGlzdGFuY2UgPSBjdXJyRGlzdDtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gUGluY2hJbnB1dDtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNTAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICAgICAgICBEcmF3ZXJMYXlvdXQ6IF9fd2VicGFja19yZXF1aXJlX18oNTEpLFxuXHQgICAgICAgIEZsZXhpYmxlTGF5b3V0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSxcblx0ICAgICAgICBHcmlkTGF5b3V0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSxcblx0ICAgICAgICBTZXF1ZW50aWFsTGF5b3V0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KSxcblx0ICAgICAgICBTY3JvbGx2aWV3OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KVxuXHQgICAgfTtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBDb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHQgICAgdmFyIFRyYW5zaXRpb25hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cdCAgICB2YXIgVmlldyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXHQgICAgdmFyIExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHQgICAgdmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHQgICAgdmFyIERpZmZlcmVudGlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xuXHQgICAgdmFyIEFjY3VtdWxhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cdCAgICB2YXIgRXZlbnRNYXBwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuXHQgICAgdmFyIENPTlNUQU5UUyA9IHtcblx0ICAgICAgICBESVJFQ1RJT04gOiB7XG5cdCAgICAgICAgICAgIFggOiAwLFxuXHQgICAgICAgICAgICBZIDogMVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgU0lERSA6IHtcblx0ICAgICAgICAgICAgTEVGVCA6IDAsXG5cdCAgICAgICAgICAgIFRPUCA6IDEsXG5cdCAgICAgICAgICAgIFJJR0hUIDogMixcblx0ICAgICAgICAgICAgQk9UVE9NIDogM1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgT1JJRU5UQVRJT04gOiB7XG5cdCAgICAgICAgICAgIFBPU0lUSVZFIDogIDEsXG5cdCAgICAgICAgICAgIE5FR0FUSVZFIDogLTFcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgbGF5b3V0IGNvbXBvc2VkIG9mIHR3byBzZWN0aW9uczogY29udGVudCBhbmQgZHJhd2VyLlxuXHQgICAgICpcblx0ICAgICAqICBUaGUgZHJhd2VyIGlzIGluaXRpYWxseSBoaWRkZW4gYmVoaW5kIHRoZSBjb250ZW50LCB1bnRpbCBpdCBpcyBtb3ZlZFxuXHQgICAgICogIGJ5IGEgY2FsbCB0byBzZXRQb3NpdGlvbi4gVGhlIHNvdXJjZSBvZiB0aGUgbW92ZW1lbnQgY2FuIGJlIGJ5IHN1YnNjcmliaW5nXG5cdCAgICAgKiAgdGhlIGxheW91dCB0byB1c2VyIGlucHV0IChsaWtlIGEgTW91c2UvVG91Y2gvU2Nyb2xsIGlucHV0KSwgb3IgYnkgbWFudWFsbHlcblx0ICAgICAqICBjYWxsaW5nIHNldFBvc2l0aW9uIHdpdGggYSB0cmFuc2l0aW9uLlxuXHQgICAgICpcblx0ICAgICAqICBUaGUgbGF5b3V0IGVtaXRzIGEgYHN0YXJ0YCwgYHVwZGF0ZWAgYW5kIGBlbmRgIFN0cmVhbSB3aXRoIHBheWxvYWRcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIGBwcm9ncmVzc2AgLSBOdW1iZXIgYmV0d2VlbiAwIGFuZCAxIGluZGljYXRpbmcgaG93IG9wZW4gdGhlIGRyYXdlciBpc1xuXHQgICAgICogICAgICBgdmFsdWVgIC0gUGl4ZWwgZGlzcGxhY2VtZW50IGluIGhvdyBvcGVuIHRoZSBkcmF3ZXIgaXNcblx0ICAgICAqXG5cdCAgICAgKiAgSXQgYWxzbyBlbWl0cyBgY2xvc2VgIGFuZCBgb3BlbmAgZXZlbnRzLlxuXHQgICAgICpcblx0ICAgICAqICBUaGUgZHJhd2VyIGNhbiBiZSByZXZlYWxlZCBmcm9tIGFueSBzaWRlIG9mIHRoZSBjb250ZW50ICh0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQpLFxuXHQgICAgICogIGJ5IHNwZWNpZnlpbmcgYSBzaWRlIG9wdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiAgQGNsYXNzIERyYXdlckxheW91dFxuXHQgICAgICogIEBjb25zdHJ1Y3RvclxuXHQgICAgICogIEBuYW1lc3BhY2UgTGF5b3V0c1xuXHQgICAgICogIEBleHRlbmRzIENvcmUuVmlld1xuXHQgICAgICogIEBwYXJhbSBbb3B0aW9uc10ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcblx0ICAgICAqICBAcGFyYW0gW29wdGlvbnMuc2lkZV0ge051bWJlcn0gICAgICAgICAgICAgICAgICBTaWRlIHRvIHJldmVhbCB0aGUgZHJhd2VyIGZyb20uIERlZmluZWQgaW4gRHJhd2VyTGF5b3V0LlNJREVTXG5cdCAgICAgKiAgQHBhcmFtIFtvcHRpb25zLnJldmVhbExlbmd0aF0ge051bWJlcn0gICAgICAgICAgVGhlIG1heGltdW0gbGVuZ3RoIHRvIHJldmVhbCB0aGUgZHJhd2VyXG5cdCAgICAgKiAgQHBhcmFtIFtvcHRpb25zLnZlbG9jaXR5VGhyZXNob2xkXSB7TnVtYmVyfSAgICAgVGhlIHZlbG9jaXR5IG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgZHJhd2VyIHRyYW5zaXRpb25cblx0ICAgICAqICBAcGFyYW0gW29wdGlvbnMucG9zaXRpb25UaHJlc2hvbGRdIHtOdW1iZXJ9ICAgICBUaGUgZGlzcGxhY2VtZW50IG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgZHJhd2VyIHRyYW5zaXRpb25cblx0ICAgICAqICBAcGFyYW0gW29wdGlvbnMudHJhbnNpdGlvbkNsb3NlXSB7T2JqZWN0fSAgICAgICBBIHRyYW5zaXRpb24gZGVmaW5pdGlvbiBmb3IgY2xvc2luZyB0aGUgZHJhd2VyXG5cdCAgICAgKiAgQHBhcmFtIFtvcHRpb25zLnRyYW5zaXRpb25PcGVuXSB7T2JqZWN0fSAgICAgICAgQSB0cmFuc2l0aW9uIGRlZmluaXRpb24gZm9yIG9wZW5pbmcgdGhlIGRyYXdlclxuXHQgICAgICovXG5cdCAgICB2YXIgRHJhd2VyTGF5b3V0ID0gVmlldy5leHRlbmQoe1xuXHQgICAgICAgIGRlZmF1bHRzIDoge1xuXHQgICAgICAgICAgICBzaWRlIDogQ09OU1RBTlRTLlNJREUuTEVGVCxcblx0ICAgICAgICAgICAgcmV2ZWFsTGVuZ3RoIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgICB2ZWxvY2l0eVRocmVzaG9sZCA6IEluZmluaXR5LFxuXHQgICAgICAgICAgICBwb3NpdGlvblRocmVzaG9sZCA6IDAsXG5cdCAgICAgICAgICAgIHRyYW5zaXRpb25PcGVuIDogdHJ1ZSxcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkNsb3NlIDogdHJ1ZVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZXZlbnRzIDoge1xuXHQgICAgICAgICAgICBjaGFuZ2UgOiBfdXBkYXRlU3RhdGVcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGluaXRpYWxpemUgOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdGlvbnMpe1xuXHQgICAgICAgICAgICAvLyBERVJJVkVEIFNUQVRFXG5cblx0ICAgICAgICAgICAgLy8gdmVydGljYWwgb3IgaG9yaXpvbnRhbCBtb3ZlbWVudFxuXHQgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IF9nZXREaXJlY3Rpb25Gcm9tU2lkZShvcHRpb25zLnNpZGUpO1xuXG5cdCAgICAgICAgICAgIC8vIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG1vdmVtZW50IGFsb25nIHRoZSBkaXJlY3Rpb25cblx0ICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IF9nZXRPcmllbnRhdGlvbkZyb21TaWRlKG9wdGlvbnMuc2lkZSk7XG5cblx0ICAgICAgICAgICAgLy8gc2NhbGUgdGhlIHJldmVhbExlbmd0aCBieSB0aGUgcGFyaXR5IG9mIHRoZSBkaXJlY3Rpb25cblx0ICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJldmVhbExlbmd0aCAqPSB0aGlzLm9yaWVudGF0aW9uO1xuXG5cdCAgICAgICAgICAgIC8vIG9wZW4gc3RhdGUgKG5lZWRlZCBmb3IgdG9nZ2xpbmcpXG5cdCAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgLy8gU1RSRUFNU1xuXHQgICAgICAgICAgICBcblx0ICAgICAgICAgICAgLy8gcmVzcG9uc2libGUgZm9yIG1hbnVhbGx5IG1vdmluZyB0aGUgY29udGVudCB3aXRob3V0IHVzZXIgaW5wdXRcblx0ICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RyZWFtID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuXG5cdCAgICAgICAgICAgIC8vIHJlc3BvbnNpYmxlIGZvciBtb3ZpbmcgdGhlIGNvbnRlbnQgZnJvbSB1c2VyIGlucHV0XG5cdCAgICAgICAgICAgIHZhciBnZXN0dXJlRGVsdGEgPSBuZXcgU3RyZWFtKHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0IDogZnVuY3Rpb24gKCl7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RyZWFtLmhhbHQoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uIChkYXRhKXtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBtb2RpZnkgdGhlIGRlbHRhIGZyb20gdXNlciBpbnB1dCB0byBiZSBjb25zdHJhaW5lZFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSByZXZlYWxMZW5ndGhcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBkYXRhLmRlbHRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEZWx0YSA9IGRlbHRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXZlYWxMZW5ndGggPSBvcHRpb25zLnJldmVhbExlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmdldCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbiArIGRlbHRhO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIE1JTl9MRU5HVEggPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBNQVhfTEVOR1RIID0gMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSBDT05TVEFOVFMuT1JJRU5UQVRJT04uUE9TSVRJVkUpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIE1BWF9MRU5HVEggPSByZXZlYWxMZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBNSU5fTEVOR1RIID0gcmV2ZWFsTGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uID49IE1BWF9MRU5HVEggfHwgbmV3UG9zaXRpb24gPD0gTUlOX0xFTkdUSCl7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbiA+IE1BWF9MRU5HVEggJiYgbmV3UG9zaXRpb24gPiBNSU5fTEVOR1RIICYmIGN1cnJlbnRQb3NpdGlvbiAhPT0gTUFYX0xFTkdUSClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlbHRhID0gTUFYX0xFTkdUSCAtIGN1cnJlbnRQb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3UG9zaXRpb24gPCBNSU5fTEVOR1RIICYmIGN1cnJlbnRQb3NpdGlvbiAhPT0gTUlOX0xFTkdUSClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlbHRhID0gTUlOX0xFTkdUSCAtIGN1cnJlbnRQb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVsdGEgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdEZWx0YTtcblx0ICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgICAgIGVuZCA6IGZ1bmN0aW9uIChkYXRhKXtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBkYXRhLnZlbG9jaXR5O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vcmllbnRhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uLmdldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG9wdGlvbnMucmV2ZWFsTGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBNQVhfTEVOR1RIID0gb3JpZW50YXRpb24gKiBsZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uVGhyZXNob2xkID0gb3B0aW9ucy5wb3NpdGlvblRocmVzaG9sZCB8fCBNQVhfTEVOR1RIIC8gMjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHlUaHJlc2hvbGQgPSBvcHRpb25zLnZlbG9jaXR5VGhyZXNob2xkO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IE1BWF9MRU5HVEgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZE9wZW4gPVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAocG9zaXRpb24gPj0gcG9zaXRpb25UaHJlc2hvbGQpICYmICgodmVsb2NpdHkgPiAtdmVsb2NpdHlUaHJlc2hvbGQpIHx8ICh2ZWxvY2l0eSA+IHZlbG9jaXR5VGhyZXNob2xkKSkgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHBvc2l0aW9uIDwgIHBvc2l0aW9uVGhyZXNob2xkKSAmJiAoKHZlbG9jaXR5ID4gIHZlbG9jaXR5VGhyZXNob2xkKSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkT3Blbil7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uT3Blbi52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4odGhpcy5vcHRpb25zLnRyYW5zaXRpb25PcGVuLCBmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25PcGVuLnZlbG9jaXR5ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uQ2xvc2UudmVsb2NpdHkgPSB2ZWxvY2l0eTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSh0aGlzLm9wdGlvbnMudHJhbnNpdGlvbkNsb3NlLCBmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25DbG9zZS52ZWxvY2l0eSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGdlc3R1cmVEZWx0YS5zdWJzY3JpYmUodGhpcy5pbnB1dCk7XG5cblx0ICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25EZWx0YSA9IG5ldyBEaWZmZXJlbnRpYWwoKTtcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbkRlbHRhLnN1YnNjcmliZSh0aGlzLnRyYW5zaXRpb25TdHJlYW0pO1xuXG5cdCAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgQWNjdW11bGF0b3IoMCk7XG5cdCAgICAgICAgICAgIHRoaXMucG9zaXRpb24uc3Vic2NyaWJlKGdlc3R1cmVEZWx0YSk7XG5cdCAgICAgICAgICAgIHRoaXMucG9zaXRpb24uc3Vic2NyaWJlKHRyYW5zaXRpb25EZWx0YSk7XG5cblx0ICAgICAgICAgICAgdmFyIG91dHB1dE1hcHBlciA9IG5ldyBFdmVudE1hcHBlcihmdW5jdGlvbihwb3NpdGlvbil7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogcG9zaXRpb24sXG5cdCAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MgOiBwb3NpdGlvbiAvIHRoaXMub3B0aW9ucy5yZXZlYWxMZW5ndGhcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgICAgICB0aGlzLm91dHB1dC5zdWJzY3JpYmUob3V0cHV0TWFwcGVyKS5zdWJzY3JpYmUodGhpcy5wb3NpdGlvbik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXQgdGhlIGRyYXdlciBjb21wb25lbnQgd2l0aCBhIFN1cmZhY2Ugb2YgVmlldy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2QgYWRkRHJhd2VyXG5cdCAgICAgICAgICogQHBhcmFtIGRyYXdlciB7U3VyZmFjZXxWaWV3fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZERyYXdlciA6IGZ1bmN0aW9uIGFkZERyYXdlcihkcmF3ZXIpe1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJldmVhbExlbmd0aCA9PSB1bmRlZmluZWQpXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmV2ZWFsTGVuZ3RoID0gZHJhd2VyLmdldFNpemUoKVt0aGlzLmRpcmVjdGlvbl07XG5cblx0ICAgICAgICAgICAgdGhpcy5kcmF3ZXIgPSBkcmF3ZXI7XG5cdCAgICAgICAgICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0Tm9kZSh7dHJhbnNmb3JtIDogVHJhbnNmb3JtLmJlaGluZH0pO1xuXHQgICAgICAgICAgICB0aGlzLmFkZChsYXlvdXQpLmFkZCh0aGlzLmRyYXdlcik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBTZXQgdGhlIGNvbnRlbnQgY29tcG9uZW50IHdpdGggYSBTdXJmYWNlIG9yIFZpZXcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIGFkZENvbnRlbnRcblx0ICAgICAgICAgKiBAcGFyYW0gY29udGVudCB7U3VyZmFjZXxWaWV3fVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZENvbnRlbnQgOiBmdW5jdGlvbiBhZGRDb250ZW50KGNvbnRlbnQpe1xuXHQgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5wb3NpdGlvbi5tYXAoZnVuY3Rpb24ocG9zaXRpb24pe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRpcmVjdGlvbiA9PT0gQ09OU1RBTlRTLkRJUkVDVElPTi5YKVxuXHQgICAgICAgICAgICAgICAgICAgID8gVHJhbnNmb3JtLnRyYW5zbGF0ZVgocG9zaXRpb24pXG5cdCAgICAgICAgICAgICAgICAgICAgOiBUcmFuc2Zvcm0udHJhbnNsYXRlWShwb3NpdGlvbilcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgICAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dE5vZGUoe3RyYW5zZm9ybSA6IHRyYW5zZm9ybX0pO1xuXG5cdCAgICAgICAgICAgIHRoaXMuYWRkKGxheW91dCkuYWRkKGNvbnRlbnQpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmV2ZWFscyB0aGUgZHJhd2VyIHdpdGggYSB0cmFuc2l0aW9uLlxuXHQgICAgICAgICAqICAgRW1pdHMgYW4gYG9wZW5gIGV2ZW50IHdoZW4gYW4gb3BlbmluZyB0cmFuc2l0aW9uIGhhcyBiZWVuIGNvbW1pdHRlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2Qgb3BlblxuXHQgICAgICAgICAqIEBwYXJhbSBbdHJhbnNpdGlvbl0ge0Jvb2xlYW58T2JqZWN0fSB0cmFuc2l0aW9uIGRlZmluaXRpb25cblx0ICAgICAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSB7RnVuY3Rpb259ICAgICAgICAgY2FsbGJhY2tcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBvcGVuIDogZnVuY3Rpb24gb3Blbih0cmFuc2l0aW9uLCBjYWxsYmFjayl7XG5cdCAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uID09PSB1bmRlZmluZWQpIHRyYW5zaXRpb24gPSB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbk9wZW47XG5cdCAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5vcHRpb25zLnJldmVhbExlbmd0aCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ29wZW4nKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2VhbHMgdGhlIGRyYXdlciB3aXRoIGEgdHJhbnNpdGlvbi5cblx0ICAgICAgICAgKiAgIEVtaXRzIGEgYGNsb3NlYCBldmVudCB3aGVuIGFuIGNsb3NpbmcgdHJhbnNpdGlvbiBoYXMgYmVlbiBjb21taXR0ZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIGNsb3NlXG5cdCAgICAgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uXSB7Qm9vbGVhbnxPYmplY3R9IHRyYW5zaXRpb24gZGVmaW5pdGlvblxuXHQgICAgICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIHtGdW5jdGlvbn0gICAgICAgICBjYWxsYmFja1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb3NlIDogZnVuY3Rpb24gY2xvc2UodHJhbnNpdGlvbiwgY2FsbGJhY2spe1xuXHQgICAgICAgICAgICBpZiAodHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkKSB0cmFuc2l0aW9uID0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb25DbG9zZTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbigwLCB0cmFuc2l0aW9uLCBjYWxsYmFjayk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzT3Blbil7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBUb2dnbGVzIGJldHdlZW4gb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2QgdG9nZ2xlXG5cdCAgICAgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uXSB7Qm9vbGVhbnxPYmplY3R9IHRyYW5zaXRpb24gZGVmaW5pdGlvblxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvZ2dsZSA6IGZ1bmN0aW9uIHRvZ2dsZSh0cmFuc2l0aW9uKXtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB0aGlzLmNsb3NlKHRyYW5zaXRpb24pO1xuXHQgICAgICAgICAgICBlbHNlIHRoaXMub3Blbih0cmFuc2l0aW9uKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIGluIHBpeGVscyBmb3IgdGhlIGNvbnRlbnQncyBkaXNwbGFjZW1lbnQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAgICAgICAgICogQHBhcmFtIHBvc2l0aW9uIHtOdW1iZXJ9ICAgICAgICAgICAgIHBvc2l0aW9uXG5cdCAgICAgICAgICogQHBhcmFtIFt0cmFuc2l0aW9uXSB7Qm9vbGVhbnxPYmplY3R9IHRyYW5zaXRpb24gZGVmaW5pdGlvblxuXHQgICAgICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIHtGdW5jdGlvbn0gICAgICAgICBjYWxsYmFja1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHNldFBvc2l0aW9uIDogZnVuY3Rpb24gc2V0UG9zaXRpb24ocG9zaXRpb24sIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblN0cmVhbS5yZXNldCh0aGlzLnBvc2l0aW9uLmdldCgpKTtcblx0ICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uU3RyZWFtLnNldChwb3NpdGlvbiwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRvIGxhc3Qgc3RhdGUgb2YgYmVpbmcgb3BlbiBvciBjbG9zZWRcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBtZXRob2QgcmVzZXRcblx0ICAgICAgICAgKiBAcGFyYW0gW3RyYW5zaXRpb25dIHtCb29sZWFufE9iamVjdH0gdHJhbnNpdGlvbiBkZWZpbml0aW9uXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQgOiBmdW5jdGlvbiByZXNldCh0cmFuc2l0aW9uKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbikgdGhpcy5vcGVuKHRyYW5zaXRpb24pO1xuXHQgICAgICAgICAgICBlbHNlIHRoaXMuY2xvc2UodHJhbnNpdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgfSwgQ09OU1RBTlRTKTtcblxuXHQgICAgZnVuY3Rpb24gX2dldERpcmVjdGlvbkZyb21TaWRlKHNpZGUpIHtcblx0ICAgICAgICB2YXIgU0lERSA9IENPTlNUQU5UUy5TSURFO1xuXHQgICAgICAgIHZhciBESVJFQ1RJT04gPSBDT05TVEFOVFMuRElSRUNUSU9OO1xuXHQgICAgICAgIHJldHVybiAoc2lkZSA9PT0gU0lERS5MRUZUIHx8IHNpZGUgPT09IFNJREUuUklHSFQpXG5cdCAgICAgICAgICAgID8gRElSRUNUSU9OLlhcblx0ICAgICAgICAgICAgOiBESVJFQ1RJT04uWTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gX2dldE9yaWVudGF0aW9uRnJvbVNpZGUoc2lkZSkge1xuXHQgICAgICAgIHZhciBTSURFUyA9IENPTlNUQU5UUy5TSURFO1xuXHQgICAgICAgIHJldHVybiAoc2lkZSA9PT0gU0lERVMuTEVGVCB8fCBzaWRlID09PSBTSURFUy5UT1ApXG5cdCAgICAgICAgICAgID8gQ09OU1RBTlRTLk9SSUVOVEFUSU9OLlBPU0lUSVZFXG5cdCAgICAgICAgICAgIDogQ09OU1RBTlRTLk9SSUVOVEFUSU9OLk5FR0FUSVZFO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoZGF0YSl7XG5cdCAgICAgICAgdmFyIGtleSA9IGRhdGEua2V5O1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG5cdCAgICAgICAgaWYgKGtleSAhPT0gJ3NpZGUnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gX2dldERpcmVjdGlvbkZyb21TaWRlKHZhbHVlKTtcblx0ICAgICAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IF9nZXRPcmllbnRhdGlvbkZyb21TaWRlKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5vcHRpb25zLnJldmVhbExlbmd0aCAqPSB0aGlzLmRpcmVjdGlvbjtcblx0ICAgIH1cblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBEcmF3ZXJMYXlvdXQ7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDUyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpe1xuXHQgICAgdmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHQgICAgdmFyIE9wdGlvbnNNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGlmZmVyZW50aWFsIGlzIGEgU3RyZWFtIHRoYXQgZW1pdHMgZGlmZmVyZW50aWFscyBvZiBjb25zZWN1dGl2ZVxuXHQgICAgICogIGlucHV0IHZhbHVlcy5cblx0ICAgICAqXG5cdCAgICAgKiAgSXQgZW1pdHMgYHN0YXJ0YCwgYHVwZGF0ZWAgYW5kIGBlbmRgIGV2ZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiAgQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBkaWZmZXJlbnRpYWwgPSBuZXcgRGlmZmVyZW50aWFsKCk7XG5cdCAgICAgKiAgICAgIC8vIHRoaXMgZ2l2ZXMgZGlmZmVyZW50aWFscyBvZiBtb3VzZSBpbnB1dFxuXHQgICAgICogICAgICBkaWZmZXJlbnRpYWwuc3Vic2NyaWJlKG1vdXNlSW5wdXQucGx1Y2soJ3ZhbHVlJykpO1xuXHQgICAgICpcblx0ICAgICAqXG5cdCAgICAgKiBAY2xhc3MgRGlmZmVyZW50aWFsXG5cdCAgICAgKiBAZXh0ZW5kcyBTdHJlYW1zLlN0cmVhbVxuXHQgICAgICogQHVzZXMgQ29yZS5PcHRpb25zTWFuYWdlclxuXHQgICAgICogQG5hbWVzcGFjZSBTdHJlYW1zXG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9uc10ge09iamVjdH0gICAgICAgIE9wdGlvbnNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5zY2FsZV0ge051bWJlcn0gIFNjYWxlIHRvIGFwcGx5IHRvIGRpZmZlcmVudGlhbFxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBEaWZmZXJlbnRpYWwob3B0aW9ucyl7XG5cdCAgICAgICAgdGhpcy5vcHRpb25zID0gT3B0aW9uc01hbmFnZXIuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuXHQgICAgICAgIHZhciBwcmV2aW91cyA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB2YXIgZGVsdGEgPSB1bmRlZmluZWQ7XG5cblx0ICAgICAgICBTdHJlYW0uY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVsdGE7IH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHRoaXMuX2V2ZW50SW5wdXQub24oJ3N0YXJ0JywgZnVuY3Rpb24odmFsdWUpeyBwcmV2aW91cyA9IHZhbHVlOyB9KTtcblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCd1cGRhdGUnLCBmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsZTtcblx0ICAgICAgICAgICAgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0ICAgICAgICAgICAgICAgIGRlbHRhID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZpb3VzLmxlbmd0aDsgaSsrKVxuXHQgICAgICAgICAgICAgICAgICAgIGRlbHRhW2ldID0gc2NhbGUgKiAodmFsdWVbaV0gLSBwcmV2aW91c1tpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBkZWx0YSA9IHNjYWxlICogKHZhbHVlIC0gcHJldmlvdXMpO1xuXHQgICAgICAgICAgICBwcmV2aW91cyA9IHZhbHVlO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9XG5cblx0ICAgIERpZmZlcmVudGlhbC5ERUZBVUxUX09QVElPTlMgPSB7XG5cdCAgICAgICAgc2NhbGUgOiAxXG5cdCAgICB9O1xuXG5cdCAgICBEaWZmZXJlbnRpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlKTtcblx0ICAgIERpZmZlcmVudGlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaWZmZXJlbnRpYWw7XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gRGlmZmVyZW50aWFsO1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA1MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKXtcblx0ICAgIHZhciBPcHRpb25zTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXHQgICAgdmFyIFN0cmVhbSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXHQgICAgdmFyIHByZVRpY2tRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdCAgICB2YXIgZGlydHlRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWNjdW11bGF0b3IgaXMgYSBTdHJlYW0gdGhhdCBhY2N1bXVsYXRlcyBhIHZhbHVlIGdpdmVuIGJ5IGFcblx0ICAgICAqICBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVycy5cblx0ICAgICAqXG5cdCAgICAgKiAgSXQgZW1pdHMgYHN0YXJ0YCwgYHVwZGF0ZWAgYW5kIGBlbmRgIGV2ZW50cy5cblx0ICAgICAqXG5cdCAgICAgKiAgQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIHZhciBhY2N1bXVsYXRvciA9IG5ldyBBY2N1bXVsYXRvcigwKTtcblx0ICAgICAqXG5cdCAgICAgKiAgICAgIC8vIHRoaXMgZ2l2ZXMgdGhlIHRvdGFsIGRpc3BsYWNlbWVudCBvZiBtb3VzZSBpbnB1dFxuXHQgICAgICogICAgICBhY2N1bXVsYXRvci5zdWJzY3JpYmUobW91c2VJbnB1dC5wbHVjaygnZGVsdGEnKSk7XG5cdCAgICAgKlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBBY2N1bXVsYXRvclxuXHQgICAgICogQGV4dGVuZHMgU3RyZWFtcy5TdHJlYW1cblx0ICAgICAqIEBuYW1lc3BhY2UgU3RyZWFtc1xuXHQgICAgICogQGNvbnN0cnVjdG9yXG5cdCAgICAgKiBAcGFyYW0gW3N1bV0ge051bWJlcnxBcnJheX0gICAgSW5pdGlhbCB2YWx1ZVxuXHQgICAgICogQHBhcmFtIFtvcHRpb25zXSB7T2JqZWN0fSAgICAgIE9wdGlvbnNcblx0ICAgICAqIEBwYXJhbSBbb3B0aW9ucy5taW5dIHtOdW1iZXJ9ICBTZXQgYSBtaW5pbXVtIHZhbHVlXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMubWF4XSB7TnVtYmVyfSAgU2V0IGEgbWF4aW11bSB2YWx1ZVxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBBY2N1bXVsYXRvcihzdW0sIG9wdGlvbnMpe1xuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IE9wdGlvbnNNYW5hZ2VyLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0ICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHN0YXRlIG5lY2Vzc2FyeT9cblx0ICAgICAgICB0aGlzLnN1bSA9IHVuZGVmaW5lZDtcblxuXHQgICAgICAgIGlmIChzdW0gIT09IHVuZGVmaW5lZCkgdGhpcy5zZXQoc3VtKTtcblxuXHQgICAgICAgIFN0cmVhbS5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgc3RhcnQgOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5zdW0gfHwgMDsgfS5iaW5kKHRoaXMpLFxuXHQgICAgICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5zdW07IH0uYmluZCh0aGlzKSxcblx0ICAgICAgICAgICAgZW5kIDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuc3VtIHx8IDA7IH0uYmluZCh0aGlzKVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLy8gVE9ETzogaXMgYHN0YXJ0YCBldmVudCBuZWNlc3Nhcnk/XG5cdCAgICAgICAgdGhpcy5fZXZlbnRJbnB1dC5vbignc3RhcnQnLCBmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnN1bSAhPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN1bSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bVtpXSA9IGNsYW1wKHZhbHVlW2ldLCB0aGlzLm9wdGlvbnMubWluLCB0aGlzLm9wdGlvbnMubWF4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHRoaXMuc3VtID0gY2xhbXAodmFsdWUsIHRoaXMub3B0aW9ucy5taW4sIHRoaXMub3B0aW9ucy5tYXgpO1xuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICB0aGlzLl9ldmVudElucHV0Lm9uKCd1cGRhdGUnLCBmdW5jdGlvbihkZWx0YSl7XG5cdCAgICAgICAgICAgIGlmIChkZWx0YSBpbnN0YW5jZW9mIEFycmF5KXtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGEubGVuZ3RoOyBpKyspe1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtW2ldICs9IGRlbHRhW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtW2ldID0gY2xhbXAodGhpcy5zdW1baV0sIHRoaXMub3B0aW9ucy5taW4sIHRoaXMub3B0aW9ucy5tYXgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zdW0gKz0gZGVsdGE7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN1bSA9IGNsYW1wKHRoaXMuc3VtLCB0aGlzLm9wdGlvbnMubWluLCB0aGlzLm9wdGlvbnMubWF4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICB9XG5cblx0ICAgIEFjY3VtdWxhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyZWFtLnByb3RvdHlwZSk7XG5cdCAgICBBY2N1bXVsYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBY2N1bXVsYXRvcjtcblxuXHQgICAgQWNjdW11bGF0b3IuREVGQVVMVF9PUFRJT05TID0ge1xuXHQgICAgICAgIG1pbiA6IC1JbmZpbml0eSxcblx0ICAgICAgICBtYXggOiAgSW5maW5pdHlcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCl7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNldCBhY2N1bXVsYXRlZCB2YWx1ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kIHNldFxuXHQgICAgICogQHBhcmFtIHN1bSB7TnVtYmVyfSAgICAgICAgICAgICAgQ3VycmVudCB2YWx1ZVxuXHQgICAgICogQHBhcmFtIFtzaWxlbnQ9ZmFsc2VdIHtCb29sZWFufSAgRmxhZyB0byBzdXBwcmVzcyBldmVudHNcblx0ICAgICAqL1xuXHQgICAgQWNjdW11bGF0b3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHN1bSwgc2lsZW50KXtcblx0ICAgICAgICB0aGlzLnN1bSA9IHN1bTtcblx0ICAgICAgICBpZiAoc2lsZW50ID09PSB0cnVlKSByZXR1cm47XG5cdCAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICAgIHByZVRpY2tRdWV1ZS5wdXNoKGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHNlbGYudHJpZ2dlcignc3RhcnQnLCBzdW0pO1xuXHQgICAgICAgICAgICBkaXJ0eVF1ZXVlLnB1c2goZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgICAgIHNlbGYudHJpZ2dlcignZW5kJywgc3VtKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSlcblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogUmV0dXJucyBjdXJyZW50IGFjY3VtdWxhdGVkIHZhbHVlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2QgZ2V0XG5cdCAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAgICAgKi9cblx0ICAgIEFjY3VtdWxhdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpe1xuXHQgICAgICAgIHJldHVybiB0aGlzLnN1bTtcblx0ICAgIH07XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gQWNjdW11bGF0b3I7XG5cdH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cblxuLyoqKi8gfSxcbi8qIDU0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyogQ29weXJpZ2h0IMKpIDIwMTUgRGF2aWQgVmFsZG1hbiAqL1xuXG5cdCEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIHZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblx0ICAgIHZhciBUcmFuc2l0aW9uYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHQgICAgdmFyIFZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0ICAgIHZhciBTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICAgIHZhciBMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICAgIHZhciBTaXplTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG5cdCAgICB2YXIgQ09OU1RBTlRTID0ge1xuXHQgICAgICAgIERJUkVDVElPTiA6IHtcblx0ICAgICAgICAgICAgWCA6IDAsXG5cdCAgICAgICAgICAgIFkgOiAxXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGxheW91dCB3aGljaCBhcnJhbmdlcyBpdGVtcyB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseSBhbmRcblx0ICAgICAqICB3aXRoIHNpemVzIHByZXNjcmliZWQgYnkgcmF0aW9zIG9mIGEgY29udGFpbmluZyBzaXplLiBUaGVzZVxuXHQgICAgICogIHJhdGlvcyBjYW4gYmUgYW5pbWF0ZWQuXG5cdCAgICAgKlxuXHQgICAgICogQGNsYXNzIEZsZXhpYmxlTGF5b3V0XG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBuYW1lc3BhY2UgTGF5b3V0c1xuXHQgICAgICogQGV4dGVuZHMgQ29yZS5WaWV3XG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnNdIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLmRpcmVjdGlvbl17TnVtYmVyfSAgICAgICAgICAgICAgIERpcmVjdGlvbiB0byBsYXkgb3V0IGl0ZW1zXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMucmF0aW9zXSB7VHJhbnNpdGlvbmFibGV8QXJyYXl9ICAgVGhlIHByb3BvcnRpb25zXG5cdCAgICAgKi9cblx0ICAgIHZhciBGbGV4aWJsZUxheW91dCA9IFZpZXcuZXh0ZW5kKHtcblx0ICAgICAgICBkZWZhdWx0cyA6IHtcblx0ICAgICAgICAgICAgZGlyZWN0aW9uIDogQ09OU1RBTlRTLkRJUkVDVElPTi5YLFxuXHQgICAgICAgICAgICByYXRpb3MgOiBbXVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uIGluaXRpYWxpemUob3B0aW9ucyl7XG5cdCAgICAgICAgICAgIHZhciByYXRpb3MgPSAob3B0aW9ucy5yYXRpb3MgaW5zdGFuY2VvZiBUcmFuc2l0aW9uYWJsZSlcblx0ICAgICAgICAgICAgICAgID8gb3B0aW9ucy5yYXRpb3Ncblx0ICAgICAgICAgICAgICAgIDogbmV3IFRyYW5zaXRpb25hYmxlKG9wdGlvbnMucmF0aW9zKTtcblxuXHQgICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG5cblx0ICAgICAgICAgICAgdmFyIHN0YXRlU3RyZWFtID0gU3RyZWFtLmxpZnQoZnVuY3Rpb24ocmF0aW9zLCBwYXJlbnRTaXplKXtcblx0ICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbjtcblxuXHQgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlbWFpbmluZyBzaXplIGFmdGVyIHRydWUtc2l6ZWQgbm9kZXMgYXJlIGFjY291bnRlZCBmb3Jcblx0ICAgICAgICAgICAgICAgIHZhciBmbGV4TGVuZ3RoID0gcGFyZW50U2l6ZVtkaXJlY3Rpb25dO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJhdGlvU3VtID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF0aW9zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJhdGlvID0gcmF0aW9zW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcmF0aW8gIT09ICdudW1iZXInKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IGZsZXhMZW5ndGggLT0gbm9kZS5nZXRTaXplKClbZGlyZWN0aW9uXSB8fCAwXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogcmF0aW9TdW0gKz0gcmF0aW87XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBzaXplcyBhbmQgZGlzcGxhY2VtZW50cyBvZiBub2Rlc1xuXHQgICAgICAgICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG5cdCAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpemVzID0gW107XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhdGlvcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIHJhdGlvID0gcmF0aW9zW2ldO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVMZW5ndGggPSAodHlwZW9mIHJhdGlvID09PSAnbnVtYmVyJylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgPyBmbGV4TGVuZ3RoICogcmF0aW8gLyByYXRpb1N1bVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IG5vZGUuZ2V0U2l6ZSgpW2RpcmVjdGlvbl07XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gKGRpcmVjdGlvbiA9PSBDT05TVEFOVFMuRElSRUNUSU9OLlgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgID8gVHJhbnNmb3JtLnRyYW5zbGF0ZVgoZGlzcGxhY2VtZW50KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA6IFRyYW5zZm9ybS50cmFuc2xhdGVZKGRpc3BsYWNlbWVudCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IChkaXJlY3Rpb24gPT0gQ09OU1RBTlRTLkRJUkVDVElPTi5YKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IFtub2RlTGVuZ3RoLCB1bmRlZmluZWRdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDogW3VuZGVmaW5lZCwgbm9kZUxlbmd0aF07XG5cblx0ICAgICAgICAgICAgICAgICAgICBzaXplcy5wdXNoKHNpemUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50ICs9IG5vZGVMZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtcyA6IHRyYW5zZm9ybXMsXG5cdCAgICAgICAgICAgICAgICAgICAgc2l6ZXMgOiBzaXplc1xuXHQgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICB9LmJpbmQodGhpcyksIFtyYXRpb3MsIHRoaXMuc2l6ZV0pO1xuXG5cdCAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IHN0YXRlU3RyZWFtLnBsdWNrKCd0cmFuc2Zvcm1zJyk7XG5cdCAgICAgICAgICAgIHRoaXMuc2l6ZXMgPSBzdGF0ZVN0cmVhbS5wbHVjaygnc2l6ZXMnKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZCBjb250ZW50IGFzIGFuIGFycmF5IG9mIFZpZXdzIG9yIFN1cmZhY2VzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQG1ldGhvZCBhZGRJdGVtc1xuXHQgICAgICAgICAqIEBwYXJhbSBpdGVtcyB7QXJyYXl9ICBBbiBhcnJheSBvZiBWaWV3cyBvciBTdXJmYWNlc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZEl0ZW1zIDogZnVuY3Rpb24gYWRkSXRlbXMoaXRlbXMpe1xuXHQgICAgICAgICAgICB0aGlzLm5vZGVzID0gaXRlbXM7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSsrKXtcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGxheW91dE5vZGUgPSBuZXcgTGF5b3V0Tm9kZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtIDogdGhpcy50cmFuc2Zvcm1zLnBsdWNrKGkpXG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpemVOb2RlID0gbmV3IFNpemVOb2RlKHtcblx0ICAgICAgICAgICAgICAgICAgICBzaXplIDogdGhpcy5zaXplcy5wbHVjayhpKVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxheW91dE5vZGUpLmFkZChzaXplTm9kZSkuYWRkKG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSwgQ09OU1RBTlRTKTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBGbGV4aWJsZUxheW91dDtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBDb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHQgICAgdmFyIFZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0ICAgIHZhciBTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcblx0ICAgIHZhciBMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0ICAgIHZhciBTaXplTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXHQgICAgdmFyIFRyYW5zaXRpb25hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBsYXlvdXQgdGhhdCBhcnJhbmdlcyBpdGVtcyBpbiBhIGdyaWQgYW5kIGNhbiByZWFycmFuZ2UgdGhlIGdyaWQgcmVzcG9uc2l2ZWx5LlxuXHQgICAgICpcblx0ICAgICAqICBUaGUgdXNlciBwcm92aWRlcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHBlciByb3cgaW4gYW4gYXJyYXkgb3IgYSBkaWN0aW9uYXJ5XG5cdCAgICAgKiAgd2l0aCBrZXlzIHRoYXQgYXJlIHBpeGVsIHZhbHVlcy4gVGhlIGl0ZW1zIHdpbGwgYmUgc2l6ZWQgdG8gZmlsbCB0aGUgYXZhaWxhYmxlIHNwYWNlLlxuXHQgICAgICpcblx0ICAgICAqICBMZXQgaXRlbXNQZXJSb3cgYmUgYSBkaWN0aW9uYXJ5IGlmIHlvdSB3YW50IHRoZSBncmlkIHRvIHJlYXJyYW5nZSByZXNwb25zaXZlbHkuIFRoZVxuXHQgICAgICogIGtleXMgc2hvdWxkIGJlIHBpeGVsIHZhbHVlcy4gVGhlIHJvdyBhcnJhbmdlbWVudCB3aWxsIGJlIG9uZSBvZiB0aGUgZW50cmllcyBvZlxuXHQgICAgICogIHRoZSBkaWN0aW9uYXJ5IHdob3NlIGtleSB2YWx1ZSBpcyBjbG9zZXN0IHRvIHRoZSBwYXJlbnQgd2lkdGggd2l0aG91dCBleGNlZWRpbmcgaXQuXG5cdCAgICAgKlxuXHQgICAgICogIEBjbGFzcyBHcmlkTGF5b3V0XG5cdCAgICAgKiAgQGNvbnN0cnVjdG9yXG5cdCAgICAgKiAgQGV4dGVuZHMgQ29yZS5WaWV3XG5cdCAgICAgKiAgQHBhcmFtIFtvcHRpb25zXSB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNcblx0ICAgICAqICBAcGFyYW0gb3B0aW9ucy5pdGVtc0J5Um93IHtBcnJheXxPYmplY3R9ICAgICAgICAgICAgTnVtYmVyIG9mIGl0ZW1zIHBlciByb3csIG9yIGFuIG9iamVjdCBvZiB7d2lkdGggOiBpdGVtc0J5Um93fSBwYWlyc1xuXHQgICAgICogIEBwYXJhbSBbb3B0aW9ucy5ndXR0ZXI9MF0ge1RyYW5zaXRpb25hYmxlfE51bWJlcn0gICBHYXAgc3BhY2UgYmV0d2VlbiBzdWNjZXNzaXZlIGl0ZW1zXG5cdCAgICAgKi9cblx0ICAgIHZhciBHcmlkTGF5b3V0ID0gVmlldy5leHRlbmQoe1xuXHQgICAgICAgIGRlZmF1bHRzIDoge1xuXHQgICAgICAgICAgICBpdGVtc1BlclJvdyA6IFtdLFxuXHQgICAgICAgICAgICBndXR0ZXIgOiAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBldmVudHMgOiB7fSxcblx0ICAgICAgICBpbml0aWFsaXplIDogZnVuY3Rpb24gaW5pdGlhbGl6ZShvcHRpb25zKXtcblx0ICAgICAgICAgICAgdmFyIGd1dHRlciA9IChvcHRpb25zLmd1dHRlciBpbnN0YW5jZW9mIFRyYW5zaXRpb25hYmxlKVxuXHQgICAgICAgICAgICAgICAgPyBvcHRpb25zLmd1dHRlclxuXHQgICAgICAgICAgICAgICAgOiBuZXcgVHJhbnNpdGlvbmFibGUob3B0aW9ucy5ndXR0ZXIpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gU3RyZWFtLmxpZnQoZnVuY3Rpb24oc2l6ZSwgZ3V0dGVyKXtcblx0ICAgICAgICAgICAgICAgIGlmICghc2l6ZSkgcmV0dXJuIGZhbHNlOyAvLyBUT0RPOiBmaXggYnVnXG5cblx0ICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IHNpemVbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc2l6ZVsxXTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSAoKG9wdGlvbnMuaXRlbXNQZXJSb3cgaW5zdGFuY2VvZiBBcnJheSkpXG5cdCAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLml0ZW1zUGVyUm93XG5cdCAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3RSb3dzKG9wdGlvbnMuaXRlbXNQZXJSb3csIHdpZHRoKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIG51bVJvd3MgPSByb3dzLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciByb3dIZWlnaHQgPSAoaGVpZ2h0IC0gKChudW1Sb3dzIC0gMSkgKiBndXR0ZXIpKSAvIG51bVJvd3M7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaXplcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgeSA9IDA7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBudW1Sb3dzOyByb3crKyl7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG51bUNvbHMgPSByb3dzW3Jvd107XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbFdpZHRoID0gKHdpZHRoIC0gKChudW1Db2xzIC0gMSkgKiBndXR0ZXIpKSAvIG51bUNvbHM7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbnVtQ29sczsgY29sKyspe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IFtjb2xXaWR0aCwgcm93SGVpZ2h0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXMucHVzaChzaXplKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goW3gseV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IGNvbFdpZHRoICsgZ3V0dGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHkgKz0gcm93SGVpZ2h0ICsgZ3V0dGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIHNpemVzIDogc2l6ZXMsXG5cdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zIDogcG9zaXRpb25zXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9LCBbdGhpcy5zaXplLCBndXR0ZXJdKVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkIGl0ZW1zIHRvIHRoZSBsYXlvdXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAbWV0aG9kIGFkZEl0ZW1zXG5cdCAgICAgICAgICogQHBhcmFtIFtpdGVtc10ge0FycmF5fSAgIEFycmF5IG9mIFN1cmZhY2VzIG9yIFZpZXdzXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgYWRkSXRlbXMgOiBmdW5jdGlvbiBhZGRJdGVtcyhpdGVtcyl7XG5cdCAgICAgICAgICAgIHZhciBzaXplcyA9IHRoaXMuc3RyZWFtLnBsdWNrKCdzaXplcycpO1xuXHQgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5zdHJlYW0ucGx1Y2soJ3Bvc2l0aW9ucycpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspe1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBpdGVtc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBzaXplcy5wbHVjayhpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9ucy5wbHVjayhpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHBvc2l0aW9uLm1hcChmdW5jdGlvbihwb3NpdGlvbil7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS50cmFuc2xhdGUocG9zaXRpb24pO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaXplID0gbmV3IFNpemVOb2RlKHtzaXplIDogc2l6ZX0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXROb2RlKHt0cmFuc2Zvcm0gOiB0cmFuc2Zvcm19KTtcblxuXHQgICAgICAgICAgICAgICAgdGhpcy5hZGQoc2l6ZSkuYWRkKGxheW91dCkuYWRkKG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIHNlbGVjdFJvd3Mocm93cywgd2lkdGgpe1xuXHQgICAgICAgIGZvciAodmFyIGN1dG9mZiBpbiByb3dzKSB7XG5cdCAgICAgICAgICAgIGlmICh3aWR0aCA8PSBwYXJzZUludChjdXRvZmYpKVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByb3dzW2N1dG9mZl07XG5cdCAgICB9XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gR3JpZExheW91dDtcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBDb3B5cmlnaHQgwqkgMjAxNSBEYXZpZCBWYWxkbWFuICovXG5cblx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXHQgICAgdmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHQgICAgdmFyIFZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblx0ICAgIHZhciBSZXNpemVTdHJlYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0ICAgIHZhciBMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXHQgICAgdmFyIENPTlNUQU5UUyA9IHtcblx0ICAgICAgICBESVJFQ1RJT04gOiB7XG5cdCAgICAgICAgICAgIFggOiAwLFxuXHQgICAgICAgICAgICBZIDogMVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBsYXlvdXQgd2hpY2ggYXJyYW5nZXMgaXRlbXMgaW4gc2VyaWVzIGJhc2VkIG9uIHRoZWlyIHNpemUuXG5cdCAgICAgKiAgSXRlbXMgY2FuIGJlIGFycmFuZ2VkIHZlcnRpY2FsbHkgb3IgaG9yaXpvbnRhbGx5LlxuXHQgICAgICpcblx0ICAgICAqIEBjbGFzcyBTZXF1ZW50aWFsTGF5b3V0XG5cdCAgICAgKiBAY29uc3RydWN0b3Jcblx0ICAgICAqIEBuYW1lc3BhY2UgTGF5b3V0c1xuXHQgICAgICogQGV4dGVuZHMgQ29yZS5WaWV3XG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnNdIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1xuXHQgICAgICogQHBhcmFtIFtvcHRpb25zLmRpcmVjdGlvbl17TnVtYmVyfSAgICAgICAgICAgICAgIERpcmVjdGlvbiB0byBsYXkgb3V0IGl0ZW1zXG5cdCAgICAgKiBAcGFyYW0gW29wdGlvbnMuc3BhY2luZ10ge1RyYW5zaXRpb25hYmxlfEFycmF5fSAgR3V0dGVyIHNwYWNpbmcgYmV0d2VlbiBpdGVtc1xuXHQgICAgICovXG5cdCAgICB2YXIgU2VxdWVudGlhbExheW91dCA9IFZpZXcuZXh0ZW5kKHtcblx0ICAgICAgICBkZWZhdWx0cyA6IHtcblx0ICAgICAgICAgICAgZGlyZWN0aW9uIDogQ09OU1RBTlRTLkRJUkVDVElPTi5YLFxuXHQgICAgICAgICAgICBzcGFjaW5nIDogMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uIGluaXRpYWxpemUoKXt9LFxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZCBjb250ZW50IGFzIGFuIGFycmF5IG9mIFZpZXdzIG9yIFN1cmZhY2VzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQG1ldGhvZCBhZGRJdGVtc1xuXHQgICAgICAgICAqIEBwYXJhbSBpdGVtcyB7QXJyYXl9ICBBbiBhcnJheSBvZiBWaWV3cyBvciBTdXJmYWNlc1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGFkZEl0ZW1zIDogZnVuY3Rpb24gYWRkSXRlbXMoaXRlbXMpe1xuXHQgICAgICAgICAgICB2YXIgc2l6ZXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKylcblx0ICAgICAgICAgICAgICAgIHNpemVzLnB1c2goaXRlbXNbaV0uc2l6ZSk7XG5cblx0ICAgICAgICAgICAgdmFyIHN0cmVhbSA9IFJlc2l6ZVN0cmVhbS5saWZ0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2l6ZXMgPSBhcmd1bWVudHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcblx0ICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG5cblx0ICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSAwO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplcy5sZW5ndGg7IGkrKyl7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBzaXplc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBkaXJlY3Rpb24gPT09IENPTlNUQU5UUy5ESVJFQ1RJT04uWFxuXHQgICAgICAgICAgICAgICAgICAgICAgICA/IFRyYW5zZm9ybS50cmFuc2xhdGVYKGxlbmd0aClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBUcmFuc2Zvcm0udHJhbnNsYXRlWShsZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBsZW5ndGggKz0gc2l6ZVtkaXJlY3Rpb25dICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtcyA6IHRyYW5zZm9ybXMsXG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgc2l6ZXMpO1xuXG5cdCAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1zID0gc3RyZWFtLnBsdWNrKCd0cmFuc2Zvcm1zJyk7XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdHJlYW0ucGx1Y2soJ2xlbmd0aCcpO1xuXG5cdCAgICAgICAgICAgIHRoaXMub3V0cHV0LnN1YnNjcmliZShsZW5ndGgpO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspe1xuXHQgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBpdGVtc1tpXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zLnBsdWNrKGkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXROb2RlKHt0cmFuc2Zvcm0gOiB0cmFuc2Zvcm19KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxheW91dCkuYWRkKG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSwgQ09OU1RBTlRTKTtcblxuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBTZXF1ZW50aWFsTGF5b3V0O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA1NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIENvcHlyaWdodCDCqSAyMDE1IERhdmlkIFZhbGRtYW4gKi9cblxuXHQhKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICB2YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cdCAgICB2YXIgVHJhbnNpdGlvbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblx0ICAgIHZhciBWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cdCAgICB2YXIgTGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdCAgICB2YXIgU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdCAgICB2YXIgUmVzaXplU3RyZWFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdCAgICB2YXIgQWNjdW11bGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblx0ICAgIHZhciBEaWZmZXJlbnRpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblxuXHQgICAgdmFyIFNlcXVlbnRpYWxMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblx0ICAgIHZhciBDb250YWluZXJTdXJmYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cblx0ICAgIHZhciBHZW5lcmljSW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblx0ICAgIHZhciBTY3JvbGxJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXHQgICAgdmFyIFRvdWNoSW5wdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxuXHQgICAgR2VuZXJpY0lucHV0LnJlZ2lzdGVyKHtcblx0ICAgICAgICB0b3VjaCA6IFRvdWNoSW5wdXQsXG5cdCAgICAgICAgc2Nyb2xsIDogU2Nyb2xsSW5wdXRcblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgQ09OU1RBTlRTID0ge1xuXHQgICAgICAgIERJUkVDVElPTiA6IHtcblx0ICAgICAgICAgICAgWCA6IDAsXG5cdCAgICAgICAgICAgIFkgOiAxXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdmFyIFNjcm9sbHZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cdCAgICAgICAgZGVmYXVsdHMgOiB7XG5cdCAgICAgICAgICAgIGRpcmVjdGlvbiA6IENPTlNUQU5UUy5ESVJFQ1RJT04uWSxcblx0ICAgICAgICAgICAgcGFnZVRyYW5zaXRpb24gOiBmYWxzZVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHQgICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAwO1xuXHQgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gMDtcblx0ICAgICAgICAgICAgdGhpcy5pdGVtT2Zmc2V0ID0gMDtcblx0ICAgICAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuXHQgICAgICAgICAgICB0aGlzLmxheW91dCA9IG5ldyBTZXF1ZW50aWFsTGF5b3V0KHtcblx0ICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA6IG9wdGlvbnMuZGlyZWN0aW9uXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHZhciBnZW5lcmljSW5wdXQgPSBuZXcgR2VuZXJpY0lucHV0KFsndG91Y2gnLCAnc2Nyb2xsJ10sIHtcblx0ICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA6IG9wdGlvbnMuZGlyZWN0aW9uXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG5ldyBBY2N1bXVsYXRvcigwKTtcblxuXHQgICAgICAgICAgICB0aGlzLmRyYWcgPSBuZXcgVHJhbnNpdGlvbmFibGUoMCk7XG5cdCAgICAgICAgICAgIHRoaXMuc3ByaW5nID0gbmV3IFRyYW5zaXRpb25hYmxlKDApO1xuXG5cdCAgICAgICAgICAgIHZhciBkcmFnRGlmZmVyZW50aWFsID0gbmV3IERpZmZlcmVudGlhbCgpO1xuXHQgICAgICAgICAgICB2YXIgc3ByaW5nRGlmZmVyZW50aWFsID0gbmV3IERpZmZlcmVudGlhbCgpO1xuXHQgICAgICAgICAgICB2YXIgZ2VzdHVyZURpZmZlcmVudGlhbCA9IGdlbmVyaWNJbnB1dC5wbHVjaygnZGVsdGEnKTtcblxuXHQgICAgICAgICAgICBkcmFnRGlmZmVyZW50aWFsLnN1YnNjcmliZSh0aGlzLmRyYWcpO1xuXHQgICAgICAgICAgICBzcHJpbmdEaWZmZXJlbnRpYWwuc3Vic2NyaWJlKHRoaXMuc3ByaW5nKTtcblxuXHQgICAgICAgICAgICBwb3NpdGlvbi5zdWJzY3JpYmUoZ2VzdHVyZURpZmZlcmVudGlhbCk7XG5cdCAgICAgICAgICAgIHBvc2l0aW9uLnN1YnNjcmliZShkcmFnRGlmZmVyZW50aWFsKTtcblx0ICAgICAgICAgICAgLy9wb3NpdGlvbi5zdWJzY3JpYmUoc3ByaW5nRGlmZmVyZW50aWFsKTtcblxuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5wYWdlVHJhbnNpdGlvbil7XG5cdCAgICAgICAgICAgICAgICBnZW5lcmljSW5wdXQub24oJ2VuZCcsIGZ1bmN0aW9uKGRhdGEpe1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkQm91bmNlKSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnLnJlc2V0KDApO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ByaW5nLnJlc2V0KDApO1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnZVRyYW5zaXRpb24udmVsb2NpdHkgPSBkYXRhLnZlbG9jaXR5ICsgdGhpcy5kcmFnLmdldFZlbG9jaXR5KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnLnNldCgwLCBvcHRpb25zLnBhZ2VUcmFuc2l0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICAgICAgICAgIGdlbmVyaWNJbnB1dC5vbignc3RhcnQnLCBmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZy5oYWx0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpbmcuaGFsdCgpO1xuXHQgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgICAgICAgICAgdGhpcy5zcHJpbmcub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZy52ZWxvY2l0eSA9IDA7XG5cdCAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGlzLnNwcmluZy5vbignZW5kJywgZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFuZ2VQYWdlLmNhbGwodGhpcywgdGhpcy5fY3VycmVudEluZGV4KTtcblx0ICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLmRyYWcub24oJ2VuZCcsIGZ1bmN0aW9uKGRhdGEpe1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zcHJpbmcuc2V0KHRoaXMuaXRlbU9mZnNldCwge1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnZlOiAnc3ByaW5nJyxcblx0ICAgICAgICAgICAgICAgICAgICBwZXJpb2Q6IDcwLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhbXBpbmc6IDAuNyxcblx0ICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA6IGRhdGEudmVsb2NpdHlcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cblx0ICAgICAgICAgICAgdmFyIG92ZXJmbG93U3RyZWFtID0gUmVzaXplU3RyZWFtLmxpZnQoZnVuY3Rpb24oY29udGVudExlbmd0aCwgdmlld3BvcnRTaXplKXtcblx0ICAgICAgICAgICAgICAgIGlmICghY29udGVudExlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdwb3J0U2l6ZVtvcHRpb25zLmRpcmVjdGlvbl0gLSBjb250ZW50TGVuZ3RoO1xuXHQgICAgICAgICAgICB9LCBbdGhpcy5sYXlvdXQsIHRoaXMuc2l6ZV0pO1xuXG5cblx0ICAgICAgICAgICAgdmFyIHNob3VsZEJvdW5jZSA9IHRydWU7XG5cdCAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gU3RyZWFtLmxpZnQoZnVuY3Rpb24odG9wLCBvdmVyZmxvdyl7XG5cdCAgICAgICAgICAgICAgICBzaG91bGRCb3VuY2UgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFvdmVyZmxvdykgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmFnLmlzQWN0aXZlKCkgfHwgdGhpcy5zcHJpbmcuaXNBY3RpdmUoKSlcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0b3ApO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodG9wIDw9IG92ZXJmbG93KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2hvdWxkQm91bmNlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uc2V0KG92ZXJmbG93LCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBjaGFuZ2VQYWdlLmNhbGwodGhpcywgdGhpcy5fY3VycmVudEluZGV4KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3c7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmKHRvcCA+PSAwKXtcblx0ICAgICAgICAgICAgICAgICAgICBzaG91bGRCb3VuY2UgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi5zZXQoMCwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhbmdlUGFnZS5jYWxsKHRoaXMsIHRoaXMuX2N1cnJlbnRJbmRleCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodG9wKTtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBbcG9zaXRpb24sIG92ZXJmbG93U3RyZWFtXSk7XG5cblx0ICAgICAgICAgICAgdmFyIGRpc3BsYWNlbWVudE5vZGUgPSBuZXcgTGF5b3V0Tm9kZSh7XG5cdCAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gOiB0aGlzLm9mZnNldC5tYXAoZnVuY3Rpb24ocG9zaXRpb24pe1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpcmVjdGlvbiA9PSBDT05TVEFOVFMuRElSRUNUSU9OLllcblx0ICAgICAgICAgICAgICAgICAgICAgICAgPyBUcmFuc2Zvcm0udHJhbnNsYXRlWShwb3NpdGlvbilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgOiBUcmFuc2Zvcm0udHJhbnNsYXRlWChwb3NpdGlvbik7XG5cdCAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IENvbnRhaW5lclN1cmZhY2Uoe1xuXHQgICAgICAgICAgICAgICAgcHJvcGVydGllcyA6IHtcblx0ICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA6ICdoaWRkZW4nXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGdlbmVyaWNJbnB1dC5zdWJzY3JpYmUoY29udGFpbmVyKTtcblxuXHQgICAgICAgICAgICBjb250YWluZXIuYWRkKGRpc3BsYWNlbWVudE5vZGUpLmFkZCh0aGlzLmxheW91dCk7XG5cdCAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRhaW5lcik7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnb3RvIDogZnVuY3Rpb24oaW5kZXgsIHRyYW5zaXRpb24sIGNhbGxiYWNrKXtcblx0ICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gfHwgdGhpcy5vcHRpb25zLnRyYW5zaXRpb247XG5cdCAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuaXRlbU9mZnNldDtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5fY3VycmVudEluZGV4KXtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9jdXJyZW50SW5kZXg7IGkgPCBpbmRleDsgaSsrKVxuXHQgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHRoaXMuaXRlbXNbaV0uZ2V0U2l6ZSgpW3RoaXMub3B0aW9ucy5kaXJlY3Rpb25dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4IDwgdGhpcy5fY3VycmVudEluZGV4KXtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9jdXJyZW50SW5kZXg7IGkgPiBpbmRleDsgaS0tKVxuXHQgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXMuaXRlbXNbaV0uZ2V0U2l6ZSgpW3RoaXMub3B0aW9ucy5kaXJlY3Rpb25dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgcmV0dXJuO1xuXG5cdCAgICAgICAgICAgIHRoaXMuc3ByaW5nLnNldCgwKTtcblx0ICAgICAgICAgICAgdGhpcy5zcHJpbmcuc2V0KE1hdGguY2VpbChwb3NpdGlvbiksIHRyYW5zaXRpb24sIGNhbGxiYWNrKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGFkZEl0ZW1zIDogZnVuY3Rpb24oaXRlbXMpe1xuXHQgICAgICAgICAgICB0aGlzLmxheW91dC5hZGRJdGVtcyhpdGVtcyk7XG5cdCAgICAgICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcblxuXHQgICAgICAgICAgICB2YXIgYXJncyA9IFt0aGlzLm9mZnNldF07XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspe1xuXHQgICAgICAgICAgICAgICAgYXJncy5wdXNoKGl0ZW1zW2ldLnNpemUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGFjY3VtTGVuZ3RoID0gMDtcblx0ICAgICAgICAgICAgdmFyIGl0ZW1PZmZzZXRTdHJlYW0gPSBTdHJlYW0ubGlmdChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHNbMF07XG5cdCAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5vcHRpb25zLmRpcmVjdGlvbjtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2N1cnJlbnRJbmRleDtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2l6ZSA9IGFyZ3VtZW50c1tpbmRleCArIDFdO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTaXplKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgICAgICAgICB2YXIgaXRlbU9mZnNldCA9IC1vZmZzZXQgLSBhY2N1bUxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGVuZ3RoID0gY3VycmVudFNpemVbZGlyZWN0aW9uXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGl0ZW1PZmZzZXQgPj0gY3VycmVudExlbmd0aCl7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyBjdXJyZW50Tm9kZSBmb3J3YXJkc1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuXHQgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBhY2N1bUxlbmd0aCArPSBjdXJyZW50TGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbU9mZnNldCA8IDApe1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgY3VycmVudE5vZGUgYmFja3dhcmRzXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRJbmRleCA9PSAwKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4LS07XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBhcmd1bWVudHNbdGhpcy5fY3VycmVudEluZGV4ICsgMV1bZGlyZWN0aW9uXTtcblx0ICAgICAgICAgICAgICAgICAgICBhY2N1bUxlbmd0aCAtPSBjdXJyZW50TGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBpdGVtT2Zmc2V0IC8gY3VycmVudExlbmd0aDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhpcy5pdGVtT2Zmc2V0ID0gKGl0ZW1PZmZzZXQgPCBjdXJyZW50TGVuZ3RoIC8gMilcblx0ICAgICAgICAgICAgICAgICAgICA/IGl0ZW1PZmZzZXRcblx0ICAgICAgICAgICAgICAgICAgICA6IGl0ZW1PZmZzZXQgLSBjdXJyZW50TGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4IDogdGhpcy5fY3VycmVudEluZGV4LFxuXHQgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzIDogcHJvZ3Jlc3Ncblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgYXJncyk7XG5cblx0ICAgICAgICAgICAgdGhpcy5vdXRwdXQuc3Vic2NyaWJlKGl0ZW1PZmZzZXRTdHJlYW0pO1xuXG5cdCAgICAgICAgICAgIGl0ZW1PZmZzZXRTdHJlYW0ub24oJ3N0YXJ0JywgZnVuY3Rpb24odmFsdWUpe1xuXHQgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG5cdCAgICAgICAgICAgIGl0ZW1PZmZzZXRTdHJlYW0ub24oJ3VwZGF0ZScsIGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXHQgICAgICAgICAgICBpdGVtT2Zmc2V0U3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbih2YWx1ZSl7XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGNoYW5nZVBhZ2UoaW5kZXgpe1xuXHQgICAgICAgIGNvbnNvbGUubG9nKGluZGV4LCB0aGlzLl9wcmV2aW91c0luZGV4KVxuXHQgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLl9wcmV2aW91c0luZGV4KSByZXR1cm47XG5cdCAgICAgICAgdGhpcy5vdXRwdXQuZW1pdCgncGFnZScsIGluZGV4KTtcblx0ICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gaW5kZXg7XG5cdCAgICB9XG5cblx0ICAgIG1vZHVsZS5leHBvcnRzID0gU2Nyb2xsdmlldztcblx0fS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblxuXG4vKioqLyB9LFxuLyogNTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzshKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICAgICAgICBBY2N1bXVsYXRvcjogX193ZWJwYWNrX3JlcXVpcmVfXyg1MyksXG5cdCAgICAgICAgRGlmZmVyZW50aWFsOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSxcblx0ICAgICAgICBTaW1wbGVTdHJlYW06IF9fd2VicGFja19yZXF1aXJlX18oMTEpLFxuXHQgICAgICAgIFN0cmVhbTogX193ZWJwYWNrX3JlcXVpcmVfXygxNSksXG5cdCAgICAgICAgT2JzZXJ2YWJsZTogX193ZWJwYWNrX3JlcXVpcmVfXygxNiksXG5cdCAgICAgICAgU2l6ZU9ic2VydmFibGU6IF9fd2VicGFja19yZXF1aXJlX18oMTkpXG5cdCAgICB9O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH0sXG4vKiA1OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXHQgICAgICAgIFR3ZWVuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSxcblx0ICAgICAgICBTcHJpbmc6IF9fd2VicGFja19yZXF1aXJlX18oMjQpLFxuXHQgICAgICAgIEluZXJ0aWE6IF9fd2VicGFja19yZXF1aXJlX18oMjUpXG5cdCAgICB9O1xuXHR9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjsiLCIvKiFcbiAqIHZ1ZS1yb3V0ZXIgdjAuNy4xMFxuICogKGMpIDIwMTYgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICBnbG9iYWwuVnVlUm91dGVyID0gZmFjdG9yeSgpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYmFiZWxIZWxwZXJzID0ge307XG5cbiAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gVGFyZ2V0KHBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgfVxuXG4gIFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgdG86IGZ1bmN0aW9uIHRvKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBkZWxlZ2F0ZSA9IHRoaXMuZGVsZWdhdGU7XG5cbiAgICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS53aWxsQWRkUm91dGUpIHtcbiAgICAgICAgdGFyZ2V0ID0gZGVsZWdhdGUud2lsbEFkZFJvdXRlKHRoaXMubWF0Y2hlci50YXJnZXQsIHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0Y2hlci5hZGQodGhpcy5wYXRoLCB0YXJnZXQpO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IGhhdmUgYW4gYXJndW1lbnQgaW4gdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byBgdG9gXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0Y2hlci5hZGRDaGlsZCh0aGlzLnBhdGgsIHRhcmdldCwgY2FsbGJhY2ssIHRoaXMuZGVsZWdhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1hdGNoZXIodGFyZ2V0KSB7XG4gICAgdGhpcy5yb3V0ZXMgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0ge307XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBNYXRjaGVyLnByb3RvdHlwZSA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChwYXRoLCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLnJvdXRlc1twYXRoXSA9IGhhbmRsZXI7XG4gICAgfSxcblxuICAgIGFkZENoaWxkOiBmdW5jdGlvbiBhZGRDaGlsZChwYXRoLCB0YXJnZXQsIGNhbGxiYWNrLCBkZWxlZ2F0ZSkge1xuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcih0YXJnZXQpO1xuICAgICAgdGhpcy5jaGlsZHJlbltwYXRoXSA9IG1hdGNoZXI7XG5cbiAgICAgIHZhciBtYXRjaCA9IGdlbmVyYXRlTWF0Y2gocGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuXG4gICAgICBpZiAoZGVsZWdhdGUgJiYgZGVsZWdhdGUuY29udGV4dEVudGVyZWQpIHtcbiAgICAgICAgZGVsZWdhdGUuY29udGV4dEVudGVyZWQodGFyZ2V0LCBtYXRjaCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG1hdGNoKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVNYXRjaChzdGFydGluZ1BhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCBuZXN0ZWRDYWxsYmFjaykge1xuICAgICAgdmFyIGZ1bGxQYXRoID0gc3RhcnRpbmdQYXRoICsgcGF0aDtcblxuICAgICAgaWYgKG5lc3RlZENhbGxiYWNrKSB7XG4gICAgICAgIG5lc3RlZENhbGxiYWNrKGdlbmVyYXRlTWF0Y2goZnVsbFBhdGgsIG1hdGNoZXIsIGRlbGVnYXRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldChzdGFydGluZ1BhdGggKyBwYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlKHJvdXRlQXJyYXksIHBhdGgsIGhhbmRsZXIpIHtcbiAgICB2YXIgbGVuID0gMDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJvdXRlQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gcm91dGVBcnJheVtpXS5wYXRoLmxlbmd0aDtcbiAgICB9XG5cbiAgICBwYXRoID0gcGF0aC5zdWJzdHIobGVuKTtcbiAgICB2YXIgcm91dGUgPSB7IHBhdGg6IHBhdGgsIGhhbmRsZXI6IGhhbmRsZXIgfTtcbiAgICByb3V0ZUFycmF5LnB1c2gocm91dGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZWFjaFJvdXRlKGJhc2VSb3V0ZSwgbWF0Y2hlciwgY2FsbGJhY2ssIGJpbmRpbmcpIHtcbiAgICB2YXIgcm91dGVzID0gbWF0Y2hlci5yb3V0ZXM7XG5cbiAgICBmb3IgKHZhciBwYXRoIGluIHJvdXRlcykge1xuICAgICAgaWYgKHJvdXRlcy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgICAgICB2YXIgcm91dGVBcnJheSA9IGJhc2VSb3V0ZS5zbGljZSgpO1xuICAgICAgICBhZGRSb3V0ZShyb3V0ZUFycmF5LCBwYXRoLCByb3V0ZXNbcGF0aF0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVyLmNoaWxkcmVuW3BhdGhdKSB7XG4gICAgICAgICAgZWFjaFJvdXRlKHJvdXRlQXJyYXksIG1hdGNoZXIuY2hpbGRyZW5bcGF0aF0sIGNhbGxiYWNrLCBiaW5kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGJpbmRpbmcsIHJvdXRlQXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFwIChjYWxsYmFjaywgYWRkUm91dGVDYWxsYmFjaykge1xuICAgIHZhciBtYXRjaGVyID0gbmV3IE1hdGNoZXIoKTtcblxuICAgIGNhbGxiYWNrKGdlbmVyYXRlTWF0Y2goXCJcIiwgbWF0Y2hlciwgdGhpcy5kZWxlZ2F0ZSkpO1xuXG4gICAgZWFjaFJvdXRlKFtdLCBtYXRjaGVyLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIGlmIChhZGRSb3V0ZUNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFJvdXRlQ2FsbGJhY2sodGhpcywgcm91dGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGQocm91dGUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgdmFyIHNwZWNpYWxzID0gWycvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJ107XG5cbiAgdmFyIGVzY2FwZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnKFxcXFwnICsgc3BlY2lhbHMuam9pbignfFxcXFwnKSArICcpJywgJ2cnKTtcblxuICBmdW5jdGlvbiBpc0FycmF5KHRlc3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRlc3QpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICAvLyBBIFNlZ21lbnQgcmVwcmVzZW50cyBhIHNlZ21lbnQgaW4gdGhlIG9yaWdpbmFsIHJvdXRlIGRlc2NyaXB0aW9uLlxuICAvLyBFYWNoIFNlZ21lbnQgdHlwZSBwcm92aWRlcyBhbiBgZWFjaENoYXJgIGFuZCBgcmVnZXhgIG1ldGhvZC5cbiAgLy9cbiAgLy8gVGhlIGBlYWNoQ2hhcmAgbWV0aG9kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggb25lIG9yIG1vcmUgY2hhcmFjdGVyXG4gIC8vIHNwZWNpZmljYXRpb25zLiBBIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGNvbnN1bWVzIG9uZSBvciBtb3JlIGlucHV0XG4gIC8vIGNoYXJhY3RlcnMuXG4gIC8vXG4gIC8vIFRoZSBgcmVnZXhgIG1ldGhvZCByZXR1cm5zIGEgcmVnZXggZnJhZ21lbnQgZm9yIHRoZSBzZWdtZW50LiBJZiB0aGVcbiAgLy8gc2VnbWVudCBpcyBhIGR5bmFtaWMgb2Ygc3RhciBzZWdtZW50LCB0aGUgcmVnZXggZnJhZ21lbnQgYWxzbyBpbmNsdWRlc1xuICAvLyBhIGNhcHR1cmUuXG4gIC8vXG4gIC8vIEEgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gY29udGFpbnM6XG4gIC8vXG4gIC8vICogYHZhbGlkQ2hhcnNgOiBhIFN0cmluZyB3aXRoIGEgbGlzdCBvZiBhbGwgdmFsaWQgY2hhcmFjdGVycywgb3JcbiAgLy8gKiBgaW52YWxpZENoYXJzYDogYSBTdHJpbmcgd2l0aCBhIGxpc3Qgb2YgYWxsIGludmFsaWQgY2hhcmFjdGVyc1xuICAvLyAqIGByZXBlYXRgOiB0cnVlIGlmIHRoZSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBjYW4gcmVwZWF0XG5cbiAgZnVuY3Rpb24gU3RhdGljU2VnbWVudChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgfVxuICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZSA9IHtcbiAgICBlYWNoQ2hhcjogZnVuY3Rpb24gZWFjaENoYXIoY2FsbGJhY2spIHtcbiAgICAgIHZhciBzdHJpbmcgPSB0aGlzLnN0cmluZyxcbiAgICAgICAgICBjaDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoID0gc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgY2FsbGJhY2soeyB2YWxpZENoYXJzOiBjaCB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBEeW5hbWljU2VnbWVudChuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBEeW5hbWljU2VnbWVudC5wcm90b3R5cGUgPSB7XG4gICAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayh7IGludmFsaWRDaGFyczogXCIvXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIFwiKFteL10rKVwiO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zW3RoaXMubmFtZV07XG4gICAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIjpcIiArIHRoaXMubmFtZSA6IHZhbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU3RhclNlZ21lbnQobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgU3RhclNlZ21lbnQucHJvdG90eXBlID0ge1xuICAgIGVhY2hDaGFyOiBmdW5jdGlvbiBlYWNoQ2hhcihjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soeyBpbnZhbGlkQ2hhcnM6IFwiXCIsIHJlcGVhdDogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIFwiKC4rKVwiO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zW3RoaXMubmFtZV07XG4gICAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIjpcIiArIHRoaXMubmFtZSA6IHZhbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gRXBzaWxvblNlZ21lbnQoKSB7fVxuICBFcHNpbG9uU2VnbWVudC5wcm90b3R5cGUgPSB7XG4gICAgZWFjaENoYXI6IGZ1bmN0aW9uIGVhY2hDaGFyKCkge30sXG4gICAgcmVnZXg6IGZ1bmN0aW9uIHJlZ2V4KCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2Uocm91dGUsIG5hbWVzLCBzcGVjaWZpY2l0eSkge1xuICAgIC8vIG5vcm1hbGl6ZSByb3V0ZSBhcyBub3Qgc3RhcnRpbmcgd2l0aCBhIFwiL1wiLiBSZWNvZ25pdGlvbiB3aWxsXG4gICAgLy8gYWxzbyBub3JtYWxpemUuXG4gICAgaWYgKHJvdXRlLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgIHJvdXRlID0gcm91dGUuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50cyA9IHJvdXRlLnNwbGl0KFwiL1wiKSxcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gQSByb3V0ZXMgaGFzIHNwZWNpZmljaXR5IGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoYXQgaXRzIGRpZmZlcmVudCBzZWdtZW50c1xuICAgIC8vIGFwcGVhciBpbi4gVGhpcyBzeXN0ZW0gbWlycm9ycyBob3cgdGhlIG1hZ25pdHVkZSBvZiBudW1iZXJzIHdyaXR0ZW4gYXMgc3RyaW5nc1xuICAgIC8vIHdvcmtzLlxuICAgIC8vIENvbnNpZGVyIGEgbnVtYmVyIHdyaXR0ZW4gYXM6IFwiYWJjXCIuIEFuIGV4YW1wbGUgd291bGQgYmUgXCIyMDBcIi4gQW55IG90aGVyIG51bWJlciB3cml0dGVuXG4gICAgLy8gXCJ4eXpcIiB3aWxsIGJlIHNtYWxsZXIgdGhhbiBcImFiY1wiIHNvIGxvbmcgYXMgYGEgPiB6YC4gRm9yIGluc3RhbmNlLCBcIjE5OVwiIGlzIHNtYWxsZXJcbiAgICAvLyB0aGVuIFwiMjAwXCIsIGV2ZW4gdGhvdWdoIFwieVwiIGFuZCBcInpcIiAod2hpY2ggYXJlIGJvdGggOSkgYXJlIGxhcmdlciB0aGFuIFwiMFwiICh0aGUgdmFsdWVcbiAgICAvLyBvZiAoYGJgIGFuZCBgY2ApLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxlYWRpbmcgc3ltYm9sLCBcIjJcIiwgaXMgbGFyZ2VyIHRoYW4gdGhlIG90aGVyXG4gICAgLy8gbGVhZGluZyBzeW1ib2wsIFwiMVwiLlxuICAgIC8vIFRoZSBydWxlIGlzIHRoYXQgc3ltYm9scyB0byB0aGUgbGVmdCBjYXJyeSBtb3JlIHdlaWdodCB0aGFuIHN5bWJvbHMgdG8gdGhlIHJpZ2h0XG4gICAgLy8gd2hlbiBhIG51bWJlciBpcyB3cml0dGVuIG91dCBhcyBhIHN0cmluZy4gSW4gdGhlIGFib3ZlIHN0cmluZ3MsIHRoZSBsZWFkaW5nIGRpZ2l0XG4gICAgLy8gcmVwcmVzZW50cyBob3cgbWFueSAxMDAncyBhcmUgaW4gdGhlIG51bWJlciwgYW5kIGl0IGNhcnJpZXMgbW9yZSB3ZWlnaHQgdGhhbiB0aGUgbWlkZGxlXG4gICAgLy8gbnVtYmVyIHdoaWNoIHJlcHJlc2VudHMgaG93IG1hbnkgMTAncyBhcmUgaW4gdGhlIG51bWJlci5cbiAgICAvLyBUaGlzIHN5c3RlbSBvZiBudW1iZXIgbWFnbml0dWRlIHdvcmtzIHdlbGwgZm9yIHJvdXRlIHNwZWNpZmljaXR5LCB0b28uIEEgcm91dGUgd3JpdHRlbiBhc1xuICAgIC8vIGBhL2IvY2Agd2lsbCBiZSBtb3JlIHNwZWNpZmljIHRoYW4gYHgveS96YCBhcyBsb25nIGFzIGBhYCBpcyBtb3JlIHNwZWNpZmljIHRoYW5cbiAgICAvLyBgeGAsIGlycmVzcGVjdGl2ZSBvZiB0aGUgb3RoZXIgcGFydHMuXG4gICAgLy8gQmVjYXVzZSBvZiB0aGlzIHNpbWlsYXJpdHksIHdlIGFzc2lnbiBlYWNoIHR5cGUgb2Ygc2VnbWVudCBhIG51bWJlciB2YWx1ZSB3cml0dGVuIGFzIGFcbiAgICAvLyBzdHJpbmcuIFdlIGNhbiBmaW5kIHRoZSBzcGVjaWZpY2l0eSBvZiBjb21wb3VuZCByb3V0ZXMgYnkgY29uY2F0ZW5hdGluZyB0aGVzZSBzdHJpbmdzXG4gICAgLy8gdG9nZXRoZXIsIGZyb20gbGVmdCB0byByaWdodC4gQWZ0ZXIgd2UgaGF2ZSBsb29wZWQgdGhyb3VnaCBhbGwgb2YgdGhlIHNlZ21lbnRzLFxuICAgIC8vIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlci5cbiAgICBzcGVjaWZpY2l0eS52YWwgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2ggPSBzZWdtZW50Lm1hdGNoKC9eOihbXlxcL10rKSQvKSkge1xuICAgICAgICByZXN1bHRzLnB1c2gobmV3IER5bmFtaWNTZWdtZW50KG1hdGNoWzFdKSk7XG4gICAgICAgIG5hbWVzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzMnO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IHNlZ21lbnQubWF0Y2goL15cXCooW15cXC9dKykkLykpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGFyU2VnbWVudChtYXRjaFsxXSkpO1xuICAgICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzInO1xuICAgICAgICBuYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHRzLnB1c2gobmV3IEVwc2lsb25TZWdtZW50KCkpO1xuICAgICAgICBzcGVjaWZpY2l0eS52YWwgKz0gJzEnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBTdGF0aWNTZWdtZW50KHNlZ21lbnQpKTtcbiAgICAgICAgc3BlY2lmaWNpdHkudmFsICs9ICc0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzcGVjaWZpY2l0eS52YWwgPSArc3BlY2lmaWNpdHkudmFsO1xuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyBBIFN0YXRlIGhhcyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFuZCAoYGNoYXJTcGVjYCkgYW5kIGEgbGlzdCBvZiBwb3NzaWJsZVxuICAvLyBzdWJzZXF1ZW50IHN0YXRlcyAoYG5leHRTdGF0ZXNgKS5cbiAgLy9cbiAgLy8gSWYgYSBTdGF0ZSBpcyBhbiBhY2NlcHRpbmcgc3RhdGUsIGl0IHdpbGwgYWxzbyBoYXZlIHNldmVyYWwgYWRkaXRpb25hbFxuICAvLyBwcm9wZXJ0aWVzOlxuICAvL1xuICAvLyAqIGByZWdleGA6IEEgcmVndWxhciBleHByZXNzaW9uIHRoYXQgaXMgdXNlZCB0byBleHRyYWN0IHBhcmFtZXRlcnMgZnJvbSBwYXRoc1xuICAvLyAgIHRoYXQgcmVhY2hlZCB0aGlzIGFjY2VwdGluZyBzdGF0ZS5cbiAgLy8gKiBgaGFuZGxlcnNgOiBJbmZvcm1hdGlvbiBvbiBob3cgdG8gY29udmVydCB0aGUgbGlzdCBvZiBjYXB0dXJlcyBpbnRvIGNhbGxzXG4gIC8vICAgdG8gcmVnaXN0ZXJlZCBoYW5kbGVycyB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyc1xuICAvLyAqIGB0eXBlc2A6IEhvdyBtYW55IHN0YXRpYywgZHluYW1pYyBvciBzdGFyIHNlZ21lbnRzIGluIHRoaXMgcm91dGUuIFVzZWQgdG9cbiAgLy8gICBkZWNpZGUgd2hpY2ggcm91dGUgdG8gdXNlIGlmIG11bHRpcGxlIHJlZ2lzdGVyZWQgcm91dGVzIG1hdGNoIGEgcGF0aC5cbiAgLy9cbiAgLy8gQ3VycmVudGx5LCBTdGF0ZSBpcyBpbXBsZW1lbnRlZCBuYWl2ZWx5IGJ5IGxvb3Bpbmcgb3ZlciBgbmV4dFN0YXRlc2AgYW5kXG4gIC8vIGNvbXBhcmluZyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFnYWluc3QgYSBjaGFyYWN0ZXIuIEEgbW9yZSBlZmZpY2llbnRcbiAgLy8gaW1wbGVtZW50YXRpb24gd291bGQgdXNlIGEgaGFzaCBvZiBrZXlzIHBvaW50aW5nIGF0IG9uZSBvciBtb3JlIG5leHQgc3RhdGVzLlxuXG4gIGZ1bmN0aW9uIFN0YXRlKGNoYXJTcGVjKSB7XG4gICAgdGhpcy5jaGFyU3BlYyA9IGNoYXJTcGVjO1xuICAgIHRoaXMubmV4dFN0YXRlcyA9IFtdO1xuICB9XG5cbiAgU3RhdGUucHJvdG90eXBlID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGNoYXJTcGVjKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0U3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXh0U3RhdGVzW2ldO1xuXG4gICAgICAgIHZhciBpc0VxdWFsID0gY2hpbGQuY2hhclNwZWMudmFsaWRDaGFycyA9PT0gY2hhclNwZWMudmFsaWRDaGFycztcbiAgICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgY2hpbGQuY2hhclNwZWMuaW52YWxpZENoYXJzID09PSBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG5cbiAgICAgICAgaWYgKGlzRXF1YWwpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbiBwdXQoY2hhclNwZWMpIHtcbiAgICAgIHZhciBzdGF0ZTtcblxuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFscmVhZHkgZXhpc3RzIGluIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnRcbiAgICAgIC8vIHN0YXRlLCBqdXN0IHJldHVybiB0aGF0IHN0YXRlLlxuICAgICAgaWYgKHN0YXRlID0gdGhpcy5nZXQoY2hhclNwZWMpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBhIG5ldyBzdGF0ZSBmb3IgdGhlIGNoYXJhY3RlciBzcGVjXG4gICAgICBzdGF0ZSA9IG5ldyBTdGF0ZShjaGFyU3BlYyk7XG5cbiAgICAgIC8vIEluc2VydCB0aGUgbmV3IHN0YXRlIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgIHRoaXMubmV4dFN0YXRlcy5wdXNoKHN0YXRlKTtcblxuICAgICAgLy8gSWYgdGhpcyBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiByZXBlYXRzLCBpbnNlcnQgdGhlIG5ldyBzdGF0ZSBhcyBhIGNoaWxkXG4gICAgICAvLyBvZiBpdHNlbGYuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IHRyaWdnZXIgYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIGVhY2hcbiAgICAgIC8vIHRyYW5zaXRpb24gZHVyaW5nIHJlY29nbml0aW9uIGNvbnN1bWVzIGEgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoYXJTcGVjLnJlcGVhdCkge1xuICAgICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIG5ldyBzdGF0ZVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGEgbGlzdCBvZiBjaGlsZCBzdGF0ZXMgbWF0Y2hpbmcgdGhlIG5leHQgY2hhcmFjdGVyXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGNoKSB7XG4gICAgICAvLyBERUJVRyBcIlByb2Nlc3NpbmcgYFwiICsgY2ggKyBcImA6XCJcbiAgICAgIHZhciBuZXh0U3RhdGVzID0gdGhpcy5uZXh0U3RhdGVzLFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIGNoYXJTcGVjLFxuICAgICAgICAgIGNoYXJzO1xuXG4gICAgICAvLyBERUJVRyBcIiAgXCIgKyBkZWJ1Z1N0YXRlKHRoaXMpXG4gICAgICB2YXIgcmV0dXJuZWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0U3RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5leHRTdGF0ZXNbaV07XG5cbiAgICAgICAgY2hhclNwZWMgPSBjaGlsZC5jaGFyU3BlYztcblxuICAgICAgICBpZiAodHlwZW9mIChjaGFycyA9IGNoYXJTcGVjLnZhbGlkQ2hhcnMpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGlmIChjaGFycy5pbmRleE9mKGNoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybmVkLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGNoYXJzID0gY2hhclNwZWMuaW52YWxpZENoYXJzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoY2hhcnMuaW5kZXhPZihjaCkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm5lZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVybmVkO1xuICAgIH1cblxuICAgIC8qKiBJRiBERUJVR1xuICAgICwgZGVidWc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXJTcGVjID0gdGhpcy5jaGFyU3BlYyxcbiAgICAgICAgICBkZWJ1ZyA9IFwiW1wiLFxuICAgICAgICAgIGNoYXJzID0gY2hhclNwZWMudmFsaWRDaGFycyB8fCBjaGFyU3BlYy5pbnZhbGlkQ2hhcnM7XG4gICAgICAgaWYgKGNoYXJTcGVjLmludmFsaWRDaGFycykgeyBkZWJ1ZyArPSBcIl5cIjsgfVxuICAgICAgZGVidWcgKz0gY2hhcnM7XG4gICAgICBkZWJ1ZyArPSBcIl1cIjtcbiAgICAgICBpZiAoY2hhclNwZWMucmVwZWF0KSB7IGRlYnVnICs9IFwiK1wiOyB9XG4gICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICBFTkQgSUYgKiovXG4gIH07XG5cbiAgLyoqIElGIERFQlVHXG4gIGZ1bmN0aW9uIGRlYnVnKGxvZykge1xuICAgIGNvbnNvbGUubG9nKGxvZyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJ1Z1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLm5leHRTdGF0ZXMubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgIGlmIChuLm5leHRTdGF0ZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiBcIiggXCIgKyBuLmRlYnVnKCkgKyBcIiBbYWNjZXB0aW5nXSApXCI7IH1cbiAgICAgIHJldHVybiBcIiggXCIgKyBuLmRlYnVnKCkgKyBcIiA8dGhlbj4gXCIgKyBuLm5leHRTdGF0ZXMubWFwKGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMuZGVidWcoKSB9KS5qb2luKFwiIG9yIFwiKSArIFwiIClcIjtcbiAgICB9KS5qb2luKFwiLCBcIilcbiAgfVxuICBFTkQgSUYgKiovXG5cbiAgLy8gU29ydCB0aGUgcm91dGVzIGJ5IHNwZWNpZmljaXR5XG4gIGZ1bmN0aW9uIHNvcnRTb2x1dGlvbnMoc3RhdGVzKSB7XG4gICAgcmV0dXJuIHN0YXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5zcGVjaWZpY2l0eS52YWwgLSBhLnNwZWNpZmljaXR5LnZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29nbml6ZUNoYXIoc3RhdGVzLCBjaCkge1xuICAgIHZhciBuZXh0U3RhdGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tpXTtcblxuICAgICAgbmV4dFN0YXRlcyA9IG5leHRTdGF0ZXMuY29uY2F0KHN0YXRlLm1hdGNoKGNoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZXM7XG4gIH1cblxuICB2YXIgb0NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgICByZXR1cm4gbmV3IEYoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKSB7XG4gICAgdGhpcy5xdWVyeVBhcmFtcyA9IHF1ZXJ5UGFyYW1zIHx8IHt9O1xuICB9XG4gIFJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlID0gb0NyZWF0ZSh7XG4gICAgc3BsaWNlOiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLFxuICAgIHNsaWNlOiBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgcHVzaDogQXJyYXkucHJvdG90eXBlLnB1c2gsXG4gICAgbGVuZ3RoOiAwLFxuICAgIHF1ZXJ5UGFyYW1zOiBudWxsXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVyKHN0YXRlLCBwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgIHZhciBoYW5kbGVycyA9IHN0YXRlLmhhbmRsZXJzLFxuICAgICAgICByZWdleCA9IHN0YXRlLnJlZ2V4O1xuICAgIHZhciBjYXB0dXJlcyA9IHBhdGgubWF0Y2gocmVnZXgpLFxuICAgICAgICBjdXJyZW50Q2FwdHVyZSA9IDE7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgIG5hbWVzID0gaGFuZGxlci5uYW1lcyxcbiAgICAgICAgICBwYXJhbXMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBuYW1lcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgcGFyYW1zW25hbWVzW2pdXSA9IGNhcHR1cmVzW2N1cnJlbnRDYXB0dXJlKytdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIuaGFuZGxlciwgcGFyYW1zOiBwYXJhbXMsIGlzRHluYW1pYzogISFuYW1lcy5sZW5ndGggfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KSB7XG4gICAgc2VnbWVudC5lYWNoQ2hhcihmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHZhciBzdGF0ZTtcblxuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFN0YXRlLnB1dChjaCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFydCkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjEzLjQuMVxuICAgIHBhcnQgPSBwYXJ0LnJlcGxhY2UoL1xcKy9nbSwgJyUyMCcpO1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFydCk7XG4gIH1cblxuICAvLyBUaGUgbWFpbiBpbnRlcmZhY2VcblxuICB2YXIgUm91dGVSZWNvZ25pemVyID0gZnVuY3Rpb24gUm91dGVSZWNvZ25pemVyKCkge1xuICAgIHRoaXMucm9vdFN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5uYW1lcyA9IHt9O1xuICB9O1xuXG4gIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiBhZGQocm91dGVzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5yb290U3RhdGUsXG4gICAgICAgICAgcmVnZXggPSBcIl5cIixcbiAgICAgICAgICBzcGVjaWZpY2l0eSA9IHt9LFxuICAgICAgICAgIGhhbmRsZXJzID0gW10sXG4gICAgICAgICAgYWxsU2VnbWVudHMgPSBbXSxcbiAgICAgICAgICBuYW1lO1xuXG4gICAgICB2YXIgaXNFbXB0eSA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm91dGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV0sXG4gICAgICAgICAgICBuYW1lcyA9IFtdO1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHBhcnNlKHJvdXRlLnBhdGgsIG5hbWVzLCBzcGVjaWZpY2l0eSk7XG5cbiAgICAgICAgYWxsU2VnbWVudHMgPSBhbGxTZWdtZW50cy5jb25jYXQoc2VnbWVudHMpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gc2VnbWVudHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tqXTtcblxuICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgRXBzaWxvblNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIEFkZCBhIFwiL1wiIGZvciB0aGUgbmV3IHNlZ21lbnRcbiAgICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUucHV0KHsgdmFsaWRDaGFyczogXCIvXCIgfSk7XG4gICAgICAgICAgcmVnZXggKz0gXCIvXCI7XG5cbiAgICAgICAgICAvLyBBZGQgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VnbWVudCB0byB0aGUgTkZBIGFuZCByZWdleFxuICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IGFkZFNlZ21lbnQoY3VycmVudFN0YXRlLCBzZWdtZW50KTtcbiAgICAgICAgICByZWdleCArPSBzZWdtZW50LnJlZ2V4KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFuZGxlciA9IHsgaGFuZGxlcjogcm91dGUuaGFuZGxlciwgbmFtZXM6IG5hbWVzIH07XG4gICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRTdGF0ZS5wdXQoeyB2YWxpZENoYXJzOiBcIi9cIiB9KTtcbiAgICAgICAgcmVnZXggKz0gXCIvXCI7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRTdGF0ZS5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgICAgY3VycmVudFN0YXRlLnJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCArIFwiJFwiKTtcbiAgICAgIGN1cnJlbnRTdGF0ZS5zcGVjaWZpY2l0eSA9IHNwZWNpZmljaXR5O1xuXG4gICAgICBpZiAobmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5hcykge1xuICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0ge1xuICAgICAgICAgIHNlZ21lbnRzOiBhbGxTZWdtZW50cyxcbiAgICAgICAgICBoYW5kbGVyczogaGFuZGxlcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlcnNGb3I6IGZ1bmN0aW9uIGhhbmRsZXJzRm9yKG5hbWUpIHtcbiAgICAgIHZhciByb3V0ZSA9IHRoaXMubmFtZXNbbmFtZV0sXG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHJvdXRlIG5hbWVkIFwiICsgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcm91dGUuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJvdXRlLmhhbmRsZXJzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgaGFzUm91dGU6IGZ1bmN0aW9uIGhhc1JvdXRlKG5hbWUpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubmFtZXNbbmFtZV07XG4gICAgfSxcblxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbiBnZW5lcmF0ZShuYW1lLCBwYXJhbXMpIHtcbiAgICAgIHZhciByb3V0ZSA9IHRoaXMubmFtZXNbbmFtZV0sXG4gICAgICAgICAgb3V0cHV0ID0gXCJcIjtcbiAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gcm91dGUgbmFtZWQgXCIgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnRzID0gcm91dGUuc2VnbWVudHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBFcHNpbG9uU2VnbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9IFwiL1wiO1xuICAgICAgICBvdXRwdXQgKz0gc2VnbWVudC5nZW5lcmF0ZShwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0LmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIG91dHB1dCA9ICcvJyArIG91dHB1dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgb3V0cHV0ICs9IHRoaXMuZ2VuZXJhdGVRdWVyeVN0cmluZyhwYXJhbXMucXVlcnlQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZVF1ZXJ5U3RyaW5nOiBmdW5jdGlvbiBnZW5lcmF0ZVF1ZXJ5U3RyaW5nKHBhcmFtcykge1xuICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2V5cy5zb3J0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFpciA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgdmFyIGFycmF5UGFpciA9IGtleSArICdbXScgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWVbal0pO1xuICAgICAgICAgICAgcGFpcnMucHVzaChhcnJheVBhaXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWlyICs9IFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgICBwYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCI/XCIgKyBwYWlycy5qb2luKFwiJlwiKTtcbiAgICB9LFxuXG4gICAgcGFyc2VRdWVyeVN0cmluZzogZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZykge1xuICAgICAgdmFyIHBhaXJzID0gcXVlcnlTdHJpbmcuc3BsaXQoXCImXCIpLFxuICAgICAgICAgIHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKSxcbiAgICAgICAgICAgIGtleSA9IGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhaXJbMF0pLFxuICAgICAgICAgICAga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICAgIGlzQXJyYXkgPSBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICBpZiAocGFpci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9ICd0cnVlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL0hhbmRsZSBhcnJheXNcbiAgICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMiAmJiBrZXkuc2xpY2Uoa2V5TGVuZ3RoIC0gMikgPT09ICdbXScpIHtcbiAgICAgICAgICAgIGlzQXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIGtleUxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeVBhcmFtc1trZXldKSB7XG4gICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBwYWlyWzFdID8gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFpclsxXSkgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgIHF1ZXJ5UGFyYW1zW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlQYXJhbXM7XG4gICAgfSxcblxuICAgIHJlY29nbml6ZTogZnVuY3Rpb24gcmVjb2duaXplKHBhdGgpIHtcbiAgICAgIHZhciBzdGF0ZXMgPSBbdGhpcy5yb290U3RhdGVdLFxuICAgICAgICAgIHBhdGhMZW4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHF1ZXJ5U3RhcnQsXG4gICAgICAgICAgcXVlcnlQYXJhbXMgPSB7fSxcbiAgICAgICAgICBpc1NsYXNoRHJvcHBlZCA9IGZhbHNlO1xuXG4gICAgICBxdWVyeVN0YXJ0ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gICAgICBpZiAocXVlcnlTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcGF0aC5zdWJzdHIocXVlcnlTdGFydCArIDEsIHBhdGgubGVuZ3RoKTtcbiAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHF1ZXJ5U3RhcnQpO1xuICAgICAgICBxdWVyeVBhcmFtcyA9IHRoaXMucGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIHBhdGggPSBkZWNvZGVVUkkocGF0aCk7XG5cbiAgICAgIC8vIERFQlVHIEdST1VQIHBhdGhcblxuICAgICAgaWYgKHBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICBwYXRoID0gXCIvXCIgKyBwYXRoO1xuICAgICAgfVxuXG4gICAgICBwYXRoTGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICBpZiAocGF0aExlbiA+IDEgJiYgcGF0aC5jaGFyQXQocGF0aExlbiAtIDEpID09PSBcIi9cIikge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aExlbiAtIDEpO1xuICAgICAgICBpc1NsYXNoRHJvcHBlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzdGF0ZXMgPSByZWNvZ25pemVDaGFyKHN0YXRlcywgcGF0aC5jaGFyQXQoaSkpO1xuICAgICAgICBpZiAoIXN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBFTkQgREVCVUcgR1JPVVBcblxuICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHN0YXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YXRlc1tpXS5oYW5kbGVycykge1xuICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKHN0YXRlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhdGVzID0gc29ydFNvbHV0aW9ucyhzb2x1dGlvbnMpO1xuXG4gICAgICB2YXIgc3RhdGUgPSBzb2x1dGlvbnNbMF07XG5cbiAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5oYW5kbGVycykge1xuICAgICAgICAvLyBpZiBhIHRyYWlsaW5nIHNsYXNoIHdhcyBkcm9wcGVkIGFuZCBhIHN0YXIgc2VnbWVudCBpcyB0aGUgbGFzdCBzZWdtZW50XG4gICAgICAgIC8vIHNwZWNpZmllZCwgcHV0IHRoZSB0cmFpbGluZyBzbGFzaCBiYWNrXG4gICAgICAgIGlmIChpc1NsYXNoRHJvcHBlZCAmJiBzdGF0ZS5yZWdleC5zb3VyY2Uuc2xpY2UoLTUpID09PSBcIiguKykkXCIpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aCArIFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5kSGFuZGxlcihzdGF0ZSwgcGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLm1hcCA9IG1hcDtcblxuICBSb3V0ZVJlY29nbml6ZXIuVkVSU0lPTiA9ICcwLjEuOSc7XG5cbiAgdmFyIGdlblF1ZXJ5ID0gUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZVF1ZXJ5U3RyaW5nO1xuXG4gIC8vIGV4cG9ydCBkZWZhdWx0IGZvciBob2xkaW5nIHRoZSBWdWUgcmVmZXJlbmNlXG4gIHZhciBleHBvcnRzJDEgPSB7fTtcbiAgLyoqXG4gICAqIFdhcm4gc3R1ZmYuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcbiAgICovXG5cbiAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdnVlLXJvdXRlcl0gJyArIG1zZyk7XG4gICAgICBpZiAoIWV4cG9ydHMkMS5WdWUgfHwgZXhwb3J0cyQxLlZ1ZS5jb25maWcuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcignd2FybmluZyBzdGFjayB0cmFjZTonKS5zdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgYSByZWxhdGl2ZSBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBhcHBlbmRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiByZXNvbHZlUGF0aChiYXNlLCByZWxhdGl2ZSwgYXBwZW5kKSB7XG4gICAgdmFyIHF1ZXJ5ID0gYmFzZS5tYXRjaCgvKFxcPy4qKSQvKTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnlbMV07XG4gICAgICBiYXNlID0gYmFzZS5zbGljZSgwLCAtcXVlcnkubGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gYSBxdWVyeSFcbiAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmU7XG4gICAgfVxuICAgIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICAgIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICAgIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgaWYgKHNlZ21lbnQgPT09ICcuJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gICAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjay5qb2luKCcvJyk7XG4gIH1cblxuICAvKipcbiAgICogRm9yZ2l2aW5nIGNoZWNrIGZvciBhIHByb21pc2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG5cbiAgZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgICByZXR1cm4gcCAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpdmUgYSByb3V0ZSBjb25maWcgZmllbGQgZnJvbSBhIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBPUiBhIGNvbXBvbmVudCBjb250cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFZ1ZX0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgbmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gY29tcG9uZW50ICYmIChjb21wb25lbnQuJG9wdGlvbnMgfHwgY29tcG9uZW50Lm9wdGlvbnMpO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucm91dGUgJiYgb3B0aW9ucy5yb3V0ZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LiBIYXZlIHRvIGRvIGEgZGlydHlcbiAgICogbW9jayBoZXJlIGJlY2F1c2Ugb2YgVnVlIGNvcmUncyBpbnRlcm5hbCBBUEkgZGVwZW5kcyBvblxuICAgKiBhbiBJRCBjaGVjay5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgdmFyIHJlc29sdmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChoYW5kbGVyLCBjYikge1xuICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgIHJlc29sdmVyID0ge1xuICAgICAgICByZXNvbHZlOiBleHBvcnRzJDEuVnVlLnByb3RvdHlwZS5fcmVzb2x2ZUNvbXBvbmVudCxcbiAgICAgICAgJG9wdGlvbnM6IHtcbiAgICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICBfOiBoYW5kbGVyLmNvbXBvbmVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZXIuJG9wdGlvbnMuY29tcG9uZW50cy5fID0gaGFuZGxlci5jb21wb25lbnQ7XG4gICAgfVxuICAgIHJlc29sdmVyLnJlc29sdmUoJ18nLCBmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICBoYW5kbGVyLmNvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgICAgIGNiKENvbXBvbmVudCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWFwIHRoZSBkeW5hbWljIHNlZ21lbnRzIGluIGEgcGF0aCB0byBwYXJhbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5XG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcFBhcmFtcyhwYXRoLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSBwYXJhbXMgPSB7fTtcblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoLzooW15cXC9dKykvZywgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtc1trZXldO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICB3YXJuKCdwYXJhbSBcIicgKyBrZXkgKyAnXCIgbm90IGZvdW5kIHdoZW4gZ2VuZXJhdGluZyAnICsgJ3BhdGggZm9yIFwiJyArIHBhdGggKyAnXCIgd2l0aCBwYXJhbXMgJyArIEpTT04uc3RyaW5naWZ5KHBhcmFtcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbCB8fCAnJztcbiAgICB9KTtcbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIHBhdGggKz0gZ2VuUXVlcnkocXVlcnkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHZhciBoYXNoUkUgPSAvIy4qJC87XG5cbiAgdmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5KF9yZWYpIHtcbiAgICAgIHZhciByb290ID0gX3JlZi5yb290O1xuICAgICAgdmFyIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcbiAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MNUhpc3RvcnkpO1xuXG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgICAgICAgaWYgKHJvb3QuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICByb290ID0gJy8nICsgcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICB0aGlzLnJvb3RSRSA9IG5ldyBSZWdFeHAoJ15cXFxcJyArIHRoaXMucm9vdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgICAgLy8gY2hlY2sgYmFzZSB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICB0aGlzLmJhc2UgPSBiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cblxuICAgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdXJsID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgaWYgKF90aGlzLnJvb3QpIHtcbiAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShfdGhpcy5yb290UkUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5vbkNoYW5nZSh1cmwsIGUgJiYgZS5zdGF0ZSwgbG9jYXRpb24uaGFzaCk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB0aGlzLmxpc3RlbmVyKCk7XG4gICAgfTtcblxuICAgIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICB9O1xuXG4gICAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvKHBhdGgsIHJlcGxhY2UsIGFwcGVuZCkge1xuICAgICAgdmFyIHVybCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCB1cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjb3JkIHNjcm9sbCBwb3NpdGlvbiBieSByZXBsYWNpbmcgY3VycmVudCBzdGF0ZVxuICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XG4gICAgICAgICAgcG9zOiB7XG4gICAgICAgICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgICB9XG4gICAgICAgIH0sICcnKTtcbiAgICAgICAgLy8gdGhlbiBwdXNoIG5ldyBzdGF0ZVxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaE1hdGNoID0gcGF0aC5tYXRjaChoYXNoUkUpO1xuICAgICAgdmFyIGhhc2ggPSBoYXNoTWF0Y2ggJiYgaGFzaE1hdGNoWzBdO1xuICAgICAgcGF0aCA9IHVybFxuICAgICAgLy8gc3RyaXAgaGFzaCBzbyBpdCBkb2Vzbid0IG1lc3MgdXAgcGFyYW1zXG4gICAgICAucmVwbGFjZShoYXNoUkUsICcnKVxuICAgICAgLy8gcmVtb3ZlIHJvb3QgYmVmb3JlIG1hdGNoaW5nXG4gICAgICAucmVwbGFjZSh0aGlzLnJvb3RSRSwgJycpO1xuICAgICAgdGhpcy5vbkNoYW5nZShwYXRoLCBudWxsLCBoYXNoKTtcbiAgICB9O1xuXG4gICAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICAvLyBhYnNvbHV0ZSBwYXRoXG4gICAgICA/IHRoaXMucm9vdCA/IHRoaXMucm9vdCArICcvJyArIHBhdGgucmVwbGFjZSgvXlxcLy8sICcnKSA6IHBhdGggOiByZXNvbHZlUGF0aCh0aGlzLmJhc2UgfHwgbG9jYXRpb24ucGF0aG5hbWUsIHBhdGgsIGFwcGVuZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBIVE1MNUhpc3Rvcnk7XG4gIH0pKCk7XG5cbiAgdmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIYXNoSGlzdG9yeShfcmVmKSB7XG4gICAgICB2YXIgaGFzaGJhbmcgPSBfcmVmLmhhc2hiYW5nO1xuICAgICAgdmFyIG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZTtcbiAgICAgIGJhYmVsSGVscGVycy5jbGFzc0NhbGxDaGVjayh0aGlzLCBIYXNoSGlzdG9yeSk7XG5cbiAgICAgIHRoaXMuaGFzaGJhbmcgPSBoYXNoYmFuZztcbiAgICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICB9XG5cbiAgICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoID0gbG9jYXRpb24uaGFzaDtcbiAgICAgICAgdmFyIHJhdyA9IHBhdGgucmVwbGFjZSgvXiMhPy8sICcnKTtcbiAgICAgICAgLy8gYWx3YXlzXG4gICAgICAgIGlmIChyYXcuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICByYXcgPSAnLycgKyByYXc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvcm1hdHRlZFBhdGggPSBzZWxmLmZvcm1hdFBhdGgocmF3KTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZFBhdGggIT09IHBhdGgpIHtcbiAgICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKGZvcm1hdHRlZFBhdGgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlcm1pbmUgcXVlcnlcbiAgICAgICAgLy8gbm90ZSBpdCdzIHBvc3NpYmxlIHRvIGhhdmUgcXVlcmllcyBpbiBib3RoIHRoZSBhY3R1YWwgVVJMXG4gICAgICAgIC8vIGFuZCB0aGUgaGFzaCBmcmFnbWVudCBpdHNlbGYuXG4gICAgICAgIHZhciBxdWVyeSA9IGxvY2F0aW9uLnNlYXJjaCAmJiBwYXRoLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnICsgbG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpIDogbG9jYXRpb24uc2VhcmNoO1xuICAgICAgICBzZWxmLm9uQ2hhbmdlKGRlY29kZVVSSShwYXRoLnJlcGxhY2UoL14jIT8vLCAnJykgKyBxdWVyeSkpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICB0aGlzLmxpc3RlbmVyKCk7XG4gICAgfTtcblxuICAgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgfTtcblxuICAgIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvKHBhdGgsIHJlcGxhY2UsIGFwcGVuZCkge1xuICAgICAgcGF0aCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZm9ybWF0UGF0aCA9IGZ1bmN0aW9uIGZvcm1hdFBhdGgocGF0aCwgYXBwZW5kKSB7XG4gICAgICB2YXIgaXNBYnNvbG91dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgICAgdmFyIHByZWZpeCA9ICcjJyArICh0aGlzLmhhc2hiYW5nID8gJyEnIDogJycpO1xuICAgICAgcmV0dXJuIGlzQWJzb2xvdXRlID8gcHJlZml4ICsgcGF0aCA6IHByZWZpeCArIHJlc29sdmVQYXRoKGxvY2F0aW9uLmhhc2gucmVwbGFjZSgvXiMhPy8sICcnKSwgcGF0aCwgYXBwZW5kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhhc2hIaXN0b3J5O1xuICB9KSgpO1xuXG4gIHZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0SGlzdG9yeShfcmVmKSB7XG4gICAgICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlO1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIEFic3RyYWN0SGlzdG9yeSk7XG5cbiAgICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgIHRoaXMuY3VycmVudFBhdGggPSAnLyc7XG4gICAgfVxuXG4gICAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5vbkNoYW5nZSgnLycpO1xuICAgIH07XG5cbiAgICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgLy8gbm9vcFxuICAgIH07XG5cbiAgICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKSB7XG4gICAgICBwYXRoID0gdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpO1xuICAgICAgdGhpcy5vbkNoYW5nZShwYXRoKTtcbiAgICB9O1xuXG4gICAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24gZm9ybWF0UGF0aChwYXRoLCBhcHBlbmQpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6IHJlc29sdmVQYXRoKHRoaXMuY3VycmVudFBhdGgsIHBhdGgsIGFwcGVuZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBBYnN0cmFjdEhpc3Rvcnk7XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgcmV1c2FiaWxpdHkgb2YgYW4gZXhpc3Rpbmcgcm91dGVyIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKi9cblxuICBmdW5jdGlvbiBjYW5SZXVzZSh2aWV3LCBoYW5kbGVyLCB0cmFuc2l0aW9uKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHZpZXcuY2hpbGRWTTtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbXBvcnRhbnQ6IGNoZWNrIHZpZXcuQ29tcG9uZW50IGhlcmUgYmVjYXVzZSBpdCBtYXlcbiAgICAvLyBoYXZlIGJlZW4gY2hhbmdlZCBpbiBhY3RpdmF0ZSBob29rXG4gICAgaWYgKHZpZXcuQ29tcG9uZW50ICE9PSBoYW5kbGVyLmNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgY2FuUmV1c2VGbiA9IGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgJ2NhblJldXNlJyk7XG4gICAgcmV0dXJuIHR5cGVvZiBjYW5SZXVzZUZuID09PSAnYm9vbGVhbicgPyBjYW5SZXVzZUZuIDogY2FuUmV1c2VGbiA/IGNhblJldXNlRm4uY2FsbChjb21wb25lbnQsIHtcbiAgICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgICAgZnJvbTogdHJhbnNpdGlvbi5mcm9tXG4gICAgfSkgOiB0cnVlOyAvLyBkZWZhdWx0cyB0byB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21wb25lbnQgY2FuIGRlYWN0aXZhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbkRlYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgbmV4dCkge1xuICAgIHZhciBmcm9tQ29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIHZhciBob29rID0gZ2V0Um91dGVDb25maWcoZnJvbUNvbXBvbmVudCwgJ2NhbkRlYWN0aXZhdGUnKTtcbiAgICBpZiAoIWhvb2spIHtcbiAgICAgIG5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsSG9vayhob29rLCBmcm9tQ29tcG9uZW50LCBuZXh0LCB7XG4gICAgICAgIGV4cGVjdEJvb2xlYW46IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbXBvbmVudCBjYW4gYWN0aXZhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbkFjdGl2YXRlKGhhbmRsZXIsIHRyYW5zaXRpb24sIG5leHQpIHtcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnQoaGFuZGxlciwgZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgICAgLy8gaGF2ZSB0byBjaGVjayBkdWUgdG8gYXN5bmMtbmVzc1xuICAgICAgaWYgKHRyYW5zaXRpb24uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBkZXRlcm1pbmUgaWYgdGhpcyBjb21wb25lbnQgY2FuIGJlIGFjdGl2YXRlZFxuICAgICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdjYW5BY3RpdmF0ZScpO1xuICAgICAgaWYgKCFob29rKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2soaG9vaywgbnVsbCwgbmV4dCwge1xuICAgICAgICAgIGV4cGVjdEJvb2xlYW46IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBkZWFjdGl2YXRlIGhvb2tzIGZvciBleGlzdGluZyByb3V0ZXItdmlld3MuXG4gICAqXG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlfSB2aWV3XG4gICAqIEBwYXJhbSB7VHJhbnNpdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGUodmlldywgdHJhbnNpdGlvbiwgbmV4dCkge1xuICAgIHZhciBjb21wb25lbnQgPSB2aWV3LmNoaWxkVk07XG4gICAgdmFyIGhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhjb21wb25lbnQsICdkZWFjdGl2YXRlJyk7XG4gICAgaWYgKCFob29rKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGhvb2ssIGNvbXBvbmVudCwgbmV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIC8gc3dpdGNoIGNvbXBvbmVudCBmb3IgYSByb3V0ZXItdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFjdGl2YXRlKHZpZXcsIHRyYW5zaXRpb24sIGRlcHRoLCBjYiwgcmV1c2UpIHtcbiAgICB2YXIgaGFuZGxlciA9IHRyYW5zaXRpb24uYWN0aXZhdGVRdWV1ZVtkZXB0aF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBzYXZlQ2hpbGRWaWV3KHZpZXcpO1xuICAgICAgaWYgKHZpZXcuX2JvdW5kKSB7XG4gICAgICAgIHZpZXcuc2V0Q29tcG9uZW50KG51bGwpO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdmlldy5Db21wb25lbnQgPSBoYW5kbGVyLmNvbXBvbmVudDtcbiAgICB2YXIgYWN0aXZhdGVIb29rID0gZ2V0Um91dGVDb25maWcoQ29tcG9uZW50LCAnYWN0aXZhdGUnKTtcbiAgICB2YXIgZGF0YUhvb2sgPSBnZXRSb3V0ZUNvbmZpZyhDb21wb25lbnQsICdkYXRhJyk7XG4gICAgdmFyIHdhaXRGb3JEYXRhID0gZ2V0Um91dGVDb25maWcoQ29tcG9uZW50LCAnd2FpdEZvckRhdGEnKTtcblxuICAgIHZpZXcuZGVwdGggPSBkZXB0aDtcbiAgICB2aWV3LmFjdGl2YXRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICB2YXIgbG9hZGluZyA9ICEhKGRhdGFIb29rICYmICF3YWl0Rm9yRGF0YSk7XG5cbiAgICAvLyBcInJldXNlXCIgaXMgYSBmbGFnIHBhc3NlZCBkb3duIHdoZW4gdGhlIHBhcmVudCB2aWV3IGlzXG4gICAgLy8gZWl0aGVyIHJldXNlZCB2aWEga2VlcC1hbGl2ZSBvciBhcyBhIGNoaWxkIG9mIGEga2VwdC1hbGl2ZSB2aWV3LlxuICAgIC8vIG9mIGNvdXJzZSB3ZSBjYW4gb25seSByZXVzZSBpZiB0aGUgY3VycmVudCBrZXB0LWFsaXZlIGluc3RhbmNlXG4gICAgLy8gaXMgb2YgdGhlIGNvcnJlY3QgdHlwZS5cbiAgICByZXVzZSA9IHJldXNlICYmIHZpZXcuY2hpbGRWTSAmJiB2aWV3LmNoaWxkVk0uY29uc3RydWN0b3IgPT09IENvbXBvbmVudDtcblxuICAgIGlmIChyZXVzZSkge1xuICAgICAgLy8ganVzdCByZXVzZVxuICAgICAgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gbG9hZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgc2F2ZUNoaWxkVmlldyh2aWV3KTtcblxuICAgICAgLy8gdW5idWlsZCBjdXJyZW50IGNvbXBvbmVudC4gdGhpcyBzdGVwIGFsc28gZGVzdHJveXNcbiAgICAgIC8vIGFuZCByZW1vdmVzIGFsbCBuZXN0ZWQgY2hpbGQgdmlld3MuXG4gICAgICB2aWV3LnVuYnVpbGQodHJ1ZSk7XG5cbiAgICAgIC8vIGJ1aWxkIHRoZSBuZXcgY29tcG9uZW50LiB0aGlzIHdpbGwgYWxzbyBjcmVhdGUgdGhlXG4gICAgICAvLyBkaXJlY3QgY2hpbGQgdmlldyBvZiB0aGUgY3VycmVudCBvbmUuIGl0IHdpbGwgcmVnaXN0ZXJcbiAgICAgIC8vIGl0c2VsZiBhcyB2aWV3LmNoaWxkVmlldy5cbiAgICAgIGNvbXBvbmVudCA9IHZpZXcuYnVpbGQoe1xuICAgICAgICBfbWV0YToge1xuICAgICAgICAgICRsb2FkaW5nUm91dGVEYXRhOiBsb2FkaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgdGhpcy5fcm91dGVyVmlldyA9IHZpZXc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBoYW5kbGUga2VlcC1hbGl2ZS5cbiAgICAgIC8vIHdoZW4gYSBrZXB0LWFsaXZlIGNoaWxkIHZtIGlzIHJlc3RvcmVkLCB3ZSBuZWVkIHRvXG4gICAgICAvLyBhZGQgaXRzIGNhY2hlZCBjaGlsZCB2aWV3cyBpbnRvIHRoZSByb3V0ZXIncyB2aWV3IGxpc3QsXG4gICAgICAvLyBhbmQgYWxzbyBwcm9wZXJseSB1cGRhdGUgY3VycmVudCB2aWV3J3MgY2hpbGQgdmlldy5cbiAgICAgIGlmICh2aWV3LmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnQuJGxvYWRpbmdSb3V0ZURhdGEgPSBsb2FkaW5nO1xuICAgICAgICB2YXIgY2FjaGVkQ2hpbGRWaWV3ID0gY29tcG9uZW50Ll9rZWVwQWxpdmVSb3V0ZXJWaWV3O1xuICAgICAgICBpZiAoY2FjaGVkQ2hpbGRWaWV3KSB7XG4gICAgICAgICAgdmlldy5jaGlsZFZpZXcgPSBjYWNoZWRDaGlsZFZpZXc7XG4gICAgICAgICAgY29tcG9uZW50Ll9rZWVwQWxpdmVSb3V0ZXJWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFudXAgdGhlIGNvbXBvbmVudCBpbiBjYXNlIHRoZSB0cmFuc2l0aW9uIGlzIGFib3J0ZWRcbiAgICAvLyBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBldmVyIGluc2VydGVkLlxuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIGNvbXBvbmVudC4kZGVzdHJveSgpO1xuICAgIH07XG5cbiAgICAvLyBhY3R1YWxseSBpbnNlcnQgdGhlIGNvbXBvbmVudCBhbmQgdHJpZ2dlciB0cmFuc2l0aW9uXG4gICAgdmFyIGluc2VydCA9IGZ1bmN0aW9uIGluc2VydCgpIHtcbiAgICAgIGlmIChyZXVzZSkge1xuICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcm91dGVyID0gdHJhbnNpdGlvbi5yb3V0ZXI7XG4gICAgICBpZiAocm91dGVyLl9yZW5kZXJlZCB8fCByb3V0ZXIuX3RyYW5zaXRpb25PbkxvYWQpIHtcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKGNvbXBvbmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyB0cmFuc2l0aW9uIG9uIGZpcnN0IHJlbmRlciwgbWFudWFsIHRyYW5zaXRpb25cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh2aWV3LnNldEN1cnJlbnQpIHtcbiAgICAgICAgICAvLyAwLjEyIGNvbXBhdFxuICAgICAgICAgIHZpZXcuc2V0Q3VycmVudChjb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuMFxuICAgICAgICAgIHZpZXcuY2hpbGRWTSA9IGNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnQuJGJlZm9yZSh2aWV3LmFuY2hvciwgbnVsbCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9O1xuXG4gICAgdmFyIGFmdGVyRGF0YSA9IGZ1bmN0aW9uIGFmdGVyRGF0YSgpIHtcbiAgICAgIC8vIGFjdGl2YXRlIHRoZSBjaGlsZCB2aWV3XG4gICAgICBpZiAodmlldy5jaGlsZFZpZXcpIHtcbiAgICAgICAgYWN0aXZhdGUodmlldy5jaGlsZFZpZXcsIHRyYW5zaXRpb24sIGRlcHRoICsgMSwgbnVsbCwgcmV1c2UgfHwgdmlldy5rZWVwQWxpdmUpO1xuICAgICAgfVxuICAgICAgaW5zZXJ0KCk7XG4gICAgfTtcblxuICAgIC8vIGNhbGxlZCBhZnRlciBhY3RpdmF0aW9uIGhvb2sgaXMgcmVzb2x2ZWRcbiAgICB2YXIgYWZ0ZXJBY3RpdmF0ZSA9IGZ1bmN0aW9uIGFmdGVyQWN0aXZhdGUoKSB7XG4gICAgICB2aWV3LmFjdGl2YXRlZCA9IHRydWU7XG4gICAgICBpZiAoZGF0YUhvb2sgJiYgd2FpdEZvckRhdGEpIHtcbiAgICAgICAgLy8gd2FpdCB1bnRpbCBkYXRhIGxvYWRlZCB0byBpbnNlcnRcbiAgICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vaywgYWZ0ZXJEYXRhLCBjbGVhbnVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxvYWQgZGF0YSBhbmQgaW5zZXJ0IGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgaWYgKGRhdGFIb29rKSB7XG4gICAgICAgICAgbG9hZERhdGEoY29tcG9uZW50LCB0cmFuc2l0aW9uLCBkYXRhSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgYWZ0ZXJEYXRhKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChhY3RpdmF0ZUhvb2spIHtcbiAgICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGFjdGl2YXRlSG9vaywgY29tcG9uZW50LCBhZnRlckFjdGl2YXRlLCB7IGNsZWFudXA6IGNsZWFudXAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyQWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV1c2UgYSB2aWV3LCBqdXN0IHJlbG9hZCBkYXRhIGlmIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJldXNlKHZpZXcsIHRyYW5zaXRpb24pIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdmlldy5jaGlsZFZNO1xuICAgIHZhciBkYXRhSG9vayA9IGdldFJvdXRlQ29uZmlnKGNvbXBvbmVudCwgJ2RhdGEnKTtcbiAgICBpZiAoZGF0YUhvb2spIHtcbiAgICAgIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgZGF0YUhvb2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3luY2hyb25vdXNseSBsb2FkIGFuZCBhcHBseSBkYXRhIHRvIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb259IHRyYW5zaXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbGVhbnVwXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGxvYWREYXRhKGNvbXBvbmVudCwgdHJhbnNpdGlvbiwgaG9vaywgY2IsIGNsZWFudXApIHtcbiAgICBjb21wb25lbnQuJGxvYWRpbmdSb3V0ZURhdGEgPSB0cnVlO1xuICAgIHRyYW5zaXRpb24uY2FsbEhvb2tzKGhvb2ssIGNvbXBvbmVudCwgZnVuY3Rpb24gKGRhdGEsIG9uRXJyb3IpIHtcbiAgICAgIC8vIG1lcmdlIGRhdGEgZnJvbSBtdWx0aXBsZSBkYXRhIGhvb2tzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhLl9uZWVkTWVyZ2UpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEucmVkdWNlKGZ1bmN0aW9uIChyZXMsIG9iaikge1xuICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgIHJlc1trZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgcHJvbWlzZSBzdWdhciBzeW50YXhcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFba2V5XTtcbiAgICAgICAgICBpZiAoaXNQcm9taXNlKHZhbCkpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godmFsLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkVmFsKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC4kc2V0KGtleSwgcmVzb2x2ZWRWYWwpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQuJHNldChrZXksIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXBvbmVudC4kbG9hZGluZ1JvdXRlRGF0YSA9IGZhbHNlO1xuICAgICAgICBjb21wb25lbnQuJGVtaXQoJ3JvdXRlLWRhdGEtbG9hZGVkJywgY29tcG9uZW50KTtcbiAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VzWzBdLmNvbnN0cnVjdG9yLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcG9uZW50LiRsb2FkaW5nUm91dGVEYXRhID0gZmFsc2U7XG4gICAgICAgICAgY29tcG9uZW50LiRlbWl0KCdyb3V0ZS1kYXRhLWxvYWRlZCcsIGNvbXBvbmVudCk7XG4gICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfSwgb25FcnJvcik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgY2xlYW51cDogY2xlYW51cCxcbiAgICAgIGV4cGVjdERhdGE6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlIHRoZSBjaGlsZCB2aWV3IGZvciBhIGtlcHQtYWxpdmUgdmlldyBzbyB0aGF0XG4gICAqIHdlIGNhbiByZXN0b3JlIGl0IHdoZW4gaXQgaXMgc3dpdGNoZWQgYmFjayB0by5cbiAgICpcbiAgICogQHBhcmFtIHtEaXJlY3RpdmV9IHZpZXdcbiAgICovXG5cbiAgZnVuY3Rpb24gc2F2ZUNoaWxkVmlldyh2aWV3KSB7XG4gICAgaWYgKHZpZXcua2VlcEFsaXZlICYmIHZpZXcuY2hpbGRWTSAmJiB2aWV3LmNoaWxkVmlldykge1xuICAgICAgdmlldy5jaGlsZFZNLl9rZWVwQWxpdmVSb3V0ZXJWaWV3ID0gdmlldy5jaGlsZFZpZXc7XG4gICAgfVxuICAgIHZpZXcuY2hpbGRWaWV3ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBwbGFpbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFJvdXRlVHJhbnNpdGlvbiBvYmplY3QgbWFuYWdlcyB0aGUgcGlwZWxpbmUgb2YgYVxuICAgKiByb3V0ZXItdmlldyBzd2l0Y2hpbmcgcHJvY2Vzcy4gVGhpcyBpcyBhbHNvIHRoZSBvYmplY3RcbiAgICogcGFzc2VkIGludG8gdXNlciByb3V0ZSBob29rcy5cbiAgICpcbiAgICogQHBhcmFtIHtSb3V0ZXJ9IHJvdXRlclxuICAgKiBAcGFyYW0ge1JvdXRlfSB0b1xuICAgKiBAcGFyYW0ge1JvdXRlfSBmcm9tXG4gICAqL1xuXG4gIHZhciBSb3V0ZVRyYW5zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRlVHJhbnNpdGlvbihyb3V0ZXIsIHRvLCBmcm9tKSB7XG4gICAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGVUcmFuc2l0aW9uKTtcblxuICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICB0aGlzLnRvID0gdG87XG4gICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWJvcnQgY3VycmVudCB0cmFuc2l0aW9uIGFuZCByZXR1cm4gdG8gcHJldmlvdXMgbG9jYXRpb24uXG4gICAgICovXG5cbiAgICBSb3V0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBpZiB0aGUgcm9vdCBwYXRoIHRocm93cyBhbiBlcnJvciBkdXJpbmcgdmFsaWRhdGlvblxuICAgICAgICAvLyBvbiBpbml0aWFsIGxvYWQsIGl0IGdldHMgY2F1Z2h0IGluIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICAgIHZhciBhYm9ydGluZ09uTG9hZCA9ICF0aGlzLmZyb20ucGF0aCAmJiB0aGlzLnRvLnBhdGggPT09ICcvJztcbiAgICAgICAgaWYgKCFhYm9ydGluZ09uTG9hZCkge1xuICAgICAgICAgIHRoaXMucm91dGVyLnJlcGxhY2UodGhpcy5mcm9tLnBhdGggfHwgJy8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBYm9ydCBjdXJyZW50IHRyYW5zaXRpb24gYW5kIHJlZGlyZWN0IHRvIGEgbmV3IGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKi9cblxuICAgIFJvdXRlVHJhbnNpdGlvbi5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdChwYXRoKSB7XG4gICAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xuICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcGF0aCA9IG1hcFBhcmFtcyhwYXRoLCB0aGlzLnRvLnBhcmFtcywgdGhpcy50by5xdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wYXJhbXMgPSBwYXRoLnBhcmFtcyB8fCB0aGlzLnRvLnBhcmFtcztcbiAgICAgICAgICBwYXRoLnF1ZXJ5ID0gcGF0aC5xdWVyeSB8fCB0aGlzLnRvLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm91dGVyLnJlcGxhY2UocGF0aCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgcm91dGVyIHZpZXcgdHJhbnNpdGlvbidzIHBpcGVsaW5lIGNhbiBiZSBkZXNjcmliZWQgYXNcbiAgICAgKiBmb2xsb3dzLCBhc3N1bWluZyB3ZSBhcmUgdHJhbnNpdGlvbmluZyBmcm9tIGFuIGV4aXN0aW5nXG4gICAgICogPHJvdXRlci12aWV3PiBjaGFpbiBbQ29tcG9uZW50IEEsIENvbXBvbmVudCBCXSB0byBhIG5ld1xuICAgICAqIGNoYWluIFtDb21wb25lbnQgQSwgQ29tcG9uZW50IENdOlxuICAgICAqXG4gICAgICogIEEgICAgQVxuICAgICAqICB8ID0+IHxcbiAgICAgKiAgQiAgICBDXG4gICAgICpcbiAgICAgKiAxLiBSZXVzYWJsaXR5IHBoYXNlOlxuICAgICAqICAgLT4gY2FuUmV1c2UoQSwgQSlcbiAgICAgKiAgIC0+IGNhblJldXNlKEIsIEMpXG4gICAgICogICAtPiBkZXRlcm1pbmUgbmV3IHF1ZXVlczpcbiAgICAgKiAgICAgIC0gZGVhY3RpdmF0aW9uOiBbQl1cbiAgICAgKiAgICAgIC0gYWN0aXZhdGlvbjogW0NdXG4gICAgICpcbiAgICAgKiAyLiBWYWxpZGF0aW9uIHBoYXNlOlxuICAgICAqICAgLT4gY2FuRGVhY3RpdmF0ZShCKVxuICAgICAqICAgLT4gY2FuQWN0aXZhdGUoQylcbiAgICAgKlxuICAgICAqIDMuIEFjdGl2YXRpb24gcGhhc2U6XG4gICAgICogICAtPiBkZWFjdGl2YXRlKEIpXG4gICAgICogICAtPiBhY3RpdmF0ZShDKVxuICAgICAqXG4gICAgICogRWFjaCBvZiB0aGVzZSBzdGVwcyBjYW4gYmUgYXN5bmNocm9ub3VzLCBhbmQgYW55XG4gICAgICogc3RlcCBjYW4gcG90ZW50aWFsbHkgYWJvcnQgdGhlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KGNiKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXM7XG5cbiAgICAgIC8vIGRldGVybWluZSB0aGUgcXVldWUgb2Ygdmlld3MgdG8gZGVhY3RpdmF0ZVxuICAgICAgdmFyIGRlYWN0aXZhdGVRdWV1ZSA9IFtdO1xuICAgICAgdmFyIHZpZXcgPSB0aGlzLnJvdXRlci5fcm9vdFZpZXc7XG4gICAgICB3aGlsZSAodmlldykge1xuICAgICAgICBkZWFjdGl2YXRlUXVldWUudW5zaGlmdCh2aWV3KTtcbiAgICAgICAgdmlldyA9IHZpZXcuY2hpbGRWaWV3O1xuICAgICAgfVxuICAgICAgdmFyIHJldmVyc2VEZWFjdGl2YXRlUXVldWUgPSBkZWFjdGl2YXRlUXVldWUuc2xpY2UoKS5yZXZlcnNlKCk7XG5cbiAgICAgIC8vIGRldGVybWluZSB0aGUgcXVldWUgb2Ygcm91dGUgaGFuZGxlcnMgdG8gYWN0aXZhdGVcbiAgICAgIHZhciBhY3RpdmF0ZVF1ZXVlID0gdGhpcy5hY3RpdmF0ZVF1ZXVlID0gdG9BcnJheSh0aGlzLnRvLm1hdGNoZWQpLm1hcChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmhhbmRsZXI7XG4gICAgICB9KTtcblxuICAgICAgLy8gMS4gUmV1c2FiaWxpdHkgcGhhc2VcbiAgICAgIHZhciBpID0gdW5kZWZpbmVkLFxuICAgICAgICAgIHJldXNlUXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmV2ZXJzZURlYWN0aXZhdGVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWNhblJldXNlKHJldmVyc2VEZWFjdGl2YXRlUXVldWVbaV0sIGFjdGl2YXRlUXVldWVbaV0sIHRyYW5zaXRpb24pKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICByZXVzZVF1ZXVlID0gcmV2ZXJzZURlYWN0aXZhdGVRdWV1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgZGVhY3RpdmF0ZVF1ZXVlID0gcmV2ZXJzZURlYWN0aXZhdGVRdWV1ZS5zbGljZShpKS5yZXZlcnNlKCk7XG4gICAgICAgIGFjdGl2YXRlUXVldWUgPSBhY3RpdmF0ZVF1ZXVlLnNsaWNlKGkpO1xuICAgICAgfVxuXG4gICAgICAvLyAyLiBWYWxpZGF0aW9uIHBoYXNlXG4gICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGRlYWN0aXZhdGVRdWV1ZSwgY2FuRGVhY3RpdmF0ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGFjdGl2YXRlUXVldWUsIGNhbkFjdGl2YXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbi5ydW5RdWV1ZShkZWFjdGl2YXRlUXVldWUsIGRlYWN0aXZhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIDMuIEFjdGl2YXRpb24gcGhhc2VcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHJvdXRlciBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgICB0cmFuc2l0aW9uLnJvdXRlci5fb25UcmFuc2l0aW9uVmFsaWRhdGVkKHRyYW5zaXRpb24pO1xuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHJldXNlIGZvciBhbGwgcmV1c2VkIHZpZXdzXG4gICAgICAgICAgICByZXVzZVF1ZXVlICYmIHJldXNlUXVldWUuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgICByZXR1cm4gcmV1c2UodmlldywgdHJhbnNpdGlvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoYWluIHRoYXQgbmVlZHMgdG8gYmUgcmVwbGFjZWRcbiAgICAgICAgICAgIC8vIGlzIHRoZSB0b3AtbW9zdCBub24tcmV1c2FibGUgdmlldy5cbiAgICAgICAgICAgIGlmIChkZWFjdGl2YXRlUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBfdmlldyA9IGRlYWN0aXZhdGVRdWV1ZVtkZWFjdGl2YXRlUXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIHZhciBkZXB0aCA9IHJldXNlUXVldWUgPyByZXVzZVF1ZXVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgIGFjdGl2YXRlKF92aWV3LCB0cmFuc2l0aW9uLCBkZXB0aCwgY2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXN5bmNocm9ub3VzbHkgYW5kIHNlcXVlbnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIHRvIGFcbiAgICAgKiBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHF1ZXVlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5ydW5RdWV1ZSA9IGZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlLCBmbiwgY2IpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcztcbiAgICAgIHN0ZXAoMCk7XG4gICAgICBmdW5jdGlvbiBzdGVwKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgdHJhbnNpdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGwgYSB1c2VyIHByb3ZpZGVkIHJvdXRlIHRyYW5zaXRpb24gaG9vayBhbmQgaGFuZGxlXG4gICAgICogdGhlIHJlc3BvbnNlIChlLmcuIGlmIHRoZSB1c2VyIHJldHVybnMgYSBwcm9taXNlKS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB1c2VyIG5laXRoZXIgZXhwZWN0cyBhbiBhcmd1bWVudCBub3IgcmV0dXJucyBhXG4gICAgICogcHJvbWlzZSwgdGhlIGhvb2sgaXMgYXNzdW1lZCB0byBiZSBzeW5jaHJvbm91cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGV4cGVjdEJvb2xlYW5cbiAgICAgKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gZXhwZWN0RGF0YVxuICAgICAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gY2xlYW51cFxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5jYWxsSG9vayA9IGZ1bmN0aW9uIGNhbGxIb29rKGhvb2ssIGNvbnRleHQsIGNiKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzNdO1xuXG4gICAgICB2YXIgX3JlZiRleHBlY3RCb29sZWFuID0gX3JlZi5leHBlY3RCb29sZWFuO1xuICAgICAgdmFyIGV4cGVjdEJvb2xlYW4gPSBfcmVmJGV4cGVjdEJvb2xlYW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRleHBlY3RCb29sZWFuO1xuICAgICAgdmFyIF9yZWYkZXhwZWN0RGF0YSA9IF9yZWYuZXhwZWN0RGF0YTtcbiAgICAgIHZhciBleHBlY3REYXRhID0gX3JlZiRleHBlY3REYXRhID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkZXhwZWN0RGF0YTtcbiAgICAgIHZhciBjbGVhbnVwID0gX3JlZi5jbGVhbnVwO1xuXG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgbmV4dENhbGxlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBhYm9ydCB0aGUgdHJhbnNpdGlvblxuICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIGNsZWFudXAgJiYgY2xlYW51cCgpO1xuICAgICAgICB0cmFuc2l0aW9uLmFib3J0KCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBoYW5kbGUgZXJyb3JzXG4gICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIC8vIGNsZWFudXAgaW5kaWNhdGVzIGFuIGFmdGVyLWFjdGl2YXRpb24gaG9vayxcbiAgICAgICAgLy8gc28gaW5zdGVhZCBvZiBhYm9ydGluZyB3ZSBqdXN0IGxldCB0aGUgdHJhbnNpdGlvblxuICAgICAgICAvLyBmaW5pc2guXG4gICAgICAgIGNsZWFudXAgPyBuZXh0KCkgOiBhYm9ydCgpO1xuICAgICAgICBpZiAoZXJyICYmICF0cmFuc2l0aW9uLnJvdXRlci5fc3VwcHJlc3MpIHtcbiAgICAgICAgICB3YXJuKCdVbmNhdWdodCBlcnJvciBkdXJpbmcgdHJhbnNpdGlvbjogJyk7XG4gICAgICAgICAgdGhyb3cgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWR2YW5jZSB0aGUgdHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGVwXG4gICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoZGF0YSkge1xuICAgICAgICBpZiAobmV4dENhbGxlZCkge1xuICAgICAgICAgIHdhcm4oJ3RyYW5zaXRpb24ubmV4dCgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uYWJvcnRlZCkge1xuICAgICAgICAgIGNsZWFudXAgJiYgY2xlYW51cCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYiAmJiBjYihkYXRhLCBvbkVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGV4cG9zZSBhIGNsb25lIG9mIHRoZSB0cmFuc2l0aW9uIG9iamVjdCwgc28gdGhhdCBlYWNoXG4gICAgICAvLyBob29rIGdldHMgYSBjbGVhbiBjb3B5IGFuZCBwcmV2ZW50IHRoZSB1c2VyIGZyb21cbiAgICAgIC8vIG1lc3Npbmcgd2l0aCB0aGUgaW50ZXJuYWxzLlxuICAgICAgdmFyIGV4cG9zZWQgPSB7XG4gICAgICAgIHRvOiB0cmFuc2l0aW9uLnRvLFxuICAgICAgICBmcm9tOiB0cmFuc2l0aW9uLmZyb20sXG4gICAgICAgIGFib3J0OiBhYm9ydCxcbiAgICAgICAgbmV4dDogbmV4dCxcbiAgICAgICAgcmVkaXJlY3Q6IGZ1bmN0aW9uIHJlZGlyZWN0KCkge1xuICAgICAgICAgIHRyYW5zaXRpb24ucmVkaXJlY3QuYXBwbHkodHJhbnNpdGlvbiwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gYWN0dWFsbHkgY2FsbCB0aGUgaG9va1xuICAgICAgdmFyIHJlcyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGhvb2suY2FsbChjb250ZXh0LCBleHBvc2VkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gb25FcnJvcihlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgYm9vbGVhbi9wcm9taXNlIHJldHVybiB2YWx1ZXNcbiAgICAgIHZhciByZXNJc1Byb21pc2UgPSBpc1Byb21pc2UocmVzKTtcbiAgICAgIGlmIChleHBlY3RCb29sZWFuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXMgPyBuZXh0KCkgOiBhYm9ydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc0lzUHJvbWlzZSkge1xuICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgICAgb2sgPyBuZXh0KCkgOiBhYm9ydCgpO1xuICAgICAgICAgIH0sIG9uRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFob29rLmxlbmd0aCkge1xuICAgICAgICAgIG5leHQocmVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXNJc1Byb21pc2UpIHtcbiAgICAgICAgcmVzLnRoZW4obmV4dCwgb25FcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGV4cGVjdERhdGEgJiYgaXNQbGFpbk9qYmVjdChyZXMpIHx8ICFob29rLmxlbmd0aCkge1xuICAgICAgICBuZXh0KHJlcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBzaW5nbGUgaG9vayBvciBhbiBhcnJheSBvZiBhc3luYyBob29rcyBpbiBzZXJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob29rc1xuICAgICAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuXG4gICAgUm91dGVUcmFuc2l0aW9uLnByb3RvdHlwZS5jYWxsSG9va3MgPSBmdW5jdGlvbiBjYWxsSG9va3MoaG9va3MsIGNvbnRleHQsIGNiLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShob29rcykpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgcmVzLl9uZWVkTWVyZ2UgPSB0cnVlO1xuICAgICAgICAgIHZhciBvbkVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIF90aGlzLnJ1blF1ZXVlKGhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNhbGxIb29rKGhvb2ssIGNvbnRleHQsIGZ1bmN0aW9uIChyLCBvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIpIHJlcy5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IgPSBvbkVycm9yO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2IocmVzLCBvbkVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsbEhvb2soaG9va3MsIGNvbnRleHQsIGNiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJvdXRlVHJhbnNpdGlvbjtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBpc1BsYWluT2piZWN0KHZhbCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICBmdW5jdGlvbiB0b0FycmF5KHZhbCkge1xuICAgIHJldHVybiB2YWwgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWwpIDogW107XG4gIH1cblxuICB2YXIgaW50ZXJuYWxLZXlzUkUgPSAvXihjb21wb25lbnR8c3ViUm91dGVzKSQvO1xuXG4gIC8qKlxuICAgKiBSb3V0ZSBDb250ZXh0IE9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1JvdXRlcn0gcm91dGVyXG4gICAqL1xuXG4gIHZhciBSb3V0ZSA9IGZ1bmN0aW9uIFJvdXRlKHBhdGgsIHJvdXRlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBiYWJlbEhlbHBlcnMuY2xhc3NDYWxsQ2hlY2sodGhpcywgUm91dGUpO1xuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZXIuX3JlY29nbml6ZXIucmVjb2duaXplKHBhdGgpO1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAvLyBjb3B5IGFsbCBjdXN0b20gZmllbGRzIGZyb20gcm91dGUgY29uZmlnc1xuICAgICAgW10uZm9yRWFjaC5jYWxsKG1hdGNoZWQsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWF0Y2guaGFuZGxlcikge1xuICAgICAgICAgIGlmICghaW50ZXJuYWxLZXlzUkUudGVzdChrZXkpKSB7XG4gICAgICAgICAgICBfdGhpc1trZXldID0gbWF0Y2guaGFuZGxlcltrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBzZXQgcXVlcnkgYW5kIHBhcmFtc1xuICAgICAgdGhpcy5xdWVyeSA9IG1hdGNoZWQucXVlcnlQYXJhbXM7XG4gICAgICB0aGlzLnBhcmFtcyA9IFtdLnJlZHVjZS5jYWxsKG1hdGNoZWQsIGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgaWYgKGN1ci5wYXJhbXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VyLnBhcmFtcykge1xuICAgICAgICAgICAgcHJldltrZXldID0gY3VyLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHBhdGggYW5kIHJvdXRlclxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgLy8gZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMubWF0Y2hlZCA9IG1hdGNoZWQgfHwgcm91dGVyLl9ub3RGb3VuZEhhbmRsZXI7XG4gICAgLy8gSW1wb3J0YW50OiBmcmVlemUgc2VsZiB0byBwcmV2ZW50IG9ic2VydmF0aW9uXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhcHBseU92ZXJyaWRlIChWdWUpIHtcbiAgICB2YXIgX1Z1ZSR1dGlsID0gVnVlLnV0aWw7XG4gICAgdmFyIGV4dGVuZCA9IF9WdWUkdXRpbC5leHRlbmQ7XG4gICAgdmFyIGlzQXJyYXkgPSBfVnVlJHV0aWwuaXNBcnJheTtcbiAgICB2YXIgZGVmaW5lUmVhY3RpdmUgPSBfVnVlJHV0aWwuZGVmaW5lUmVhY3RpdmU7XG5cbiAgICAvLyBvdmVycmlkZSBWdWUncyBpbml0IGFuZCBkZXN0cm95IHByb2Nlc3MgdG8ga2VlcCB0cmFjayBvZiByb3V0ZXIgaW5zdGFuY2VzXG4gICAgdmFyIGluaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgcm9vdCA9IG9wdGlvbnMuX3BhcmVudCB8fCBvcHRpb25zLnBhcmVudCB8fCB0aGlzO1xuICAgICAgdmFyIHJvdXRlciA9IHJvb3QuJHJvdXRlcjtcbiAgICAgIHZhciByb3V0ZSA9IHJvb3QuJHJvdXRlO1xuICAgICAgaWYgKHJvdXRlcikge1xuICAgICAgICAvLyBleHBvc2Ugcm91dGVyXG4gICAgICAgIHRoaXMuJHJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgcm91dGVyLl9jaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2RlZmluZU1ldGEpIHtcbiAgICAgICAgICAvLyAwLjEyXG4gICAgICAgICAgdGhpcy5fZGVmaW5lTWV0YSgnJHJvdXRlJywgcm91dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDEuMFxuICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsICckcm91dGUnLCByb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluaXQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3kgPSBWdWUucHJvdG90eXBlLl9kZXN0cm95O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgJiYgdGhpcy4kcm91dGVyKSB7XG4gICAgICAgIHRoaXMuJHJvdXRlci5fY2hpbGRyZW4uJHJlbW92ZSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gMS4wIG9ubHk6IGVuYWJsZSByb3V0ZSBtaXhpbnNcbiAgICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gICAgdmFyIGhvb2tzVG9NZXJnZVJFID0gL14oZGF0YXxhY3RpdmF0ZXxkZWFjdGl2YXRlKSQvO1xuXG4gICAgaWYgKHN0cmF0cykge1xuICAgICAgc3RyYXRzLnJvdXRlID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICAgICAgICB2YXIgYSA9IHJldFtrZXldO1xuICAgICAgICAgIHZhciBiID0gY2hpbGRWYWxba2V5XTtcbiAgICAgICAgICAvLyBmb3IgZGF0YSwgYWN0aXZhdGUgYW5kIGRlYWN0aXZhdGUsIHdlIG5lZWQgdG8gbWVyZ2UgdGhlbSBpbnRvXG4gICAgICAgICAgLy8gYXJyYXlzIHNpbWlsYXIgdG8gbGlmZWN5Y2xlIGhvb2tzLlxuICAgICAgICAgIGlmIChhICYmIGhvb2tzVG9NZXJnZVJFLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSAoaXNBcnJheShhKSA/IGEgOiBbYV0pLmNvbmNhdChiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBWaWV3IChWdWUpIHtcblxuICAgIHZhciBfID0gVnVlLnV0aWw7XG4gICAgdmFyIGNvbXBvbmVudERlZiA9XG4gICAgLy8gMC4xMlxuICAgIFZ1ZS5kaXJlY3RpdmUoJ19jb21wb25lbnQnKSB8fFxuICAgIC8vIDEuMFxuICAgIFZ1ZS5pbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50O1xuICAgIC8vIDxyb3V0ZXItdmlldz4gZXh0ZW5kcyB0aGUgaW50ZXJuYWwgY29tcG9uZW50IGRpcmVjdGl2ZVxuICAgIHZhciB2aWV3RGVmID0gXy5leHRlbmQoe30sIGNvbXBvbmVudERlZik7XG5cbiAgICAvLyB3aXRoIHNvbWUgb3ZlcnJpZGVzXG4gICAgXy5leHRlbmQodmlld0RlZiwge1xuXG4gICAgICBfaXNSb3V0ZXJWaWV3OiB0cnVlLFxuXG4gICAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgICB2YXIgcm91dGUgPSB0aGlzLnZtLiRyb3V0ZTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghcm91dGUpIHtcbiAgICAgICAgICB3YXJuKCc8cm91dGVyLXZpZXc+IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgJyArICdyb3V0ZXItZW5hYmxlZCBhcHAuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZvcmNlIGR5bmFtaWMgZGlyZWN0aXZlIHNvIHYtY29tcG9uZW50IGRvZXNuJ3RcbiAgICAgICAgLy8gYXR0ZW1wdCB0byBidWlsZCByaWdodCBub3dcbiAgICAgICAgdGhpcy5faXNEeW5hbWljTGl0ZXJhbCA9IHRydWU7XG4gICAgICAgIC8vIGZpbmFsbHksIGluaXQgYnkgZGVsZWdhdGluZyB0byB2LWNvbXBvbmVudFxuICAgICAgICBjb21wb25lbnREZWYuYmluZC5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgcGFyZW50IHZpZXdcbiAgICAgICAgdmFyIHBhcmVudFZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnZtO1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5fcm91dGVyVmlldykge1xuICAgICAgICAgICAgcGFyZW50VmlldyA9IHBhcmVudC5fcm91dGVyVmlldztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Vmlldykge1xuICAgICAgICAgIC8vIHJlZ2lzdGVyIHNlbGYgYXMgYSBjaGlsZCBvZiB0aGUgcGFyZW50IHZpZXcsXG4gICAgICAgICAgLy8gaW5zdGVhZCBvZiBhY3RpdmF0aW5nIG5vdy4gVGhpcyBpcyBzbyB0aGF0IHRoZVxuICAgICAgICAgIC8vIGNoaWxkJ3MgYWN0aXZhdGUgaG9vayBpcyBjYWxsZWQgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gcGFyZW50J3MgaGFzIHJlc29sdmVkLlxuICAgICAgICAgIHRoaXMucGFyZW50VmlldyA9IHBhcmVudFZpZXc7XG4gICAgICAgICAgcGFyZW50Vmlldy5jaGlsZFZpZXcgPSB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHJvb3QgdmlldyFcbiAgICAgICAgICB2YXIgcm91dGVyID0gcm91dGUucm91dGVyO1xuICAgICAgICAgIHJvdXRlci5fcm9vdFZpZXcgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIGxhdGUtcmVuZGVyZWQgdmlld1xuICAgICAgICAvLyB0d28gcG9zc2liaWxpdGllczpcbiAgICAgICAgLy8gMS4gcm9vdCB2aWV3IHJlbmRlcmVkIGFmdGVyIHRyYW5zaXRpb24gaGFzIGJlZW5cbiAgICAgICAgLy8gICAgdmFsaWRhdGVkO1xuICAgICAgICAvLyAyLiBjaGlsZCB2aWV3IHJlbmRlcmVkIGFmdGVyIHBhcmVudCB2aWV3IGhhcyBiZWVuXG4gICAgICAgIC8vICAgIGFjdGl2YXRlZC5cbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSByb3V0ZS5yb3V0ZXIuX2N1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgICBpZiAoIXBhcmVudFZpZXcgJiYgdHJhbnNpdGlvbi5kb25lIHx8IHBhcmVudFZpZXcgJiYgcGFyZW50Vmlldy5hY3RpdmF0ZWQpIHtcbiAgICAgICAgICB2YXIgZGVwdGggPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5kZXB0aCArIDEgOiAwO1xuICAgICAgICAgIGFjdGl2YXRlKHRoaXMsIHRyYW5zaXRpb24sIGRlcHRoKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFZpZXcpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFZpZXcuY2hpbGRWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnREZWYudW5iaW5kLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBWdWUuZWxlbWVudERpcmVjdGl2ZSgncm91dGVyLXZpZXcnLCB2aWV3RGVmKTtcbiAgfVxuXG4gIHZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvJC87XG4gIHZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcbiAgdmFyIHF1ZXJ5U3RyaW5nUkUgPSAvXFw/LiokLztcblxuICAvLyBpbnN0YWxsIHYtbGluaywgd2hpY2ggcHJvdmlkZXMgbmF2aWdhdGlvbiBzdXBwb3J0IGZvclxuICAvLyBIVE1MNSBoaXN0b3J5IG1vZGVcbiAgZnVuY3Rpb24gTGluayAoVnVlKSB7XG4gICAgdmFyIF9WdWUkdXRpbCA9IFZ1ZS51dGlsO1xuICAgIHZhciBfYmluZCA9IF9WdWUkdXRpbC5iaW5kO1xuICAgIHZhciBpc09iamVjdCA9IF9WdWUkdXRpbC5pc09iamVjdDtcbiAgICB2YXIgYWRkQ2xhc3MgPSBfVnVlJHV0aWwuYWRkQ2xhc3M7XG4gICAgdmFyIHJlbW92ZUNsYXNzID0gX1Z1ZSR1dGlsLnJlbW92ZUNsYXNzO1xuXG4gICAgVnVlLmRpcmVjdGl2ZSgnbGluay1hY3RpdmUnLCB7XG4gICAgICBwcmlvcml0eTogMTAwMSxcbiAgICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgICAgIHRoaXMuZWwuX192X2xpbmtfYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFZ1ZS5kaXJlY3RpdmUoJ2xpbmsnLCB7XG4gICAgICBwcmlvcml0eTogMTAwMCxcblxuICAgICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdm0uJHJvdXRlKSB7XG4gICAgICAgICAgd2Fybigndi1saW5rIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGEgcm91dGVyLWVuYWJsZWQgYXBwLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvdXRlciA9IHZtLiRyb3V0ZS5yb3V0ZXI7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGluZ3Mgd2hlbiB0aGUgcm91dGUgY2hhbmdlc1xuICAgICAgICB0aGlzLnVud2F0Y2ggPSB2bS4kd2F0Y2goJyRyb3V0ZScsIF9iaW5kKHRoaXMub25Sb3V0ZVVwZGF0ZSwgdGhpcykpO1xuICAgICAgICAvLyBjaGVjayBpZiBhY3RpdmUgY2xhc3NlcyBzaG91bGQgYmUgYXBwbGllZCB0byBhIGRpZmZlcmVudCBlbGVtZW50XG4gICAgICAgIHRoaXMuYWN0aXZlRWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5lbC5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5fX3ZfbGlua19hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRWwgPSBwYXJlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gbmVlZCB0byBoYW5kbGUgY2xpY2sgaWYgbGluayBleHBlY3RzIHRvIGJlIG9wZW5lZFxuICAgICAgICAvLyBpbiBhIG5ldyB3aW5kb3cvdGFiLlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuZWwudGFnTmFtZSA9PT0gJ0EnICYmIHRoaXMuZWwuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSA9PT0gJ19ibGFuaycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGNsaWNrXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfYmluZCh0aGlzLm9uQ2xpY2ssIHRoaXMpKTtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZCA9IHRhcmdldC5hcHBlbmQ7XG4gICAgICAgICAgdGhpcy5leGFjdCA9IHRhcmdldC5leGFjdDtcbiAgICAgICAgICB0aGlzLnByZXZBY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgICAgICAgdGhpcy5hY3RpdmVDbGFzcyA9IHRhcmdldC5hY3RpdmVDbGFzcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUm91dGVVcGRhdGUodGhpcy52bS4kcm91dGUpO1xuICAgICAgfSxcblxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSByZXR1cm47XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICAgIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcblxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAvLyB2LWxpbmsgd2l0aCBleHByZXNzaW9uLCBqdXN0IGdvXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMucm91dGVyLmdvKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gZXhwcmVzc2lvbiwgZGVsZWdhdGUgZm9yIGFuIDxhPiBpbnNpZGVcbiAgICAgICAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICAgICAgICB3aGlsZSAoZWwudGFnTmFtZSAhPT0gJ0EnICYmIGVsICE9PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC50YWdOYW1lID09PSAnQScgJiYgc2FtZU9yaWdpbihlbCkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLmdvKHtcbiAgICAgICAgICAgICAgcGF0aDogZWwucGF0aG5hbWUsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHRhcmdldCAmJiB0YXJnZXQucmVwbGFjZSxcbiAgICAgICAgICAgICAgYXBwZW5kOiB0YXJnZXQgJiYgdGFyZ2V0LmFwcGVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBvblJvdXRlVXBkYXRlOiBmdW5jdGlvbiBvblJvdXRlVXBkYXRlKHJvdXRlKSB7XG4gICAgICAgIC8vIHJvdXRlci5fc3RyaW5naWZ5UGF0aCBpcyBkZXBlbmRlbnQgb24gY3VycmVudCByb3V0ZVxuICAgICAgICAvLyBhbmQgbmVlZHMgdG8gYmUgY2FsbGVkIGFnYWluIHdoZW52ZXIgcm91dGUgY2hhbmdlcy5cbiAgICAgICAgdmFyIG5ld1BhdGggPSB0aGlzLnJvdXRlci5fc3RyaW5naWZ5UGF0aCh0aGlzLnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLnBhdGggIT09IG5ld1BhdGgpIHtcbiAgICAgICAgICB0aGlzLnBhdGggPSBuZXdQYXRoO1xuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlTWF0Y2goKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUhyZWYoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUNsYXNzZXMocm91dGUucGF0aCk7XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGVBY3RpdmVNYXRjaDogZnVuY3Rpb24gdXBkYXRlQWN0aXZlTWF0Y2goKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUkUgPSB0aGlzLnBhdGggJiYgIXRoaXMuZXhhY3QgPyBuZXcgUmVnRXhwKCdeJyArIHRoaXMucGF0aC5yZXBsYWNlKC9cXC8kLywgJycpLnJlcGxhY2UocXVlcnlTdHJpbmdSRSwgJycpLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpICsgJyhcXFxcL3wkKScpIDogbnVsbDtcbiAgICAgIH0sXG5cbiAgICAgIHVwZGF0ZUhyZWY6IGZ1bmN0aW9uIHVwZGF0ZUhyZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgIT09ICdBJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gICAgICAgIC8vIGRvIG5vdCBmb3JtYXQgbm9uLWhhc2ggcmVsYXRpdmUgcGF0aHNcbiAgICAgICAgdmFyIGhyZWYgPSBwYXRoICYmIChyb3V0ZXIubW9kZSA9PT0gJ2hhc2gnIHx8IGlzQWJzb2x1dGUpID8gcm91dGVyLmhpc3RvcnkuZm9ybWF0UGF0aChwYXRoLCB0aGlzLmFwcGVuZCkgOiBwYXRoO1xuICAgICAgICBpZiAoaHJlZikge1xuICAgICAgICAgIHRoaXMuZWwuaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdXBkYXRlQ2xhc3NlczogZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyhwYXRoKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuYWN0aXZlRWw7XG4gICAgICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgfHwgdGhpcy5yb3V0ZXIuX2xpbmtBY3RpdmVDbGFzcztcbiAgICAgICAgLy8gY2xlYXIgb2xkIGNsYXNzXG4gICAgICAgIGlmICh0aGlzLnByZXZBY3RpdmVDbGFzcyAhPT0gYWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgdGhpcy5wcmV2QWN0aXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBxdWVyeSBzdHJpbmcgYmVmb3JlIG1hdGNoaW5nXG4gICAgICAgIHZhciBkZXN0ID0gdGhpcy5wYXRoLnJlcGxhY2UocXVlcnlTdHJpbmdSRSwgJycpO1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHF1ZXJ5U3RyaW5nUkUsICcnKTtcbiAgICAgICAgLy8gYWRkIG5ldyBjbGFzc1xuICAgICAgICBpZiAodGhpcy5leGFjdCkge1xuICAgICAgICAgIGlmIChkZXN0ID09PSBwYXRoIHx8XG4gICAgICAgICAgLy8gYWxzbyBhbGxvdyBhZGRpdGlvbmFsIHRyYWlsaW5nIHNsYXNoXG4gICAgICAgICAgZGVzdC5jaGFyQXQoZGVzdC5sZW5ndGggLSAxKSAhPT0gJy8nICYmIGRlc3QgPT09IHBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUkUgJiYgdGhpcy5hY3RpdmVSRS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICBhZGRDbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZXIpO1xuICAgICAgICB0aGlzLnVud2F0Y2ggJiYgdGhpcy51bndhdGNoKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzYW1lT3JpZ2luKGxpbmspIHtcbiAgICAgIHJldHVybiBsaW5rLnByb3RvY29sID09PSBsb2NhdGlvbi5wcm90b2NvbCAmJiBsaW5rLmhvc3RuYW1lID09PSBsb2NhdGlvbi5ob3N0bmFtZSAmJiBsaW5rLnBvcnQgPT09IGxvY2F0aW9uLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnlCYWNrZW5kcyA9IHtcbiAgICBhYnN0cmFjdDogQWJzdHJhY3RIaXN0b3J5LFxuICAgIGhhc2g6IEhhc2hIaXN0b3J5LFxuICAgIGh0bWw1OiBIVE1MNUhpc3RvcnlcbiAgfTtcblxuICAvLyBsYXRlIGJpbmQgZHVyaW5nIGluc3RhbGxcbiAgdmFyIFZ1ZSA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogUm91dGVyIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgdmFyIFJvdXRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm91dGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIF9yZWYkaGFzaGJhbmcgPSBfcmVmLmhhc2hiYW5nO1xuICAgICAgdmFyIGhhc2hiYW5nID0gX3JlZiRoYXNoYmFuZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9yZWYkaGFzaGJhbmc7XG4gICAgICB2YXIgX3JlZiRhYnN0cmFjdCA9IF9yZWYuYWJzdHJhY3Q7XG4gICAgICB2YXIgYWJzdHJhY3QgPSBfcmVmJGFic3RyYWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IF9yZWYkYWJzdHJhY3Q7XG4gICAgICB2YXIgX3JlZiRoaXN0b3J5ID0gX3JlZi5oaXN0b3J5O1xuICAgICAgdmFyIGhpc3RvcnkgPSBfcmVmJGhpc3RvcnkgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRoaXN0b3J5O1xuICAgICAgdmFyIF9yZWYkc2F2ZVNjcm9sbFBvc2l0aW9uID0gX3JlZi5zYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgICB2YXIgc2F2ZVNjcm9sbFBvc2l0aW9uID0gX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiRzYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgICB2YXIgX3JlZiR0cmFuc2l0aW9uT25Mb2FkID0gX3JlZi50cmFuc2l0aW9uT25Mb2FkO1xuICAgICAgdmFyIHRyYW5zaXRpb25PbkxvYWQgPSBfcmVmJHRyYW5zaXRpb25PbkxvYWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZiR0cmFuc2l0aW9uT25Mb2FkO1xuICAgICAgdmFyIF9yZWYkc3VwcHJlc3NUcmFuc2l0aW9uRXJyb3IgPSBfcmVmLnN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgICAgdmFyIHN1cHByZXNzVHJhbnNpdGlvbkVycm9yID0gX3JlZiRzdXBwcmVzc1RyYW5zaXRpb25FcnJvciA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJHN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgICAgdmFyIF9yZWYkcm9vdCA9IF9yZWYucm9vdDtcbiAgICAgIHZhciByb290ID0gX3JlZiRyb290ID09PSB1bmRlZmluZWQgPyBudWxsIDogX3JlZiRyb290O1xuICAgICAgdmFyIF9yZWYkbGlua0FjdGl2ZUNsYXNzID0gX3JlZi5saW5rQWN0aXZlQ2xhc3M7XG4gICAgICB2YXIgbGlua0FjdGl2ZUNsYXNzID0gX3JlZiRsaW5rQWN0aXZlQ2xhc3MgPT09IHVuZGVmaW5lZCA/ICd2LWxpbmstYWN0aXZlJyA6IF9yZWYkbGlua0FjdGl2ZUNsYXNzO1xuICAgICAgYmFiZWxIZWxwZXJzLmNsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFSb3V0ZXIuaW5zdGFsbGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGluc3RhbGwgdGhlIFJvdXRlciB3aXRoIFZ1ZS51c2UoKSBiZWZvcmUgJyArICdjcmVhdGluZyBhbiBpbnN0YW5jZS4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVnVlIGluc3RhbmNlc1xuICAgICAgdGhpcy5hcHAgPSBudWxsO1xuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcblxuICAgICAgLy8gcm91dGUgcmVjb2duaXplclxuICAgICAgdGhpcy5fcmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcbiAgICAgIHRoaXMuX2d1YXJkUmVjb2duaXplciA9IG5ldyBSb3V0ZVJlY29nbml6ZXIoKTtcblxuICAgICAgLy8gc3RhdGVcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3N0YXJ0Q2IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFJvdXRlID0ge307XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9wcmV2aW91c1RyYW5zaXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5fbm90Rm91bmRIYW5kbGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX25vdEZvdW5kUmVkaXJlY3QgPSBudWxsO1xuICAgICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzID0gW107XG4gICAgICB0aGlzLl9hZnRlckVhY2hIb29rcyA9IFtdO1xuXG4gICAgICAvLyB0cmlnZ2VyIHRyYW5zaXRpb24gb24gaW5pdGlhbCByZW5kZXI/XG4gICAgICB0aGlzLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fdHJhbnNpdGlvbk9uTG9hZCA9IHRyYW5zaXRpb25PbkxvYWQ7XG5cbiAgICAgIC8vIGhpc3RvcnkgbW9kZVxuICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICB0aGlzLl9hYnN0cmFjdCA9IGFic3RyYWN0O1xuICAgICAgdGhpcy5faGFzaGJhbmcgPSBoYXNoYmFuZztcblxuICAgICAgLy8gY2hlY2sgaWYgSFRNTDUgaGlzdG9yeSBpcyBhdmFpbGFibGVcbiAgICAgIHZhciBoYXNQdXNoU3RhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oaXN0b3J5ID0gaGlzdG9yeSAmJiBoYXNQdXNoU3RhdGU7XG4gICAgICB0aGlzLl9oaXN0b3J5RmFsbGJhY2sgPSBoaXN0b3J5ICYmICFoYXNQdXNoU3RhdGU7XG5cbiAgICAgIC8vIGNyZWF0ZSBoaXN0b3J5IG9iamVjdFxuICAgICAgdmFyIGluQnJvd3NlciA9IFZ1ZS51dGlsLmluQnJvd3NlcjtcbiAgICAgIHRoaXMubW9kZSA9ICFpbkJyb3dzZXIgfHwgdGhpcy5fYWJzdHJhY3QgPyAnYWJzdHJhY3QnIDogdGhpcy5faGlzdG9yeSA/ICdodG1sNScgOiAnaGFzaCc7XG5cbiAgICAgIHZhciBIaXN0b3J5ID0gaGlzdG9yeUJhY2tlbmRzW3RoaXMubW9kZV07XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh7XG4gICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgIGhhc2hiYW5nOiB0aGlzLl9oYXNoYmFuZyxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhdGgsIHN0YXRlLCBhbmNob3IpIHtcbiAgICAgICAgICBfdGhpcy5fbWF0Y2gocGF0aCwgc3RhdGUsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBvdGhlciBvcHRpb25zXG4gICAgICB0aGlzLl9zYXZlU2Nyb2xsUG9zaXRpb24gPSBzYXZlU2Nyb2xsUG9zaXRpb247XG4gICAgICB0aGlzLl9saW5rQWN0aXZlQ2xhc3MgPSBsaW5rQWN0aXZlQ2xhc3M7XG4gICAgICB0aGlzLl9zdXBwcmVzcyA9IHN1cHByZXNzVHJhbnNpdGlvbkVycm9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93IGRpcmVjdGx5IHBhc3NpbmcgY29tcG9uZW50cyB0byBhIHJvdXRlXG4gICAgICogZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJcbiAgICAgKi9cblxuICAgIC8vIEFQSSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICogUmVnaXN0ZXIgYSBtYXAgb2YgdG9wLWxldmVsIHBhdGhzLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAoX21hcCkge1xuICAgICAgZm9yICh2YXIgcm91dGUgaW4gX21hcCkge1xuICAgICAgICB0aGlzLm9uKHJvdXRlLCBfbWFwW3JvdXRlXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzaW5nbGUgcm9vdC1sZXZlbCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vdFBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgICAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGNvbXBvbmVudFxuICAgICAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IFtzdWJSb3V0ZXNdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IFtmb3JjZVJlZnJlc2hdXG4gICAgICogICAgICAgICAgICAgICAgIC0ge0Z1bmN0aW9ufSBbYmVmb3JlXVxuICAgICAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW2FmdGVyXVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKHJvb3RQYXRoLCBoYW5kbGVyKSB7XG4gICAgICBpZiAocm9vdFBhdGggPT09ICcqJykge1xuICAgICAgICB0aGlzLl9ub3RGb3VuZChoYW5kbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2FkZFJvdXRlKHJvb3RQYXRoLCBoYW5kbGVyLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHJlZGlyZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiByZWRpcmVjdChtYXApIHtcbiAgICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICAgIHRoaXMuX2FkZFJlZGlyZWN0KHBhdGgsIG1hcFtwYXRoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGFsaWFzZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gYWxpYXMobWFwKSB7XG4gICAgICBmb3IgKHZhciBwYXRoIGluIG1hcCkge1xuICAgICAgICB0aGlzLl9hZGRBbGlhcyhwYXRoLCBtYXBbcGF0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBnbG9iYWwgYmVmb3JlIGhvb2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaChmbikge1xuICAgICAgdGhpcy5fYmVmb3JlRWFjaEhvb2tzLnB1c2goZm4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBnbG9iYWwgYWZ0ZXIgaG9vay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaChmbikge1xuICAgICAgdGhpcy5fYWZ0ZXJFYWNoSG9va3MucHVzaChmbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGUgdG8gYSBnaXZlbiBwYXRoLlxuICAgICAqIFRoZSBwYXRoIGNhbiBiZSBhbiBvYmplY3QgZGVzY3JpYmluZyBhIG5hbWVkIHBhdGggaW5cbiAgICAgKiB0aGUgZm9ybWF0IG9mIHsgbmFtZTogJy4uLicsIHBhcmFtczoge30sIHF1ZXJ5OiB7fX1cbiAgICAgKiBUaGUgcGF0aCBpcyBhc3N1bWVkIHRvIGJlIGFscmVhZHkgZGVjb2RlZCwgYW5kIHdpbGxcbiAgICAgKiBiZSByZXNvbHZlZCBhZ2FpbnN0IHJvb3QgKGlmIHByb3ZpZGVkKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwYXRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmVwbGFjZV1cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyhwYXRoKSB7XG4gICAgICB2YXIgcmVwbGFjZSA9IGZhbHNlO1xuICAgICAgdmFyIGFwcGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKFZ1ZS51dGlsLmlzT2JqZWN0KHBhdGgpKSB7XG4gICAgICAgIHJlcGxhY2UgPSBwYXRoLnJlcGxhY2U7XG4gICAgICAgIGFwcGVuZCA9IHBhdGguYXBwZW5kO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHRoaXMuX3N0cmluZ2lmeVBhdGgocGF0aCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB0aGlzLmhpc3RvcnkuZ28ocGF0aCwgcmVwbGFjZSwgYXBwZW5kKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvcnQgaGFuZCBmb3IgcmVwbGFjaW5nIGN1cnJlbnQgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoID0geyBwYXRoOiBwYXRoIH07XG4gICAgICB9XG4gICAgICBwYXRoLnJlcGxhY2UgPSB0cnVlO1xuICAgICAgdGhpcy5nbyhwYXRoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIHJvdXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VnVlQ29uc3RydWN0b3J9IEFwcFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydChBcHAsIGNvbnRhaW5lciwgY2IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgd2FybignYWxyZWFkeSBzdGFydGVkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0YXJ0Q2IgPSBjYjtcbiAgICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXBwIHx8ICFjb250YWluZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3RhcnQgdnVlLXJvdXRlciB3aXRoIGEgY29tcG9uZW50IGFuZCBhICcgKyAncm9vdCBjb250YWluZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChBcHAgaW5zdGFuY2VvZiBWdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3RhcnQgdnVlLXJvdXRlciB3aXRoIGEgY29tcG9uZW50LCBub3QgYSAnICsgJ1Z1ZSBpbnN0YW5jZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcHBDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHZhciBDdG9yID0gdGhpcy5fYXBwQ29uc3RydWN0b3IgPSB0eXBlb2YgQXBwID09PSAnZnVuY3Rpb24nID8gQXBwIDogVnVlLmV4dGVuZChBcHApO1xuICAgICAgICAvLyBnaXZlIGl0IGEgbmFtZSBmb3IgYmV0dGVyIGRlYnVnZ2luZ1xuICAgICAgICBDdG9yLm9wdGlvbnMubmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8ICdSb3V0ZXJBcHAnO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgaGlzdG9yeSBmYWxsYmFjayBpbiBicm93c2VycyB0aGF0IGRvIG5vdFxuICAgICAgLy8gc3VwcG9ydCBIVE1MNSBoaXN0b3J5IEFQSVxuICAgICAgaWYgKHRoaXMuX2hpc3RvcnlGYWxsYmFjaykge1xuICAgICAgICB2YXIgX2xvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICB2YXIgX2hpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHsgcm9vdDogdGhpcy5fcm9vdCB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBfaGlzdG9yeS5yb290ID8gX2xvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoX2hpc3Rvcnkucm9vdFJFLCAnJykgOiBfbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgIGlmIChwYXRoICYmIHBhdGggIT09ICcvJykge1xuICAgICAgICAgIF9sb2NhdGlvbi5hc3NpZ24oKF9oaXN0b3J5LnJvb3QgfHwgJycpICsgJy8nICsgdGhpcy5oaXN0b3J5LmZvcm1hdFBhdGgocGF0aCkgKyBfbG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5oaXN0b3J5LnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgbGlzdGVuaW5nIHRvIHJvdXRlIGNoYW5nZXMuXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5oaXN0b3J5LnN0b3AoKTtcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLyoqXG4gICAgKiBBZGQgYSByb3V0ZSBjb250YWluaW5nIGEgbGlzdCBvZiBzZWdtZW50cyB0byB0aGUgaW50ZXJuYWxcbiAgICAqIHJvdXRlIHJlY29nbml6ZXIuIFdpbGwgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGFkZCBhbGxcbiAgICAqIHBvc3NpYmxlIHN1Yi1yb3V0ZXMuXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kbGVyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBzZWdtZW50c1xuICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9hZGRSb3V0ZSA9IGZ1bmN0aW9uIF9hZGRSb3V0ZShwYXRoLCBoYW5kbGVyLCBzZWdtZW50cykge1xuICAgICAgZ3VhcmRDb21wb25lbnQocGF0aCwgaGFuZGxlcik7XG4gICAgICBoYW5kbGVyLnBhdGggPSBwYXRoO1xuICAgICAgaGFuZGxlci5mdWxsUGF0aCA9IChzZWdtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHBhdGgsIHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyBzZWdtZW50LnBhdGg7XG4gICAgICB9LCAnJykgKyBwYXRoKS5yZXBsYWNlKCcvLycsICcvJyk7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgfSk7XG4gICAgICB0aGlzLl9yZWNvZ25pemVyLmFkZChzZWdtZW50cywge1xuICAgICAgICBhczogaGFuZGxlci5uYW1lXG4gICAgICB9KTtcbiAgICAgIC8vIGFkZCBzdWIgcm91dGVzXG4gICAgICBpZiAoaGFuZGxlci5zdWJSb3V0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgc3ViUGF0aCBpbiBoYW5kbGVyLnN1YlJvdXRlcykge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IHdhbGsgYWxsIHN1YiByb3V0ZXNcbiAgICAgICAgICB0aGlzLl9hZGRSb3V0ZShzdWJQYXRoLCBoYW5kbGVyLnN1YlJvdXRlc1tzdWJQYXRoXSxcbiAgICAgICAgICAvLyBwYXNzIGEgY29weSBpbiByZWN1cnNpb24gdG8gYXZvaWQgbXV0YXRpbmdcbiAgICAgICAgICAvLyBhY3Jvc3MgYnJhbmNoZXNcbiAgICAgICAgICBzZWdtZW50cy5zbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG5vdEZvdW5kIHJvdXRlIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFuZGxlclxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fbm90Rm91bmQgPSBmdW5jdGlvbiBfbm90Rm91bmQoaGFuZGxlcikge1xuICAgICAgZ3VhcmRDb21wb25lbnQoJyonLCBoYW5kbGVyKTtcbiAgICAgIHRoaXMuX25vdEZvdW5kSGFuZGxlciA9IFt7IGhhbmRsZXI6IGhhbmRsZXIgfV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlZGlyZWN0IHJlY29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlZGlyZWN0UGF0aFxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fYWRkUmVkaXJlY3QgPSBmdW5jdGlvbiBfYWRkUmVkaXJlY3QocGF0aCwgcmVkaXJlY3RQYXRoKSB7XG4gICAgICBpZiAocGF0aCA9PT0gJyonKSB7XG4gICAgICAgIHRoaXMuX25vdEZvdW5kUmVkaXJlY3QgPSByZWRpcmVjdFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hZGRHdWFyZChwYXRoLCByZWRpcmVjdFBhdGgsIHRoaXMucmVwbGFjZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhbGlhcyByZWNvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1BhdGhcbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX2FkZEFsaWFzID0gZnVuY3Rpb24gX2FkZEFsaWFzKHBhdGgsIGFsaWFzUGF0aCkge1xuICAgICAgdGhpcy5fYWRkR3VhcmQocGF0aCwgYWxpYXNQYXRoLCB0aGlzLl9tYXRjaCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHBhdGggZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXBwZWRQYXRoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fYWRkR3VhcmQgPSBmdW5jdGlvbiBfYWRkR3VhcmQocGF0aCwgbWFwcGVkUGF0aCwgX2hhbmRsZXIpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9ndWFyZFJlY29nbml6ZXIuYWRkKFt7XG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIobWF0Y2gsIHF1ZXJ5KSB7XG4gICAgICAgICAgdmFyIHJlYWxQYXRoID0gbWFwUGFyYW1zKG1hcHBlZFBhdGgsIG1hdGNoLnBhcmFtcywgcXVlcnkpO1xuICAgICAgICAgIF9oYW5kbGVyLmNhbGwoX3RoaXMyLCByZWFsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBwYXRoIG1hdGNoZXMgYW55IHJlZGlyZWN0IHJlY29yZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gaWYgdHJ1ZSwgd2lsbCBza2lwIG5vcm1hbCBtYXRjaC5cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX2NoZWNrR3VhcmQgPSBmdW5jdGlvbiBfY2hlY2tHdWFyZChwYXRoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IHRoaXMuX2d1YXJkUmVjb2duaXplci5yZWNvZ25pemUocGF0aCk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBtYXRjaGVkWzBdLmhhbmRsZXIobWF0Y2hlZFswXSwgbWF0Y2hlZC5xdWVyeVBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ub3RGb3VuZFJlZGlyZWN0KSB7XG4gICAgICAgIG1hdGNoZWQgPSB0aGlzLl9yZWNvZ25pemVyLnJlY29nbml6ZShwYXRoKTtcbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlKHRoaXMuX25vdEZvdW5kUmVkaXJlY3QpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1hdGNoIGEgVVJMIHBhdGggYW5kIHNldCB0aGUgcm91dGUgY29udGV4dCBvbiB2bSxcbiAgICAgKiB0cmlnZ2VyaW5nIHZpZXcgdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGF0ZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FuY2hvcl1cbiAgICAgKi9cblxuICAgIFJvdXRlci5wcm90b3R5cGUuX21hdGNoID0gZnVuY3Rpb24gX21hdGNoKHBhdGgsIHN0YXRlLCBhbmNob3IpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fY2hlY2tHdWFyZChwYXRoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50Um91dGUgPSB0aGlzLl9jdXJyZW50Um91dGU7XG4gICAgICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbjtcblxuICAgICAgaWYgKGN1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgIGlmIChjdXJyZW50VHJhbnNpdGlvbi50by5wYXRoID09PSBwYXRoKSB7XG4gICAgICAgICAgLy8gZG8gbm90aGluZyBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSB0cmFuc2l0aW9uIGdvaW5nIHRvIHRoZSBzYW1lIHBhdGhcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJvdXRlLnBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgICAvLyBXZSBhcmUgZ29pbmcgdG8gdGhlIHNhbWUgcGF0aCwgYnV0IHdlIGFsc28gaGF2ZSBhbiBvbmdvaW5nIGJ1dFxuICAgICAgICAgIC8vIG5vdC15ZXQtdmFsaWRhdGVkIHRyYW5zaXRpb24uIEFib3J0IHRoYXQgdHJhbnNpdGlvbiBhbmQgcmVzZXQgdG9cbiAgICAgICAgICAvLyBwcmV2IHRyYW5zaXRpb24uXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0aGlzLl9wcmV2VHJhbnNpdGlvbjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ29pbmcgdG8gYSB0b3RhbGx5IGRpZmZlcmVudCBwYXRoLiBhYm9ydCBvbmdvaW5nIHRyYW5zaXRpb24uXG4gICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29uc3RydWN0IG5ldyByb3V0ZSBhbmQgdHJhbnNpdGlvbiBjb250ZXh0XG4gICAgICB2YXIgcm91dGUgPSBuZXcgUm91dGUocGF0aCwgdGhpcyk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiA9IG5ldyBSb3V0ZVRyYW5zaXRpb24odGhpcywgcm91dGUsIGN1cnJlbnRSb3V0ZSk7XG5cbiAgICAgIC8vIGN1cnJlbnQgdHJhbnNpdGlvbiBpcyB1cGRhdGVkIHJpZ2h0IG5vdy5cbiAgICAgIC8vIGhvd2V2ZXIsIGN1cnJlbnQgcm91dGUgd2lsbCBvbmx5IGJlIHVwZGF0ZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAvLyBiZWVuIHZhbGlkYXRlZC5cbiAgICAgIHRoaXMuX3ByZXZUcmFuc2l0aW9uID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cbiAgICAgIGlmICghdGhpcy5hcHApIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICAgIHZhciByb3V0ZXIgPSBfdGhpczM7XG4gICAgICAgICAgX3RoaXMzLmFwcCA9IG5ldyBfdGhpczMuX2FwcENvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGVsOiBfdGhpczMuX2FwcENvbnRhaW5lcixcbiAgICAgICAgICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgICAgICAgICAgIHRoaXMuJHJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfbWV0YToge1xuICAgICAgICAgICAgICAkcm91dGU6IHJvdXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGdsb2JhbCBiZWZvcmUgaG9va1xuICAgICAgdmFyIGJlZm9yZUhvb2tzID0gdGhpcy5fYmVmb3JlRWFjaEhvb2tzO1xuICAgICAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5zdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9wb3N0VHJhbnNpdGlvbihyb3V0ZSwgc3RhdGUsIGFuY2hvcik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgaWYgKGJlZm9yZUhvb2tzLmxlbmd0aCkge1xuICAgICAgICB0cmFuc2l0aW9uLnJ1blF1ZXVlKGJlZm9yZUhvb2tzLCBmdW5jdGlvbiAoaG9vaywgXywgbmV4dCkge1xuICAgICAgICAgIGlmICh0cmFuc2l0aW9uID09PSBfdGhpczMuX2N1cnJlbnRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uLmNhbGxIb29rKGhvb2ssIG51bGwsIG5leHQsIHtcbiAgICAgICAgICAgICAgZXhwZWN0Qm9vbGVhbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydFRyYW5zaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZWQgJiYgdGhpcy5fc3RhcnRDYikge1xuICAgICAgICB0aGlzLl9zdGFydENiLmNhbGwobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhBQ0s6XG4gICAgICAvLyBzZXQgcmVuZGVyZWQgdG8gdHJ1ZSBhZnRlciB0aGUgdHJhbnNpdGlvbiBzdGFydCwgc29cbiAgICAgIC8vIHRoYXQgY29tcG9uZW50cyB0aGF0IGFyZSBhY2l0dmF0ZWQgc3luY2hyb25vdXNseSBrbm93XG4gICAgICAvLyB3aGV0aGVyIGl0IGlzIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGN1cnJlbnQgdG8gdGhlIG5ldyB0cmFuc2l0aW9uLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSB0cmFuc2l0aW9uIG9iamVjdCB3aGVuIHRoZVxuICAgICAqIHZhbGlkYXRpb24gb2YgYSByb3V0ZSBoYXMgc3VjY2VlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc2l0aW9ufSB0cmFuc2l0aW9uXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9vblRyYW5zaXRpb25WYWxpZGF0ZWQgPSBmdW5jdGlvbiBfb25UcmFuc2l0aW9uVmFsaWRhdGVkKHRyYW5zaXRpb24pIHtcbiAgICAgIC8vIHNldCBjdXJyZW50IHJvdXRlXG4gICAgICB2YXIgcm91dGUgPSB0aGlzLl9jdXJyZW50Um91dGUgPSB0cmFuc2l0aW9uLnRvO1xuICAgICAgLy8gdXBkYXRlIHJvdXRlIGNvbnRleHQgZm9yIGFsbCBjaGlsZHJlblxuICAgICAgaWYgKHRoaXMuYXBwLiRyb3V0ZSAhPT0gcm91dGUpIHtcbiAgICAgICAgdGhpcy5hcHAuJHJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQuJHJvdXRlID0gcm91dGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gY2FsbCBnbG9iYWwgYWZ0ZXIgaG9va1xuICAgICAgaWYgKHRoaXMuX2FmdGVyRWFjaEhvb2tzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9hZnRlckVhY2hIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2suY2FsbChudWxsLCB7XG4gICAgICAgICAgICB0bzogdHJhbnNpdGlvbi50byxcbiAgICAgICAgICAgIGZyb206IHRyYW5zaXRpb24uZnJvbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2l0aW9uLmRvbmUgPSB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc3R1ZmYgYWZ0ZXIgdGhlIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JvdXRlfSByb3V0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhdGVdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFthbmNob3JdXG4gICAgICovXG5cbiAgICBSb3V0ZXIucHJvdG90eXBlLl9wb3N0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIF9wb3N0VHJhbnNpdGlvbihyb3V0ZSwgc3RhdGUsIGFuY2hvcikge1xuICAgICAgLy8gaGFuZGxlIHNjcm9sbCBwb3NpdGlvbnNcbiAgICAgIC8vIHNhdmVkIHNjcm9sbCBwb3NpdGlvbnMgdGFrZSBwcmlvcml0eVxuICAgICAgLy8gdGhlbiB3ZSBjaGVjayBpZiB0aGUgcGF0aCBoYXMgYW4gYW5jaG9yXG4gICAgICB2YXIgcG9zID0gc3RhdGUgJiYgc3RhdGUucG9zO1xuICAgICAgaWYgKHBvcyAmJiB0aGlzLl9zYXZlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zLngsIHBvcy55KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGFuY2hvcikge1xuICAgICAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGFuY2hvci5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIGVsLm9mZnNldFRvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIG5hbWVkIHJvdXRlIG9iamVjdCAvIHN0cmluZyBwYXRocyBpbnRvXG4gICAgICogYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TnVtYmVyfSBwYXRoXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuXG4gICAgUm91dGVyLnByb3RvdHlwZS5fc3RyaW5naWZ5UGF0aCA9IGZ1bmN0aW9uIF9zdHJpbmdpZnlQYXRoKHBhdGgpIHtcbiAgICAgIHZhciBmdWxsUGF0aCA9ICcnO1xuICAgICAgaWYgKHBhdGggJiYgdHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwYXRoLm5hbWUpIHtcbiAgICAgICAgICB2YXIgZXh0ZW5kID0gVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICAgIHZhciBjdXJyZW50UGFyYW1zID0gdGhpcy5fY3VycmVudFRyYW5zaXRpb24gJiYgdGhpcy5fY3VycmVudFRyYW5zaXRpb24udG8ucGFyYW1zO1xuICAgICAgICAgIHZhciB0YXJnZXRQYXJhbXMgPSBwYXRoLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gY3VycmVudFBhcmFtcyA/IGV4dGVuZChleHRlbmQoe30sIGN1cnJlbnRQYXJhbXMpLCB0YXJnZXRQYXJhbXMpIDogdGFyZ2V0UGFyYW1zO1xuICAgICAgICAgIGlmIChwYXRoLnF1ZXJ5KSB7XG4gICAgICAgICAgICBwYXJhbXMucXVlcnlQYXJhbXMgPSBwYXRoLnF1ZXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdWxsUGF0aCA9IHRoaXMuX3JlY29nbml6ZXIuZ2VuZXJhdGUocGF0aC5uYW1lLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhdGgucGF0aCkge1xuICAgICAgICAgIGZ1bGxQYXRoID0gcGF0aC5wYXRoO1xuICAgICAgICAgIGlmIChwYXRoLnF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9yZWNvZ25pemVyLmdlbmVyYXRlUXVlcnlTdHJpbmcocGF0aC5xdWVyeSk7XG4gICAgICAgICAgICBpZiAoZnVsbFBhdGguaW5kZXhPZignPycpID4gLTEpIHtcbiAgICAgICAgICAgICAgZnVsbFBhdGggKz0gJyYnICsgcXVlcnkuc2xpY2UoMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmdWxsUGF0aCArPSBxdWVyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGxQYXRoID0gcGF0aCA/IHBhdGggKyAnJyA6ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kZVVSSShmdWxsUGF0aCk7XG4gICAgfTtcblxuICAgIHJldHVybiBSb3V0ZXI7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gZ3VhcmRDb21wb25lbnQocGF0aCwgaGFuZGxlcikge1xuICAgIHZhciBjb21wID0gaGFuZGxlci5jb21wb25lbnQ7XG4gICAgaWYgKFZ1ZS51dGlsLmlzUGxhaW5PYmplY3QoY29tcCkpIHtcbiAgICAgIGNvbXAgPSBoYW5kbGVyLmNvbXBvbmVudCA9IFZ1ZS5leHRlbmQoY29tcCk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgY29tcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGFuZGxlci5jb21wb25lbnQgPSBudWxsO1xuICAgICAgd2FybignaW52YWxpZCBjb21wb25lbnQgZm9yIHJvdXRlIFwiJyArIHBhdGggKyAnXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgLyogSW5zdGFsbGF0aW9uICovXG5cbiAgUm91dGVyLmluc3RhbGxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBJbnN0YWxsYXRpb24gaW50ZXJmYWNlLlxuICAgKiBJbnN0YWxsIHRoZSBuZWNlc3NhcnkgZGlyZWN0aXZlcy5cbiAgICovXG5cbiAgUm91dGVyLmluc3RhbGwgPSBmdW5jdGlvbiAoZXh0ZXJuYWxWdWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoUm91dGVyLmluc3RhbGxlZCkge1xuICAgICAgd2FybignYWxyZWFkeSBpbnN0YWxsZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFZ1ZSA9IGV4dGVybmFsVnVlO1xuICAgIGFwcGx5T3ZlcnJpZGUoVnVlKTtcbiAgICBWaWV3KFZ1ZSk7XG4gICAgTGluayhWdWUpO1xuICAgIGV4cG9ydHMkMS5WdWUgPSBWdWU7XG4gICAgUm91dGVyLmluc3RhbGxlZCA9IHRydWU7XG4gIH07XG5cbiAgLy8gYXV0byBpbnN0YWxsXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICAgIHdpbmRvdy5WdWUudXNlKFJvdXRlcik7XG4gIH1cblxuICByZXR1cm4gUm91dGVyO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHZ1ZVRvdWNoID0ge31cbiAgdmFyIEhhbW1lciA9IHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nXG4gICAgPyByZXF1aXJlKCdoYW1tZXJqcycpXG4gICAgOiB3aW5kb3cuSGFtbWVyXG4gIHZhciBnZXN0dXJlcyA9IFsndGFwJywgJ3BhbicsICdwaW5jaCcsICdwcmVzcycsICdyb3RhdGUnLCAnc3dpcGUnXVxuICB2YXIgY3VzdG9tZUV2ZW50cyA9IHt9XG5cbiAgdnVlVG91Y2guaW5zdGFsbCA9IGZ1bmN0aW9uIChWdWUpIHtcblxuICAgIFZ1ZS5kaXJlY3RpdmUoJ3RvdWNoJywge1xuXG4gICAgICBpc0ZuOiB0cnVlLFxuICAgICAgYWNjZXB0U3RhdGVtZW50OiB0cnVlLFxuXG4gICAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbC5oYW1tZXIpIHtcbiAgICAgICAgICB0aGlzLmVsLmhhbW1lciA9IG5ldyBIYW1tZXIuTWFuYWdlcih0aGlzLmVsKVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYyA9IHRoaXMubWMgPSB0aGlzLmVsLmhhbW1lclxuICAgICAgICAvLyBkZXRlcm1pbmUgZXZlbnQgdHlwZVxuICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmFyZ1xuICAgICAgICB2YXIgcmVjb2duaXplclR5cGUsIHJlY29nbml6ZXJcblxuICAgICAgICBpZiAoY3VzdG9tZUV2ZW50c1tldmVudF0pIHsgLy8gY3VzdG9tIGV2ZW50XG5cbiAgICAgICAgICB2YXIgY3VzdG9tID0gY3VzdG9tZUV2ZW50c1tldmVudF1cbiAgICAgICAgICByZWNvZ25pemVyVHlwZSA9IGN1c3RvbS50eXBlXG4gICAgICAgICAgcmVjb2duaXplciA9IG5ldyBIYW1tZXJbY2FwaXRhbGl6ZShyZWNvZ25pemVyVHlwZSldKGN1c3RvbSlcbiAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgobWMucmVjb2duaXplcnMpXG4gICAgICAgICAgbWMuYWRkKHJlY29nbml6ZXIpXG5cbiAgICAgICAgfSBlbHNlIHsgLy8gYnVpbHQtaW4gZXZlbnRcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VzdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChldmVudC5pbmRleE9mKGdlc3R1cmVzW2ldKSA9PT0gMCkge1xuICAgICAgICAgICAgICByZWNvZ25pemVyVHlwZSA9IGdlc3R1cmVzW2ldXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVjb2duaXplclR5cGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCB2LXRvdWNoIGV2ZW50OiAnICsgZXZlbnQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVjb2duaXplciA9IG1jLmdldChyZWNvZ25pemVyVHlwZSlcbiAgICAgICAgICBpZiAoIXJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIC8vIGFkZCByZWNvZ25pemVyXG4gICAgICAgICAgICByZWNvZ25pemVyID0gbmV3IEhhbW1lcltjYXBpdGFsaXplKHJlY29nbml6ZXJUeXBlKV0oKVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG11bHRpcGxlIHJlY29nbml6ZXJzIHdvcmsgdG9nZXRoZXIuLi5cbiAgICAgICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChtYy5yZWNvZ25pemVycylcbiAgICAgICAgICAgIG1jLmFkZChyZWNvZ25pemVyKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgbWMgPSB0aGlzLm1jXG4gICAgICAgIHZhciB2bSA9IHRoaXMudm1cbiAgICAgICAgdmFyIGV2ZW50ID0gdGhpcy5hcmdcbiAgICAgICAgLy8gdGVhcmRvd24gb2xkIGhhbmRsZXJcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlcikge1xuICAgICAgICAgIG1jLm9mZihldmVudCwgdGhpcy5oYW5kbGVyKVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlZmluZSBuZXcgaGFuZGxlclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUudGFyZ2V0Vk0gPSB2bVxuICAgICAgICAgIGZuLmNhbGwodm0sIGUpXG4gICAgICAgIH1cbiAgICAgICAgbWMub24oZXZlbnQsIHRoaXMuaGFuZGxlcilcbiAgICAgIH0sXG5cbiAgICAgIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1jLm9mZih0aGlzLmFyZywgdGhpcy5oYW5kbGVyKVxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubWMuaGFuZGxlcnMpLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubWMuZGVzdHJveSgpXG4gICAgICAgICAgdGhpcy5lbC5oYW1tZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjdXN0b20gZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGEgSGFtbWVyLmpzIHJlY29nbml6ZXIgb3B0aW9uIG9iamVjdC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZCBmaWVsZHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB0eXBlOiB0aGUgYmFzZSByZWNvZ25pemVyIHRvIHVzZSBmb3IgdGhpcyBldmVudFxuICAgKi9cblxuICB2dWVUb3VjaC5yZWdpc3RlckN1c3RvbUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5ldmVudCA9IGV2ZW50XG4gICAgY3VzdG9tZUV2ZW50c1tldmVudF0gPSBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiBjYXBpdGFsaXplIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdnVlVG91Y2hcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpeyByZXR1cm4gdnVlVG91Y2ggfSlcbiAgfSBlbHNlIGlmICh3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZVRvdWNoID0gdnVlVG91Y2hcbiAgICBWdWUudXNlKHZ1ZVRvdWNoKVxuICB9XG5cbn0pKCkiLCIvKiFcbiAqIFZ1ZS5qcyB2MS4wLjE1XG4gKiAoYykgMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHNldChvYmosIGtleSwgdmFsKSB7XG4gIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmouX2lzVnVlKSB7XG4gICAgc2V0KG9iai5fZGF0YSwga2V5LCB2YWwpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAoIW9iKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9iLmNvbnZlcnQoa2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIGlmIChvYi52bXMpIHtcbiAgICB2YXIgaSA9IG9iLnZtcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHZtID0gb2Iudm1zW2ldO1xuICAgICAgdm0uX3Byb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24gZGVsKG9iaiwga2V5KSB7XG4gIGlmICghaGFzT3duKG9iaiwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZWxldGUgb2JqW2tleV07XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xuICBpZiAob2Iudm1zKSB7XG4gICAgdmFyIGkgPSBvYi52bXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciB2bSA9IG9iLnZtc1tpXTtcbiAgICAgIHZtLl91bnByb3h5KGtleSk7XG4gICAgICB2bS5fZGlnZXN0KCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBleHByZXNzaW9uIGlzIGEgbGl0ZXJhbCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbnZhciBsaXRlcmFsVmFsdWVSRSA9IC9eXFxzPyh0cnVlfGZhbHNlfFtcXGRcXC5dK3wnW14nXSonfFwiW15cIl0qXCIpXFxzPyQvO1xuXG5mdW5jdGlvbiBpc0xpdGVyYWwoZXhwKSB7XG4gIHJldHVybiBsaXRlcmFsVmFsdWVSRS50ZXN0KGV4cCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Rjtcbn1cblxuLyoqXG4gKiBHdWFyZCB0ZXh0IG91dHB1dCwgbWFrZSBzdXJlIHVuZGVmaW5lZCBvdXRwdXRzXG4gKiBlbXB0eSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gX3RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIENoZWNrIGFuZCBjb252ZXJ0IHBvc3NpYmxlIG51bWVyaWMgc3RyaW5ncyB0byBudW1iZXJzXG4gKiBiZWZvcmUgc2V0dGluZyBiYWNrIHRvIGRhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfE51bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkID0gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBzdHJpbmcgYm9vbGVhbiBsaXRlcmFscyBpbnRvIHJlYWwgYm9vbGVhbnMuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7KnxCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHRvQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJyA/IHRydWUgOiB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWU7XG59XG5cbi8qKlxuICogU3RyaXAgcXVvdGVzIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmcgfCBmYWxzZX1cbiAqL1xuXG5mdW5jdGlvbiBzdHJpcFF1b3RlcyhzdHIpIHtcbiAgdmFyIGEgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoIC0gMSk7XG4gIHJldHVybiBhID09PSBiICYmIChhID09PSAweDIyIHx8IGEgPT09IDB4MjcpID8gc3RyLnNsaWNlKDEsIC0xKSA6IHN0cjtcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxtaXRlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIHRvVXBwZXIpO1xufVxuXG5mdW5jdGlvbiB0b1VwcGVyKF8sIGMpIHtcbiAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJztcbn1cblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgaHlwaGVuYXRlUkUgPSAvKFthLXpcXGRdKShbQS1aXSkvZztcblxuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgaHlwaGVuL3VuZGVyc2NvcmUvc2xhc2ggZGVsaW1pdGVyZWQgbmFtZXMgaW50b1xuICogY2FtZWxpemVkIGNsYXNzTmFtZXMuXG4gKlxuICogZS5nLiBteS1jb21wb25lbnQgPT4gTXlDb21wb25lbnRcbiAqICAgICAgc29tZV9lbHNlICAgID0+IFNvbWVFbHNlXG4gKiAgICAgIHNvbWUvY29tcCAgICA9PiBTb21lQ29tcFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX1xcL10pKFxcdykvZztcblxuZnVuY3Rpb24gY2xhc3NpZnkoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFLCB0b1VwcGVyKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHhcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGJpbmQkMShmbiwgY3R4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbCA/IGwgPiAxID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpIDogZm4uY2FsbChjdHgsIGEpIDogZm4uY2FsbChjdHgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXktbGlrZX0gbGlzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBzdGFydCBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tXG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5kKHRvLCBmcm9tKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0b1trZXlzW2ldXSA9IGZyb21ba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9TVFJJTkc7XG59XG5cbi8qKlxuICogQXJyYXkgdHlwZSBjaGVjay5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogRGVmaW5lIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHBhcmFtIHtCb29sZWFufSBbZW51bWVyYWJsZV1cbiAqL1xuXG5mdW5jdGlvbiBkZWYob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRGVib3VuY2UgYSBmdW5jdGlvbiBzbyBpdCBvbmx5IGdldHMgY2FsbGVkIGFmdGVyIHRoZVxuICogaW5wdXQgc3RvcHMgYXJyaXZpbmcgYWZ0ZXIgdGhlIGdpdmVuIHdhaXQgcGVyaW9kLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gX2RlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBNYW51YWwgaW5kZXhPZiBiZWNhdXNlIGl0J3Mgc2xpZ2h0bHkgZmFzdGVyIHRoYW5cbiAqIG5hdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIG9iaikge1xuICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBNYWtlIGEgY2FuY2VsbGFibGUgdmVyc2lvbiBvZiBhbiBhc3luYyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY2FuY2VsbGFibGUoZm4pIHtcbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbiAgY2IuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGNiLmNhbmNlbGxlZCA9IHRydWU7XG4gIH07XG4gIHJldHVybiBjYjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4gIHJldHVybiBhID09IGIgfHwgKGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpID8gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpIDogZmFsc2UpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xufVxuXG52YXIgaGFzUHJvdG8gPSAoJ19fcHJvdG9fXycgaW4ge30pO1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdykgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG52YXIgaXNJRTkgPSBpbkJyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xuXG52YXIgaXNBbmRyb2lkID0gaW5Ccm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xuXG52YXIgdHJhbnNpdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gdW5kZWZpbmVkO1xudmFyIGFuaW1hdGlvblByb3AgPSB1bmRlZmluZWQ7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSB1bmRlZmluZWQ7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUU5KSB7XG4gIHZhciBpc1dlYmtpdFRyYW5zID0gd2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZDtcbiAgdmFyIGlzV2Via2l0QW5pbSA9IHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkO1xuICB0cmFuc2l0aW9uUHJvcCA9IGlzV2Via2l0VHJhbnMgPyAnV2Via2l0VHJhbnNpdGlvbicgOiAndHJhbnNpdGlvbic7XG4gIHRyYW5zaXRpb25FbmRFdmVudCA9IGlzV2Via2l0VHJhbnMgPyAnd2Via2l0VHJhbnNpdGlvbkVuZCcgOiAndHJhbnNpdGlvbmVuZCc7XG4gIGFuaW1hdGlvblByb3AgPSBpc1dlYmtpdEFuaW0gPyAnV2Via2l0QW5pbWF0aW9uJyA6ICdhbmltYXRpb24nO1xuICBhbmltYXRpb25FbmRFdmVudCA9IGlzV2Via2l0QW5pbSA/ICd3ZWJraXRBbmltYXRpb25FbmQnIDogJ2FuaW1hdGlvbmVuZCc7XG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuIElkZWFsbHkgdGhpc1xuICogc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgbWljcm90YXNrLCBzbyB3ZSBsZXZlcmFnZVxuICogTXV0YXRpb25PYnNlcnZlciBpZiBpdCdzIGF2YWlsYWJsZSwgYW5kIGZhbGxiYWNrIHRvXG4gKiBzZXRUaW1lb3V0KDApLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKi9cblxudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvdW50ZXIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gY291bnRlcjtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRpbWVyRnVuYyA9IHNldFRpbWVvdXQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjYiwgY3R4KSB7XG4gICAgdmFyIGZ1bmMgPSBjdHggPyBmdW5jdGlvbiAoKSB7XG4gICAgICBjYi5jYWxsKGN0eCk7XG4gICAgfSA6IGNiO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICAgIGlmIChwZW5kaW5nKSByZXR1cm47XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKG5leHRUaWNrSGFuZGxlciwgMCk7XG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiBDYWNoZShsaW1pdCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5fa2V5bWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxudmFyIHAgPSBDYWNoZS5wcm90b3R5cGU7XG5cbi8qKlxuICogUHV0IDx2YWx1ZT4gaW50byB0aGUgY2FjaGUgYXNzb2NpYXRlZCB3aXRoIDxrZXk+LlxuICogUmV0dXJucyB0aGUgZW50cnkgd2hpY2ggd2FzIHJlbW92ZWQgdG8gbWFrZSByb29tIGZvclxuICogdGhlIG5ldyBlbnRyeS4gT3RoZXJ3aXNlIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqIChpLmUuIGlmIHRoZXJlIHdhcyBlbm91Z2ggcm9vbSBhbHJlYWR5KS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtFbnRyeXx1bmRlZmluZWR9XG4gKi9cblxucC5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgcmVtb3ZlZDtcbiAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5saW1pdCkge1xuICAgIHJlbW92ZWQgPSB0aGlzLnNoaWZ0KCk7XG4gIH1cblxuICB2YXIgZW50cnkgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgZW50cnkgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG4gICAgdGhpcy5fa2V5bWFwW2tleV0gPSBlbnRyeTtcbiAgICBpZiAodGhpcy50YWlsKSB7XG4gICAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeTtcbiAgICAgIGVudHJ5Lm9sZGVyID0gdGhpcy50YWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB9XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5zaXplKys7XG4gIH1cbiAgZW50cnkudmFsdWUgPSB2YWx1ZTtcblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG5cbi8qKlxuICogUHVyZ2UgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgZnJvbSB0aGVcbiAqIGNhY2hlLiBSZXR1cm5zIHRoZSByZW1vdmVkIGVudHJ5IG9yIHVuZGVmaW5lZCBpZiB0aGVcbiAqIGNhY2hlIHdhcyBlbXB0eS5cbiAqL1xuXG5wLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gIGlmIChlbnRyeSkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXdlcjtcbiAgICB0aGlzLmhlYWQub2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgZW50cnkubmV3ZXIgPSBlbnRyeS5vbGRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9rZXltYXBbZW50cnkua2V5XSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNpemUtLTtcbiAgfVxuICByZXR1cm4gZW50cnk7XG59O1xuXG4vKipcbiAqIEdldCBhbmQgcmVnaXN0ZXIgcmVjZW50IHVzZSBvZiA8a2V5Pi4gUmV0dXJucyB0aGUgdmFsdWVcbiAqIGFzc29jaWF0ZWQgd2l0aCA8a2V5PiBvciB1bmRlZmluZWQgaWYgbm90IGluIGNhY2hlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV0dXJuRW50cnlcbiAqIEByZXR1cm4ge0VudHJ5fCp9XG4gKi9cblxucC5nZXQgPSBmdW5jdGlvbiAoa2V5LCByZXR1cm5FbnRyeSkge1xuICB2YXIgZW50cnkgPSB0aGlzLl9rZXltYXBba2V5XTtcbiAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKGVudHJ5ID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xuICB9XG4gIC8vIEhFQUQtLS0tLS0tLS0tLS0tLVRBSUxcbiAgLy8gICA8Lm9sZGVyICAgLm5ld2VyPlxuICAvLyAgPC0tLSBhZGQgZGlyZWN0aW9uIC0tXG4gIC8vICAgQSAgQiAgQyAgPEQ+ICBFXG4gIGlmIChlbnRyeS5uZXdlcikge1xuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXdlcjtcbiAgICB9XG4gICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjsgLy8gQyA8LS0gRS5cbiAgfVxuICBpZiAoZW50cnkub2xkZXIpIHtcbiAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyOyAvLyBDLiAtLT4gRVxuICB9XG4gIGVudHJ5Lm5ld2VyID0gdW5kZWZpbmVkOyAvLyBEIC0teFxuICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbDsgLy8gRC4gLS0+IEVcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXdlciA9IGVudHJ5OyAvLyBFLiA8LS0gRFxuICB9XG4gIHRoaXMudGFpbCA9IGVudHJ5O1xuICByZXR1cm4gcmV0dXJuRW50cnkgPyBlbnRyeSA6IGVudHJ5LnZhbHVlO1xufTtcblxudmFyIGNhY2hlJDEgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgZmlsdGVyVG9rZW5SRSA9IC9bXlxccydcIl0rfCdbXiddKid8XCJbXlwiXSpcIi9nO1xudmFyIHJlc2VydmVkQXJnUkUgPSAvXmluJHxeLT9cXGQrLztcblxuLyoqXG4gKiBQYXJzZXIgc3RhdGVcbiAqL1xuXG52YXIgc3RyO1xudmFyIGRpcjtcbnZhciBjO1xudmFyIHByZXY7XG52YXIgaTtcbnZhciBsO1xudmFyIGxhc3RGaWx0ZXJJbmRleDtcbnZhciBpblNpbmdsZTtcbnZhciBpbkRvdWJsZTtcbnZhciBjdXJseTtcbnZhciBzcXVhcmU7XG52YXIgcGFyZW47XG4vKipcbiAqIFB1c2ggYSBmaWx0ZXIgdG8gdGhlIGN1cnJlbnQgZGlyZWN0aXZlIG9iamVjdFxuICovXG5cbmZ1bmN0aW9uIHB1c2hGaWx0ZXIoKSB7XG4gIHZhciBleHAgPSBzdHIuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCk7XG4gIHZhciBmaWx0ZXI7XG4gIGlmIChleHApIHtcbiAgICBmaWx0ZXIgPSB7fTtcbiAgICB2YXIgdG9rZW5zID0gZXhwLm1hdGNoKGZpbHRlclRva2VuUkUpO1xuICAgIGZpbHRlci5uYW1lID0gdG9rZW5zWzBdO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgZmlsdGVyLmFyZ3MgPSB0b2tlbnMuc2xpY2UoMSkubWFwKHByb2Nlc3NGaWx0ZXJBcmcpO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyKSB7XG4gICAgKGRpci5maWx0ZXJzID0gZGlyLmZpbHRlcnMgfHwgW10pLnB1c2goZmlsdGVyKTtcbiAgfVxuICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhcmd1bWVudCBpcyBkeW5hbWljIGFuZCBzdHJpcCBxdW90ZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIHByb2Nlc3NGaWx0ZXJBcmcoYXJnKSB7XG4gIGlmIChyZXNlcnZlZEFyZ1JFLnRlc3QoYXJnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdG9OdW1iZXIoYXJnKSxcbiAgICAgIGR5bmFtaWM6IGZhbHNlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RyaXBwZWQgPSBzdHJpcFF1b3RlcyhhcmcpO1xuICAgIHZhciBkeW5hbWljID0gc3RyaXBwZWQgPT09IGFyZztcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGR5bmFtaWMgPyBhcmcgOiBzdHJpcHBlZCxcbiAgICAgIGR5bmFtaWM6IGR5bmFtaWNcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBkaXJlY3RpdmUgdmFsdWUgYW5kIGV4dHJhY3QgdGhlIGV4cHJlc3Npb25cbiAqIGFuZCBpdHMgZmlsdGVycyBpbnRvIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIFwiYSArIDEgfCB1cHBlcmNhc2VcIiB3aWxsIHlpZWxkOlxuICoge1xuICogICBleHByZXNzaW9uOiAnYSArIDEnLFxuICogICBmaWx0ZXJzOiBbXG4gKiAgICAgeyBuYW1lOiAndXBwZXJjYXNlJywgYXJnczogbnVsbCB9XG4gKiAgIF1cbiAqIH1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VEaXJlY3RpdmUocykge1xuXG4gIHZhciBoaXQgPSBjYWNoZSQxLmdldChzKTtcbiAgaWYgKGhpdCkge1xuICAgIHJldHVybiBoaXQ7XG4gIH1cblxuICAvLyByZXNldCBwYXJzZXIgc3RhdGVcbiAgc3RyID0gcztcbiAgaW5TaW5nbGUgPSBpbkRvdWJsZSA9IGZhbHNlO1xuICBjdXJseSA9IHNxdWFyZSA9IHBhcmVuID0gMDtcbiAgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgZGlyID0ge307XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAvLyBjaGVjayBzaW5nbGUgcXVvdGVcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gIWluU2luZ2xlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIC8vIGNoZWNrIGRvdWJsZSBxdW90ZVxuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSAhaW5Eb3VibGU7XG4gICAgfSBlbHNlIGlmIChjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICBzdHIuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiYgc3RyLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDKSB7XG4gICAgICBpZiAoZGlyLmV4cHJlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbHJlYWR5IGhhcyBmaWx0ZXJcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOlxuICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTticmVhazsgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OlxuICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTticmVhazsgLy8gJ1xuICAgICAgICBjYXNlIDB4Mjg6XG4gICAgICAgICAgcGFyZW4rKzticmVhazsgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgcGFyZW4tLTticmVhazsgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6XG4gICAgICAgICAgc3F1YXJlKys7YnJlYWs7IC8vIFtcbiAgICAgICAgY2FzZSAweDVEOlxuICAgICAgICAgIHNxdWFyZS0tO2JyZWFrOyAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjpcbiAgICAgICAgICBjdXJseSsrO2JyZWFrOyAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDpcbiAgICAgICAgICBjdXJseS0tO2JyZWFrOyAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpci5leHByZXNzaW9uID09IG51bGwpIHtcbiAgICBkaXIuZXhwcmVzc2lvbiA9IHN0ci5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgY2FjaGUkMS5wdXQocywgZGlyKTtcbiAgcmV0dXJuIGRpcjtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IE9iamVjdC5mcmVlemUoe1xuICBwYXJzZURpcmVjdGl2ZTogcGFyc2VEaXJlY3RpdmVcbn0pO1xuXG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG52YXIgY2FjaGUgPSB1bmRlZmluZWQ7XG52YXIgdGFnUkUgPSB1bmRlZmluZWQ7XG52YXIgaHRtbFJFID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc28gaXQgY2FuIGJlIHVzZWQgaW4gYSBSZWdFeHBcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVJlZ2V4KCkge1xuICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy5kZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIGNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLmRlbGltaXRlcnNbMV0pO1xuICB2YXIgdW5zYWZlT3BlbiA9IGVzY2FwZVJlZ2V4KGNvbmZpZy51bnNhZmVEZWxpbWl0ZXJzWzBdKTtcbiAgdmFyIHVuc2FmZUNsb3NlID0gZXNjYXBlUmVnZXgoY29uZmlnLnVuc2FmZURlbGltaXRlcnNbMV0pO1xuICB0YWdSRSA9IG5ldyBSZWdFeHAodW5zYWZlT3BlbiArICcoLis/KScgKyB1bnNhZmVDbG9zZSArICd8JyArIG9wZW4gKyAnKC4rPyknICsgY2xvc2UsICdnJyk7XG4gIGh0bWxSRSA9IG5ldyBSZWdFeHAoJ14nICsgdW5zYWZlT3BlbiArICcuKicgKyB1bnNhZmVDbG9zZSArICckJyk7XG4gIC8vIHJlc2V0IGNhY2hlXG4gIGNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgdGVtcGxhdGUgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD4gfCBudWxsfVxuICogICAgICAgICAgICAgICAtIHtTdHJpbmd9IHR5cGVcbiAqICAgICAgICAgICAgICAgLSB7U3RyaW5nfSB2YWx1ZVxuICogICAgICAgICAgICAgICAtIHtCb29sZWFufSBbaHRtbF1cbiAqICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gW29uZVRpbWVdXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNvbXBpbGVSZWdleCgpO1xuICB9XG4gIHZhciBoaXQgPSBjYWNoZS5nZXQodGV4dCk7XG4gIGlmIChoaXQpIHtcbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9nLCAnJyk7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXgsIGh0bWwsIHZhbHVlLCBmaXJzdCwgb25lVGltZTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkge1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB2YWx1ZTogdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIGh0bWwgPSBodG1sUkUudGVzdChtYXRjaFswXSk7XG4gICAgdmFsdWUgPSBodG1sID8gbWF0Y2hbMV0gOiBtYXRjaFsyXTtcbiAgICBmaXJzdCA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgb25lVGltZSA9IGZpcnN0ID09PSA0MjsgLy8gKlxuICAgIHZhbHVlID0gb25lVGltZSA/IHZhbHVlLnNsaWNlKDEpIDogdmFsdWU7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdGFnOiB0cnVlLFxuICAgICAgdmFsdWU6IHZhbHVlLnRyaW0oKSxcbiAgICAgIGh0bWw6IGh0bWwsXG4gICAgICBvbmVUaW1lOiBvbmVUaW1lXG4gICAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdmFsdWU6IHRleHQuc2xpY2UobGFzdEluZGV4KVxuICAgIH0pO1xuICB9XG4gIGNhY2hlLnB1dCh0ZXh0LCB0b2tlbnMpO1xuICByZXR1cm4gdG9rZW5zO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIGxpc3Qgb2YgdG9rZW5zIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqIGUuZy4gdG9rZW5zIHBhcnNlZCBmcm9tICdhIHt7Yn19IGMnIGNhbiBiZSBzZXJpYWxpemVkXG4gKiBpbnRvIG9uZSBzaW5nbGUgZXhwcmVzc2lvbiBhcyAnXCJhIFwiICsgYiArIFwiIGNcIicuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHRva2Vuc1RvRXhwKHRva2Vucywgdm0pIHtcbiAgaWYgKHRva2Vucy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gZm9ybWF0VG9rZW4odG9rZW4sIHZtKTtcbiAgICB9KS5qb2luKCcrJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdFRva2VuKHRva2Vuc1swXSwgdm0sIHRydWUpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGEgc2luZ2xlIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlblxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZV1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRUb2tlbih0b2tlbiwgdm0sIHNpbmdsZSkge1xuICByZXR1cm4gdG9rZW4udGFnID8gdG9rZW4ub25lVGltZSAmJiB2bSA/ICdcIicgKyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgKyAnXCInIDogaW5saW5lRmlsdGVycyh0b2tlbi52YWx1ZSwgc2luZ2xlKSA6ICdcIicgKyB0b2tlbi52YWx1ZSArICdcIic7XG59XG5cbi8qKlxuICogRm9yIGFuIGF0dHJpYnV0ZSB3aXRoIG11bHRpcGxlIGludGVycG9sYXRpb24gdGFncyxcbiAqIGUuZy4gYXR0cj1cInNvbWUte3t0aGluZyB8IGZpbHRlcn19XCIsIGluIG9yZGVyIHRvIGNvbWJpbmVcbiAqIHRoZSB3aG9sZSB0aGluZyBpbnRvIGEgc2luZ2xlIHdhdGNoYWJsZSBleHByZXNzaW9uLCB3ZVxuICogaGF2ZSB0byBpbmxpbmUgdGhvc2UgZmlsdGVycy4gVGhpcyBmdW5jdGlvbiBkb2VzIGV4YWN0bHlcbiAqIHRoYXQuIFRoaXMgaXMgYSBiaXQgaGFja3kgYnV0IGl0IGF2b2lkcyBoZWF2eSBjaGFuZ2VzXG4gKiB0byBkaXJlY3RpdmUgcGFyc2VyIGFuZCB3YXRjaGVyIG1lY2hhbmlzbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNpbmdsZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnZhciBmaWx0ZXJSRSQxID0gL1tefF1cXHxbXnxdLztcbmZ1bmN0aW9uIGlubGluZUZpbHRlcnMoZXhwLCBzaW5nbGUpIHtcbiAgaWYgKCFmaWx0ZXJSRSQxLnRlc3QoZXhwKSkge1xuICAgIHJldHVybiBzaW5nbGUgPyBleHAgOiAnKCcgKyBleHAgKyAnKSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpciA9IHBhcnNlRGlyZWN0aXZlKGV4cCk7XG4gICAgaWYgKCFkaXIuZmlsdGVycykge1xuICAgICAgcmV0dXJuICcoJyArIGV4cCArICcpJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0aGlzLl9hcHBseUZpbHRlcnMoJyArIGRpci5leHByZXNzaW9uICsgLy8gdmFsdWVcbiAgICAgICcsbnVsbCwnICsgLy8gb2xkVmFsdWUgKG51bGwgZm9yIHJlYWQpXG4gICAgICBKU09OLnN0cmluZ2lmeShkaXIuZmlsdGVycykgKyAvLyBmaWx0ZXIgZGVzY3JpcHRvcnNcbiAgICAgICcsZmFsc2UpJzsgLy8gd3JpdGU/XG4gICAgfVxuICB9XG59XG5cbnZhciB0ZXh0JDEgPSBPYmplY3QuZnJlZXplKHtcbiAgY29tcGlsZVJlZ2V4OiBjb21waWxlUmVnZXgsXG4gIHBhcnNlVGV4dDogcGFyc2VUZXh0LFxuICB0b2tlbnNUb0V4cDogdG9rZW5zVG9FeHBcbn0pO1xuXG52YXIgZGVsaW1pdGVycyA9IFsne3snLCAnfX0nXTtcbnZhciB1bnNhZmVEZWxpbWl0ZXJzID0gWyd7e3snLCAnfX19J107XG5cbnZhciBjb25maWcgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcHJpbnQgZGVidWcgbWVzc2FnZXMuXG4gICAqIEFsc28gZW5hYmxlcyBzdGFjayB0cmFjZSBmb3Igd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cblxuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBhc3luYyByZW5kZXJpbmcuXG4gICAqL1xuXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHdhcm4gYWdhaW5zdCBlcnJvcnMgY2F1Z2h0IHdoZW4gZXZhbHVhdGluZ1xuICAgKiBleHByZXNzaW9ucy5cbiAgICovXG5cbiAgd2FybkV4cHJlc3Npb25FcnJvcnM6IHRydWUsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRvIGhhbmRsZSBmdWxseSBvYmplY3QgcHJvcGVydGllcyB3aGljaFxuICAgKiBhcmUgYWxyZWFkeSBiYWNrZWQgYnkgZ2V0dGVycyBhbmQgc2V0ZXJzLiBEZXBlbmRpbmcgb25cbiAgICogdXNlIGNhc2UgYW5kIGVudmlyb25tZW50LCB0aGlzIG1pZ2h0IGludHJvZHVjZSBub24tbmVnbGlibGVcbiAgICogcGVyZm9ybWFuY2UgcGVuYWx0aWVzLlxuICAgKi9cbiAgY29udmVydEFsbFByb3BlcnRpZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmbGFnIHRvIGluZGljYXRlIHRoZSBkZWxpbWl0ZXJzIGhhdmUgYmVlblxuICAgKiBjaGFuZ2VkLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG5cbiAgX2RlbGltaXRlcnNDaGFuZ2VkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IHR5cGVzIHRoYXQgYSBjb21wb25lbnQgY2FuIG93bi5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cblxuICBfYXNzZXRUeXBlczogWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2VsZW1lbnREaXJlY3RpdmUnLCAnZmlsdGVyJywgJ3RyYW5zaXRpb24nLCAncGFydGlhbCddLFxuXG4gIC8qKlxuICAgKiBwcm9wIGJpbmRpbmcgbW9kZXNcbiAgICovXG5cbiAgX3Byb3BCaW5kaW5nTW9kZXM6IHtcbiAgICBPTkVfV0FZOiAwLFxuICAgIFRXT19XQVk6IDEsXG4gICAgT05FX1RJTUU6IDJcbiAgfSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIGJhdGNoZXIgZmx1c2ggY3ljbGUuXG4gICAqL1xuXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwXG5cbn0sIHtcbiAgZGVsaW1pdGVyczogeyAvKipcbiAgICAgICAgICAgICAgICAgKiBJbnRlcnBvbGF0aW9uIGRlbGltaXRlcnMuIENoYW5naW5nIHRoZXNlIHdvdWxkIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdGV4dCBwYXJzZXIgdG8gcmUtY29tcGlsZSB0aGUgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fVxuICAgICAgICAgICAgICAgICAqL1xuXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVsaW1pdGVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgZGVsaW1pdGVycyA9IHZhbDtcbiAgICAgIGNvbXBpbGVSZWdleCgpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSxcbiAgdW5zYWZlRGVsaW1pdGVyczoge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHVuc2FmZURlbGltaXRlcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIHVuc2FmZURlbGltaXRlcnMgPSB2YWw7XG4gICAgICBjb21waWxlUmVnZXgoKTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgd2FybiA9IHVuZGVmaW5lZDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgZSkge1xuICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50IHx8IGNvbmZpZy5kZWJ1ZykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbVnVlIHdhcm5dOiAnICsgbXNnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcuZGVidWcpIHtcbiAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcignV2FybmluZyBTdGFjayBUcmFjZScpLnN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xufVxuXG4vKipcbiAqIEFwcGVuZCB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZFdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIEluc2VydEJlZm9yZSB3aXRoIHRyYW5zaXRpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZVdpdGhUcmFuc2l0aW9uKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICBhcHBseVRyYW5zaXRpb24oZWwsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldCk7XG4gIH0sIHZtLCBjYik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHdpdGggdHJhbnNpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVXaXRoVHJhbnNpdGlvbihlbCwgdm0sIGNiKSB7XG4gIGFwcGx5VHJhbnNpdGlvbihlbCwgLTEsIGZ1bmN0aW9uICgpIHtcbiAgICByZW1vdmUoZWwpO1xuICB9LCB2bSwgY2IpO1xufVxuXG4vKipcbiAqIEFwcGx5IHRyYW5zaXRpb25zIHdpdGggYW4gb3BlcmF0aW9uIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgMTogZW50ZXJcbiAqICAgICAgICAgICAgICAgICAtMTogbGVhdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wIC0gdGhlIGFjdHVhbCBET00gb3BlcmF0aW9uXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRyYW5zaXRpb24oZWwsIGRpcmVjdGlvbiwgb3AsIHZtLCBjYikge1xuICB2YXIgdHJhbnNpdGlvbiA9IGVsLl9fdl90cmFucztcbiAgaWYgKCF0cmFuc2l0aW9uIHx8XG4gIC8vIHNraXAgaWYgdGhlcmUgYXJlIG5vIGpzIGhvb2tzIGFuZCBDU1MgdHJhbnNpdGlvbiBpc1xuICAvLyBub3Qgc3VwcG9ydGVkXG4gICF0cmFuc2l0aW9uLmhvb2tzICYmICF0cmFuc2l0aW9uRW5kRXZlbnQgfHxcbiAgLy8gc2tpcCB0cmFuc2l0aW9ucyBmb3IgaW5pdGlhbCBjb21waWxlXG4gICF2bS5faXNDb21waWxlZCB8fFxuICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgbWFuaXB1bGF0ZWQgYnkgYSBwYXJlbnQgZGlyZWN0aXZlXG4gIC8vIGR1cmluZyB0aGUgcGFyZW50J3MgY29tcGlsYXRpb24gcGhhc2UsIHNraXAgdGhlXG4gIC8vIGFuaW1hdGlvbi5cbiAgdm0uJHBhcmVudCAmJiAhdm0uJHBhcmVudC5faXNDb21waWxlZCkge1xuICAgIG9wKCk7XG4gICAgaWYgKGNiKSBjYigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYWN0aW9uID0gZGlyZWN0aW9uID4gMCA/ICdlbnRlcicgOiAnbGVhdmUnO1xuICB0cmFuc2l0aW9uW2FjdGlvbl0ob3AsIGNiKTtcbn1cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RvciA9IGVsO1xuICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFlbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAqIE5vdGU6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyBzaG91bGQgd29yayBoZXJlXG4gKiBidXQgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGNvbW1lbnQgbm9kZXMgaW4gcGhhbnRvbWpzLFxuICogbWFraW5nIHVuaXQgdGVzdHMgZGlmZmljdWx0LiBUaGlzIGlzIGZpeGVkIGJ5IGRvaW5nIHRoZVxuICogY29udGFpbnMoKSBjaGVjayBvbiB0aGUgbm9kZSdzIHBhcmVudE5vZGUgaW5zdGVhZCBvZlxuICogdGhlIG5vZGUgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpbkRvYyhub2RlKSB7XG4gIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBwYXJlbnQgPSBub2RlICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIGRvYyA9PT0gbm9kZSB8fCBkb2MgPT09IHBhcmVudCB8fCAhIShwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxICYmIGRvYy5jb250YWlucyhwYXJlbnQpKTtcbn1cblxuLyoqXG4gKiBHZXQgYW5kIHJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gX2F0dHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyKG5vZGUsIF9hdHRyKSB7XG4gIHZhciB2YWwgPSBub2RlLmdldEF0dHJpYnV0ZShfYXR0cik7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShfYXR0cik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBHZXQgYW4gYXR0cmlidXRlIHdpdGggY29sb24gb3Igdi1iaW5kOiBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cblxuZnVuY3Rpb24gZ2V0QmluZEF0dHIobm9kZSwgbmFtZSkge1xuICB2YXIgdmFsID0gZ2V0QXR0cihub2RlLCAnOicgKyBuYW1lKTtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9IGdldEF0dHIobm9kZSwgJ3YtYmluZDonICsgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgcHJlc2VuY2Ugb2YgYSBiaW5kIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmRBdHRyKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUuaGFzQXR0cmlidXRlKG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCc6JyArIG5hbWUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2LWJpbmQ6JyArIG5hbWUpO1xufVxuXG4vKipcbiAqIEluc2VydCBlbCBiZWZvcmUgdGFyZ2V0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBiZWZvcmUoZWwsIHRhcmdldCkge1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldCk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGVsIGFmdGVyIHRhcmdldFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gYWZ0ZXIoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgYmVmb3JlKGVsLCB0YXJnZXQubmV4dFNpYmxpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBlbCBmcm9tIERPTVxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmUoZWwpIHtcbiAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG59XG5cbi8qKlxuICogUHJlcGVuZCBlbCB0byB0YXJnZXRcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICovXG5cbmZ1bmN0aW9uIHByZXBlbmQoZWwsIHRhcmdldCkge1xuICBpZiAodGFyZ2V0LmZpcnN0Q2hpbGQpIHtcbiAgICBiZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG59XG5cbi8qKlxuICogUmVwbGFjZSB0YXJnZXQgd2l0aCBlbFxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKi9cblxuZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIGVsKSB7XG4gIHZhciBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWwsIHRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXIgc2hvcnRoYW5kLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqL1xuXG5mdW5jdGlvbiBvbiQxKGVsLCBldmVudCwgY2IpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2IpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lciBzaG9ydGhhbmQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbmZ1bmN0aW9uIG9mZihlbCwgZXZlbnQsIGNiKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiKTtcbn1cblxuLyoqXG4gKiBJbiBJRTksIHNldEF0dHJpYnV0ZSgnY2xhc3MnKSB3aWxsIHJlc3VsdCBpbiBlbXB0eSBjbGFzc1xuICogaWYgdGhlIGVsZW1lbnQgYWxzbyBoYXMgdGhlIDpjbGFzcyBhdHRyaWJ1dGU7IEhvd2V2ZXIgaW5cbiAqIFBoYW50b21KUywgc2V0dGluZyBgY2xhc3NOYW1lYCBkb2VzIG5vdCB3b3JrIG9uIFNWRyBlbGVtZW50cy4uLlxuICogU28gd2UgaGF2ZSB0byBkbyBhIGNvbmRpdGlvbmFsIGNoZWNrIGhlcmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IGNsc1xuICovXG5cbmZ1bmN0aW9uIHNldENsYXNzKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiAhKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkpIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbHM7XG4gIH0gZWxzZSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBJRSAmIFNWR1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbHNcbiAqL1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgJyAnO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgc2V0Q2xhc3MoZWwsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgSUUgJiBTVkdcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xzXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNscykge1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArICcgJztcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgc2V0Q2xhc3MoZWwsIGN1ci50cmltKCkpO1xuICB9XG4gIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCByYXcgY29udGVudCBpbnNpZGUgYW4gZWxlbWVudCBpbnRvIGEgdGVtcG9yYXJ5XG4gKiBjb250YWluZXIgZGl2XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtCb29sZWFufSBhc0ZyYWdtZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50KGVsLCBhc0ZyYWdtZW50KSB7XG4gIHZhciBjaGlsZDtcbiAgdmFyIHJhd0NvbnRlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNUZW1wbGF0ZShlbCkgJiYgZWwuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBlbCA9IGVsLmNvbnRlbnQ7XG4gIH1cbiAgaWYgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgIHRyaW1Ob2RlKGVsKTtcbiAgICByYXdDb250ZW50ID0gYXNGcmFnbWVudCA/IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG4gICAgd2hpbGUgKGNoaWxkID0gZWwuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgcmF3Q29udGVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByYXdDb250ZW50O1xufVxuXG4vKipcbiAqIFRyaW0gcG9zc2libGUgZW1wdHkgaGVhZC90YWlsIHRleHROb2RlcyBpbnNpZGUgYSBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKi9cblxuZnVuY3Rpb24gdHJpbU5vZGUobm9kZSkge1xuICB0cmltKG5vZGUsIG5vZGUuZmlyc3RDaGlsZCk7XG4gIHRyaW0obm9kZSwgbm9kZS5sYXN0Q2hpbGQpO1xufVxuXG5mdW5jdGlvbiB0cmltKHBhcmVudCwgbm9kZSkge1xuICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzICYmICFub2RlLmRhdGEudHJpbSgpKSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIHRlbXBsYXRlIHRhZy5cbiAqIE5vdGUgaWYgdGhlIHRlbXBsYXRlIGFwcGVhcnMgaW5zaWRlIGFuIFNWRyBpdHMgdGFnTmFtZVxuICogd2lsbCBiZSBpbiBsb3dlcmNhc2UuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICovXG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGUoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZ05hbWUgJiYgZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBcImFuY2hvclwiIGZvciBwZXJmb3JtaW5nIGRvbSBpbnNlcnRpb24vcmVtb3ZhbHMuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2Ygc2NlbmFyaW9zOlxuICogLSBmcmFnbWVudCBpbnN0YW5jZVxuICogLSB2LWh0bWxcbiAqIC0gdi1pZlxuICogLSB2LWZvclxuICogLSBjb21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtCb29sZWFufSBwZXJzaXN0IC0gSUUgdHJhc2hlcyBlbXB0eSB0ZXh0Tm9kZXMgb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lTm9kZSh0cnVlKSwgc28gaW4gY2VydGFpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZXMgdGhlIGFuY2hvciBuZWVkcyB0byBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uLWVtcHR5IHRvIGJlIHBlcnNpc3RlZCBpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLlxuICogQHJldHVybiB7Q29tbWVudHxUZXh0fVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuY2hvcihjb250ZW50LCBwZXJzaXN0KSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuZGVidWcgPyBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGVyc2lzdCA/ICcgJyA6ICcnKTtcbiAgYW5jaG9yLl9fdnVlX2FuY2hvciA9IHRydWU7XG4gIHJldHVybiBhbmNob3I7XG59XG5cbi8qKlxuICogRmluZCBhIGNvbXBvbmVudCByZWYgYXR0cmlidXRlIHRoYXQgc3RhcnRzIHdpdGggJC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge1N0cmluZ3x1bmRlZmluZWR9XG4gKi9cblxudmFyIHJlZlJFID0gL152LXJlZjovO1xuXG5mdW5jdGlvbiBmaW5kUmVmKG5vZGUpIHtcbiAgaWYgKG5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgdmFyIGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAocmVmUkUudGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gY2FtZWxpemUobmFtZS5yZXBsYWNlKHJlZlJFLCAnJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcCBhIGZ1bmN0aW9uIHRvIGEgcmFuZ2Ugb2Ygbm9kZXMgLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtOb2RlfSBlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wXG4gKi9cblxuZnVuY3Rpb24gbWFwTm9kZVJhbmdlKG5vZGUsIGVuZCwgb3ApIHtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlIChub2RlICE9PSBlbmQpIHtcbiAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBvcChub2RlKTtcbiAgICBub2RlID0gbmV4dDtcbiAgfVxuICBvcChlbmQpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHJhbmdlIG9mIG5vZGVzIHdpdGggdHJhbnNpdGlvbiwgc3RvcmVcbiAqIHRoZSBub2RlcyBpbiBhIGZyYWdtZW50IHdpdGggY29ycmVjdCBvcmRlcmluZyxcbiAqIGFuZCBjYWxsIGNhbGxiYWNrIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge05vZGV9IGVuZFxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZVJhbmdlKHN0YXJ0LCBlbmQsIHZtLCBmcmFnLCBjYikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVtb3ZlZCA9IDA7XG4gIHZhciBub2RlcyA9IFtdO1xuICBtYXBOb2RlUmFuZ2Uoc3RhcnQsIGVuZCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gZW5kKSBkb25lID0gdHJ1ZTtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgIHJlbW92ZVdpdGhUcmFuc2l0aW9uKG5vZGUsIHZtLCBvblJlbW92ZWQpO1xuICB9KTtcbiAgZnVuY3Rpb24gb25SZW1vdmVkKCkge1xuICAgIHJlbW92ZWQrKztcbiAgICBpZiAoZG9uZSAmJiByZW1vdmVkID49IG5vZGVzLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNiICYmIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBjb21tb25UYWdSRSA9IC9eKGRpdnxwfHNwYW58aW1nfGF8YnxpfGJyfHVsfG9sfGxpfGgxfGgyfGgzfGg0fGg1fGg2fGNvZGV8cHJlfHRhYmxlfHRofHRkfHRyfGZvcm18bGFiZWx8aW5wdXR8c2VsZWN0fG9wdGlvbnxuYXZ8YXJ0aWNsZXxzZWN0aW9ufGhlYWRlcnxmb290ZXIpJC87XG52YXIgcmVzZXJ2ZWRUYWdSRSA9IC9eKHNsb3R8cGFydGlhbHxjb21wb25lbnQpJC87XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBhIGNvbXBvbmVudCwgaWYgeWVzIHJldHVybiBpdHNcbiAqIGNvbXBvbmVudCBpZC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudEF0dHIoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc0F0dHJzID0gZWwuaGFzQXR0cmlidXRlcygpO1xuICBpZiAoIWNvbW1vblRhZ1JFLnRlc3QodGFnKSAmJiAhcmVzZXJ2ZWRUYWdSRS50ZXN0KHRhZykpIHtcbiAgICBpZiAocmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkge1xuICAgICAgcmV0dXJuIHsgaWQ6IHRhZyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXMgPSBoYXNBdHRycyAmJiBnZXRJc0JpbmRpbmcoZWwpO1xuICAgICAgaWYgKGlzKSB7XG4gICAgICAgIHJldHVybiBpcztcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xIHx8IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgLy8gQ2hyb21lIHJldHVybnMgdW5rbm93biBmb3Igc2V2ZXJhbCBIVE1MNSBlbGVtZW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU0MDUyNlxuICAgICAgICAhL14oZGF0YXx0aW1lfHJ0Y3xyYikkLy50ZXN0KHRhZykpIHtcbiAgICAgICAgICB3YXJuKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICsgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc0F0dHJzKSB7XG4gICAgcmV0dXJuIGdldElzQmluZGluZyhlbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgXCJpc1wiIGJpbmRpbmcgZnJvbSBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0SXNCaW5kaW5nKGVsKSB7XG4gIC8vIGR5bmFtaWMgc3ludGF4XG4gIHZhciBleHAgPSBnZXRBdHRyKGVsLCAnaXMnKTtcbiAgaWYgKGV4cCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgaWQ6IGV4cCB9O1xuICB9IGVsc2Uge1xuICAgIGV4cCA9IGdldEJpbmRBdHRyKGVsLCAnaXMnKTtcbiAgICBpZiAoZXhwICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7IGlkOiBleHAsIGR5bmFtaWM6IHRydWUgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wJ3MgaW5pdGlhbCB2YWx1ZSBvbiBhIHZtIGFuZCBpdHMgZGF0YSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gcHJvcC5wYXRoO1xuICB2YWx1ZSA9IGNvZXJjZVByb3AocHJvcCwgdmFsdWUpO1xuICB2bVtrZXldID0gdm0uX2RhdGFba2V5XSA9IGFzc2VydFByb3AocHJvcCwgdmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0UHJvcChwcm9wLCB2YWx1ZSkge1xuICAvLyBpZiBhIHByb3AgaXMgbm90IHByb3ZpZGVkIGFuZCBpcyBub3QgcmVxdWlyZWQsXG4gIC8vIHNraXAgdGhlIGNoZWNrLlxuICBpZiAocHJvcC5yYXcgPT09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgb3B0aW9ucyA9IHByb3Aub3B0aW9ucztcbiAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGU7XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IFN0cmluZykge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ3N0cmluZyc7XG4gICAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gTnVtYmVyKSB7XG4gICAgICBleHBlY3RlZFR5cGUgPSAnbnVtYmVyJztcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICAgIGV4cGVjdGVkVHlwZSA9ICdib29sZWFuJztcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBGdW5jdGlvbikge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gT2JqZWN0KSB7XG4gICAgICBleHBlY3RlZFR5cGUgPSAnb2JqZWN0JztcbiAgICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBBcnJheSkge1xuICAgICAgZXhwZWN0ZWRUeXBlID0gJ2FycmF5JztcbiAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciAnICsgcHJvcC5wYXRoICsgJz1cIicgKyBwcm9wLnJhdyArICdcIi4nICsgJyBFeHBlY3RlZCAnICsgZm9ybWF0VHlwZShleHBlY3RlZFR5cGUpICsgJywgZ290ICcgKyBmb3JtYXRWYWx1ZSh2YWx1ZSkgKyAnLicpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gb3B0aW9ucy52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvci5jYWxsKG51bGwsIHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciAnICsgcHJvcC5wYXRoICsgJz1cIicgKyBwcm9wLnJhdyArICdcIicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGb3JjZSBwYXJzaW5nIHZhbHVlIHdpdGggY29lcmNlIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Kn1cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2VQcm9wKHByb3AsIHZhbHVlKSB7XG4gIHZhciBjb2VyY2UgPSBwcm9wLm9wdGlvbnMuY29lcmNlO1xuICBpZiAoIWNvZXJjZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvLyBjb2VyY2UgaXMgYSBmdW5jdGlvblxuICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VHlwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA/IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zbGljZSgxKSA6ICdjdXN0b20gdHlwZSc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqXG4gKiBBbGwgc3RyYXRlZ3kgZnVuY3Rpb25zIGZvbGxvdyB0aGUgc2FtZSBzaWduYXR1cmU6XG4gKlxuICogQHBhcmFtIHsqfSBwYXJlbnRWYWxcbiAqIEBwYXJhbSB7Kn0gY2hpbGRWYWxcbiAqIEBwYXJhbSB7VnVlfSBbdm1dXG4gKi9cblxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgZm9yIChrZXkgaW4gZnJvbSkge1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh0b1ZhbCkgJiYgaXNPYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICsgJ2RlZmluaXRpb25zLicpO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4oKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKGNoaWxkVmFsLmNhbGwodGhpcyksIHBhcmVudFZhbC5jYWxsKHRoaXMpKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh2bSkgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh2bSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbFxuICovXG5cbnN0cmF0cy5lbCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICBpZiAoIXZtICYmIGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignVGhlIFwiZWxcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgKyAnZGVmaW5pdGlvbnMuJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZXQgPSBjaGlsZFZhbCB8fCBwYXJlbnRWYWw7XG4gIC8vIGludm9rZSB0aGUgZWxlbWVudCBmYWN0b3J5IGlmIHRoaXMgaXMgaW5zdGFuY2UgbWVyZ2VcbiAgcmV0dXJuIHZtICYmIHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgPyByZXQuY2FsbCh2bSkgOiByZXQ7XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5cbnN0cmF0cy5pbml0ID0gc3RyYXRzLmNyZWF0ZWQgPSBzdHJhdHMucmVhZHkgPSBzdHJhdHMuYXR0YWNoZWQgPSBzdHJhdHMuZGV0YWNoZWQgPSBzdHJhdHMuYmVmb3JlQ29tcGlsZSA9IHN0cmF0cy5jb21waWxlZCA9IHN0cmF0cy5iZWZvcmVEZXN0cm95ID0gc3RyYXRzLmRlc3Ryb3llZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG59O1xuXG4vKipcbiAqIDAuMTEgZGVwcmVjYXRpb24gd2FybmluZ1xuICovXG5cbnN0cmF0cy5wYXJhbUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignXCJwYXJhbUF0dHJpYnV0ZXNcIiBvcHRpb24gaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiAwLjEyLiAnICsgJ1VzZSBcInByb3BzXCIgaW5zdGVhZC4nKTtcbn07XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VBc3NldHMocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwpO1xuICByZXR1cm4gY2hpbGRWYWwgPyBleHRlbmQocmVzLCBndWFyZEFycmF5QXNzZXRzKGNoaWxkVmFsKSkgOiByZXM7XG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogRXZlbnRzICYgV2F0Y2hlcnMuXG4gKlxuICogRXZlbnRzICYgd2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cblxuc3RyYXRzLndhdGNoID0gc3RyYXRzLmV2ZW50cyA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnQgPyBwYXJlbnQuY29uY2F0KGNoaWxkKSA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuXG5zdHJhdHMucHJvcHMgPSBzdHJhdHMubWV0aG9kcyA9IHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBwYXJlbnRWYWw7XG4gIGlmICghcGFyZW50VmFsKSByZXR1cm4gY2hpbGRWYWw7XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cblxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSBjb21wb25lbnQgb3B0aW9ucyBnZXQgY29udmVydGVkIHRvIGFjdHVhbFxuICogY29uc3RydWN0b3JzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gZ3VhcmRDb21wb25lbnRzKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5jb21wb25lbnRzID0gZ3VhcmRBcnJheUFzc2V0cyhvcHRpb25zLmNvbXBvbmVudHMpO1xuICAgIHZhciBkZWY7XG4gICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGlkc1tpXTtcbiAgICAgIGlmIChjb21tb25UYWdSRS50ZXN0KGtleSkgfHwgcmVzZXJ2ZWRUYWdSRS50ZXN0KGtleSkpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRlZiA9IGNvbXBvbmVudHNba2V5XTtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlZikpIHtcbiAgICAgICAgY29tcG9uZW50c1trZXldID0gVnVlLmV4dGVuZChkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmZ1bmN0aW9uIGd1YXJkUHJvcHMob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICB2YXIgaSwgdmFsO1xuICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICBvcHRpb25zLnByb3BzID0ge307XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbF0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh2YWwubmFtZSkge1xuICAgICAgICBvcHRpb25zLnByb3BzW3ZhbC5uYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNba2V5c1tpXV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wc1trZXlzW2ldXSA9IHsgdHlwZTogdmFsIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR3VhcmQgYW4gQXJyYXktZm9ybWF0IGFzc2V0cyBvcHRpb24gYW5kIGNvbnZlcnRlZCBpdFxuICogaW50byB0aGUga2V5LXZhbHVlIE9iamVjdCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGFzc2V0c1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGd1YXJkQXJyYXlBc3NldHMoYXNzZXRzKSB7XG4gIGlmIChpc0FycmF5KGFzc2V0cykpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGkgPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBhc3NldDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhc3NldCA9IGFzc2V0c1tpXTtcbiAgICAgIHZhciBpZCA9IHR5cGVvZiBhc3NldCA9PT0gJ2Z1bmN0aW9uJyA/IGFzc2V0Lm9wdGlvbnMgJiYgYXNzZXQub3B0aW9ucy5uYW1lIHx8IGFzc2V0LmlkIDogYXNzZXQubmFtZSB8fCBhc3NldC5pZDtcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdBcnJheS1zeW50YXggYXNzZXRzIG11c3QgcHJvdmlkZSBhIFwibmFtZVwiIG9yIFwiaWRcIiBmaWVsZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1tpZF0gPSBhc3NldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYXNzZXRzO1xufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gKiBAcGFyYW0ge1Z1ZX0gW3ZtXSAtIGlmIHZtIGlzIHByZXNlbnQsIGluZGljYXRlcyB0aGlzIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgIGFuIGluc3RhbnRpYXRpb24gbWVyZ2UuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQsIHZtKSB7XG4gIGd1YXJkQ29tcG9uZW50cyhjaGlsZCk7XG4gIGd1YXJkUHJvcHMoY2hpbGQpO1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQpIHtcbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIHZhciBjYW1lbGl6ZWRJZDtcbiAgcmV0dXJuIGFzc2V0c1tpZF0gfHxcbiAgLy8gY2FtZWxDYXNlIElEXG4gIGFzc2V0c1tjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKV0gfHxcbiAgLy8gUGFzY2FsIENhc2UgSURcbiAgYXNzZXRzW2NhbWVsaXplZElkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FtZWxpemVkSWQuc2xpY2UoMSldO1xufVxuXG4vKipcbiAqIEFzc2VydCBhc3NldCBleGlzdHNcbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRBc3NldCh2YWwsIHR5cGUsIGlkKSB7XG4gIGlmICghdmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZSArICc6ICcgKyBpZCk7XG4gIH1cbn1cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKVxuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5cbjtbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3Vuc2hpZnQnLCAnc3BsaWNlJywgJ3NvcnQnLCAncmV2ZXJzZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IoKSB7XG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCB3aXRoIGEgbmV3IHZhbHVlXG4gKiBhbmQgZW1pdHMgY29ycmVzcG9uZGluZyBldmVudC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHsqfSAtIHJlcGxhY2VkIGVsZW1lbnRcbiAqL1xuXG5kZWYoYXJyYXlQcm90bywgJyRzZXQnLCBmdW5jdGlvbiAkc2V0KGluZGV4LCB2YWwpIHtcbiAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhpcy5sZW5ndGggPSBOdW1iZXIoaW5kZXgpICsgMTtcbiAgfVxuICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEsIHZhbClbMF07XG59KTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIHRoZSBlbGVtZW50IGF0IGdpdmVuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5kZWYoYXJyYXlQcm90bywgJyRyZW1vdmUnLCBmdW5jdGlvbiAkcmVtb3ZlKGl0ZW0pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghdGhpcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLCBpdGVtKTtcbiAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59KTtcblxudmFyIHVpZCQzID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERlcCgpIHtcbiAgdGhpcy5pZCA9IHVpZCQzKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufVxuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuXG4vKipcbiAqIEFkZCBhIGRpcmVjdGl2ZSBzdWJzY3JpYmVyLlxuICpcbiAqIEBwYXJhbSB7RGlyZWN0aXZlfSBzdWJcbiAqL1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZGlyZWN0aXZlIHN1YnNjcmliZXIuXG4gKlxuICogQHBhcmFtIHtEaXJlY3RpdmV9IHN1YlxuICovXG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1Yikge1xuICB0aGlzLnN1YnMuJHJlbW92ZShzdWIpO1xufTtcblxuLyoqXG4gKiBBZGQgc2VsZiBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIHRhcmdldCB3YXRjaGVyLlxuICovXG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbn07XG5cbi8qKlxuICogTm90aWZ5IGFsbCBzdWJzY3JpYmVycyBvZiBhIG5ldyB2YWx1ZS5cbiAqL1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhYmxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRvQXJyYXkodGhpcy5zdWJzKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90byA/IHByb3RvQXVnbWVudCA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBJbnN0YW5jZSBtZXRob2RzXG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jb252ZXJ0KGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqL1xuXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHByb3BlcnR5IGludG8gZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZW1pdFxuICogdGhlIGV2ZW50cyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZC9jaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuT2JzZXJ2ZXIucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgZGVmaW5lUmVhY3RpdmUodGhpcy52YWx1ZSwga2V5LCB2YWwpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gb3duZXIgdm0sIHNvIHRoYXQgd2hlbiAkc2V0LyRkZWxldGUgbXV0YXRpb25zXG4gKiBoYXBwZW4gd2UgY2FuIG5vdGlmeSBvd25lciB2bXMgdG8gcHJveHkgdGhlIGtleXMgYW5kXG4gKiBkaWdlc3QgdGhlIHdhdGNoZXJzLiBUaGlzIGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIG9iamVjdFxuICogaXMgb2JzZXJ2ZWQgYXMgYW4gaW5zdGFuY2UncyByb290ICRkYXRhLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5hZGRWbSA9IGZ1bmN0aW9uICh2bSkge1xuICAodGhpcy52bXMgfHwgKHRoaXMudm1zID0gW10pKS5wdXNoKHZtKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIG93bmVyIHZtLiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBvYmplY3QgaXNcbiAqIHN3YXBwZWQgb3V0IGFzIGFuIGluc3RhbmNlJ3MgJGRhdGEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICovXG5cbk9ic2VydmVyLnByb3RvdHlwZS5yZW1vdmVWbSA9IGZ1bmN0aW9uICh2bSkge1xuICB0aGlzLnZtcy4kcmVtb3ZlKHZtKTtcbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b1xuICovXG5cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCh0YXJnZXQsIHNyYykge1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvXG4gKi9cblxuZnVuY3Rpb24gY29weUF1Z21lbnQodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtWdWV9IFt2bV1cbiAqIEByZXR1cm4ge09ic2VydmVyfHVuZGVmaW5lZH1cbiAqIEBzdGF0aWNcbiAqL1xuXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCB2bSkge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmICgoaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmICF2YWx1ZS5faXNWdWUpIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKG9iICYmIHZtKSB7XG4gICAgb2IuYWRkVm0odm0pO1xuICB9XG4gIHJldHVybiBvYjtcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZShvYmosIGtleSwgdmFsKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIsIHNldHRlcjtcbiAgaWYgKGNvbmZpZy5jb252ZXJ0QWxsUHJvcGVydGllcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgICBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGUgPSB2YWx1ZVtpXTtcbiAgICAgICAgICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlLFxuXHRzZXQ6IHNldCxcblx0ZGVsOiBkZWwsXG5cdGhhc093bjogaGFzT3duLFxuXHRpc0xpdGVyYWw6IGlzTGl0ZXJhbCxcblx0aXNSZXNlcnZlZDogaXNSZXNlcnZlZCxcblx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG5cdHRvTnVtYmVyOiB0b051bWJlcixcblx0dG9Cb29sZWFuOiB0b0Jvb2xlYW4sXG5cdHN0cmlwUXVvdGVzOiBzdHJpcFF1b3Rlcyxcblx0Y2FtZWxpemU6IGNhbWVsaXplLFxuXHRoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcblx0Y2xhc3NpZnk6IGNsYXNzaWZ5LFxuXHRiaW5kOiBiaW5kJDEsXG5cdHRvQXJyYXk6IHRvQXJyYXksXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdGRlZjogZGVmLFxuXHRkZWJvdW5jZTogX2RlYm91bmNlLFxuXHRpbmRleE9mOiBpbmRleE9mLFxuXHRjYW5jZWxsYWJsZTogY2FuY2VsbGFibGUsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGlzQXJyYXk6IGlzQXJyYXksXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdGlzSUU5OiBpc0lFOSxcblx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG5cdGdldCB0cmFuc2l0aW9uUHJvcCAoKSB7IHJldHVybiB0cmFuc2l0aW9uUHJvcDsgfSxcblx0Z2V0IHRyYW5zaXRpb25FbmRFdmVudCAoKSB7IHJldHVybiB0cmFuc2l0aW9uRW5kRXZlbnQ7IH0sXG5cdGdldCBhbmltYXRpb25Qcm9wICgpIHsgcmV0dXJuIGFuaW1hdGlvblByb3A7IH0sXG5cdGdldCBhbmltYXRpb25FbmRFdmVudCAoKSB7IHJldHVybiBhbmltYXRpb25FbmRFdmVudDsgfSxcblx0bmV4dFRpY2s6IG5leHRUaWNrLFxuXHRxdWVyeTogcXVlcnksXG5cdGluRG9jOiBpbkRvYyxcblx0Z2V0QXR0cjogZ2V0QXR0cixcblx0Z2V0QmluZEF0dHI6IGdldEJpbmRBdHRyLFxuXHRoYXNCaW5kQXR0cjogaGFzQmluZEF0dHIsXG5cdGJlZm9yZTogYmVmb3JlLFxuXHRhZnRlcjogYWZ0ZXIsXG5cdHJlbW92ZTogcmVtb3ZlLFxuXHRwcmVwZW5kOiBwcmVwZW5kLFxuXHRyZXBsYWNlOiByZXBsYWNlLFxuXHRvbjogb24kMSxcblx0b2ZmOiBvZmYsXG5cdHNldENsYXNzOiBzZXRDbGFzcyxcblx0YWRkQ2xhc3M6IGFkZENsYXNzLFxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG5cdGV4dHJhY3RDb250ZW50OiBleHRyYWN0Q29udGVudCxcblx0dHJpbU5vZGU6IHRyaW1Ob2RlLFxuXHRpc1RlbXBsYXRlOiBpc1RlbXBsYXRlLFxuXHRjcmVhdGVBbmNob3I6IGNyZWF0ZUFuY2hvcixcblx0ZmluZFJlZjogZmluZFJlZixcblx0bWFwTm9kZVJhbmdlOiBtYXBOb2RlUmFuZ2UsXG5cdHJlbW92ZU5vZGVSYW5nZTogcmVtb3ZlTm9kZVJhbmdlLFxuXHRtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcblx0cmVzb2x2ZUFzc2V0OiByZXNvbHZlQXNzZXQsXG5cdGFzc2VydEFzc2V0OiBhc3NlcnRBc3NldCxcblx0Y2hlY2tDb21wb25lbnRBdHRyOiBjaGVja0NvbXBvbmVudEF0dHIsXG5cdGluaXRQcm9wOiBpbml0UHJvcCxcblx0YXNzZXJ0UHJvcDogYXNzZXJ0UHJvcCxcblx0Y29lcmNlUHJvcDogY29lcmNlUHJvcCxcblx0Y29tbW9uVGFnUkU6IGNvbW1vblRhZ1JFLFxuXHRyZXNlcnZlZFRhZ1JFOiByZXNlcnZlZFRhZ1JFLFxuXHRnZXQgd2FybiAoKSB7IHJldHVybiB3YXJuOyB9XG59KTtcblxudmFyIHVpZCA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIGluaXQgc2VxdWVuY2UuIFRoaXMgaXMgY2FsbGVkIGZvciBldmVyeVxuICAgKiBpbnN0YW5jZSwgaW5jbHVkaW5nIG9uZXMgdGhhdCBhcmUgY3JlYXRlZCBmcm9tIGV4dGVuZGVkXG4gICAqIGNvbnN0cnVjdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB0aGlzIG9wdGlvbnMgb2JqZWN0IHNob3VsZCBiZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSByZXN1bHQgb2YgbWVyZ2luZyBjbGFzc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYW5kIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgICB0aGlzLiRwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLiRyb290ID0gdGhpcy4kcGFyZW50ID8gdGhpcy4kcGFyZW50LiRyb290IDogdGhpcztcbiAgICB0aGlzLiRjaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuJHJlZnMgPSB7fTsgLy8gY2hpbGQgdm0gcmVmZXJlbmNlc1xuICAgIHRoaXMuJGVscyA9IHt9OyAvLyBlbGVtZW50IHJlZmVyZW5jZXNcbiAgICB0aGlzLl93YXRjaGVycyA9IFtdOyAvLyBhbGwgd2F0Y2hlcnMgYXMgYW4gYXJyYXlcbiAgICB0aGlzLl9kaXJlY3RpdmVzID0gW107IC8vIGFsbCBkaXJlY3RpdmVzXG5cbiAgICAvLyBhIHVpZFxuICAgIHRoaXMuX3VpZCA9IHVpZCsrO1xuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB0aGlzLl9pc1Z1ZSA9IHRydWU7XG5cbiAgICAvLyBldmVudHMgYm9va2tlZXBpbmdcbiAgICB0aGlzLl9ldmVudHMgPSB7fTsgLy8gcmVnaXN0ZXJlZCBjYWxsYmFja3NcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IHt9OyAvLyBmb3IgJGJyb2FkY2FzdCBvcHRpbWl6YXRpb25cblxuICAgIC8vIGZyYWdtZW50IGluc3RhbmNlIHByb3BlcnRpZXNcbiAgICB0aGlzLl9pc0ZyYWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhZ21lbnQgPSAvLyBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gLy8gQHR5cGUge1RleHR8Q29tbWVudH1cbiAgICB0aGlzLl9mcmFnbWVudEVuZCA9IG51bGw7IC8vIEB0eXBlIHtUZXh0fENvbW1lbnR9XG5cbiAgICAvLyBsaWZlY3ljbGUgc3RhdGVcbiAgICB0aGlzLl9pc0NvbXBpbGVkID0gdGhpcy5faXNEZXN0cm95ZWQgPSB0aGlzLl9pc1JlYWR5ID0gdGhpcy5faXNBdHRhY2hlZCA9IHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl91bmxpbmtGbiA9IG51bGw7XG5cbiAgICAvLyBjb250ZXh0OlxuICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAvLyB3aWxsIGJlIHRoZSBjb21tb24gcGFyZW50IHZtIG9mIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBhbmQgaXRzIGhvc3QuXG4gICAgdGhpcy5fY29udGV4dCA9IG9wdGlvbnMuX2NvbnRleHQgfHwgdGhpcy4kcGFyZW50O1xuXG4gICAgLy8gc2NvcGU6XG4gICAgLy8gaWYgdGhpcyBpcyBpbnNpZGUgYW4gaW5saW5lIHYtZm9yLCB0aGUgc2NvcGVcbiAgICAvLyB3aWxsIGJlIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgY3JlYXRlZCBmb3IgdGhpc1xuICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgLy8gYW5kIGNvbnRhaW5lciBkaXJlY3RpdmVzLlxuICAgIHRoaXMuX3Njb3BlID0gb3B0aW9ucy5fc2NvcGU7XG5cbiAgICAvLyBmcmFnbWVudDpcbiAgICAvLyBpZiB0aGlzIGluc3RhbmNlIGlzIGNvbXBpbGVkIGluc2lkZSBhIEZyYWdtZW50LCBpdFxuICAgIC8vIG5lZWRzIHRvIHJlaWdzdGVyIGl0c2VsZiBhcyBhIGNoaWxkIG9mIHRoYXQgZnJhZ21lbnRcbiAgICAvLyBmb3IgYXR0YWNoL2RldGFjaCB0byB3b3JrIHByb3Blcmx5LlxuICAgIHRoaXMuX2ZyYWcgPSBvcHRpb25zLl9mcmFnO1xuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBzZWxmIGludG8gcGFyZW50IC8gdHJhbnNjbHVzaW9uIGhvc3RcbiAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICB0aGlzLiRwYXJlbnQuJGNoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucy5cbiAgICBvcHRpb25zID0gdGhpcy4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gc2V0IHJlZlxuICAgIHRoaXMuX3VwZGF0ZVJlZigpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIGFzIGVtcHR5IG9iamVjdC5cbiAgICAvLyBpdCB3aWxsIGJlIGZpbGxlZCB1cCBpbiBfaW5pdFNjb3BlKCkuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgLy8gY2FsbCBpbml0IGhvb2tcbiAgICB0aGlzLl9jYWxsSG9vaygnaW5pdCcpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9ic2VydmF0aW9uIGFuZCBzY29wZSBpbmhlcml0YW5jZS5cbiAgICB0aGlzLl9pbml0U3RhdGUoKTtcblxuICAgIC8vIHNldHVwIGV2ZW50IHN5c3RlbSBhbmQgb3B0aW9uIGV2ZW50cy5cbiAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG5cbiAgICAvLyBjYWxsIGNyZWF0ZWQgaG9va1xuICAgIHRoaXMuX2NhbGxIb29rKCdjcmVhdGVkJyk7XG5cbiAgICAvLyBpZiBgZWxgIG9wdGlvbiBpcyBwYXNzZWQsIHN0YXJ0IGNvbXBpbGF0aW9uLlxuICAgIGlmIChvcHRpb25zLmVsKSB7XG4gICAgICB0aGlzLiRtb3VudChvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwYXRoQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG5cbi8vIGFjdGlvbnNcbnZhciBBUFBFTkQgPSAwO1xudmFyIFBVU0ggPSAxO1xudmFyIElOQ19TVUJfUEFUSF9ERVBUSCA9IDI7XG52YXIgUFVTSF9TVUJfUEFUSCA9IDM7XG5cbi8vIHN0YXRlc1xudmFyIEJFRk9SRV9QQVRIID0gMDtcbnZhciBJTl9QQVRIID0gMTtcbnZhciBCRUZPUkVfSURFTlQgPSAyO1xudmFyIElOX0lERU5UID0gMztcbnZhciBJTl9TVUJfUEFUSCA9IDQ7XG52YXIgSU5fU0lOR0xFX1FVT1RFID0gNTtcbnZhciBJTl9ET1VCTEVfUVVPVEUgPSA2O1xudmFyIEFGVEVSX1BBVEggPSA3O1xudmFyIEVSUk9SID0gODtcblxudmFyIHBhdGhTdGF0ZU1hY2hpbmUgPSBbXTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfUEFUSF0gPSB7XG4gICd3cyc6IFtCRUZPUkVfUEFUSF0sXG4gICdpZGVudCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEhdLFxuICAnZW9mJzogW0FGVEVSX1BBVEhdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1BBVEhdID0ge1xuICAnd3MnOiBbSU5fUEFUSF0sXG4gICcuJzogW0JFRk9SRV9JREVOVF0sXG4gICdbJzogW0lOX1NVQl9QQVRIXSxcbiAgJ2VvZic6IFtBRlRFUl9QQVRIXVxufTtcblxucGF0aFN0YXRlTWFjaGluZVtCRUZPUkVfSURFTlRdID0ge1xuICAnd3MnOiBbQkVGT1JFX0lERU5UXSxcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0lERU5UXSA9IHtcbiAgJ2lkZW50JzogW0lOX0lERU5ULCBBUFBFTkRdLFxuICAnMCc6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ251bWJlcic6IFtJTl9JREVOVCwgQVBQRU5EXSxcbiAgJ3dzJzogW0lOX1BBVEgsIFBVU0hdLFxuICAnLic6IFtCRUZPUkVfSURFTlQsIFBVU0hdLFxuICAnWyc6IFtJTl9TVUJfUEFUSCwgUFVTSF0sXG4gICdlb2YnOiBbQUZURVJfUEFUSCwgUFVTSF1cbn07XG5cbnBhdGhTdGF0ZU1hY2hpbmVbSU5fU1VCX1BBVEhdID0ge1xuICBcIidcIjogW0lOX1NJTkdMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1wiJzogW0lOX0RPVUJMRV9RVU9URSwgQVBQRU5EXSxcbiAgJ1snOiBbSU5fU1VCX1BBVEgsIElOQ19TVUJfUEFUSF9ERVBUSF0sXG4gICddJzogW0lOX1BBVEgsIFBVU0hfU1VCX1BBVEhdLFxuICAnZW9mJzogRVJST1IsXG4gICdlbHNlJzogW0lOX1NVQl9QQVRILCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX1NJTkdMRV9RVU9URV0gPSB7XG4gIFwiJ1wiOiBbSU5fU1VCX1BBVEgsIEFQUEVORF0sXG4gICdlb2YnOiBFUlJPUixcbiAgJ2Vsc2UnOiBbSU5fU0lOR0xFX1FVT1RFLCBBUFBFTkRdXG59O1xuXG5wYXRoU3RhdGVNYWNoaW5lW0lOX0RPVUJMRV9RVU9URV0gPSB7XG4gICdcIic6IFtJTl9TVUJfUEFUSCwgQVBQRU5EXSxcbiAgJ2VvZic6IEVSUk9SLFxuICAnZWxzZSc6IFtJTl9ET1VCTEVfUVVPVEUsIEFQUEVORF1cbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgY2hhcmFjdGVyIGluIGEga2V5cGF0aC5cbiAqXG4gKiBAcGFyYW0ge0NoYXJ9IGNoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoQ2hhclR5cGUoY2gpIHtcbiAgaWYgKGNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ2VvZic7XG4gIH1cblxuICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDVCOiAvLyBbXG4gICAgY2FzZSAweDVEOiAvLyBdXG4gICAgY2FzZSAweDJFOiAvLyAuXG4gICAgY2FzZSAweDIyOiAvLyBcIlxuICAgIGNhc2UgMHgyNzogLy8gJ1xuICAgIGNhc2UgMHgzMDpcbiAgICAgIC8vIDBcbiAgICAgIHJldHVybiBjaDtcblxuICAgIGNhc2UgMHg1RjogLy8gX1xuICAgIGNhc2UgMHgyNDpcbiAgICAgIC8vICRcbiAgICAgIHJldHVybiAnaWRlbnQnO1xuXG4gICAgY2FzZSAweDIwOiAvLyBTcGFjZVxuICAgIGNhc2UgMHgwOTogLy8gVGFiXG4gICAgY2FzZSAweDBBOiAvLyBOZXdsaW5lXG4gICAgY2FzZSAweDBEOiAvLyBSZXR1cm5cbiAgICBjYXNlIDB4QTA6IC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgY2FzZSAweEZFRkY6IC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgIGNhc2UgMHgyMDI4OiAvLyBMaW5lIFNlcGFyYXRvclxuICAgIGNhc2UgMHgyMDI5OlxuICAgICAgLy8gUGFyYWdyYXBoIFNlcGFyYXRvclxuICAgICAgcmV0dXJuICd3cyc7XG4gIH1cblxuICAvLyBhLXosIEEtWlxuICBpZiAoY29kZSA+PSAweDYxICYmIGNvZGUgPD0gMHg3QSB8fCBjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVBKSB7XG4gICAgcmV0dXJuICdpZGVudCc7XG4gIH1cblxuICAvLyAxLTlcbiAgaWYgKGNvZGUgPj0gMHgzMSAmJiBjb2RlIDw9IDB4MzkpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICByZXR1cm4gJ2Vsc2UnO1xufVxuXG4vKipcbiAqIEZvcm1hdCBhIHN1YlBhdGgsIHJldHVybiBpdHMgcGxhaW4gZm9ybSBpZiBpdCBpc1xuICogYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuIE90aGVyd2lzZSBwcmVwZW5kIHRoZVxuICogZHluYW1pYyBpbmRpY2F0b3IgKCopLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0U3ViUGF0aChwYXRoKSB7XG4gIHZhciB0cmltbWVkID0gcGF0aC50cmltKCk7XG4gIC8vIGludmFsaWQgbGVhZGluZyAwXG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJzAnICYmIGlzTmFOKHBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0xpdGVyYWwodHJpbW1lZCkgPyBzdHJpcFF1b3Rlcyh0cmltbWVkKSA6ICcqJyArIHRyaW1tZWQ7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgcGF0aCBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciBpbmRleCA9IC0xO1xuICB2YXIgbW9kZSA9IEJFRk9SRV9QQVRIO1xuICB2YXIgc3ViUGF0aERlcHRoID0gMDtcbiAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwO1xuXG4gIHZhciBhY3Rpb25zID0gW107XG5cbiAgYWN0aW9uc1tQVVNIXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBhY3Rpb25zW0FQUEVORF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSBuZXdDaGFyO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgKz0gbmV3Q2hhcjtcbiAgICB9XG4gIH07XG5cbiAgYWN0aW9uc1tJTkNfU1VCX1BBVEhfREVQVEhdID0gZnVuY3Rpb24gKCkge1xuICAgIGFjdGlvbnNbQVBQRU5EXSgpO1xuICAgIHN1YlBhdGhEZXB0aCsrO1xuICB9O1xuXG4gIGFjdGlvbnNbUFVTSF9TVUJfUEFUSF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN1YlBhdGhEZXB0aCA+IDApIHtcbiAgICAgIHN1YlBhdGhEZXB0aC0tO1xuICAgICAgbW9kZSA9IElOX1NVQl9QQVRIO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YlBhdGhEZXB0aCA9IDA7XG4gICAgICBrZXkgPSBmb3JtYXRTdWJQYXRoKGtleSk7XG4gICAgICBpZiAoa2V5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3Rpb25zW1BVU0hdKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlVW5lc2NhcGVRdW90ZSgpIHtcbiAgICB2YXIgbmV4dENoYXIgPSBwYXRoW2luZGV4ICsgMV07XG4gICAgaWYgKG1vZGUgPT09IElOX1NJTkdMRV9RVU9URSAmJiBuZXh0Q2hhciA9PT0gXCInXCIgfHwgbW9kZSA9PT0gSU5fRE9VQkxFX1FVT1RFICYmIG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgbmV3Q2hhciA9ICdcXFxcJyArIG5leHRDaGFyO1xuICAgICAgYWN0aW9uc1tBUFBFTkRdKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobW9kZSAhPSBudWxsKSB7XG4gICAgaW5kZXgrKztcbiAgICBjID0gcGF0aFtpbmRleF07XG5cbiAgICBpZiAoYyA9PT0gJ1xcXFwnICYmIG1heWJlVW5lc2NhcGVRdW90ZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gZ2V0UGF0aENoYXJUeXBlKGMpO1xuICAgIHR5cGVNYXAgPSBwYXRoU3RhdGVNYWNoaW5lW21vZGVdO1xuICAgIHRyYW5zaXRpb24gPSB0eXBlTWFwW3R5cGVdIHx8IHR5cGVNYXBbJ2Vsc2UnXSB8fCBFUlJPUjtcblxuICAgIGlmICh0cmFuc2l0aW9uID09PSBFUlJPUikge1xuICAgICAgcmV0dXJuOyAvLyBwYXJzZSBlcnJvclxuICAgIH1cblxuICAgIG1vZGUgPSB0cmFuc2l0aW9uWzBdO1xuICAgIGFjdGlvbiA9IGFjdGlvbnNbdHJhbnNpdGlvblsxXV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgbmV3Q2hhciA9IHRyYW5zaXRpb25bMl07XG4gICAgICBuZXdDaGFyID0gbmV3Q2hhciA9PT0gdW5kZWZpbmVkID8gYyA6IG5ld0NoYXI7XG4gICAgICBpZiAoYWN0aW9uKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gQUZURVJfUEFUSCkge1xuICAgICAga2V5cy5yYXcgPSBwYXRoO1xuICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXh0ZXJuYWwgcGFyc2UgdGhhdCBjaGVjayBmb3IgYSBjYWNoZSBoaXQgZmlyc3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QXJyYXl8dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBoaXQgPSBwYXRoQ2FjaGUuZ2V0KHBhdGgpO1xuICBpZiAoIWhpdCkge1xuICAgIGhpdCA9IHBhcnNlKHBhdGgpO1xuICAgIGlmIChoaXQpIHtcbiAgICAgIHBhdGhDYWNoZS5wdXQocGF0aCwgaGl0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhpdDtcbn1cblxuLyoqXG4gKiBHZXQgZnJvbSBhbiBvYmplY3QgZnJvbSBhIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXRoKG9iaiwgcGF0aCkge1xuICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKHBhdGgpLmdldChvYmopO1xufVxuXG4vKipcbiAqIFdhcm4gYWdhaW5zdCBzZXR0aW5nIG5vbi1leGlzdGVudCByb290IHBhdGggb24gYSB2bS5cbiAqL1xuXG52YXIgd2Fybk5vbkV4aXN0ZW50O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2Fybk5vbkV4aXN0ZW50ID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB3YXJuKCdZb3UgYXJlIHNldHRpbmcgYSBub24tZXhpc3RlbnQgcGF0aCBcIicgKyBwYXRoLnJhdyArICdcIiAnICsgJ29uIGEgdm0gaW5zdGFuY2UuIENvbnNpZGVyIHByZS1pbml0aWFsaXppbmcgdGhlIHByb3BlcnR5ICcgKyAnd2l0aCB0aGUgXCJkYXRhXCIgb3B0aW9uIGZvciBtb3JlIHJlbGlhYmxlIHJlYWN0aXZpdHkgJyArICdhbmQgYmV0dGVyIHBlcmZvcm1hbmNlLicpO1xuICB9O1xufVxuXG4vKipcbiAqIFNldCBvbiBhbiBvYmplY3QgZnJvbSBhIHBhdGhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBwYXRoXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHNldFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgdmFyIG9yaWdpbmFsID0gb2JqO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhcnNlKHBhdGgpO1xuICB9XG4gIGlmICghcGF0aCB8fCAhaXNPYmplY3Qob2JqKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdCwga2V5O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGFzdCA9IG9iajtcbiAgICBrZXkgPSBwYXRoW2ldO1xuICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnKicpIHtcbiAgICAgIGtleSA9IHBhcnNlRXhwcmVzc2lvbihrZXkuc2xpY2UoMSkpLmdldC5jYWxsKG9yaWdpbmFsLCBvcmlnaW5hbCk7XG4gICAgfVxuICAgIGlmIChpIDwgbCAtIDEpIHtcbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgICAgIG9iaiA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBsYXN0Ll9pc1Z1ZSkge1xuICAgICAgICAgIHdhcm5Ob25FeGlzdGVudChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQobGFzdCwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIG9iai4kc2V0KGtleSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9iai5faXNWdWUpIHtcbiAgICAgICAgICB3YXJuTm9uRXhpc3RlbnQocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KG9iaiwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIHBhdGggPSBPYmplY3QuZnJlZXplKHtcbiAgcGFyc2VQYXRoOiBwYXJzZVBhdGgsXG4gIGdldFBhdGg6IGdldFBhdGgsXG4gIHNldFBhdGg6IHNldFBhdGhcbn0pO1xuXG52YXIgZXhwcmVzc2lvbkNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgYWxsb3dlZEtleXdvcmRzID0gJ01hdGgsRGF0ZSx0aGlzLHRydWUsZmFsc2UsbnVsbCx1bmRlZmluZWQsSW5maW5pdHksTmFOLCcgKyAnaXNOYU4saXNGaW5pdGUsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksJyArICdlbmNvZGVVUklDb21wb25lbnQscGFyc2VJbnQscGFyc2VGbG9hdCc7XG52YXIgYWxsb3dlZEtleXdvcmRzUkUgPSBuZXcgUmVnRXhwKCdeKCcgKyBhbGxvd2VkS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbi8vIGtleXdvcmRzIHRoYXQgZG9uJ3QgbWFrZSBzZW5zZSBpbnNpZGUgZXhwcmVzc2lvbnNcbnZhciBpbXByb3BlcktleXdvcmRzID0gJ2JyZWFrLGNhc2UsY2xhc3MsY2F0Y2gsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCwnICsgJ2RlbGV0ZSxkbyxlbHNlLGV4cG9ydCxleHRlbmRzLGZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLCcgKyAnaW1wb3J0LGluLGluc3RhbmNlb2YsbGV0LHJldHVybixzdXBlcixzd2l0Y2gsdGhyb3csdHJ5LCcgKyAndmFyLHdoaWxlLHdpdGgseWllbGQsZW51bSxhd2FpdCxpbXBsZW1lbnRzLHBhY2thZ2UsJyArICdwcm9jdGVjdGVkLHN0YXRpYyxpbnRlcmZhY2UscHJpdmF0ZSxwdWJsaWMnO1xudmFyIGltcHJvcGVyS2V5d29yZHNSRSA9IG5ldyBSZWdFeHAoJ14oJyArIGltcHJvcGVyS2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8JykgKyAnXFxcXGIpJyk7XG5cbnZhciB3c1JFID0gL1xccy9nO1xudmFyIG5ld2xpbmVSRSA9IC9cXG4vZztcbnZhciBzYXZlUkUgPSAvW1xceyxdXFxzKltcXHdcXCRfXStcXHMqOnwoJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcIil8bmV3IHx0eXBlb2YgfHZvaWQgL2c7XG52YXIgcmVzdG9yZVJFID0gL1wiKFxcZCspXCIvZztcbnZhciBwYXRoVGVzdFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXFxdfFxcW1wiLio/XCJcXF18XFxbXFxkK1xcXXxcXFtbQS1aYS16XyRdW1xcdyRdKlxcXSkqJC87XG52YXIgaWRlbnRSRSA9IC9bXlxcdyRcXC5dKD86W0EtWmEtel8kXVtcXHckXSopL2c7XG52YXIgYm9vbGVhbkxpdGVyYWxSRSA9IC9eKD86dHJ1ZXxmYWxzZSkkLztcblxuLyoqXG4gKiBTYXZlIC8gUmV3cml0ZSAvIFJlc3RvcmVcbiAqXG4gKiBXaGVuIHJld3JpdGluZyBwYXRocyBmb3VuZCBpbiBhbiBleHByZXNzaW9uLCBpdCBpc1xuICogcG9zc2libGUgZm9yIHRoZSBzYW1lIGxldHRlciBzZXF1ZW5jZXMgdG8gYmUgZm91bmQgaW5cbiAqIHN0cmluZ3MgYW5kIE9iamVjdCBsaXRlcmFsIHByb3BlcnR5IGtleXMuIFRoZXJlZm9yZSB3ZVxuICogcmVtb3ZlIGFuZCBzdG9yZSB0aGVzZSBwYXJ0cyBpbiBhIHRlbXBvcmFyeSBhcnJheSwgYW5kXG4gKiByZXN0b3JlIHRoZW0gYWZ0ZXIgdGhlIHBhdGggcmV3cml0ZS5cbiAqL1xuXG52YXIgc2F2ZWQgPSBbXTtcblxuLyoqXG4gKiBTYXZlIHJlcGxhY2VyXG4gKlxuICogVGhlIHNhdmUgcmVnZXggY2FuIG1hdGNoIHR3byBwb3NzaWJsZSBjYXNlczpcbiAqIDEuIEFuIG9wZW5pbmcgb2JqZWN0IGxpdGVyYWxcbiAqIDIuIEEgc3RyaW5nXG4gKiBJZiBtYXRjaGVkIGFzIGEgcGxhaW4gc3RyaW5nLCB3ZSBuZWVkIHRvIGVzY2FwZSBpdHNcbiAqIG5ld2xpbmVzLCBzaW5jZSB0aGUgc3RyaW5nIG5lZWRzIHRvIGJlIHByZXNlcnZlZCB3aGVuXG4gKiBnZW5lcmF0aW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpc1N0cmluZyAtIHN0ciBpZiBtYXRjaGVkIGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gcGxhY2Vob2xkZXIgd2l0aCBpbmRleFxuICovXG5cbmZ1bmN0aW9uIHNhdmUoc3RyLCBpc1N0cmluZykge1xuICB2YXIgaSA9IHNhdmVkLmxlbmd0aDtcbiAgc2F2ZWRbaV0gPSBpc1N0cmluZyA/IHN0ci5yZXBsYWNlKG5ld2xpbmVSRSwgJ1xcXFxuJykgOiBzdHI7XG4gIHJldHVybiAnXCInICsgaSArICdcIic7XG59XG5cbi8qKlxuICogUGF0aCByZXdyaXRlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIHJld3JpdGUocmF3KSB7XG4gIHZhciBjID0gcmF3LmNoYXJBdCgwKTtcbiAgdmFyIHBhdGggPSByYXcuc2xpY2UoMSk7XG4gIGlmIChhbGxvd2VkS2V5d29yZHNSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gcGF0aC5pbmRleE9mKCdcIicpID4gLTEgPyBwYXRoLnJlcGxhY2UocmVzdG9yZVJFLCByZXN0b3JlKSA6IHBhdGg7XG4gICAgcmV0dXJuIGMgKyAnc2NvcGUuJyArIHBhdGg7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXN0b3JlIHJlcGxhY2VyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGkgLSBtYXRjaGVkIHNhdmUgaW5kZXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlKHN0ciwgaSkge1xuICByZXR1cm4gc2F2ZWRbaV07XG59XG5cbi8qKlxuICogUmV3cml0ZSBhbiBleHByZXNzaW9uLCBwcmVmaXhpbmcgYWxsIHBhdGggYWNjZXNzb3JzIHdpdGhcbiAqIGBzY29wZS5gIGFuZCBnZW5lcmF0ZSBnZXR0ZXIvc2V0dGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlR2V0dGVyKGV4cCkge1xuICBpZiAoaW1wcm9wZXJLZXl3b3Jkc1JFLnRlc3QoZXhwKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignQXZvaWQgdXNpbmcgcmVzZXJ2ZWQga2V5d29yZHMgaW4gZXhwcmVzc2lvbjogJyArIGV4cCk7XG4gIH1cbiAgLy8gcmVzZXQgc3RhdGVcbiAgc2F2ZWQubGVuZ3RoID0gMDtcbiAgLy8gc2F2ZSBzdHJpbmdzIGFuZCBvYmplY3QgbGl0ZXJhbCBrZXlzXG4gIHZhciBib2R5ID0gZXhwLnJlcGxhY2Uoc2F2ZVJFLCBzYXZlKS5yZXBsYWNlKHdzUkUsICcnKTtcbiAgLy8gcmV3cml0ZSBhbGwgcGF0aHNcbiAgLy8gcGFkIDEgc3BhY2UgaGVyZSBiZWNhdWUgdGhlIHJlZ2V4IG1hdGNoZXMgMSBleHRyYSBjaGFyXG4gIGJvZHkgPSAoJyAnICsgYm9keSkucmVwbGFjZShpZGVudFJFLCByZXdyaXRlKS5yZXBsYWNlKHJlc3RvcmVSRSwgcmVzdG9yZSk7XG4gIHJldHVybiBtYWtlR2V0dGVyRm4oYm9keSk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBnZXR0ZXIgZnVuY3Rpb24uIFJlcXVpcmVzIGV2YWwuXG4gKlxuICogV2UgaXNvbGF0ZSB0aGUgdHJ5L2NhdGNoIHNvIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZVxuICogb3B0aW1pemF0aW9uIG9mIHRoZSBwYXJzZSBmdW5jdGlvbiB3aGVuIGl0IGlzIG5vdCBjYWxsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJvZHlcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlR2V0dGVyRm4oYm9keSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3Njb3BlJywgJ3JldHVybiAnICsgYm9keSArICc7Jyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0ludmFsaWQgZXhwcmVzc2lvbi4gJyArICdHZW5lcmF0ZWQgZnVuY3Rpb24gYm9keTogJyArIGJvZHkpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHNldHRlciBmdW5jdGlvbiBmb3IgdGhlIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVTZXR0ZXIoZXhwKSB7XG4gIHZhciBwYXRoID0gcGFyc2VQYXRoKGV4cCk7XG4gIGlmIChwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY29wZSwgdmFsKSB7XG4gICAgICBzZXRQYXRoKHNjb3BlLCBwYXRoLCB2YWwpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJbnZhbGlkIHNldHRlciBleHByZXNzaW9uOiAnICsgZXhwKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gaW50byByZS13cml0dGVuIGdldHRlci9zZXR0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVlZFNldFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGV4cCwgbmVlZFNldCkge1xuICBleHAgPSBleHAudHJpbSgpO1xuICAvLyB0cnkgY2FjaGVcbiAgdmFyIGhpdCA9IGV4cHJlc3Npb25DYWNoZS5nZXQoZXhwKTtcbiAgaWYgKGhpdCkge1xuICAgIGlmIChuZWVkU2V0ICYmICFoaXQuc2V0KSB7XG4gICAgICBoaXQuc2V0ID0gY29tcGlsZVNldHRlcihoaXQuZXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuICB2YXIgcmVzID0geyBleHA6IGV4cCB9O1xuICByZXMuZ2V0ID0gaXNTaW1wbGVQYXRoKGV4cCkgJiYgZXhwLmluZGV4T2YoJ1snKSA8IDBcbiAgLy8gb3B0aW1pemVkIHN1cGVyIHNpbXBsZSBnZXR0ZXJcbiAgPyBtYWtlR2V0dGVyRm4oJ3Njb3BlLicgKyBleHApXG4gIC8vIGR5bmFtaWMgZ2V0dGVyXG4gIDogY29tcGlsZUdldHRlcihleHApO1xuICBpZiAobmVlZFNldCkge1xuICAgIHJlcy5zZXQgPSBjb21waWxlU2V0dGVyKGV4cCk7XG4gIH1cbiAgZXhwcmVzc2lvbkNhY2hlLnB1dChleHAsIHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIHNpbXBsZSBwYXRoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gaXNTaW1wbGVQYXRoKGV4cCkge1xuICByZXR1cm4gcGF0aFRlc3RSRS50ZXN0KGV4cCkgJiZcbiAgLy8gZG9uJ3QgdHJlYXQgdHJ1ZS9mYWxzZSBhcyBwYXRoc1xuICAhYm9vbGVhbkxpdGVyYWxSRS50ZXN0KGV4cCkgJiZcbiAgLy8gTWF0aCBjb25zdGFudHMgZS5nLiBNYXRoLlBJLCBNYXRoLkUgZXRjLlxuICBleHAuc2xpY2UoMCwgNSkgIT09ICdNYXRoLic7XG59XG5cbnZhciBleHByZXNzaW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHBhcnNlRXhwcmVzc2lvbjogcGFyc2VFeHByZXNzaW9uLFxuICBpc1NpbXBsZVBhdGg6IGlzU2ltcGxlUGF0aFxufSk7XG5cbi8vIHdlIGhhdmUgdHdvIHNlcGFyYXRlIHF1ZXVlczogb25lIGZvciBkaXJlY3RpdmUgdXBkYXRlc1xuLy8gYW5kIG9uZSBmb3IgdXNlciB3YXRjaGVyIHJlZ2lzdGVyZWQgdmlhICR3YXRjaCgpLlxuLy8gd2Ugd2FudCB0byBndWFyYW50ZWUgZGlyZWN0aXZlIHVwZGF0ZXMgdG8gYmUgY2FsbGVkXG4vLyBiZWZvcmUgdXNlciB3YXRjaGVycyBzbyB0aGF0IHdoZW4gdXNlciB3YXRjaGVycyBhcmVcbi8vIHRyaWdnZXJlZCwgdGhlIERPTSB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiBpbiB1cGRhdGVkXG4vLyBzdGF0ZS5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIHVzZXJRdWV1ZSA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGludGVybmFsUXVldWVEZXBsZXRlZCA9IGZhbHNlO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBiYXRjaGVyJ3Mgc3RhdGUuXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRCYXRjaGVyU3RhdGUoKSB7XG4gIHF1ZXVlID0gW107XG4gIHVzZXJRdWV1ZSA9IFtdO1xuICBoYXMgPSB7fTtcbiAgY2lyY3VsYXIgPSB7fTtcbiAgd2FpdGluZyA9IGludGVybmFsUXVldWVEZXBsZXRlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5cbmZ1bmN0aW9uIGZsdXNoQmF0Y2hlclF1ZXVlKCkge1xuICBydW5CYXRjaGVyUXVldWUocXVldWUpO1xuICBpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgPSB0cnVlO1xuICBydW5CYXRjaGVyUXVldWUodXNlclF1ZXVlKTtcbiAgLy8gZGV2IHRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fKSB7XG4gICAgICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgfVxuICByZXNldEJhdGNoZXJTdGF0ZSgpO1xufVxuXG4vKipcbiAqIFJ1biB0aGUgd2F0Y2hlcnMgaW4gYSBzaW5nbGUgcXVldWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcXVldWVcbiAqL1xuXG5mdW5jdGlvbiBydW5CYXRjaGVyUXVldWUocXVldWUpIHtcbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICBxdWV1ZS5zcGxpY2UoaGFzW2lkXSwgMSk7XG4gICAgICAgIHdhcm4oJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCBmb3Igd2F0Y2hlciAnICsgJ3dpdGggZXhwcmVzc2lvbjogJyArIHdhdGNoZXIuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKlxuICogQHBhcmFtIHtXYXRjaGVyfSB3YXRjaGVyXG4gKiAgIHByb3BlcnRpZXM6XG4gKiAgIC0ge051bWJlcn0gaWRcbiAqICAgLSB7RnVuY3Rpb259IHJ1blxuICovXG5cbmZ1bmN0aW9uIHB1c2hXYXRjaGVyKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIC8vIGlmIGFuIGludGVybmFsIHdhdGNoZXIgaXMgcHVzaGVkLCBidXQgdGhlIGludGVybmFsXG4gICAgLy8gcXVldWUgaXMgYWxyZWFkeSBkZXBsZXRlZCwgd2UgcnVuIGl0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChpbnRlcm5hbFF1ZXVlRGVwbGV0ZWQgJiYgIXdhdGNoZXIudXNlcikge1xuICAgICAgd2F0Y2hlci5ydW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gcHVzaCB3YXRjaGVyIGludG8gYXBwcm9wcmlhdGUgcXVldWVcbiAgICB2YXIgcSA9IHdhdGNoZXIudXNlciA/IHVzZXJRdWV1ZSA6IHF1ZXVlO1xuICAgIGhhc1tpZF0gPSBxLmxlbmd0aDtcbiAgICBxLnB1c2god2F0Y2hlcik7XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoQmF0Y2hlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgICAgICAgICAgICAgICAtIHtBcnJheX0gZmlsdGVyc1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHR3b1dheVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAqICAgICAgICAgICAgICAgICAtIHtCb29sZWFufSB1c2VyXG4gKiAgICAgICAgICAgICAgICAgLSB7Qm9vbGVhbn0gc3luY1xuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxhenlcbiAqICAgICAgICAgICAgICAgICAtIHtGdW5jdGlvbn0gW3ByZVByb2Nlc3NdXG4gKiAgICAgICAgICAgICAgICAgLSB7RnVuY3Rpb259IFtwb3N0UHJvY2Vzc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucykge1xuICAvLyBtaXggaW4gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIGV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICB2YXIgaXNGbiA9IHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nO1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBpc0ZuID8gZXhwT3JGbi50b1N0cmluZygpIDogZXhwT3JGbjtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMubmV3RGVwcyA9IG51bGw7XG4gIHRoaXMucHJldkVycm9yID0gbnVsbDsgLy8gZm9yIGFzeW5jIGVycm9yIHN0YWNrc1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXIvc2V0dGVyXG4gIGlmIChpc0ZuKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIHRoaXMuc2V0dGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwT3JGbiwgdGhpcy50d29XYXkpO1xuICAgIHRoaXMuZ2V0dGVyID0gcmVzLmdldDtcbiAgICB0aGlzLnNldHRlciA9IHJlcy5zZXQ7XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XG4gIC8vIHN0YXRlIGZvciBhdm9pZGluZyBmYWxzZSB0cmlnZ2VycyBmb3IgZGVlcCBhbmQgQXJyYXlcbiAgLy8gd2F0Y2hlcnMgZHVyaW5nIHZtLl9kaWdlc3QoKVxuICB0aGlzLnF1ZXVlZCA9IHRoaXMuc2hhbGxvdyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtEZXB9IGRlcFxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwc1tpZF0pIHtcbiAgICB0aGlzLm5ld0RlcHNbaWRdID0gZGVwO1xuICAgIGlmICghdGhpcy5kZXBzW2lkXSkge1xuICAgICAgdGhpcy5kZXBzW2lkXSA9IGRlcDtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYmVmb3JlR2V0KCk7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgdmFyIHZhbHVlO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbChzY29wZSwgc2NvcGUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLndhcm5FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB3YXJuKCdFcnJvciB3aGVuIGV2YWx1YXRpbmcgZXhwcmVzc2lvbiBcIicgKyB0aGlzLmV4cHJlc3Npb24gKyAnXCIuICcgKyAoY29uZmlnLmRlYnVnID8gJycgOiAnVHVybiBvbiBkZWJ1ZyBtb2RlIHRvIHNlZSBzdGFjayB0cmFjZS4nKSwgZSk7XG4gICAgfVxuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodGhpcy5wcmVQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnByZVByb2Nlc3ModmFsdWUpO1xuICB9XG4gIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICB2YWx1ZSA9IHNjb3BlLl9hcHBseUZpbHRlcnModmFsdWUsIG51bGwsIHRoaXMuZmlsdGVycywgZmFsc2UpO1xuICB9XG4gIGlmICh0aGlzLnBvc3RQcm9jZXNzKSB7XG4gICAgdmFsdWUgPSB0aGlzLnBvc3RQcm9jZXNzKHZhbHVlKTtcbiAgfVxuICB0aGlzLmFmdGVyR2V0KCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHdpdGggdGhlIHNldHRlci5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGUgfHwgdGhpcy52bTtcbiAgaWYgKHRoaXMuZmlsdGVycykge1xuICAgIHZhbHVlID0gc2NvcGUuX2FwcGx5RmlsdGVycyh2YWx1ZSwgdGhpcy52YWx1ZSwgdGhpcy5maWx0ZXJzLCB0cnVlKTtcbiAgfVxuICB0cnkge1xuICAgIHRoaXMuc2V0dGVyLmNhbGwoc2NvcGUsIHNjb3BlLCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcud2FybkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHdhcm4oJ0Vycm9yIHdoZW4gZXZhbHVhdGluZyBzZXR0ZXIgXCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiJywgZSk7XG4gICAgfVxuICB9XG4gIC8vIHR3by13YXkgc3luYyBmb3Igdi1mb3IgYWxpYXNcbiAgdmFyIGZvckNvbnRleHQgPSBzY29wZS4kZm9yQ29udGV4dDtcbiAgaWYgKGZvckNvbnRleHQgJiYgZm9yQ29udGV4dC5hbGlhcyA9PT0gdGhpcy5leHByZXNzaW9uKSB7XG4gICAgaWYgKGZvckNvbnRleHQuZmlsdGVycykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHR3by13YXkgYmluZGluZyBvbiAnICsgJ2Egdi1mb3IgYWxpYXMgKCcgKyB0aGlzLmV4cHJlc3Npb24gKyAnKSwgYW5kIHRoZSAnICsgJ3YtZm9yIGhhcyBmaWx0ZXJzLiBUaGlzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkuICcgKyAnRWl0aGVyIHJlbW92ZSB0aGUgZmlsdGVycyBvciB1c2UgYW4gYXJyYXkgb2YgJyArICdvYmplY3RzIGFuZCBiaW5kIHRvIG9iamVjdCBwcm9wZXJ0aWVzIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvckNvbnRleHQuX3dpdGhMb2NrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAgIC8vIG9yaWdpbmFsIGlzIGFuIG9iamVjdFxuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlW3Njb3BlLiRrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JDb250ZXh0LnJhd1ZhbHVlLiRzZXQoc2NvcGUuJGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJlcGFyZSBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5cbldhdGNoZXIucHJvdG90eXBlLmJlZm9yZUdldCA9IGZ1bmN0aW9uICgpIHtcbiAgRGVwLnRhcmdldCA9IHRoaXM7XG4gIHRoaXMubmV3RGVwcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuYWZ0ZXJHZXQgPSBmdW5jdGlvbiAoKSB7XG4gIERlcC50YXJnZXQgPSBudWxsO1xuICB2YXIgaWRzID0gT2JqZWN0LmtleXModGhpcy5kZXBzKTtcbiAgdmFyIGkgPSBpZHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGlkID0gaWRzW2ldO1xuICAgIGlmICghdGhpcy5uZXdEZXBzW2lkXSkge1xuICAgICAgdGhpcy5kZXBzW2lkXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvd1xuICovXG5cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMgfHwgIWNvbmZpZy5hc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgcXVldWVkLCBvbmx5IG92ZXJ3cml0ZSBzaGFsbG93IHdpdGggbm9uLXNoYWxsb3csXG4gICAgLy8gYnV0IG5vdCB0aGUgb3RoZXIgd2F5IGFyb3VuZC5cbiAgICB0aGlzLnNoYWxsb3cgPSB0aGlzLnF1ZXVlZCA/IHNoYWxsb3cgPyB0aGlzLnNoYWxsb3cgOiBmYWxzZSA6ICEhc2hhbGxvdztcbiAgICB0aGlzLnF1ZXVlZCA9IHRydWU7XG4gICAgLy8gcmVjb3JkIGJlZm9yZS1wdXNoIGVycm9yIHN0YWNrIGluIGRlYnVnIG1vZGVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcpIHtcbiAgICAgIHRoaXMucHJldkVycm9yID0gbmV3IEVycm9yKCdbdnVlXSBhc3luYyBzdGFjayB0cmFjZScpO1xuICAgIH1cbiAgICBwdXNoV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXRjaGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgYmF0Y2hlci5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgIC8vIGhhdmUgbXV0YXRlZDsgYnV0IG9ubHkgZG8gc28gaWYgdGhpcyBpcyBhXG4gICAgLy8gbm9uLXNoYWxsb3cgdXBkYXRlIChjYXVzZWQgYnkgYSB2bSBkaWdlc3QpLlxuICAgIChpc09iamVjdCh2YWx1ZSkgfHwgdGhpcy5kZWVwKSAmJiAhdGhpcy5zaGFsbG93KSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gaW4gZGVidWcgKyBhc3luYyBtb2RlLCB3aGVuIGEgd2F0Y2hlciBjYWxsYmFja3NcbiAgICAgIC8vIHRocm93cywgd2UgYWxzbyB0aHJvdyB0aGUgc2F2ZWQgYmVmb3JlLXB1c2ggZXJyb3JcbiAgICAgIC8vIHNvIHRoZSBmdWxsIGNyb3NzLXRpY2sgc3RhY2sgdHJhY2UgaXMgYXZhaWxhYmxlLlxuICAgICAgdmFyIHByZXZFcnJvciA9IHRoaXMucHJldkVycm9yO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcuZGVidWcgJiYgcHJldkVycm9yKSB7XG4gICAgICAgIHRoaXMucHJldkVycm9yID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHByZXZFcnJvcjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5xdWV1ZWQgPSB0aGlzLnNoYWxsb3cgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGF2b2lkIG92ZXJ3cml0aW5nIGFub3RoZXIgd2F0Y2hlciB0aGF0IGlzIGJlaW5nXG4gIC8vIGNvbGxlY3RlZC5cbiAgdmFyIGN1cnJlbnQgPSBEZXAudGFyZ2V0O1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICBEZXAudGFyZ2V0ID0gY3VycmVudDtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cblxuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVwSWRzID0gT2JqZWN0LmtleXModGhpcy5kZXBzKTtcbiAgdmFyIGkgPSBkZXBJZHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcy5kZXBzW2RlcElkc1tpXV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJjcmliZXIgbGlzdC5cbiAqL1xuXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHdlIGNhbiBza2lwIHRoaXMgaWYgdGhlIHZtIGlmIGJlaW5nIGRlc3Ryb3llZFxuICAgIC8vIHdoaWNoIGNhbiBpbXByb3ZlIHRlYXJkb3duIHBlcmZvcm1hbmNlLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgdGhpcy52bS5fd2F0Y2hlcnMuJHJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgdmFyIGRlcElkcyA9IE9iamVjdC5rZXlzKHRoaXMuZGVwcyk7XG4gICAgdmFyIGkgPSBkZXBJZHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tkZXBJZHNbaV1dLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnZtID0gdGhpcy5jYiA9IHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3J1c2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCkge1xuICB2YXIgaSwga2V5cztcbiAgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHRyYXZlcnNlKHZhbFtpXSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB0cmF2ZXJzZSh2YWxba2V5c1tpXV0pO1xuICB9XG59XG5cbnZhciBjbG9hayA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHRoaXMudm0uJG9uY2UoJ3ByZS1ob29rOmNvbXBpbGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd2LWNsb2FrJyk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciByZWYgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LXJlZjonICsgdGhpcy5hcmcgKyAnIG11c3QgYmUgdXNlZCBvbiBhIGNoaWxkICcgKyAnY29tcG9uZW50LiBGb3VuZCBvbiA8JyArIHRoaXMuZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJz4uJyk7XG4gIH1cbn07XG5cbnZhciBPTiA9IDcwMDtcbnZhciBNT0RFTCA9IDgwMDtcbnZhciBCSU5EID0gODUwO1xudmFyIFRSQU5TSVRJT04gPSAxMTAwO1xudmFyIEVMID0gMTUwMDtcbnZhciBDT01QT05FTlQgPSAxNTAwO1xudmFyIFBBUlRJQUwgPSAxNzUwO1xudmFyIEZPUiA9IDIwMDA7XG52YXIgSUYgPSAyMDAwO1xudmFyIFNMT1QgPSAyMTAwO1xuXG52YXIgZWwgPSB7XG5cbiAgcHJpb3JpdHk6IEVMLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmFyZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gY2FtZWxpemUodGhpcy5hcmcpO1xuICAgIHZhciByZWZzID0gKHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pLiRlbHM7XG4gICAgaWYgKGhhc093bihyZWZzLCBpZCkpIHtcbiAgICAgIHJlZnNbaWRdID0gdGhpcy5lbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocmVmcywgaWQsIHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kZWxzO1xuICAgIGlmIChyZWZzW3RoaXMuaWRdID09PSB0aGlzLmVsKSB7XG4gICAgICByZWZzW3RoaXMuaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW1zLSddO1xudmFyIGNhbWVsUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbnZhciBpbXBvcnRhbnRSRSA9IC8haW1wb3J0YW50Oz8kLztcbnZhciBwcm9wQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgdGVzdEVsID0gbnVsbDtcblxudmFyIHN0eWxlID0ge1xuXG4gIGRlZXA6IHRydWUsXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5lbC5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUucmVkdWNlKGV4dGVuZCwge30pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYW5kbGVPYmplY3QodmFsdWUgfHwge30pO1xuICAgIH1cbiAgfSxcblxuICBoYW5kbGVPYmplY3Q6IGZ1bmN0aW9uIGhhbmRsZU9iamVjdCh2YWx1ZSkge1xuICAgIC8vIGNhY2hlIG9iamVjdCBzdHlsZXMgc28gdGhhdCBvbmx5IGNoYW5nZWQgcHJvcHNcbiAgICAvLyBhcmUgYWN0dWFsbHkgdXBkYXRlZC5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlIHx8ICh0aGlzLmNhY2hlID0ge30pO1xuICAgIHZhciBuYW1lLCB2YWw7XG4gICAgZm9yIChuYW1lIGluIGNhY2hlKSB7XG4gICAgICBpZiAoIShuYW1lIGluIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZShuYW1lLCBudWxsKTtcbiAgICAgICAgZGVsZXRlIGNhY2hlW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgIHZhbCA9IHZhbHVlW25hbWVdO1xuICAgICAgaWYgKHZhbCAhPT0gY2FjaGVbbmFtZV0pIHtcbiAgICAgICAgY2FjaGVbbmFtZV0gPSB2YWw7XG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlKG5hbWUsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHByb3AsIHZhbHVlKSB7XG4gICAgcHJvcCA9IG5vcm1hbGl6ZShwcm9wKTtcbiAgICBpZiAoIXByb3ApIHJldHVybjsgLy8gdW5zdXBwb3J0ZWQgcHJvcFxuICAgIC8vIGNhc3QgcG9zc2libGUgbnVtYmVycy9ib29sZWFucyBpbnRvIHN0cmluZ3NcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWUgKz0gJyc7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YXIgaXNJbXBvcnRhbnQgPSBpbXBvcnRhbnRSRS50ZXN0KHZhbHVlKSA/ICdpbXBvcnRhbnQnIDogJyc7XG4gICAgICBpZiAoaXNJbXBvcnRhbnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGltcG9ydGFudFJFLCAnJykudHJpbSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCB2YWx1ZSwgaXNJbXBvcnRhbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIENTUyBwcm9wZXJ0eSBuYW1lLlxuICogLSBjYWNoZSByZXN1bHRcbiAqIC0gYXV0byBwcmVmaXhcbiAqIC0gY2FtZWxDYXNlIC0+IGRhc2gtY2FzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplKHByb3ApIHtcbiAgaWYgKHByb3BDYWNoZVtwcm9wXSkge1xuICAgIHJldHVybiBwcm9wQ2FjaGVbcHJvcF07XG4gIH1cbiAgdmFyIHJlcyA9IHByZWZpeChwcm9wKTtcbiAgcHJvcENhY2hlW3Byb3BdID0gcHJvcENhY2hlW3Jlc10gPSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQXV0byBkZXRlY3QgdGhlIGFwcHJvcHJpYXRlIHByZWZpeCBmb3IgYSBDU1MgcHJvcGVydHkuXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNTIzNjkyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXgocHJvcCkge1xuICBwcm9wID0gaHlwaGVuYXRlKHByb3ApO1xuICB2YXIgY2FtZWwgPSBjYW1lbGl6ZShwcm9wKTtcbiAgdmFyIHVwcGVyID0gY2FtZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbC5zbGljZSgxKTtcbiAgaWYgKCF0ZXN0RWwpIHtcbiAgICB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfVxuICBpZiAoY2FtZWwgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbiAgdmFyIGkgPSBwcmVmaXhlcy5sZW5ndGg7XG4gIHZhciBwcmVmaXhlZDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHByZWZpeGVkID0gY2FtZWxQcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlc1tpXSArIHByb3A7XG4gICAgfVxuICB9XG59XG5cbi8vIHhsaW5rXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbnZhciB4bGlua1JFID0gL154bGluazovO1xuXG4vLyBjaGVjayBmb3IgYXR0cmlidXRlcyB0aGF0IHByb2hpYml0IGludGVycG9sYXRpb25zXG52YXIgZGlzYWxsb3dlZEludGVycEF0dHJSRSA9IC9edi18Xjp8XkB8Xig/OmlzfHRyYW5zaXRpb258dHJhbnNpdGlvbi1tb2RlfGRlYm91bmNlfHRyYWNrLWJ5fHN0YWdnZXJ8ZW50ZXItc3RhZ2dlcnxsZWF2ZS1zdGFnZ2VyKSQvO1xuLy8gdGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYWxzbyBzZXQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzXG4vLyBiZWNhdXNlIHRoZXkgb25seSBhZmZlY3QgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbnZhciBhdHRyV2l0aFByb3BzUkUgPSAvXig/OnZhbHVlfGNoZWNrZWR8c2VsZWN0ZWR8bXV0ZWQpJC87XG5cbi8vIHRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIHNldCBhIGhpZGRlbiBwcm9wZXJ0eSBmb3Jcbi8vIGJpbmRpbmcgdi1tb2RlbCB0byBvYmplY3QgdmFsdWVzXG52YXIgbW9kZWxQcm9wcyA9IHtcbiAgdmFsdWU6ICdfdmFsdWUnLFxuICAndHJ1ZS12YWx1ZSc6ICdfdHJ1ZVZhbHVlJyxcbiAgJ2ZhbHNlLXZhbHVlJzogJ19mYWxzZVZhbHVlJ1xufTtcblxudmFyIGJpbmQgPSB7XG5cbiAgcHJpb3JpdHk6IEJJTkQsXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgLy8gc2hvdWxkIGJlIGRlZXAgd2F0Y2ggb24gb2JqZWN0IG1vZGVcbiAgICBpZiAoIWF0dHIpIHtcbiAgICAgIHRoaXMuZGVlcCA9IHRydWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9uIGJpbmRpbmdzXG4gICAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLmRlc2NyaXB0b3I7XG4gICAgdmFyIHRva2VucyA9IGRlc2NyaXB0b3IuaW50ZXJwO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIC8vIGhhbmRsZSBpbnRlcnBvbGF0aW9ucyB3aXRoIG9uZS10aW1lIHRva2Vuc1xuICAgICAgaWYgKGRlc2NyaXB0b3IuaGFzT25lVGltZSkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSB0b2tlbnNUb0V4cCh0b2tlbnMsIHRoaXMuX3Njb3BlIHx8IHRoaXMudm0pO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IGFsbG93IGJpbmRpbmcgb24gbmF0aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChkaXNhbGxvd2VkSW50ZXJwQXR0clJFLnRlc3QoYXR0cikgfHwgYXR0ciA9PT0gJ25hbWUnICYmICh0YWcgPT09ICdQQVJUSUFMJyB8fCB0YWcgPT09ICdTTE9UJykpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnICsgJ2F0dHJpYnV0ZSBpbnRlcnBvbGF0aW9uIGlzIG5vdCBhbGxvd2VkIGluIFZ1ZS5qcyAnICsgJ2RpcmVjdGl2ZXMgYW5kIHNwZWNpYWwgYXR0cmlidXRlcy4nKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJhdyA9IGF0dHIgKyAnPVwiJyArIGRlc2NyaXB0b3IucmF3ICsgJ1wiOiAnO1xuICAgICAgICAvLyB3YXJuIHNyY1xuICAgICAgICBpZiAoYXR0ciA9PT0gJ3NyYycpIHtcbiAgICAgICAgICB3YXJuKHJhdyArICdpbnRlcnBvbGF0aW9uIGluIFwic3JjXCIgYXR0cmlidXRlIHdpbGwgY2F1c2UgJyArICdhIDQwNCByZXF1ZXN0LiBVc2Ugdi1iaW5kOnNyYyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2FybiBzdHlsZVxuICAgICAgICBpZiAoYXR0ciA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgIHdhcm4ocmF3ICsgJ2ludGVycG9sYXRpb24gaW4gXCJzdHlsZVwiIGF0dHJpYnV0ZSB3aWxsIGNhdXNlICcgKyAndGhlIGF0dHJpYnV0ZSB0byBiZSBkaXNjYXJkZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIuICcgKyAnVXNlIHYtYmluZDpzdHlsZSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXR0ciA9IHRoaXMuYXJnO1xuICAgIGlmICh0aGlzLmFyZykge1xuICAgICAgdGhpcy5oYW5kbGVTaW5nbGUoYXR0ciwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSB8fCB7fSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHNoYXJlIG9iamVjdCBoYW5kbGVyIHdpdGggdi1iaW5kOmNsYXNzXG4gIGhhbmRsZU9iamVjdDogc3R5bGUuaGFuZGxlT2JqZWN0LFxuXG4gIGhhbmRsZVNpbmdsZTogZnVuY3Rpb24gaGFuZGxlU2luZ2xlKGF0dHIsIHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgaW50ZXJwID0gdGhpcy5kZXNjcmlwdG9yLmludGVycDtcbiAgICBpZiAoIWludGVycCAmJiBhdHRyV2l0aFByb3BzUkUudGVzdChhdHRyKSAmJiBhdHRyIGluIGVsKSB7XG4gICAgICBlbFthdHRyXSA9IGF0dHIgPT09ICd2YWx1ZScgPyB2YWx1ZSA9PSBudWxsIC8vIElFOSB3aWxsIHNldCBpbnB1dC52YWx1ZSB0byBcIm51bGxcIiBmb3IgbnVsbC4uLlxuICAgICAgPyAnJyA6IHZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIC8vIHNldCBtb2RlbCBwcm9wc1xuICAgIHZhciBtb2RlbFByb3AgPSBtb2RlbFByb3BzW2F0dHJdO1xuICAgIGlmICghaW50ZXJwICYmIG1vZGVsUHJvcCkge1xuICAgICAgZWxbbW9kZWxQcm9wXSA9IHZhbHVlO1xuICAgICAgLy8gdXBkYXRlIHYtbW9kZWwgaWYgcHJlc2VudFxuICAgICAgdmFyIG1vZGVsID0gZWwuX192X21vZGVsO1xuICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsLmxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGRvIG5vdCBzZXQgdmFsdWUgYXR0cmlidXRlIGZvciB0ZXh0YXJlYVxuICAgIGlmIChhdHRyID09PSAndmFsdWUnICYmIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgLy8gaGFuZGxlIGVkZ2UgY2FzZSAjMTk2MDpcbiAgICAgICAgLy8gY2xhc3MgaW50ZXJwb2xhdGlvbiBzaG91bGQgbm90IG92ZXJ3cml0ZSBWdWUgdHJhbnNpdGlvbiBjbGFzc1xuICAgICAgICBpZiAoZWwuX192X3RyYW5zKSB7XG4gICAgICAgICAgdmFsdWUgKz0gJyAnICsgZWwuX192X3RyYW5zLmlkICsgJy10cmFuc2l0aW9uJztcbiAgICAgICAgfVxuICAgICAgICBzZXRDbGFzcyhlbCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh4bGlua1JFLnRlc3QoYXR0cikpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywgYXR0ciwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gICdkZWxldGUnOiA0NixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MFxufTtcblxuZnVuY3Rpb24ga2V5RmlsdGVyKGhhbmRsZXIsIGtleXMpIHtcbiAgdmFyIGNvZGVzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGFyQ29kZSA9IGtleS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyQ29kZSA+IDQ3ICYmIGNoYXJDb2RlIDwgNTgpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChrZXksIDEwKTtcbiAgICB9XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNoYXJDb2RlID0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDY0ICYmIGNoYXJDb2RlIDwgOTEpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5Q29kZXNba2V5XTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlIYW5kbGVyKGUpIHtcbiAgICBpZiAoY29kZXMuaW5kZXhPZihlLmtleUNvZGUpID4gLTEpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdG9wRmlsdGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0b3BIYW5kbGVyKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRGaWx0ZXIoaGFuZGxlcikge1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEhhbmRsZXIoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuICB9O1xufVxuXG52YXIgb24gPSB7XG5cbiAgYWNjZXB0U3RhdGVtZW50OiB0cnVlLFxuICBwcmlvcml0eTogT04sXG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBkZWFsIHdpdGggaWZyYW1lc1xuICAgIGlmICh0aGlzLmVsLnRhZ05hbWUgPT09ICdJRlJBTUUnICYmIHRoaXMuYXJnICE9PSAnbG9hZCcpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuaWZyYW1lQmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb24kMShzZWxmLmVsLmNvbnRlbnRXaW5kb3csIHNlbGYuYXJnLCBzZWxmLmhhbmRsZXIpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ2xvYWQnLCB0aGlzLmlmcmFtZUJpbmQpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShoYW5kbGVyKSB7XG4gICAgLy8gc3R1YiBhIG5vb3AgZm9yIHYtb24gd2l0aCBubyB2YWx1ZSxcbiAgICAvLyBlLmcuIEBtb3VzZWRvd24ucHJldmVudFxuICAgIGlmICghdGhpcy5kZXNjcmlwdG9yLnJhdykge1xuICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW9uOicgKyB0aGlzLmFyZyArICc9XCInICsgdGhpcy5leHByZXNzaW9uICsgJ1wiIGV4cGVjdHMgYSBmdW5jdGlvbiB2YWx1ZSwgJyArICdnb3QgJyArIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IG1vZGlmaWVyc1xuICAgIGlmICh0aGlzLm1vZGlmaWVycy5zdG9wKSB7XG4gICAgICBoYW5kbGVyID0gc3RvcEZpbHRlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kaWZpZXJzLnByZXZlbnQpIHtcbiAgICAgIGhhbmRsZXIgPSBwcmV2ZW50RmlsdGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBrZXkgZmlsdGVyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGlmaWVycykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgIT09ICdzdG9wJyAmJiBrZXkgIT09ICdwcmV2ZW50JztcbiAgICB9KTtcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXIgPSBrZXlGaWx0ZXIoaGFuZGxlciwga2V5cyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cbiAgICBpZiAodGhpcy5pZnJhbWVCaW5kKSB7XG4gICAgICB0aGlzLmlmcmFtZUJpbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb24kMSh0aGlzLmVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBlbCA9IHRoaXMuaWZyYW1lQmluZCA/IHRoaXMuZWwuY29udGVudFdpbmRvdyA6IHRoaXMuZWw7XG4gICAgaWYgKHRoaXMuaGFuZGxlcikge1xuICAgICAgb2ZmKGVsLCB0aGlzLmFyZywgdGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG59O1xuXG52YXIgY2hlY2tib3ggPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWwuaGFzT3duUHJvcGVydHkoJ192YWx1ZScpID8gZWwuX3ZhbHVlIDogc2VsZi5wYXJhbXMubnVtYmVyID8gdG9OdW1iZXIoZWwudmFsdWUpIDogZWwudmFsdWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldEJvb2xlYW5WYWx1ZSgpIHtcbiAgICAgIHZhciB2YWwgPSBlbC5jaGVja2VkO1xuICAgICAgaWYgKHZhbCAmJiBlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIHJldHVybiBlbC5fdHJ1ZVZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWwgJiYgZWwuaGFzT3duUHJvcGVydHkoJ19mYWxzZVZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl9mYWxzZVZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1vZGVsID0gc2VsZi5fd2F0Y2hlci52YWx1ZTtcbiAgICAgIGlmIChpc0FycmF5KG1vZGVsKSkge1xuICAgICAgICB2YXIgdmFsID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoZWwuY2hlY2tlZCkge1xuICAgICAgICAgIGlmIChpbmRleE9mKG1vZGVsLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgbW9kZWwucHVzaCh2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbC4kcmVtb3ZlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2V0KGdldEJvb2xlYW5WYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICB0aGlzLmFmdGVyQmluZCA9IHRoaXMubGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVsLmNoZWNrZWQgPSBpbmRleE9mKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpID4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3RydWVWYWx1ZScpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBlbC5fdHJ1ZVZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNlbGVjdCA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgLy8gbWV0aG9kIHRvIGZvcmNlIHVwZGF0ZSBET00gdXNpbmcgbGF0ZXN0IHZhbHVlLlxuICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fd2F0Y2hlcikge1xuICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLmdldCgpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIG11bHRpcGxlIHNlbGVjdFxuICAgIHZhciBtdWx0aXBsZSA9IHRoaXMubXVsdGlwbGUgPSBlbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJyk7XG5cbiAgICAvLyBhdHRhY2ggbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoZWwsIG11bHRpcGxlKTtcbiAgICAgIHZhbHVlID0gc2VsZi5wYXJhbXMubnVtYmVyID8gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodG9OdW1iZXIpIDogdG9OdW1iZXIodmFsdWUpIDogdmFsdWU7XG4gICAgICBzZWxmLnNldCh2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLmxpc3RlbmVyKTtcblxuICAgIC8vIGlmIGhhcyBpbml0aWFsIHZhbHVlLCBzZXQgYWZ0ZXJCaW5kXG4gICAgdmFyIGluaXRWYWx1ZSA9IGdldFZhbHVlKGVsLCBtdWx0aXBsZSwgdHJ1ZSk7XG4gICAgaWYgKG11bHRpcGxlICYmIGluaXRWYWx1ZS5sZW5ndGggfHwgIW11bHRpcGxlICYmIGluaXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5hZnRlckJpbmQgPSB0aGlzLmxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8vIEFsbCBtYWpvciBicm93c2VycyBleGNlcHQgRmlyZWZveCByZXNldHNcbiAgICAvLyBzZWxlY3RlZEluZGV4IHdpdGggdmFsdWUgLTEgdG8gMCB3aGVuIHRoZSBlbGVtZW50XG4gICAgLy8gaXMgYXBwZW5kZWQgdG8gYSBuZXcgcGFyZW50LCB0aGVyZWZvcmUgd2UgaGF2ZSB0b1xuICAgIC8vIGZvcmNlIGEgRE9NIHVwZGF0ZSB3aGVuZXZlciB0aGF0IGhhcHBlbnMuLi5cbiAgICB0aGlzLnZtLiRvbignaG9vazphdHRhY2hlZCcsIHRoaXMuZm9yY2VVcGRhdGUpO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgdmFyIG11bHRpID0gdGhpcy5tdWx0aXBsZSAmJiBpc0FycmF5KHZhbHVlKTtcbiAgICB2YXIgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gICAgdmFyIGkgPSBvcHRpb25zLmxlbmd0aDtcbiAgICB2YXIgb3AsIHZhbDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBvcCA9IG9wdGlvbnNbaV07XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuICAgICAgb3Auc2VsZWN0ZWQgPSBtdWx0aSA/IGluZGV4T2YkMSh2YWx1ZSwgdmFsKSA+IC0xIDogbG9vc2VFcXVhbCh2YWx1ZSwgdmFsKTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhpcy52bS4kb2ZmKCdob29rOmF0dGFjaGVkJywgdGhpcy5mb3JjZVVwZGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHNlbGVjdCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U2VsZWN0RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbXVsdGlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QXJyYXl8Kn1cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShlbCwgbXVsdGksIGluaXQpIHtcbiAgdmFyIHJlcyA9IG11bHRpID8gW10gOiBudWxsO1xuICB2YXIgb3AsIHZhbCwgc2VsZWN0ZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcCA9IGVsLm9wdGlvbnNbaV07XG4gICAgc2VsZWN0ZWQgPSBpbml0ID8gb3AuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpIDogb3Auc2VsZWN0ZWQ7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB2YWwgPSBvcC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykgPyBvcC5fdmFsdWUgOiBvcC52YWx1ZTtcbiAgICAgIGlmIChtdWx0aSkge1xuICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBOYXRpdmUgQXJyYXkuaW5kZXhPZiB1c2VzIHN0cmljdCBlcXVhbCwgYnV0IGluIHRoaXNcbiAqIGNhc2Ugd2UgbmVlZCB0byBtYXRjaCBzdHJpbmcvbnVtYmVycyB3aXRoIGN1c3RvbSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhPZiQxKGFyciwgdmFsKSB7XG4gIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxudmFyIHJhZGlvID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdmFsdWUgb3ZlcndyaXRlIHZpYSB2LWJpbmQ6dmFsdWVcbiAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eSgnX3ZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGVsLl92YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBlbC52YWx1ZTtcbiAgICAgIGlmIChzZWxmLnBhcmFtcy5udW1iZXIpIHtcbiAgICAgICAgdmFsID0gdG9OdW1iZXIodmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNldChzZWxmLmdldFZhbHVlKCkpO1xuICAgIH07XG4gICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjaGVja2VkJykpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCB0aGlzLmdldFZhbHVlKCkpO1xuICB9XG59O1xuXG52YXIgdGV4dCQyID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGlzUmFuZ2UgPSBlbC50eXBlID09PSAncmFuZ2UnO1xuICAgIHZhciBsYXp5ID0gdGhpcy5wYXJhbXMubGF6eTtcbiAgICB2YXIgbnVtYmVyID0gdGhpcy5wYXJhbXMubnVtYmVyO1xuICAgIHZhciBkZWJvdW5jZSA9IHRoaXMucGFyYW1zLmRlYm91bmNlO1xuXG4gICAgLy8gaGFuZGxlIGNvbXBvc2l0aW9uIGV2ZW50cy5cbiAgICAvLyAgIGh0dHA6Ly9ibG9nLmV2YW55b3UubWUvMjAxNC8wMS8wMy9jb21wb3NpdGlvbi1ldmVudC9cbiAgICAvLyBza2lwIHRoaXMgZm9yIEFuZHJvaWQgYmVjYXVzZSBpdCBoYW5kbGVzIGNvbXBvc2l0aW9uXG4gICAgLy8gZXZlbnRzIHF1aXRlIGRpZmZlcmVudGx5LiBBbmRyb2lkIGRvZXNuJ3QgdHJpZ2dlclxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyBmb3IgbGFuZ3VhZ2UgaW5wdXQgbWV0aG9kcyBlLmcuXG4gICAgLy8gQ2hpbmVzZSwgYnV0IGluc3RlYWQgdHJpZ2dlcnMgdGhlbSBmb3Igc3BlbGxpbmdcbiAgICAvLyBzdWdnZXN0aW9ucy4uLiAoc2VlIERpc2N1c3Npb24vIzE2MilcbiAgICB2YXIgY29tcG9zaW5nID0gZmFsc2U7XG4gICAgaWYgKCFpc0FuZHJvaWQgJiYgIWlzUmFuZ2UpIHtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBvc2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2NvbXBvc2l0aW9uZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gaW4gSUUxMSB0aGUgXCJjb21wb3NpdGlvbmVuZFwiIGV2ZW50IGZpcmVzIEFGVEVSXG4gICAgICAgIC8vIHRoZSBcImlucHV0XCIgZXZlbnQsIHNvIHRoZSBpbnB1dCBoYW5kbGVyIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gYXQgdGhlIGVuZC4uLiBoYXZlIHRvIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gIzEzMjc6IGluIGxhenkgbW9kZSB0aGlzIGlzIHVuZWNlc3NhcnkuXG4gICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBtZXNzaW5nIHdpdGggdGhlIGlucHV0IHdoZW4gdXNlciBpcyB0eXBpbmcsXG4gICAgLy8gYW5kIGZvcmNlIHVwZGF0ZSBvbiBibHVyLlxuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGlmICghaXNSYW5nZSAmJiAhbGF6eSkge1xuICAgICAgdGhpcy5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvLyBkbyBub3Qgc3luYyB2YWx1ZSBhZnRlciBmcmFnbWVudCByZW1vdmFsICgjMjAxNylcbiAgICAgICAgaWYgKCFzZWxmLl9mcmFnIHx8IHNlbGYuX2ZyYWcuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBzZWxmLnJhd0xpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE5vdyBhdHRhY2ggdGhlIG1haW4gbGlzdGVuZXJcbiAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5yYXdMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb21wb3NpbmcgfHwgIXNlbGYuX2JvdW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBudW1iZXIgfHwgaXNSYW5nZSA/IHRvTnVtYmVyKGVsLnZhbHVlKSA6IGVsLnZhbHVlO1xuICAgICAgc2VsZi5zZXQodmFsKTtcbiAgICAgIC8vIGZvcmNlIHVwZGF0ZSBvbiBuZXh0IHRpY2sgdG8gYXZvaWQgbG9jayAmIHNhbWUgdmFsdWVcbiAgICAgIC8vIGFsc28gb25seSB1cGRhdGUgd2hlbiB1c2VyIGlzIG5vdCB0eXBpbmdcbiAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYuX2JvdW5kICYmICFzZWxmLmZvY3VzZWQpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZShzZWxmLl93YXRjaGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFwcGx5IGRlYm91bmNlXG4gICAgaWYgKGRlYm91bmNlKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyID0gX2RlYm91bmNlKHRoaXMubGlzdGVuZXIsIGRlYm91bmNlKTtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGpRdWVyeSBldmVudHMsIHNpbmNlIGpRdWVyeS50cmlnZ2VyKCkgZG9lc24ndFxuICAgIC8vIHRyaWdnZXIgbmF0aXZlIGV2ZW50cyBpbiBzb21lIGNhc2VzIGFuZCBzb21lIHBsdWdpbnNcbiAgICAvLyByZWx5IG9uICQudHJpZ2dlcigpXG4gICAgLy9cbiAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSBpZiBhIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHVzaW5nXG4gICAgLy8galF1ZXJ5LCBpdCBpcyBhbHNvIHJlbW92ZWQgd2l0aCBqUXVlcnksIHRoYXQncyB3aHlcbiAgICAvLyB3ZSBkbyB0aGUgY2hlY2sgZm9yIGVhY2ggZGlyZWN0aXZlIGluc3RhbmNlIGFuZFxuICAgIC8vIHN0b3JlIHRoYXQgY2hlY2sgcmVzdWx0IG9uIGl0c2VsZi4gVGhpcyBhbHNvIGFsbG93c1xuICAgIC8vIGVhc2llciB0ZXN0IGNvdmVyYWdlIGNvbnRyb2wgYnkgdW5zZXR0aW5nIHRoZSBnbG9iYWxcbiAgICAvLyBqUXVlcnkgdmFyaWFibGUgaW4gdGVzdHMuXG4gICAgdGhpcy5oYXNqUXVlcnkgPSB0eXBlb2YgalF1ZXJ5ID09PSAnZnVuY3Rpb24nO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgalF1ZXJ5KGVsKS5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgalF1ZXJ5KGVsKS5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignY2hhbmdlJywgdGhpcy5saXN0ZW5lcik7XG4gICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgdGhpcy5vbignaW5wdXQnLCB0aGlzLmxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJRTkgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50IG9uIGJhY2tzcGFjZS9kZWwvY3V0XG4gICAgaWYgKCFsYXp5ICYmIGlzSUU5KSB7XG4gICAgICB0aGlzLm9uKCdjdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKHNlbGYubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQ2IHx8IGUua2V5Q29kZSA9PT0gOCkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGluaXRpYWwgdmFsdWUgaWYgcHJlc2VudFxuICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgfHwgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJiBlbC52YWx1ZS50cmltKCkpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kID0gdGhpcy5saXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICB0aGlzLmVsLnZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmICh0aGlzLmhhc2pRdWVyeSkge1xuICAgICAgalF1ZXJ5KGVsKS5vZmYoJ2NoYW5nZScsIHRoaXMubGlzdGVuZXIpO1xuICAgICAgalF1ZXJ5KGVsKS5vZmYoJ2lucHV0JywgdGhpcy5saXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaGFuZGxlcnMgPSB7XG4gIHRleHQ6IHRleHQkMixcbiAgcmFkaW86IHJhZGlvLFxuICBzZWxlY3Q6IHNlbGVjdCxcbiAgY2hlY2tib3g6IGNoZWNrYm94XG59O1xuXG52YXIgbW9kZWwgPSB7XG5cbiAgcHJpb3JpdHk6IE1PREVMLFxuICB0d29XYXk6IHRydWUsXG4gIGhhbmRsZXJzOiBoYW5kbGVycyxcbiAgcGFyYW1zOiBbJ2xhenknLCAnbnVtYmVyJywgJ2RlYm91bmNlJ10sXG5cbiAgLyoqXG4gICAqIFBvc3NpYmxlIGVsZW1lbnRzOlxuICAgKiAgIDxzZWxlY3Q+XG4gICAqICAgPHRleHRhcmVhPlxuICAgKiAgIDxpbnB1dCB0eXBlPVwiKlwiPlxuICAgKiAgICAgLSB0ZXh0XG4gICAqICAgICAtIGNoZWNrYm94XG4gICAqICAgICAtIHJhZGlvXG4gICAqICAgICAtIG51bWJlclxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGZyaWVuZGx5IHdhcm5pbmcuLi5cbiAgICB0aGlzLmNoZWNrRmlsdGVycygpO1xuICAgIGlmICh0aGlzLmhhc1JlYWQgJiYgIXRoaXMuaGFzV3JpdGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyBhIHJlYWQtb25seSBmaWx0ZXIgd2l0aCAnICsgJ3YtbW9kZWwuIFlvdSBtaWdodCB3YW50IHRvIHVzZSBhIHR3by13YXkgZmlsdGVyICcgKyAndG8gZW5zdXJlIGNvcnJlY3QgYmVoYXZpb3IuJyk7XG4gICAgfVxuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWU7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKHRhZyA9PT0gJ0lOUFVUJykge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2VsLnR5cGVdIHx8IGhhbmRsZXJzLnRleHQ7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMuc2VsZWN0O1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICBoYW5kbGVyID0gaGFuZGxlcnMudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZWxlbWVudCB0eXBlOiAnICsgdGFnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWwuX192X21vZGVsID0gdGhpcztcbiAgICBoYW5kbGVyLmJpbmQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZSA9IGhhbmRsZXIudXBkYXRlO1xuICAgIHRoaXMuX3VuYmluZCA9IGhhbmRsZXIudW5iaW5kO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayByZWFkL3dyaXRlIGZpbHRlciBzdGF0cy5cbiAgICovXG5cbiAgY2hlY2tGaWx0ZXJzOiBmdW5jdGlvbiBjaGVja0ZpbHRlcnMoKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XG4gICAgaWYgKCFmaWx0ZXJzKSByZXR1cm47XG4gICAgdmFyIGkgPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZmlsdGVyID0gcmVzb2x2ZUFzc2V0KHRoaXMudm0uJG9wdGlvbnMsICdmaWx0ZXJzJywgZmlsdGVyc1tpXS5uYW1lKTtcbiAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IGZpbHRlci5yZWFkKSB7XG4gICAgICAgIHRoaXMuaGFzUmVhZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLndyaXRlKSB7XG4gICAgICAgIHRoaXMuaGFzV3JpdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmVsLl9fdl9tb2RlbCA9IG51bGw7XG4gICAgdGhpcy5fdW5iaW5kICYmIHRoaXMuX3VuYmluZCgpO1xuICB9XG59O1xuXG52YXIgc2hvdyA9IHtcblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICB2YXIgbmV4dCA9IHRoaXMuZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIGlmIChuZXh0ICYmIGdldEF0dHIobmV4dCwgJ3YtZWxzZScpICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmVsc2VFbCA9IG5leHQ7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgdGhpcy5hcHBseSh0aGlzLmVsLCB2YWx1ZSk7XG4gICAgaWYgKHRoaXMuZWxzZUVsKSB7XG4gICAgICB0aGlzLmFwcGx5KHRoaXMuZWxzZUVsLCAhdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBhcHBseTogZnVuY3Rpb24gYXBwbHkoZWwsIHZhbHVlKSB7XG4gICAgaWYgKGluRG9jKGVsKSkge1xuICAgICAgYXBwbHlUcmFuc2l0aW9uKGVsLCB2YWx1ZSA/IDEgOiAtMSwgdG9nZ2xlLCB0aGlzLnZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9nZ2xlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRlbXBsYXRlQ2FjaGUgPSBuZXcgQ2FjaGUoMTAwMCk7XG52YXIgaWRTZWxlY3RvckNhY2hlID0gbmV3IENhY2hlKDEwMDApO1xuXG52YXIgbWFwID0ge1xuICBlZmF1bHQ6IFswLCAnJywgJyddLFxuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J11cbn07XG5cbm1hcC50ZCA9IG1hcC50aCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG5tYXAub3B0aW9uID0gbWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9IG1hcC50Ym9keSA9IG1hcC5jb2xncm91cCA9IG1hcC5jYXB0aW9uID0gbWFwLnRmb290ID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG5cbm1hcC5nID0gbWFwLmRlZnMgPSBtYXAuc3ltYm9sID0gbWFwLnVzZSA9IG1hcC5pbWFnZSA9IG1hcC50ZXh0ID0gbWFwLmNpcmNsZSA9IG1hcC5lbGxpcHNlID0gbWFwLmxpbmUgPSBtYXAucGF0aCA9IG1hcC5wb2x5Z29uID0gbWFwLnBvbHlsaW5lID0gbWFwLnJlY3QgPSBbMSwgJzxzdmcgJyArICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnICsgJ3htbG5zOmV2PVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS94bWwtZXZlbnRzXCInICsgJ3ZlcnNpb249XCIxLjFcIj4nLCAnPC9zdmc+J107XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgc3VwcG9ydGVkIHRlbXBsYXRlIG5vZGUgd2l0aCBhXG4gKiBEb2N1bWVudEZyYWdtZW50IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzUmVhbFRlbXBsYXRlKG5vZGUpIHtcbiAgcmV0dXJuIGlzVGVtcGxhdGUobm9kZSkgJiYgbm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDtcbn1cblxudmFyIHRhZ1JFJDEgPSAvPChbXFx3Ol0rKS87XG52YXIgZW50aXR5UkUgPSAvJiM/XFx3Kz87LztcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIHRlbXBsYXRlIHRvIGEgRG9jdW1lbnRGcmFnbWVudC5cbiAqIERldGVybWluZXMgY29ycmVjdCB3cmFwcGluZyBieSB0YWcgdHlwZXMuIFdyYXBwaW5nXG4gKiBzdHJhdGVneSBmb3VuZCBpbiBqUXVlcnkgJiBjb21wb25lbnQvZG9taWZ5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZVN0cmluZywgcmF3KSB7XG4gIC8vIHRyeSBhIGNhY2hlIGhpdCBmaXJzdFxuICB2YXIgaGl0ID0gdGVtcGxhdGVDYWNoZS5nZXQodGVtcGxhdGVTdHJpbmcpO1xuICBpZiAoaGl0KSB7XG4gICAgcmV0dXJuIGhpdDtcbiAgfVxuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgdGFnTWF0Y2ggPSB0ZW1wbGF0ZVN0cmluZy5tYXRjaCh0YWdSRSQxKTtcbiAgdmFyIGVudGl0eU1hdGNoID0gZW50aXR5UkUudGVzdCh0ZW1wbGF0ZVN0cmluZyk7XG5cbiAgaWYgKCF0YWdNYXRjaCAmJiAhZW50aXR5TWF0Y2gpIHtcbiAgICAvLyB0ZXh0IG9ubHksIHJldHVybiBhIHNpbmdsZSB0ZXh0IG5vZGUuXG4gICAgZnJhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZW1wbGF0ZVN0cmluZykpO1xuICB9IGVsc2Uge1xuXG4gICAgdmFyIHRhZyA9IHRhZ01hdGNoICYmIHRhZ01hdGNoWzFdO1xuICAgIHZhciB3cmFwID0gbWFwW3RhZ10gfHwgbWFwLmVmYXVsdDtcbiAgICB2YXIgZGVwdGggPSB3cmFwWzBdO1xuICAgIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICAgIHZhciBzdWZmaXggPSB3cmFwWzJdO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICB2YXIgdGVtcGxhdGVTdHJpbmdUb1VzZSA9IHJhdyA/IHRlbXBsYXRlU3RyaW5nIDogdGVtcGxhdGVTdHJpbmcudHJpbSgpO1xuICAgIG5vZGUuaW5uZXJIVE1MID0gcHJlZml4ICsgdGVtcGxhdGVTdHJpbmdUb1VzZSArIHN1ZmZpeDtcbiAgICB3aGlsZSAoZGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cblxuICAgIHZhciBjaGlsZDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgdGVtcGxhdGVDYWNoZS5wdXQodGVtcGxhdGVTdHJpbmcsIGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdGVtcGxhdGUgbm9kZSB0byBhIERvY3VtZW50RnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIG5vZGVUb0ZyYWdtZW50KG5vZGUpIHtcbiAgLy8gaWYgaXRzIGEgdGVtcGxhdGUgdGFnIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBpdCxcbiAgLy8gaXRzIGNvbnRlbnQgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LlxuICBpZiAoaXNSZWFsVGVtcGxhdGUobm9kZSkpIHtcbiAgICB0cmltTm9kZShub2RlLmNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvbnRlbnQ7XG4gIH1cbiAgLy8gc2NyaXB0IHRlbXBsYXRlXG4gIGlmIChub2RlLnRhZ05hbWUgPT09ICdTQ1JJUFQnKSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvRnJhZ21lbnQobm9kZS50ZXh0Q29udGVudCk7XG4gIH1cbiAgLy8gbm9ybWFsIG5vZGUsIGNsb25lIGl0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbFxuICB2YXIgY2xvbmVkTm9kZSA9IGNsb25lTm9kZShub2RlKTtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBjaGlsZDtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cbiAgd2hpbGUgKGNoaWxkID0gY2xvbmVkTm9kZS5maXJzdENoaWxkKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG4gIHRyaW1Ob2RlKGZyYWcpO1xuICByZXR1cm4gZnJhZztcbn1cblxuLy8gVGVzdCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSBTYWZhcmkgdGVtcGxhdGUgY2xvbmluZyBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3d1Zy5jZ2k/aWQ9MTM3NzU1XG52YXIgaGFzQnJva2VuVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBhLmlubmVySFRNTCA9ICc8dGVtcGxhdGU+MTwvdGVtcGxhdGU+JztcbiAgICByZXR1cm4gIWEuY2xvbmVOb2RlKHRydWUpLmZpcnN0Q2hpbGQuaW5uZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gVGVzdCBmb3IgSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBjbG9uZSBidWdcbnZhciBoYXNUZXh0YXJlYUNsb25lQnVnID0gKGZ1bmN0aW9uICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB0LnBsYWNlaG9sZGVyID0gJ3QnO1xuICAgIHJldHVybiB0LmNsb25lTm9kZSh0cnVlKS52YWx1ZSA9PT0gJ3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiAxLiBEZWFsIHdpdGggU2FmYXJpIGNsb25pbmcgbmVzdGVkIDx0ZW1wbGF0ZT4gYnVnIGJ5XG4gKiAgICBtYW51YWxseSBjbG9uaW5nIGFsbCB0ZW1wbGF0ZSBpbnN0YW5jZXMuXG4gKiAyLiBEZWFsIHdpdGggSUUxMC8xMSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWcgYnkgc2V0dGluZ1xuICogICAgdGhlIGNvcnJlY3QgdmFsdWUgYWZ0ZXIgY2xvbmluZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogQHJldHVybiB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fVxuICovXG5cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlKSB7XG4gIGlmICghbm9kZS5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xuICB2YXIgaSwgb3JpZ2luYWwsIGNsb25lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChoYXNCcm9rZW5UZW1wbGF0ZSkge1xuICAgIHZhciB0ZW1wQ2xvbmUgPSByZXM7XG4gICAgaWYgKGlzUmVhbFRlbXBsYXRlKG5vZGUpKSB7XG4gICAgICBub2RlID0gbm9kZS5jb250ZW50O1xuICAgICAgdGVtcENsb25lID0gcmVzLmNvbnRlbnQ7XG4gICAgfVxuICAgIG9yaWdpbmFsID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgIGNsb25lZCA9IHRlbXBDbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCd0ZW1wbGF0ZScpO1xuICAgICAgaSA9IGNsb25lZC5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNsb25lZFtpXS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZU5vZGUob3JpZ2luYWxbaV0pLCBjbG9uZWRbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGhhc1RleHRhcmVhQ2xvbmVCdWcpIHtcbiAgICBpZiAobm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXMudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnaW5hbCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgndGV4dGFyZWEnKTtcbiAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGgpIHtcbiAgICAgICAgY2xvbmVkID0gcmVzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJyk7XG4gICAgICAgIGkgPSBjbG9uZWQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY2xvbmVkW2ldLnZhbHVlID0gb3JpZ2luYWxbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSBvcHRpb24gYW5kIG5vcm1hbGl6ZXMgaXQgaW50byBhXG4gKiBhIERvY3VtZW50RnJhZ21lbnQgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIHBhcnRpYWwgb3IgYVxuICogaW5zdGFuY2UgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHsqfSB0ZW1wbGF0ZVxuICogICAgICAgIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlOlxuICogICAgICAgIC0gRG9jdW1lbnRGcmFnbWVudCBvYmplY3RcbiAqICAgICAgICAtIE5vZGUgb2JqZWN0IG9mIHR5cGUgVGVtcGxhdGVcbiAqICAgICAgICAtIGlkIHNlbGVjdG9yOiAnI3NvbWUtdGVtcGxhdGUtaWQnXG4gKiAgICAgICAgLSB0ZW1wbGF0ZSBzdHJpbmc6ICc8ZGl2PjxzcGFuPnt7bXNnfX08L3NwYW4+PC9kaXY+J1xuICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRDbG9uZVxuICogQHBhcmFtIHtCb29sZWFufSByYXdcbiAqICAgICAgICBpbmxpbmUgSFRNTCBpbnRlcnBvbGF0aW9uLiBEbyBub3QgY2hlY2sgZm9yIGlkXG4gKiAgICAgICAgc2VsZWN0b3IgYW5kIGtlZXAgd2hpdGVzcGFjZSBpbiB0aGUgc3RyaW5nLlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudHx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgc2hvdWxkQ2xvbmUsIHJhdykge1xuICB2YXIgbm9kZSwgZnJhZztcblxuICAvLyBpZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGRvY3VtZW50IGZyYWdtZW50LFxuICAvLyBkbyBub3RoaW5nXG4gIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICB0cmltTm9kZSh0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHNob3VsZENsb25lID8gY2xvbmVOb2RlKHRlbXBsYXRlKSA6IHRlbXBsYXRlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBpZCBzZWxlY3RvclxuICAgIGlmICghcmF3ICYmIHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAvLyBpZCBzZWxlY3RvciBjYW4gYmUgY2FjaGVkIHRvb1xuICAgICAgZnJhZyA9IGlkU2VsZWN0b3JDYWNoZS5nZXQodGVtcGxhdGUpO1xuICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KG5vZGUpO1xuICAgICAgICAgIC8vIHNhdmUgc2VsZWN0b3IgdG8gY2FjaGVcbiAgICAgICAgICBpZFNlbGVjdG9yQ2FjaGUucHV0KHRlbXBsYXRlLCBmcmFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgc3RyaW5nIHRlbXBsYXRlXG4gICAgICBmcmFnID0gc3RyaW5nVG9GcmFnbWVudCh0ZW1wbGF0ZSwgcmF3KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAvLyBhIGRpcmVjdCBub2RlXG4gICAgZnJhZyA9IG5vZGVUb0ZyYWdtZW50KHRlbXBsYXRlKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnICYmIHNob3VsZENsb25lID8gY2xvbmVOb2RlKGZyYWcpIDogZnJhZztcbn1cblxudmFyIHRlbXBsYXRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNsb25lTm9kZTogY2xvbmVOb2RlLFxuICBwYXJzZVRlbXBsYXRlOiBwYXJzZVRlbXBsYXRlXG59KTtcblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBmb3IgYSBwYXJ0aWFsbHktY29tcGlsZWQgZnJhZ21lbnQuXG4gKiBDYW4gb3B0aW9uYWxseSBjb21waWxlIGNvbnRlbnQgd2l0aCBhIGNoaWxkIHNjb3BlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7VnVlfSBbaG9zdF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdXG4gKi9cbmZ1bmN0aW9uIEZyYWdtZW50KGxpbmtlciwgdm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5jaGlsZEZyYWdzID0gW107XG4gIHRoaXMudm0gPSB2bTtcbiAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50RnJhZyA9IHBhcmVudEZyYWc7XG4gIGlmIChwYXJlbnRGcmFnKSB7XG4gICAgcGFyZW50RnJhZy5jaGlsZEZyYWdzLnB1c2godGhpcyk7XG4gIH1cbiAgdGhpcy51bmxpbmsgPSBsaW5rZXIodm0sIGZyYWcsIGhvc3QsIHNjb3BlLCB0aGlzKTtcbiAgdmFyIHNpbmdsZSA9IHRoaXMuc2luZ2xlID0gZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJlxuICAvLyBkbyBub3QgZ28gc2luZ2xlIG1vZGUgaWYgdGhlIG9ubHkgbm9kZSBpcyBhbiBhbmNob3JcbiAgIWZyYWcuY2hpbGROb2Rlc1swXS5fX3Z1ZV9hbmNob3I7XG4gIGlmIChzaW5nbGUpIHtcbiAgICB0aGlzLm5vZGUgPSBmcmFnLmNoaWxkTm9kZXNbMF07XG4gICAgdGhpcy5iZWZvcmUgPSBzaW5nbGVCZWZvcmU7XG4gICAgdGhpcy5yZW1vdmUgPSBzaW5nbGVSZW1vdmU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ub2RlID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1zdGFydCcpO1xuICAgIHRoaXMuZW5kID0gY3JlYXRlQW5jaG9yKCdmcmFnbWVudC1lbmQnKTtcbiAgICB0aGlzLmZyYWcgPSBmcmFnO1xuICAgIHByZXBlbmQodGhpcy5ub2RlLCBmcmFnKTtcbiAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuZW5kKTtcbiAgICB0aGlzLmJlZm9yZSA9IG11bHRpQmVmb3JlO1xuICAgIHRoaXMucmVtb3ZlID0gbXVsdGlSZW1vdmU7XG4gIH1cbiAgdGhpcy5ub2RlLl9fdmZyYWdfXyA9IHRoaXM7XG59XG5cbi8qKlxuICogQ2FsbCBhdHRhY2gvZGV0YWNoIGZvciBhbGwgY29tcG9uZW50cyBjb250YWluZWQgd2l0aGluXG4gKiB0aGlzIGZyYWdtZW50LiBBbHNvIGRvIHNvIHJlY3Vyc2l2ZWx5IGZvciBhbGwgY2hpbGRcbiAqIGZyYWdtZW50cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmNhbGxIb29rID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgdmFyIGksIGw7XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkRnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdGhpcy5jaGlsZEZyYWdzW2ldLmNhbGxIb29rKGhvb2spO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGhvb2sodGhpcy5jaGlsZHJlbltpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIHNpbmdsZSBub2RlIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIHNpbmdsZUJlZm9yZSh0YXJnZXQsIHdpdGhUcmFuc2l0aW9uKSB7XG4gIHRoaXMuaW5zZXJ0ZWQgPSB0cnVlO1xuICB2YXIgbWV0aG9kID0gd2l0aFRyYW5zaXRpb24gIT09IGZhbHNlID8gYmVmb3JlV2l0aFRyYW5zaXRpb24gOiBiZWZvcmU7XG4gIG1ldGhvZCh0aGlzLm5vZGUsIHRhcmdldCwgdGhpcy52bSk7XG4gIGlmIChpbkRvYyh0aGlzLm5vZGUpKSB7XG4gICAgdGhpcy5jYWxsSG9vayhhdHRhY2gpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGZyYWdtZW50LCBzaW5nbGUgbm9kZSB2ZXJzaW9uXG4gKi9cblxuZnVuY3Rpb24gc2luZ2xlUmVtb3ZlKCkge1xuICB0aGlzLmluc2VydGVkID0gZmFsc2U7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmJlZm9yZVJlbW92ZSgpO1xuICByZW1vdmVXaXRoVHJhbnNpdGlvbih0aGlzLm5vZGUsIHRoaXMudm0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2hvdWxkQ2FsbFJlbW92ZSkge1xuICAgICAgc2VsZi5jYWxsSG9vayhkZXRhY2gpO1xuICAgIH1cbiAgICBzZWxmLmRlc3Ryb3koKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5zZXJ0IGZyYWdtZW50IGJlZm9yZSB0YXJnZXQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvblxuICovXG5cbmZ1bmN0aW9uIG11bHRpQmVmb3JlKHRhcmdldCwgd2l0aFRyYW5zaXRpb24pIHtcbiAgdGhpcy5pbnNlcnRlZCA9IHRydWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHZhciBtZXRob2QgPSB3aXRoVHJhbnNpdGlvbiAhPT0gZmFsc2UgPyBiZWZvcmVXaXRoVHJhbnNpdGlvbiA6IGJlZm9yZTtcbiAgbWFwTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbWV0aG9kKG5vZGUsIHRhcmdldCwgdm0pO1xuICB9KTtcbiAgaWYgKGluRG9jKHRoaXMubm9kZSkpIHtcbiAgICB0aGlzLmNhbGxIb29rKGF0dGFjaCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZnJhZ21lbnQsIG11bHRpLW5vZGVzIHZlcnNpb25cbiAqL1xuXG5mdW5jdGlvbiBtdWx0aVJlbW92ZSgpIHtcbiAgdGhpcy5pbnNlcnRlZCA9IGZhbHNlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzaG91bGRDYWxsUmVtb3ZlID0gaW5Eb2ModGhpcy5ub2RlKTtcbiAgdGhpcy5iZWZvcmVSZW1vdmUoKTtcbiAgcmVtb3ZlTm9kZVJhbmdlKHRoaXMubm9kZSwgdGhpcy5lbmQsIHRoaXMudm0sIHRoaXMuZnJhZywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzaG91bGRDYWxsUmVtb3ZlKSB7XG4gICAgICBzZWxmLmNhbGxIb29rKGRldGFjaCk7XG4gICAgfVxuICAgIHNlbGYuZGVzdHJveSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlIHRoZSBmcmFnbWVudCBmb3IgcmVtb3ZhbC5cbiAqL1xuXG5GcmFnbWVudC5wcm90b3R5cGUuYmVmb3JlUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSwgbDtcbiAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2hpbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBjYWxsIHRoZSBzYW1lIG1ldGhvZCByZWN1cnNpdmVseSBvbiBjaGlsZFxuICAgIC8vIGZyYWdtZW50cywgZGVwdGgtZmlyc3RcbiAgICB0aGlzLmNoaWxkRnJhZ3NbaV0uYmVmb3JlUmVtb3ZlKGZhbHNlKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBDYWxsIGRlc3Ryb3kgZm9yIGFsbCBjb250YWluZWQgaW5zdGFuY2VzLFxuICAgIC8vIHdpdGggcmVtb3ZlOmZhbHNlIGFuZCBkZWZlcjp0cnVlLlxuICAgIC8vIERlZmVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAvLyBrZWVwIHRoZSBjaGlsZHJlbiB0byBjYWxsIGRldGFjaCBob29rc1xuICAgIC8vIG9uIHRoZW0uXG4gICAgdGhpcy5jaGlsZHJlbltpXS4kZGVzdHJveShmYWxzZSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIGRpcnMgPSB0aGlzLnVubGluay5kaXJzO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAvLyBkaXNhYmxlIHRoZSB3YXRjaGVycyBvbiBhbGwgdGhlIGRpcmVjdGl2ZXNcbiAgICAvLyBzbyB0aGF0IHRoZSByZW5kZXJlZCBjb250ZW50IHN0YXlzIHRoZSBzYW1lXG4gICAgLy8gZHVyaW5nIHJlbW92YWwuXG4gICAgZGlyc1tpXS5fd2F0Y2hlciAmJiBkaXJzW2ldLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVzdHJveSB0aGUgZnJhZ21lbnQuXG4gKi9cblxuRnJhZ21lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBhcmVudEZyYWcpIHtcbiAgICB0aGlzLnBhcmVudEZyYWcuY2hpbGRGcmFncy4kcmVtb3ZlKHRoaXMpO1xuICB9XG4gIHRoaXMubm9kZS5fX3ZmcmFnX18gPSBudWxsO1xuICB0aGlzLnVubGluaygpO1xufTtcblxuLyoqXG4gKiBDYWxsIGF0dGFjaCBob29rIGZvciBhIFZ1ZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gY2hpbGRcbiAqL1xuXG5mdW5jdGlvbiBhdHRhY2goY2hpbGQpIHtcbiAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCkge1xuICAgIGNoaWxkLl9jYWxsSG9vaygnYXR0YWNoZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGwgZGV0YWNoIGhvb2sgZm9yIGEgVnVlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICovXG5cbmZ1bmN0aW9uIGRldGFjaChjaGlsZCkge1xuICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQpIHtcbiAgICBjaGlsZC5fY2FsbEhvb2soJ2RldGFjaGVkJyk7XG4gIH1cbn1cblxudmFyIGxpbmtlckNhY2hlID0gbmV3IENhY2hlKDUwMDApO1xuXG4vKipcbiAqIEEgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBpbnN0YW5jZXMgb2YgYVxuICogZnJhZ21lbnQuIENhY2hlcyB0aGUgY29tcGlsZWQgbGlua2VyIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ30gZWxcbiAqL1xuZnVuY3Rpb24gRnJhZ21lbnRGYWN0b3J5KHZtLCBlbCkge1xuICB0aGlzLnZtID0gdm07XG4gIHZhciB0ZW1wbGF0ZTtcbiAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIGVsID09PSAnc3RyaW5nJztcbiAgaWYgKGlzU3RyaW5nIHx8IGlzVGVtcGxhdGUoZWwpKSB7XG4gICAgdGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlKGVsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB0ZW1wbGF0ZS5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAvLyBsaW5rZXIgY2FuIGJlIGNhY2hlZCwgYnV0IG9ubHkgZm9yIGNvbXBvbmVudHNcbiAgdmFyIGxpbmtlcjtcbiAgdmFyIGNpZCA9IHZtLmNvbnN0cnVjdG9yLmNpZDtcbiAgaWYgKGNpZCA+IDApIHtcbiAgICB2YXIgY2FjaGVJZCA9IGNpZCArIChpc1N0cmluZyA/IGVsIDogZWwub3V0ZXJIVE1MKTtcbiAgICBsaW5rZXIgPSBsaW5rZXJDYWNoZS5nZXQoY2FjaGVJZCk7XG4gICAgaWYgKCFsaW5rZXIpIHtcbiAgICAgIGxpbmtlciA9IGNvbXBpbGUodGVtcGxhdGUsIHZtLiRvcHRpb25zLCB0cnVlKTtcbiAgICAgIGxpbmtlckNhY2hlLnB1dChjYWNoZUlkLCBsaW5rZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsaW5rZXIgPSBjb21waWxlKHRlbXBsYXRlLCB2bS4kb3B0aW9ucywgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5saW5rZXIgPSBsaW5rZXI7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnJhZ21lbnQgaW5zdGFuY2Ugd2l0aCBnaXZlbiBob3N0IGFuZCBzY29wZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gaG9zdFxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge0ZyYWdtZW50fSBwYXJlbnRGcmFnXG4gKi9cblxuRnJhZ21lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaG9zdCwgc2NvcGUsIHBhcmVudEZyYWcpIHtcbiAgdmFyIGZyYWcgPSBjbG9uZU5vZGUodGhpcy50ZW1wbGF0ZSk7XG4gIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5saW5rZXIsIHRoaXMudm0sIGZyYWcsIGhvc3QsIHNjb3BlLCBwYXJlbnRGcmFnKTtcbn07XG5cbnZhciB2SWYgPSB7XG5cbiAgcHJpb3JpdHk6IElGLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoIWVsLl9fdnVlX18pIHtcbiAgICAgIC8vIGNoZWNrIGVsc2UgYmxvY2tcbiAgICAgIHZhciBuZXh0ID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgaWYgKG5leHQgJiYgZ2V0QXR0cihuZXh0LCAndi1lbHNlJykgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlKG5leHQpO1xuICAgICAgICB0aGlzLmVsc2VGYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCBuZXh0KTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIG1haW4gYmxvY2tcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWlmJyk7XG4gICAgICByZXBsYWNlKGVsLCB0aGlzLmFuY2hvcik7XG4gICAgICB0aGlzLmZhY3RvcnkgPSBuZXcgRnJhZ21lbnRGYWN0b3J5KHRoaXMudm0sIGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCd2LWlmPVwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiBjYW5ub3QgYmUgJyArICd1c2VkIG9uIGFuIGluc3RhbmNlIHJvb3QgZWxlbWVudC4nKTtcbiAgICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkgcmV0dXJuO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmZyYWcpIHtcbiAgICAgICAgdGhpcy5pbnNlcnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQoKSB7XG4gICAgaWYgKHRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcucmVtb3ZlKCk7XG4gICAgICB0aGlzLmVsc2VGcmFnID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gdGhpcy5mYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgdGhpcy5mcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuZnJhZykge1xuICAgICAgdGhpcy5mcmFnLnJlbW92ZSgpO1xuICAgICAgdGhpcy5mcmFnID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWxzZUZhY3RvcnkgJiYgIXRoaXMuZWxzZUZyYWcpIHtcbiAgICAgIHRoaXMuZWxzZUZyYWcgPSB0aGlzLmVsc2VGYWN0b3J5LmNyZWF0ZSh0aGlzLl9ob3N0LCB0aGlzLl9zY29wZSwgdGhpcy5fZnJhZyk7XG4gICAgICB0aGlzLmVsc2VGcmFnLmJlZm9yZSh0aGlzLmFuY2hvcik7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdWlkJDEgPSAwO1xuXG52YXIgdkZvciA9IHtcblxuICBwcmlvcml0eTogRk9SLFxuXG4gIHBhcmFtczogWyd0cmFjay1ieScsICdzdGFnZ2VyJywgJ2VudGVyLXN0YWdnZXInLCAnbGVhdmUtc3RhZ2dlciddLFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgLy8gc3VwcG9ydCBcIml0ZW0gaW4gaXRlbXNcIiBzeW50YXhcbiAgICB2YXIgaW5NYXRjaCA9IHRoaXMuZXhwcmVzc2lvbi5tYXRjaCgvKC4qKSBpbiAoLiopLyk7XG4gICAgaWYgKGluTWF0Y2gpIHtcbiAgICAgIHZhciBpdE1hdGNoID0gaW5NYXRjaFsxXS5tYXRjaCgvXFwoKC4qKSwoLiopXFwpLyk7XG4gICAgICBpZiAoaXRNYXRjaCkge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpdE1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGluTWF0Y2hbMl07XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmFsaWFzKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0FsaWFzIGlzIHJlcXVpcmVkIGluIHYtZm9yLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVpZCBhcyBhIGNhY2hlIGlkZW50aWZpZXJcbiAgICB0aGlzLmlkID0gJ19fdi1mb3JfXycgKyArK3VpZCQxO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpb24gbGlzdCxcbiAgICAvLyBzbyB0aGF0IHdlIGtub3cgaWYgd2UgbmVlZCB0byB1cGRhdGUgdGhlIDxzZWxlY3Q+J3NcbiAgICAvLyB2LW1vZGVsIHdoZW4gdGhlIG9wdGlvbiBsaXN0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIGJlY2F1c2Ugdi1tb2RlbCBoYXMgYSBsb3dlciBwcmlvcml0eSB0aGFuIHYtZm9yLFxuICAgIC8vIHRoZSB2LW1vZGVsIGlzIG5vdCBib3VuZCBoZXJlIHlldCwgc28gd2UgaGF2ZSB0b1xuICAgIC8vIHJldHJpdmUgaXQgaW4gdGhlIGFjdHVhbCB1cGRhdGVNb2RlbCgpIGZ1bmN0aW9uLlxuICAgIHZhciB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgdGhpcy5pc09wdGlvbiA9ICh0YWcgPT09ICdPUFRJT04nIHx8IHRhZyA9PT0gJ09QVEdST1VQJykgJiYgdGhpcy5lbC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnO1xuXG4gICAgLy8gc2V0dXAgYW5jaG9yIG5vZGVzXG4gICAgdGhpcy5zdGFydCA9IGNyZWF0ZUFuY2hvcigndi1mb3Itc3RhcnQnKTtcbiAgICB0aGlzLmVuZCA9IGNyZWF0ZUFuY2hvcigndi1mb3ItZW5kJyk7XG4gICAgcmVwbGFjZSh0aGlzLmVsLCB0aGlzLmVuZCk7XG4gICAgYmVmb3JlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcblxuICAgIC8vIGNhY2hlXG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBmcmFnbWVudCBmYWN0b3J5XG4gICAgdGhpcy5mYWN0b3J5ID0gbmV3IEZyYWdtZW50RmFjdG9yeSh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5kaWZmKGRhdGEpO1xuICAgIHRoaXMudXBkYXRlUmVmKCk7XG4gICAgdGhpcy51cGRhdGVNb2RlbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaWZmLCBiYXNlZCBvbiBuZXcgZGF0YSBhbmQgb2xkIGRhdGEsIGRldGVybWluZSB0aGVcbiAgICogbWluaW11bSBhbW91bnQgb2YgRE9NIG1hbmlwdWxhdGlvbnMgbmVlZGVkIHRvIG1ha2UgdGhlXG4gICAqIERPTSByZWZsZWN0IHRoZSBuZXcgZGF0YSBBcnJheS5cbiAgICpcbiAgICogVGhlIGFsZ29yaXRobSBkaWZmcyB0aGUgbmV3IGRhdGEgQXJyYXkgYnkgc3RvcmluZyBhXG4gICAqIGhpZGRlbiByZWZlcmVuY2UgdG8gYW4gb3duZXIgdm0gaW5zdGFuY2Ugb24gcHJldmlvdXNseVxuICAgKiBzZWVuIGRhdGEuIFRoaXMgYWxsb3dzIHVzIHRvIGFjaGlldmUgTyhuKSB3aGljaCBpc1xuICAgKiBiZXR0ZXIgdGhhbiBhIGxldmVuc2h0ZWluIGRpc3RhbmNlIGJhc2VkIGFsZ29yaXRobSxcbiAgICogd2hpY2ggaXMgTyhtICogbikuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcbiAgICovXG5cbiAgZGlmZjogZnVuY3Rpb24gZGlmZihkYXRhKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIEFycmF5IHdhcyBjb252ZXJ0ZWQgZnJvbSBhbiBPYmplY3RcbiAgICB2YXIgaXRlbSA9IGRhdGFbMF07XG4gICAgdmFyIGNvbnZlcnRlZEZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3QgPSBpc09iamVjdChpdGVtKSAmJiBoYXNPd24oaXRlbSwgJyRrZXknKSAmJiBoYXNPd24oaXRlbSwgJyR2YWx1ZScpO1xuXG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBvbGRGcmFncyA9IHRoaXMuZnJhZ3M7XG4gICAgdmFyIGZyYWdzID0gdGhpcy5mcmFncyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGFsaWFzID0gdGhpcy5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yO1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgIHZhciBpbkRvY3VtZW50ID0gaW5Eb2Moc3RhcnQpO1xuICAgIHZhciBpbml0ID0gIW9sZEZyYWdzO1xuICAgIHZhciBpLCBsLCBmcmFnLCBrZXksIHZhbHVlLCBwcmltaXRpdmU7XG5cbiAgICAvLyBGaXJzdCBwYXNzLCBnbyB0aHJvdWdoIHRoZSBuZXcgQXJyYXkgYW5kIGZpbGwgdXBcbiAgICAvLyB0aGUgbmV3IGZyYWdzIGFycmF5LiBJZiBhIHBpZWNlIG9mIGRhdGEgaGFzIGEgY2FjaGVkXG4gICAgLy8gaW5zdGFuY2UgZm9yIGl0LCB3ZSByZXVzZSBpdC4gT3RoZXJ3aXNlIGJ1aWxkIGEgbmV3XG4gICAgLy8gaW5zdGFuY2UuXG4gICAgZm9yIChpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpdGVtID0gZGF0YVtpXTtcbiAgICAgIGtleSA9IGNvbnZlcnRlZEZyb21PYmplY3QgPyBpdGVtLiRrZXkgOiBudWxsO1xuICAgICAgdmFsdWUgPSBjb252ZXJ0ZWRGcm9tT2JqZWN0ID8gaXRlbS4kdmFsdWUgOiBpdGVtO1xuICAgICAgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGZyYWcgPSAhaW5pdCAmJiB0aGlzLmdldENhY2hlZEZyYWcodmFsdWUsIGksIGtleSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICAvLyByZXVzYWJsZSBmcmFnbWVudFxuICAgICAgICBmcmFnLnJldXNlZCA9IHRydWU7XG4gICAgICAgIC8vIHVwZGF0ZSAkaW5kZXhcbiAgICAgICAgZnJhZy5zY29wZS4kaW5kZXggPSBpO1xuICAgICAgICAvLyB1cGRhdGUgJGtleVxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZnJhZy5zY29wZS4ka2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBpdGVyYXRvclxuICAgICAgICBpZiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2l0ZXJhdG9yXSA9IGtleSAhPT0gbnVsbCA/IGtleSA6IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGRhdGEgZm9yIHRyYWNrLWJ5LCBvYmplY3QgcmVwZWF0ICZcbiAgICAgICAgLy8gcHJpbWl0aXZlIHZhbHVlcy5cbiAgICAgICAgaWYgKHRyYWNrQnlLZXkgfHwgY29udmVydGVkRnJvbU9iamVjdCB8fCBwcmltaXRpdmUpIHtcbiAgICAgICAgICBmcmFnLnNjb3BlW2FsaWFzXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaXNudGFuY2VcbiAgICAgICAgZnJhZyA9IHRoaXMuY3JlYXRlKHZhbHVlLCBhbGlhcywgaSwga2V5KTtcbiAgICAgICAgZnJhZy5mcmVzaCA9ICFpbml0O1xuICAgICAgfVxuICAgICAgZnJhZ3NbaV0gPSBmcmFnO1xuICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgZnJhZy5iZWZvcmUoZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBkb25lIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcywgZ28gdGhyb3VnaCB0aGUgb2xkIGZyYWdtZW50cyBhbmRcbiAgICAvLyBkZXN0cm95IHRob3NlIHdobyBhcmUgbm90IHJldXNlZCAoYW5kIHJlbW92ZSB0aGVtXG4gICAgLy8gZnJvbSBjYWNoZSlcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gMDtcbiAgICB2YXIgdG90YWxSZW1vdmVkID0gb2xkRnJhZ3MubGVuZ3RoIC0gZnJhZ3MubGVuZ3RoO1xuICAgIGZvciAoaSA9IDAsIGwgPSBvbGRGcmFncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZyYWcgPSBvbGRGcmFnc1tpXTtcbiAgICAgIGlmICghZnJhZy5yZXVzZWQpIHtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICB0aGlzLnJlbW92ZShmcmFnLCByZW1vdmFsSW5kZXgrKywgdG90YWxSZW1vdmVkLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbCBwYXNzLCBtb3ZlL2luc2VydCBuZXcgZnJhZ21lbnRzIGludG8gdGhlXG4gICAgLy8gcmlnaHQgcGxhY2UuXG4gICAgdmFyIHRhcmdldFByZXYsIHByZXZFbCwgY3VycmVudFByZXY7XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gZnJhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmcmFnID0gZnJhZ3NbaV07XG4gICAgICAvLyB0aGlzIGlzIHRoZSBmcmFnIHRoYXQgd2Ugc2hvdWxkIGJlIGFmdGVyXG4gICAgICB0YXJnZXRQcmV2ID0gZnJhZ3NbaSAtIDFdO1xuICAgICAgcHJldkVsID0gdGFyZ2V0UHJldiA/IHRhcmdldFByZXYuc3RhZ2dlckNiID8gdGFyZ2V0UHJldi5zdGFnZ2VyQW5jaG9yIDogdGFyZ2V0UHJldi5lbmQgfHwgdGFyZ2V0UHJldi5ub2RlIDogc3RhcnQ7XG4gICAgICBpZiAoZnJhZy5yZXVzZWQgJiYgIWZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICAgIGN1cnJlbnRQcmV2ID0gZmluZFByZXZGcmFnKGZyYWcsIHN0YXJ0LCB0aGlzLmlkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmV2ICE9PSB0YXJnZXRQcmV2ICYmICghY3VycmVudFByZXYgfHxcbiAgICAgICAgLy8gb3B0aW1pemF0aW9uIGZvciBtb3ZpbmcgYSBzaW5nbGUgaXRlbS5cbiAgICAgICAgLy8gdGhhbmtzIHRvIHN1Z2dlc3Rpb25zIGJ5IEBsaXZvcmFzIGluICMxODA3XG4gICAgICAgIGZpbmRQcmV2RnJhZyhjdXJyZW50UHJldiwgc3RhcnQsIHRoaXMuaWQpICE9PSB0YXJnZXRQcmV2KSkge1xuICAgICAgICAgIHRoaXMubW92ZShmcmFnLCBwcmV2RWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgaW5zdGFuY2UsIG9yIHN0aWxsIGluIHN0YWdnZXIuXG4gICAgICAgIC8vIGluc2VydCB3aXRoIHVwZGF0ZWQgc3RhZ2dlciBpbmRleC5cbiAgICAgICAgdGhpcy5pbnNlcnQoZnJhZywgaW5zZXJ0aW9uSW5kZXgrKywgcHJldkVsLCBpbkRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIGZyYWcucmV1c2VkID0gZnJhZy5mcmVzaCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtrZXldXG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgYWxpYXMsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgaG9zdCA9IHRoaXMuX2hvc3Q7XG4gICAgLy8gY3JlYXRlIGl0ZXJhdGlvbiBzY29wZVxuICAgIHZhciBwYXJlbnRTY29wZSA9IHRoaXMuX3Njb3BlIHx8IHRoaXMudm07XG4gICAgdmFyIHNjb3BlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZSk7XG4gICAgLy8gcmVmIGhvbGRlciBmb3IgdGhlIHNjb3BlXG4gICAgc2NvcGUuJHJlZnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFNjb3BlLiRyZWZzKTtcbiAgICBzY29wZS4kZWxzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRTY29wZS4kZWxzKTtcbiAgICAvLyBtYWtlIHN1cmUgcG9pbnQgJHBhcmVudCB0byBwYXJlbnQgc2NvcGVcbiAgICBzY29wZS4kcGFyZW50ID0gcGFyZW50U2NvcGU7XG4gICAgLy8gZm9yIHR3by13YXkgYmluZGluZyBvbiBhbGlhc1xuICAgIHNjb3BlLiRmb3JDb250ZXh0ID0gdGhpcztcbiAgICAvLyBkZWZpbmUgc2NvcGUgcHJvcGVydGllc1xuICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCBhbGlhcywgdmFsdWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGluZGV4JywgaW5kZXgpO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHNjb3BlLCAnJGtleScsIGtleSk7XG4gICAgfSBlbHNlIGlmIChzY29wZS4ka2V5KSB7XG4gICAgICAvLyBhdm9pZCBhY2NpZGVudGFsIGZhbGxiYWNrXG4gICAgICBkZWYoc2NvcGUsICcka2V5JywgbnVsbCk7XG4gICAgfVxuICAgIGlmICh0aGlzLml0ZXJhdG9yKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZShzY29wZSwgdGhpcy5pdGVyYXRvciwga2V5ICE9PSBudWxsID8ga2V5IDogaW5kZXgpO1xuICAgIH1cbiAgICB2YXIgZnJhZyA9IHRoaXMuZmFjdG9yeS5jcmVhdGUoaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIGZyYWcuZm9ySWQgPSB0aGlzLmlkO1xuICAgIHRoaXMuY2FjaGVGcmFnKHZhbHVlLCBmcmFnLCBpbmRleCwga2V5KTtcbiAgICByZXR1cm4gZnJhZztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB2LXJlZiBvbiBvd25lciB2bS5cbiAgICovXG5cbiAgdXBkYXRlUmVmOiBmdW5jdGlvbiB1cGRhdGVSZWYoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuZGVzY3JpcHRvci5yZWY7XG4gICAgaWYgKCFyZWYpIHJldHVybjtcbiAgICB2YXIgaGFzaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kcmVmcztcbiAgICB2YXIgcmVmcztcbiAgICBpZiAoIXRoaXMuZnJvbU9iamVjdCkge1xuICAgICAgcmVmcyA9IHRoaXMuZnJhZ3MubWFwKGZpbmRWbUZyb21GcmFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmcyA9IHt9O1xuICAgICAgdGhpcy5mcmFncy5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgICAgIHJlZnNbZnJhZy5zY29wZS4ka2V5XSA9IGZpbmRWbUZyb21GcmFnKGZyYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhhc2hbcmVmXSA9IHJlZnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBvcHRpb24gbGlzdHMsIHVwZGF0ZSB0aGUgY29udGFpbmluZyB2LW1vZGVsIG9uXG4gICAqIHBhcmVudCA8c2VsZWN0Pi5cbiAgICovXG5cbiAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uIHVwZGF0ZU1vZGVsKCkge1xuICAgIGlmICh0aGlzLmlzT3B0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5zdGFydC5wYXJlbnROb2RlO1xuICAgICAgdmFyIG1vZGVsID0gcGFyZW50ICYmIHBhcmVudC5fX3ZfbW9kZWw7XG4gICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgbW9kZWwuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGZyYWdtZW50LiBIYW5kbGVzIHN0YWdnZXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Tm9kZX0gcHJldkVsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydChmcmFnLCBpbmRleCwgcHJldkVsLCBpbkRvY3VtZW50KSB7XG4gICAgaWYgKGZyYWcuc3RhZ2dlckNiKSB7XG4gICAgICBmcmFnLnN0YWdnZXJDYi5jYW5jZWwoKTtcbiAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIHN0YWdnZXJBbW91bnQgPSB0aGlzLmdldFN0YWdnZXIoZnJhZywgaW5kZXgsIG51bGwsICdlbnRlcicpO1xuICAgIGlmIChpbkRvY3VtZW50ICYmIHN0YWdnZXJBbW91bnQpIHtcbiAgICAgIC8vIGNyZWF0ZSBhbiBhbmNob3IgYW5kIGluc2VydCBpdCBzeW5jaHJvbm91c2x5LFxuICAgICAgLy8gc28gdGhhdCB3ZSBjYW4gcmVzb2x2ZSB0aGUgY29ycmVjdCBvcmRlciB3aXRob3V0XG4gICAgICAvLyB3b3JyeWluZyBhYm91dCBzb21lIGVsZW1lbnRzIG5vdCBpbnNlcnRlZCB5ZXRcbiAgICAgIHZhciBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3I7XG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICBhbmNob3IgPSBmcmFnLnN0YWdnZXJBbmNob3IgPSBjcmVhdGVBbmNob3IoJ3N0YWdnZXItYW5jaG9yJyk7XG4gICAgICAgIGFuY2hvci5fX3ZmcmFnX18gPSBmcmFnO1xuICAgICAgfVxuICAgICAgYWZ0ZXIoYW5jaG9yLCBwcmV2RWwpO1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5iZWZvcmUoYW5jaG9yKTtcbiAgICAgICAgcmVtb3ZlKGFuY2hvcik7XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQob3AsIHN0YWdnZXJBbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGEgZnJhZ21lbnQuIEhhbmRsZXMgc3RhZ2dlcmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5Eb2N1bWVudFxuICAgKi9cblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShmcmFnLCBpbmRleCwgdG90YWwsIGluRG9jdW1lbnQpIHtcbiAgICBpZiAoZnJhZy5zdGFnZ2VyQ2IpIHtcbiAgICAgIGZyYWcuc3RhZ2dlckNiLmNhbmNlbCgpO1xuICAgICAgZnJhZy5zdGFnZ2VyQ2IgPSBudWxsO1xuICAgICAgLy8gaXQncyBub3QgcG9zc2libGUgZm9yIHRoZSBzYW1lIGZyYWcgdG8gYmUgcmVtb3ZlZFxuICAgICAgLy8gdHdpY2UsIHNvIGlmIHdlIGhhdmUgYSBwZW5kaW5nIHN0YWdnZXIgY2FsbGJhY2ssXG4gICAgICAvLyBpdCBtZWFucyB0aGlzIGZyYWcgaXMgcXVldWVkIGZvciBlbnRlciBidXQgcmVtb3ZlZFxuICAgICAgLy8gYmVmb3JlIGl0cyB0cmFuc2l0aW9uIHN0YXJ0ZWQuIFNpbmNlIGl0IGlzIGFscmVhZHlcbiAgICAgIC8vIGRlc3Ryb3llZCwgd2UgY2FuIGp1c3QgbGVhdmUgaXQgaW4gZGV0YWNoZWQgc3RhdGUuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzdGFnZ2VyQW1vdW50ID0gdGhpcy5nZXRTdGFnZ2VyKGZyYWcsIGluZGV4LCB0b3RhbCwgJ2xlYXZlJyk7XG4gICAgaWYgKGluRG9jdW1lbnQgJiYgc3RhZ2dlckFtb3VudCkge1xuICAgICAgdmFyIG9wID0gZnJhZy5zdGFnZ2VyQ2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZyYWcuc3RhZ2dlckNiID0gbnVsbDtcbiAgICAgICAgZnJhZy5yZW1vdmUoKTtcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChvcCwgc3RhZ2dlckFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcucmVtb3ZlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlIGEgZnJhZ21lbnQgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEZvcmNlIG5vIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAgICogQHBhcmFtIHtOb2RlfSBwcmV2RWxcbiAgICovXG5cbiAgbW92ZTogZnVuY3Rpb24gbW92ZShmcmFnLCBwcmV2RWwpIHtcbiAgICAvLyBmaXggYSBjb21tb24gaXNzdWUgd2l0aCBTb3J0YWJsZTpcbiAgICAvLyBpZiBwcmV2RWwgZG9lc24ndCBoYXZlIG5leHRTaWJsaW5nLCB0aGlzIG1lYW5zIGl0J3NcbiAgICAvLyBiZWVuIGRyYWdnZWQgYWZ0ZXIgdGhlIGVuZCBhbmNob3IuIEp1c3QgcmUtcG9zaXRpb25cbiAgICAvLyB0aGUgZW5kIGFuY2hvciB0byB0aGUgZW5kIG9mIHRoZSBjb250YWluZXIuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFwcmV2RWwubmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuZW5kLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5lbmQpO1xuICAgIH1cbiAgICBmcmFnLmJlZm9yZShwcmV2RWwubmV4dFNpYmxpbmcsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FjaGUgYSBmcmFnbWVudCB1c2luZyB0cmFjay1ieSBvciB0aGUgb2JqZWN0IGtleS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAgICovXG5cbiAgY2FjaGVGcmFnOiBmdW5jdGlvbiBjYWNoZUZyYWcodmFsdWUsIGZyYWcsIGluZGV4LCBrZXkpIHtcbiAgICB2YXIgdHJhY2tCeUtleSA9IHRoaXMucGFyYW1zLnRyYWNrQnk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB2YXIgaWQ7XG4gICAgaWYgKGtleSB8fCB0cmFja0J5S2V5IHx8IHByaW1pdGl2ZSkge1xuICAgICAgaWQgPSB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHZhbHVlW3RyYWNrQnlLZXldIDoga2V5IHx8IHZhbHVlO1xuICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgY2FjaGVbaWRdID0gZnJhZztcbiAgICAgIH0gZWxzZSBpZiAodHJhY2tCeUtleSAhPT0gJyRpbmRleCcpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoaGFzT3duKHZhbHVlLCBpZCkpIHtcbiAgICAgICAgaWYgKHZhbHVlW2lkXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlW2lkXSA9IGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLndhcm5EdXBsaWNhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWYodmFsdWUsIGlkLCBmcmFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnJhZy5yYXcgPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgY2FjaGVkIGZyYWdtZW50IGZyb20gdGhlIHZhbHVlL2luZGV4L2tleVxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0ZyYWdtZW50fVxuICAgKi9cblxuICBnZXRDYWNoZWRGcmFnOiBmdW5jdGlvbiBnZXRDYWNoZWRGcmFnKHZhbHVlLCBpbmRleCwga2V5KSB7XG4gICAgdmFyIHRyYWNrQnlLZXkgPSB0aGlzLnBhcmFtcy50cmFja0J5O1xuICAgIHZhciBwcmltaXRpdmUgPSAhaXNPYmplY3QodmFsdWUpO1xuICAgIHZhciBmcmFnO1xuICAgIGlmIChrZXkgfHwgdHJhY2tCeUtleSB8fCBwcmltaXRpdmUpIHtcbiAgICAgIHZhciBpZCA9IHRyYWNrQnlLZXkgPyB0cmFja0J5S2V5ID09PSAnJGluZGV4JyA/IGluZGV4IDogdmFsdWVbdHJhY2tCeUtleV0gOiBrZXkgfHwgdmFsdWU7XG4gICAgICBmcmFnID0gdGhpcy5jYWNoZVtpZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWcgPSB2YWx1ZVt0aGlzLmlkXTtcbiAgICB9XG4gICAgaWYgKGZyYWcgJiYgKGZyYWcucmV1c2VkIHx8IGZyYWcuZnJlc2gpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMud2FybkR1cGxpY2F0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZyYWdtZW50fSBmcmFnXG4gICAqL1xuXG4gIGRlbGV0ZUNhY2hlZEZyYWc6IGZ1bmN0aW9uIGRlbGV0ZUNhY2hlZEZyYWcoZnJhZykge1xuICAgIHZhciB2YWx1ZSA9IGZyYWcucmF3O1xuICAgIHZhciB0cmFja0J5S2V5ID0gdGhpcy5wYXJhbXMudHJhY2tCeTtcbiAgICB2YXIgc2NvcGUgPSBmcmFnLnNjb3BlO1xuICAgIHZhciBpbmRleCA9IHNjb3BlLiRpbmRleDtcbiAgICAvLyBmaXggIzk0ODogYXZvaWQgYWNjaWRlbnRhbGx5IGZhbGwgdGhyb3VnaCB0b1xuICAgIC8vIGEgcGFyZW50IHJlcGVhdGVyIHdoaWNoIGhhcHBlbnMgdG8gaGF2ZSAka2V5LlxuICAgIHZhciBrZXkgPSBoYXNPd24oc2NvcGUsICcka2V5JykgJiYgc2NvcGUuJGtleTtcbiAgICB2YXIgcHJpbWl0aXZlID0gIWlzT2JqZWN0KHZhbHVlKTtcbiAgICBpZiAodHJhY2tCeUtleSB8fCBrZXkgfHwgcHJpbWl0aXZlKSB7XG4gICAgICB2YXIgaWQgPSB0cmFja0J5S2V5ID8gdHJhY2tCeUtleSA9PT0gJyRpbmRleCcgPyBpbmRleCA6IHZhbHVlW3RyYWNrQnlLZXldIDoga2V5IHx8IHZhbHVlO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVt0aGlzLmlkXSA9IG51bGw7XG4gICAgICBmcmFnLnJhdyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0YWdnZXIgYW1vdW50IGZvciBhbiBpbnNlcnRpb24vcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqL1xuXG4gIGdldFN0YWdnZXI6IGZ1bmN0aW9uIGdldFN0YWdnZXIoZnJhZywgaW5kZXgsIHRvdGFsLCB0eXBlKSB7XG4gICAgdHlwZSA9IHR5cGUgKyAnU3RhZ2dlcic7XG4gICAgdmFyIHRyYW5zID0gZnJhZy5ub2RlLl9fdl90cmFucztcbiAgICB2YXIgaG9va3MgPSB0cmFucyAmJiB0cmFucy5ob29rcztcbiAgICB2YXIgaG9vayA9IGhvb2tzICYmIChob29rc1t0eXBlXSB8fCBob29rcy5zdGFnZ2VyKTtcbiAgICByZXR1cm4gaG9vayA/IGhvb2suY2FsbChmcmFnLCBpbmRleCwgdG90YWwpIDogaW5kZXggKiBwYXJzZUludCh0aGlzLnBhcmFtc1t0eXBlXSB8fCB0aGlzLnBhcmFtcy5zdGFnZ2VyLCAxMCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZS1wcm9jZXNzIHRoZSB2YWx1ZSBiZWZvcmUgcGlwaW5nIGl0IHRocm91Z2ggdGhlXG4gICAqIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqL1xuXG4gIF9wcmVQcm9jZXNzOiBmdW5jdGlvbiBfcHJlUHJvY2Vzcyh2YWx1ZSkge1xuICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdHlwZSwgc3RvcmUgdGhlIHVuLWZpbHRlcmVkIHJhdyB2YWx1ZS5cbiAgICB0aGlzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgdGhlIHZhbHVlIGFmdGVyIGl0IGhhcyBiZWVuIHBpcGVkIHRocm91Z2hcbiAgICogdGhlIGZpbHRlcnMuIFRoaXMgaXMgcGFzc2VkIHRvIGFuZCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIuXG4gICAqXG4gICAqIEl0IGlzIG5lY2Vzc2FyeSBmb3IgdGhpcyB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZVxuICAgKiB3YXRoY2VyJ3MgZGVwZW5kZW5jeSBjb2xsZWN0aW9uIHBoYXNlIGJlY2F1c2Ugd2Ugd2FudFxuICAgKiB0aGUgdi1mb3IgdG8gdXBkYXRlIHdoZW4gdGhlIHNvdXJjZSBPYmplY3QgaXMgbXV0YXRlZC5cbiAgICovXG5cbiAgX3Bvc3RQcm9jZXNzOiBmdW5jdGlvbiBfcG9zdFByb2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAvLyBjb252ZXJ0IHBsYWluIG9iamVjdCB0byBhcnJheS5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgICB2YXIga2V5O1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXNbaV0gPSB7XG4gICAgICAgICAgJGtleToga2V5LFxuICAgICAgICAgICR2YWx1ZTogdmFsdWVba2V5XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSByYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgfHwgW107XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmRlc2NyaXB0b3IucmVmKSB7XG4gICAgICAodGhpcy5fc2NvcGUgfHwgdGhpcy52bSkuJHJlZnNbdGhpcy5kZXNjcmlwdG9yLnJlZl0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFncykge1xuICAgICAgdmFyIGkgPSB0aGlzLmZyYWdzLmxlbmd0aDtcbiAgICAgIHZhciBmcmFnO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBmcmFnID0gdGhpcy5mcmFnc1tpXTtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZWRGcmFnKGZyYWcpO1xuICAgICAgICBmcmFnLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGVscGVyIHRvIGZpbmQgdGhlIHByZXZpb3VzIGVsZW1lbnQgdGhhdCBpcyBhIGZyYWdtZW50XG4gKiBhbmNob3IuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYSBkZXN0cm95ZWQgZnJhZydzXG4gKiBlbGVtZW50IGNvdWxkIHN0aWxsIGJlIGxpbmdlcmluZyBpbiB0aGUgRE9NIGJlZm9yZSBpdHNcbiAqIGxlYXZpbmcgdHJhbnNpdGlvbiBmaW5pc2hlcywgYnV0IGl0cyBpbnNlcnRlZCBmbGFnXG4gKiBzaG91bGQgaGF2ZSBiZWVuIHNldCB0byBmYWxzZSBzbyB3ZSBjYW4gc2tpcCB0aGVtLlxuICpcbiAqIElmIHRoaXMgaXMgYSBibG9jayByZXBlYXQsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIG9ubHlcbiAqIHJldHVybiBmcmFnIHRoYXQgaXMgYm91bmQgdG8gdGhpcyB2LWZvci4gKHNlZSAjOTI5KVxuICpcbiAqIEBwYXJhbSB7RnJhZ21lbnR9IGZyYWdcbiAqIEBwYXJhbSB7Q29tbWVudHxUZXh0fSBhbmNob3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHJldHVybiB7RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZmluZFByZXZGcmFnKGZyYWcsIGFuY2hvciwgaWQpIHtcbiAgdmFyIGVsID0gZnJhZy5ub2RlLnByZXZpb3VzU2libGluZztcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghZWwpIHJldHVybjtcbiAgZnJhZyA9IGVsLl9fdmZyYWdfXztcbiAgd2hpbGUgKCghZnJhZyB8fCBmcmFnLmZvcklkICE9PSBpZCB8fCAhZnJhZy5pbnNlcnRlZCkgJiYgZWwgIT09IGFuY2hvcikge1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBmcmFnID0gZWwuX192ZnJhZ19fO1xuICB9XG4gIHJldHVybiBmcmFnO1xufVxuXG4vKipcbiAqIEZpbmQgYSB2bSBmcm9tIGEgZnJhZ21lbnQuXG4gKlxuICogQHBhcmFtIHtGcmFnbWVudH0gZnJhZ1xuICogQHJldHVybiB7VnVlfHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBmaW5kVm1Gcm9tRnJhZyhmcmFnKSB7XG4gIHZhciBub2RlID0gZnJhZy5ub2RlO1xuICAvLyBoYW5kbGUgbXVsdGktbm9kZSBmcmFnXG4gIGlmIChmcmFnLmVuZCkge1xuICAgIHdoaWxlICghbm9kZS5fX3Z1ZV9fICYmIG5vZGUgIT09IGZyYWcuZW5kICYmIG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZS5fX3Z1ZV9fO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHJhbmdlIGFycmF5IGZyb20gZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHZhciBpID0gLTE7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkobik7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmV0W2ldID0gaTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2Rm9yLndhcm5EdXBsaWNhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB3YXJuKCdEdXBsaWNhdGUgdmFsdWUgZm91bmQgaW4gdi1mb3I9XCInICsgdGhpcy5kZXNjcmlwdG9yLnJhdyArICdcIjogJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICcuIFVzZSB0cmFjay1ieT1cIiRpbmRleFwiIGlmICcgKyAneW91IGFyZSBleHBlY3RpbmcgZHVwbGljYXRlIHZhbHVlcy4nKTtcbiAgfTtcbn1cblxudmFyIGh0bWwgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAvLyBhIGNvbW1lbnQgbm9kZSBtZWFucyB0aGlzIGlzIGEgYmluZGluZyBmb3JcbiAgICAvLyB7e3sgaW5saW5lIHVuZXNjYXBlZCBodG1sIH19fVxuICAgIGlmICh0aGlzLmVsLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAvLyBob2xkIG5vZGVzXG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHByb3BlciBhbmNob3JcbiAgICAgIHRoaXMuYW5jaG9yID0gY3JlYXRlQW5jaG9yKCd2LWh0bWwnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gX3RvU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgdGhpcy5zd2FwKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgc3dhcDogZnVuY3Rpb24gc3dhcCh2YWx1ZSkge1xuICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICB2YXIgaSA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHJlbW92ZSh0aGlzLm5vZGVzW2ldKTtcbiAgICB9XG4gICAgLy8gY29udmVydCBuZXcgdmFsdWUgdG8gYSBmcmFnbWVudFxuICAgIC8vIGRvIG5vdCBhdHRlbXB0IHRvIHJldHJpZXZlIGZyb20gaWQgc2VsZWN0b3JcbiAgICB2YXIgZnJhZyA9IHBhcnNlVGVtcGxhdGUodmFsdWUsIHRydWUsIHRydWUpO1xuICAgIC8vIHNhdmUgYSByZWZlcmVuY2UgdG8gdGhlc2Ugbm9kZXMgc28gd2UgY2FuIHJlbW92ZSBsYXRlclxuICAgIHRoaXMubm9kZXMgPSB0b0FycmF5KGZyYWcuY2hpbGROb2Rlcyk7XG4gICAgYmVmb3JlKGZyYWcsIHRoaXMuYW5jaG9yKTtcbiAgfVxufTtcblxudmFyIHRleHQgPSB7XG5cbiAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcbiAgICB0aGlzLmF0dHIgPSB0aGlzLmVsLm5vZGVUeXBlID09PSAzID8gJ2RhdGEnIDogJ3RleHRDb250ZW50JztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMuZWxbdGhpcy5hdHRyXSA9IF90b1N0cmluZyh2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIG11c3QgZXhwb3J0IHBsYWluIG9iamVjdFxudmFyIHB1YmxpY0RpcmVjdGl2ZXMgPSB7XG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWwsXG4gICdmb3InOiB2Rm9yLFxuICAnaWYnOiB2SWYsXG4gIHNob3c6IHNob3csXG4gIG1vZGVsOiBtb2RlbCxcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kLFxuICBlbDogZWwsXG4gIHJlZjogcmVmLFxuICBjbG9hazogY2xvYWtcbn07XG5cbnZhciBxdWV1ZSQxID0gW107XG52YXIgcXVldWVkID0gZmFsc2U7XG5cbi8qKlxuICogUHVzaCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2JcbiAqL1xuXG5mdW5jdGlvbiBwdXNoSm9iKGpvYikge1xuICBxdWV1ZSQxLnB1c2goam9iKTtcbiAgaWYgKCFxdWV1ZWQpIHtcbiAgICBxdWV1ZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKGZsdXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIHRoZSBxdWV1ZSwgYW5kIGRvIG9uZSBmb3JjZWQgcmVmbG93IGJlZm9yZVxuICogdHJpZ2dlcmluZyB0cmFuc2l0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgLy8gRm9yY2UgbGF5b3V0XG4gIHZhciBmID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZSQxLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWUkMVtpXSgpO1xuICB9XG4gIHF1ZXVlJDEgPSBbXTtcbiAgcXVldWVkID0gZmFsc2U7XG4gIC8vIGR1bW15IHJldHVybiwgc28ganMgbGludGVycyBkb24ndCBjb21wbGFpbiBhYm91dFxuICAvLyB1bnVzZWQgdmFyaWFibGUgZlxuICByZXR1cm4gZjtcbn1cblxudmFyIFRZUEVfVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBUWVBFX0FOSU1BVElPTiA9ICdhbmltYXRpb24nO1xudmFyIHRyYW5zRHVyYXRpb25Qcm9wID0gdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nO1xudmFyIGFuaW1EdXJhdGlvblByb3AgPSBhbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJztcblxuLyoqXG4gKiBBIFRyYW5zaXRpb24gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHRoZSBzdGF0ZSBhbmQgbG9naWNcbiAqIG9mIHRoZSB0cmFuc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGhvb2tzXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqL1xuZnVuY3Rpb24gVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB2bSkge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5lbnRlckNsYXNzID0gaG9va3MgJiYgaG9va3MuZW50ZXJDbGFzcyB8fCBpZCArICctZW50ZXInO1xuICB0aGlzLmxlYXZlQ2xhc3MgPSBob29rcyAmJiBob29rcy5sZWF2ZUNsYXNzIHx8IGlkICsgJy1sZWF2ZSc7XG4gIHRoaXMuaG9va3MgPSBob29rcztcbiAgdGhpcy52bSA9IHZtO1xuICAvLyBhc3luYyBzdGF0ZVxuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gdGhpcy5vcCA9IHRoaXMuY2IgPSBudWxsO1xuICB0aGlzLmp1c3RFbnRlcmVkID0gZmFsc2U7XG4gIHRoaXMuZW50ZXJlZCA9IHRoaXMubGVmdCA9IGZhbHNlO1xuICB0aGlzLnR5cGVDYWNoZSA9IHt9O1xuICAvLyBjaGVjayBjc3MgdHJhbnNpdGlvbiB0eXBlXG4gIHRoaXMudHlwZSA9IGhvb2tzICYmIGhvb2tzLnR5cGU7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSBUWVBFX1RSQU5TSVRJT04gJiYgdGhpcy50eXBlICE9PSBUWVBFX0FOSU1BVElPTikge1xuICAgICAgd2FybignaW52YWxpZCBDU1MgdHJhbnNpdGlvbiB0eXBlIGZvciB0cmFuc2l0aW9uPVwiJyArIHRoaXMuaWQgKyAnXCI6ICcgKyB0aGlzLnR5cGUpO1xuICAgIH1cbiAgfVxuICAvLyBiaW5kXG4gIHZhciBzZWxmID0gdGhpcztbJ2VudGVyTmV4dFRpY2snLCAnZW50ZXJEb25lJywgJ2xlYXZlTmV4dFRpY2snLCAnbGVhdmVEb25lJ10uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIHNlbGZbbV0gPSBiaW5kJDEoc2VsZlttXSwgc2VsZik7XG4gIH0pO1xufVxuXG52YXIgcCQxID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbi8qKlxuICogU3RhcnQgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBlbnRlciB0cmFuc2l0aW9uIHRyaWdnZXJlZFxuICogMi4gY2FsbCBiZWZvcmVFbnRlciBob29rXG4gKiAzLiBhZGQgZW50ZXIgY2xhc3NcbiAqIDQuIGluc2VydC9zaG93IGVsZW1lbnRcbiAqIDUuIGNhbGwgZW50ZXIgaG9vayAod2l0aCBwb3NzaWJsZSBleHBsaWNpdCBqcyBjYWxsYmFjaylcbiAqIDYuIHJlZmxvd1xuICogNy4gYmFzZWQgb24gdHJhbnNpdGlvbiB0eXBlOlxuICogICAgLSB0cmFuc2l0aW9uOlxuICogICAgICAgIHJlbW92ZSBjbGFzcyBub3csIHdhaXQgZm9yIHRyYW5zaXRpb25lbmQsXG4gKiAgICAgICAgdGhlbiBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiAgICAtIGFuaW1hdGlvbjpcbiAqICAgICAgICB3YWl0IGZvciBhbmltYXRpb25lbmQsIHJlbW92ZSBjbGFzcyxcbiAqICAgICAgICB0aGVuIGRvbmUgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqICAgIC0gbm8gY3NzIHRyYW5zaXRpb246XG4gKiAgICAgICAgZG9uZSBub3cgaWYgdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFjay5cbiAqIDguIHdhaXQgZm9yIGVpdGhlciBkb25lIG9yIGpzIGNhbGxiYWNrLCB0aGVuIGNhbGxcbiAqICAgIGFmdGVyRW50ZXIgaG9vay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcCAtIGluc2VydC9zaG93IHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gKi9cblxucCQxLmVudGVyID0gZnVuY3Rpb24gKG9wLCBjYikge1xuICB0aGlzLmNhbmNlbFBlbmRpbmcoKTtcbiAgdGhpcy5jYWxsSG9vaygnYmVmb3JlRW50ZXInKTtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmVudGVyQ2xhc3MpO1xuICBvcCgpO1xuICB0aGlzLmVudGVyZWQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignZW50ZXInKTtcbiAgaWYgKHRoaXMuZW50ZXJlZCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmVudGVyQ2FuY2VsbGVkO1xuICBwdXNoSm9iKHRoaXMuZW50ZXJOZXh0VGljayk7XG59O1xuXG4vKipcbiAqIFRoZSBcIm5leHRUaWNrXCIgcGhhc2Ugb2YgYW4gZW50ZXJpbmcgdHJhbnNpdGlvbiwgd2hpY2ggaXNcbiAqIHRvIGJlIHB1c2hlZCBpbnRvIGEgcXVldWUgYW5kIGV4ZWN1dGVkIGFmdGVyIGEgcmVmbG93IHNvXG4gKiB0aGF0IHJlbW92aW5nIHRoZSBjbGFzcyBjYW4gdHJpZ2dlciBhIENTUyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5lbnRlck5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIEltcG9ydGFudCBoYWNrOlxuICAvLyBpbiBDaHJvbWUsIGlmIGEganVzdC1lbnRlcmVkIGVsZW1lbnQgaXMgYXBwbGllZCB0aGVcbiAgLy8gbGVhdmUgY2xhc3Mgd2hpbGUgaXRzIGludGVycG9sYXRlZCBwcm9wZXJ0eSBzdGlsbCBoYXNcbiAgLy8gYSB2ZXJ5IHNtYWxsIHZhbHVlICh3aXRoaW4gb25lIGZyYW1lKSwgQ2hyb21lIHdpbGxcbiAgLy8gc2tpcCB0aGUgbGVhdmUgdHJhbnNpdGlvbiBlbnRpcmVseSBhbmQgbm90IGZpcmluZyB0aGVcbiAgLy8gdHJhbnN0aW9uZW5kIGV2ZW50LiBUaGVyZWZvcmUgd2UgbmVlZCB0byBwcm90ZWN0ZWRcbiAgLy8gYWdhaW5zdCBzdWNoIGNhc2VzIHVzaW5nIGEgb25lLWZyYW1lIHRpbWVvdXQuXG4gIHRoaXMuanVzdEVudGVyZWQgPSB0cnVlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuanVzdEVudGVyZWQgPSBmYWxzZTtcbiAgfSwgMTcpO1xuXG4gIHZhciBlbnRlckRvbmUgPSB0aGlzLmVudGVyRG9uZTtcbiAgdmFyIHR5cGUgPSB0aGlzLmdldENzc1RyYW5zaXRpb25UeXBlKHRoaXMuZW50ZXJDbGFzcyk7XG4gIGlmICghdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIGlmICh0eXBlID09PSBUWVBFX1RSQU5TSVRJT04pIHtcbiAgICAgIC8vIHRyaWdnZXIgdHJhbnNpdGlvbiBieSByZW1vdmluZyBlbnRlciBjbGFzcyBub3dcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgICB0aGlzLnNldHVwQ3NzQ2IodHJhbnNpdGlvbkVuZEV2ZW50LCBlbnRlckRvbmUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVFlQRV9BTklNQVRJT04pIHtcbiAgICAgIHRoaXMuc2V0dXBDc3NDYihhbmltYXRpb25FbmRFdmVudCwgZW50ZXJEb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJEb25lKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRZUEVfVFJBTlNJVElPTikge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhlIFwiY2xlYW51cFwiIHBoYXNlIG9mIGFuIGVudGVyaW5nIHRyYW5zaXRpb24uXG4gKi9cblxucCQxLmVudGVyRG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbnRlcmVkID0gdHJ1ZTtcbiAgdGhpcy5jYW5jZWwgPSB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5lbnRlckNsYXNzKTtcbiAgdGhpcy5jYWxsSG9vaygnYWZ0ZXJFbnRlcicpO1xuICBpZiAodGhpcy5jYikgdGhpcy5jYigpO1xufTtcblxuLyoqXG4gKiBTdGFydCBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqXG4gKiAxLiBsZWF2ZSB0cmFuc2l0aW9uIHRyaWdnZXJlZC5cbiAqIDIuIGNhbGwgYmVmb3JlTGVhdmUgaG9va1xuICogMy4gYWRkIGxlYXZlIGNsYXNzICh0cmlnZ2VyIGNzcyB0cmFuc2l0aW9uKVxuICogNC4gY2FsbCBsZWF2ZSBob29rICh3aXRoIHBvc3NpYmxlIGV4cGxpY2l0IGpzIGNhbGxiYWNrKVxuICogNS4gcmVmbG93IGlmIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrIGlzIHByb3ZpZGVkXG4gKiA2LiBiYXNlZCBvbiB0cmFuc2l0aW9uIHR5cGU6XG4gKiAgICAtIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uOlxuICogICAgICAgIHdhaXQgZm9yIGVuZCBldmVudCwgcmVtb3ZlIGNsYXNzLCB0aGVuIGRvbmUgaWZcbiAqICAgICAgICB0aGVyZSdzIG5vIGV4cGxpY2l0IGpzIGNhbGxiYWNrLlxuICogICAgLSBubyBjc3MgdHJhbnNpdGlvbjpcbiAqICAgICAgICBkb25lIGlmIHRoZXJlJ3Mgbm8gZXhwbGljaXQganMgY2FsbGJhY2suXG4gKiA3LiB3YWl0IGZvciBlaXRoZXIgZG9uZSBvciBqcyBjYWxsYmFjaywgdGhlbiBjYWxsXG4gKiAgICBhZnRlckxlYXZlIGhvb2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3AgLSByZW1vdmUvaGlkZSB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICovXG5cbnAkMS5sZWF2ZSA9IGZ1bmN0aW9uIChvcCwgY2IpIHtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nKCk7XG4gIHRoaXMuY2FsbEhvb2soJ2JlZm9yZUxlYXZlJyk7XG4gIHRoaXMub3AgPSBvcDtcbiAgdGhpcy5jYiA9IGNiO1xuICBhZGRDbGFzcyh0aGlzLmVsLCB0aGlzLmxlYXZlQ2xhc3MpO1xuICB0aGlzLmxlZnQgPSBmYWxzZTtcbiAgdGhpcy5jYWxsSG9va1dpdGhDYignbGVhdmUnKTtcbiAgaWYgKHRoaXMubGVmdCkge1xuICAgIHJldHVybjsgLy8gdXNlciBjYWxsZWQgZG9uZSBzeW5jaHJvbm91c2x5LlxuICB9XG4gIHRoaXMuY2FuY2VsID0gdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmxlYXZlQ2FuY2VsbGVkO1xuICAvLyBvbmx5IG5lZWQgdG8gaGFuZGxlIGxlYXZlRG9uZSBpZlxuICAvLyAxLiB0aGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGRvbmUgKHN5bmNocm9ub3VzbHkgY2FsbGVkXG4gIC8vICAgIGJ5IHRoZSB1c2VyLCB3aGljaCBjYXVzZXMgdGhpcy5vcCBzZXQgdG8gbnVsbClcbiAgLy8gMi4gdGhlcmUncyBubyBleHBsaWNpdCBqcyBjYWxsYmFja1xuICBpZiAodGhpcy5vcCAmJiAhdGhpcy5wZW5kaW5nSnNDYikge1xuICAgIC8vIGlmIGEgQ1NTIHRyYW5zaXRpb24gbGVhdmVzIGltbWVkaWF0ZWx5IGFmdGVyIGVudGVyLFxuICAgIC8vIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50IG5ldmVyIGZpcmVzLiB0aGVyZWZvcmUgd2VcbiAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZW5kIHRoZSBsZWF2ZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5qdXN0RW50ZXJlZCkge1xuICAgICAgdGhpcy5sZWF2ZURvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEpvYih0aGlzLmxlYXZlTmV4dFRpY2spO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgXCJuZXh0VGlja1wiIHBoYXNlIG9mIGEgbGVhdmluZyB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5sZWF2ZU5leHRUaWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHlwZSA9IHRoaXMuZ2V0Q3NzVHJhbnNpdGlvblR5cGUodGhpcy5sZWF2ZUNsYXNzKTtcbiAgaWYgKHR5cGUpIHtcbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUWVBFX1RSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgICB0aGlzLnNldHVwQ3NzQ2IoZXZlbnQsIHRoaXMubGVhdmVEb25lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxlYXZlRG9uZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBcImNsZWFudXBcIiBwaGFzZSBvZiBhIGxlYXZpbmcgdHJhbnNpdGlvbi5cbiAqL1xuXG5wJDEubGVhdmVEb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlZnQgPSB0cnVlO1xuICB0aGlzLmNhbmNlbCA9IHRoaXMucGVuZGluZ0pzQ2IgPSBudWxsO1xuICB0aGlzLm9wKCk7XG4gIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMubGVhdmVDbGFzcyk7XG4gIHRoaXMuY2FsbEhvb2soJ2FmdGVyTGVhdmUnKTtcbiAgaWYgKHRoaXMuY2IpIHRoaXMuY2IoKTtcbiAgdGhpcy5vcCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbmNlbCBhbnkgcGVuZGluZyBjYWxsYmFja3MgZnJvbSBhIHByZXZpb3VzbHkgcnVubmluZ1xuICogYnV0IG5vdCBmaW5pc2hlZCB0cmFuc2l0aW9uLlxuICovXG5cbnAkMS5jYW5jZWxQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm9wID0gdGhpcy5jYiA9IG51bGw7XG4gIHZhciBoYXNQZW5kaW5nID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdDc3NDYikge1xuICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgIG9mZih0aGlzLmVsLCB0aGlzLnBlbmRpbmdDc3NFdmVudCwgdGhpcy5wZW5kaW5nQ3NzQ2IpO1xuICAgIHRoaXMucGVuZGluZ0Nzc0V2ZW50ID0gdGhpcy5wZW5kaW5nQ3NzQ2IgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnBlbmRpbmdKc0NiKSB7XG4gICAgaGFzUGVuZGluZyA9IHRydWU7XG4gICAgdGhpcy5wZW5kaW5nSnNDYi5jYW5jZWwoKTtcbiAgICB0aGlzLnBlbmRpbmdKc0NiID0gbnVsbDtcbiAgfVxuICBpZiAoaGFzUGVuZGluZykge1xuICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIHRoaXMuZW50ZXJDbGFzcyk7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgdGhpcy5sZWF2ZUNsYXNzKTtcbiAgfVxuICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICB0aGlzLmNhbmNlbC5jYWxsKHRoaXMudm0sIHRoaXMuZWwpO1xuICAgIHRoaXMuY2FuY2VsID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCBzeW5jaHJvbm91cyBob29rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cblxucCQxLmNhbGxIb29rID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgaWYgKHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXSkge1xuICAgIHRoaXMuaG9va3NbdHlwZV0uY2FsbCh0aGlzLnZtLCB0aGlzLmVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgdXNlci1wcm92aWRlZCwgcG90ZW50aWFsbHktYXN5bmMgaG9vayBmdW5jdGlvbi5cbiAqIFdlIGNoZWNrIGZvciB0aGUgbGVuZ3RoIG9mIGFyZ3VtZW50cyB0byBzZWUgaWYgdGhlIGhvb2tcbiAqIGV4cGVjdHMgYSBgZG9uZWAgY2FsbGJhY2suIElmIHRydWUsIHRoZSB0cmFuc2l0aW9uJ3MgZW5kXG4gKiB3aWxsIGJlIGRldGVybWluZWQgYnkgd2hlbiB0aGUgdXNlciBjYWxscyB0aGF0IGNhbGxiYWNrO1xuICogb3RoZXJ3aXNlLCB0aGUgZW5kIGlzIGRldGVybWluZWQgYnkgdGhlIENTUyB0cmFuc2l0aW9uIG9yXG4gKiBhbmltYXRpb24uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5wJDEuY2FsbEhvb2tXaXRoQ2IgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgaG9vayA9IHRoaXMuaG9va3MgJiYgdGhpcy5ob29rc1t0eXBlXTtcbiAgaWYgKGhvb2spIHtcbiAgICBpZiAoaG9vay5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnBlbmRpbmdKc0NiID0gY2FuY2VsbGFibGUodGhpc1t0eXBlICsgJ0RvbmUnXSk7XG4gICAgfVxuICAgIGhvb2suY2FsbCh0aGlzLnZtLCB0aGlzLmVsLCB0aGlzLnBlbmRpbmdKc0NiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCdzIHRyYW5zaXRpb24gdHlwZSBiYXNlZCBvbiB0aGVcbiAqIGNhbGN1bGF0ZWQgc3R5bGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuXG5wJDEuZ2V0Q3NzVHJhbnNpdGlvblR5cGUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIXRyYW5zaXRpb25FbmRFdmVudCB8fFxuICAvLyBza2lwIENTUyB0cmFuc2l0aW9ucyBpZiBwYWdlIGlzIG5vdCB2aXNpYmxlIC1cbiAgLy8gdGhpcyBzb2x2ZXMgdGhlIGlzc3VlIG9mIHRyYW5zaXRpb25lbmQgZXZlbnRzIG5vdFxuICAvLyBmaXJpbmcgdW50aWwgdGhlIHBhZ2UgaXMgdmlzaWJsZSBhZ2Fpbi5cbiAgLy8gcGFnZVZpc2liaWxpdHkgQVBJIGlzIHN1cHBvcnRlZCBpbiBJRTEwKywgc2FtZSBhc1xuICAvLyBDU1MgdHJhbnNpdGlvbnMuXG4gIGRvY3VtZW50LmhpZGRlbiB8fFxuICAvLyBleHBsaWNpdCBqcy1vbmx5IHRyYW5zaXRpb25cbiAgdGhpcy5ob29rcyAmJiB0aGlzLmhvb2tzLmNzcyA9PT0gZmFsc2UgfHxcbiAgLy8gZWxlbWVudCBpcyBoaWRkZW5cbiAgaXNIaWRkZW4odGhpcy5lbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgfHwgdGhpcy50eXBlQ2FjaGVbY2xhc3NOYW1lXTtcbiAgaWYgKHR5cGUpIHJldHVybiB0eXBlO1xuICB2YXIgaW5saW5lU3R5bGVzID0gdGhpcy5lbC5zdHlsZTtcbiAgdmFyIGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG4gIHZhciB0cmFuc0R1cmF0aW9uID0gaW5saW5lU3R5bGVzW3RyYW5zRHVyYXRpb25Qcm9wXSB8fCBjb21wdXRlZFN0eWxlc1t0cmFuc0R1cmF0aW9uUHJvcF07XG4gIGlmICh0cmFuc0R1cmF0aW9uICYmIHRyYW5zRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICB0eXBlID0gVFlQRV9UUkFOU0lUSU9OO1xuICB9IGVsc2Uge1xuICAgIHZhciBhbmltRHVyYXRpb24gPSBpbmxpbmVTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF0gfHwgY29tcHV0ZWRTdHlsZXNbYW5pbUR1cmF0aW9uUHJvcF07XG4gICAgaWYgKGFuaW1EdXJhdGlvbiAmJiBhbmltRHVyYXRpb24gIT09ICcwcycpIHtcbiAgICAgIHR5cGUgPSBUWVBFX0FOSU1BVElPTjtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICB0aGlzLnR5cGVDYWNoZVtjbGFzc05hbWVdID0gdHlwZTtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5cbi8qKlxuICogU2V0dXAgYSBDU1MgdHJhbnNpdGlvbmVuZC9hbmltYXRpb25lbmQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICovXG5cbnAkMS5zZXR1cENzc0NiID0gZnVuY3Rpb24gKGV2ZW50LCBjYikge1xuICB0aGlzLnBlbmRpbmdDc3NFdmVudCA9IGV2ZW50O1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlbCA9IHRoaXMuZWw7XG4gIHZhciBvbkVuZCA9IHRoaXMucGVuZGluZ0Nzc0NiID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBvZmYoZWwsIGV2ZW50LCBvbkVuZCk7XG4gICAgICBzZWxmLnBlbmRpbmdDc3NFdmVudCA9IHNlbGYucGVuZGluZ0Nzc0NiID0gbnVsbDtcbiAgICAgIGlmICghc2VsZi5wZW5kaW5nSnNDYiAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgb24kMShlbCwgZXZlbnQsIG9uRW5kKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBoaWRkZW4gLSBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3RcbiAqIHNraXAgdGhlIHRyYW5zaXRpb24gYWxsdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0hpZGRlbihlbCkge1xuICByZXR1cm4gIShlbC5vZmZzZXRXaWR0aCB8fCBlbC5vZmZzZXRIZWlnaHQgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpO1xufVxuXG52YXIgdHJhbnNpdGlvbiA9IHtcblxuICBwcmlvcml0eTogVFJBTlNJVElPTixcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShpZCwgb2xkSWQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIC8vIHJlc29sdmUgb24gb3duZXIgdm1cbiAgICB2YXIgaG9va3MgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3RyYW5zaXRpb25zJywgaWQpO1xuICAgIGlkID0gaWQgfHwgJ3YnO1xuICAgIC8vIGFwcGx5IG9uIGNsb3Nlc3Qgdm1cbiAgICBlbC5fX3ZfdHJhbnMgPSBuZXcgVHJhbnNpdGlvbihlbCwgaWQsIGhvb2tzLCB0aGlzLmVsLl9fdnVlX18gfHwgdGhpcy52bSk7XG4gICAgaWYgKG9sZElkKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbCwgb2xkSWQgKyAnLXRyYW5zaXRpb24nKTtcbiAgICB9XG4gICAgYWRkQ2xhc3MoZWwsIGlkICsgJy10cmFuc2l0aW9uJyk7XG4gIH1cbn07XG5cbnZhciBiaW5kaW5nTW9kZXMgPSBjb25maWcuX3Byb3BCaW5kaW5nTW9kZXM7XG5cbnZhciBwcm9wRGVmID0ge1xuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLnZtO1xuICAgIHZhciBwYXJlbnQgPSBjaGlsZC5fY29udGV4dDtcbiAgICAvLyBwYXNzZWQgaW4gZnJvbSBjb21waWxlciBkaXJlY3RseVxuICAgIHZhciBwcm9wID0gdGhpcy5kZXNjcmlwdG9yLnByb3A7XG4gICAgdmFyIGNoaWxkS2V5ID0gcHJvcC5wYXRoO1xuICAgIHZhciBwYXJlbnRLZXkgPSBwcm9wLnBhcmVudFBhdGg7XG4gICAgdmFyIHR3b1dheSA9IHByb3AubW9kZSA9PT0gYmluZGluZ01vZGVzLlRXT19XQVk7XG5cbiAgICB2YXIgcGFyZW50V2F0Y2hlciA9IHRoaXMucGFyZW50V2F0Y2hlciA9IG5ldyBXYXRjaGVyKHBhcmVudCwgcGFyZW50S2V5LCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YWwgPSBjb2VyY2VQcm9wKHByb3AsIHZhbCk7XG4gICAgICBpZiAoYXNzZXJ0UHJvcChwcm9wLCB2YWwpKSB7XG4gICAgICAgIGNoaWxkW2NoaWxkS2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0d29XYXk6IHR3b1dheSxcbiAgICAgIGZpbHRlcnM6IHByb3AuZmlsdGVycyxcbiAgICAgIC8vIGltcG9ydGFudDogcHJvcHMgbmVlZCB0byBiZSBvYnNlcnZlZCBvbiB0aGVcbiAgICAgIC8vIHYtZm9yIHNjb3BlIGlmIHByZXNlbnRcbiAgICAgIHNjb3BlOiB0aGlzLl9zY29wZVxuICAgIH0pO1xuXG4gICAgLy8gc2V0IHRoZSBjaGlsZCBpbml0aWFsIHZhbHVlLlxuICAgIGluaXRQcm9wKGNoaWxkLCBwcm9wLCBwYXJlbnRXYXRjaGVyLnZhbHVlKTtcblxuICAgIC8vIHNldHVwIHR3by13YXkgYmluZGluZ1xuICAgIGlmICh0d29XYXkpIHtcbiAgICAgIC8vIGltcG9ydGFudDogZGVmZXIgdGhlIGNoaWxkIHdhdGNoZXIgY3JlYXRpb24gdW50aWxcbiAgICAgIC8vIHRoZSBjcmVhdGVkIGhvb2sgKGFmdGVyIGRhdGEgb2JzZXJ2YXRpb24pXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBjaGlsZC4kb25jZSgncHJlLWhvb2s6Y3JlYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5jaGlsZFdhdGNoZXIgPSBuZXcgV2F0Y2hlcihjaGlsZCwgY2hpbGRLZXksIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICBwYXJlbnRXYXRjaGVyLnNldCh2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgLy8gZW5zdXJlIHN5bmMgdXB3YXJkIGJlZm9yZSBwYXJlbnQgc3luYyBkb3duLlxuICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIGNhc2VzIGUuZy4gdGhlIGNoaWxkXG4gICAgICAgICAgLy8gbXV0YXRlcyBhIHByb3AgYXJyYXksIHRoZW4gcmVwbGFjZXMgaXQuICgjMTY4MylcbiAgICAgICAgICBzeW5jOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIHRoaXMucGFyZW50V2F0Y2hlci50ZWFyZG93bigpO1xuICAgIGlmICh0aGlzLmNoaWxkV2F0Y2hlcikge1xuICAgICAgdGhpcy5jaGlsZFdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb21wb25lbnQgPSB7XG5cbiAgcHJpb3JpdHk6IENPTVBPTkVOVCxcblxuICBwYXJhbXM6IFsna2VlcC1hbGl2ZScsICd0cmFuc2l0aW9uLW1vZGUnLCAnaW5saW5lLXRlbXBsYXRlJ10sXG5cbiAgLyoqXG4gICAqIFNldHVwLiBUd28gcG9zc2libGUgdXNhZ2VzOlxuICAgKlxuICAgKiAtIHN0YXRpYzpcbiAgICogICA8Y29tcD4gb3IgPGRpdiB2LWNvbXBvbmVudD1cImNvbXBcIj5cbiAgICpcbiAgICogLSBkeW5hbWljOlxuICAgKiAgIDxjb21wb25lbnQgOmlzPVwidmlld1wiPlxuICAgKi9cblxuICBiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgIGlmICghdGhpcy5lbC5fX3Z1ZV9fKSB7XG4gICAgICAvLyBrZWVwLWFsaXZlIGNhY2hlXG4gICAgICB0aGlzLmtlZXBBbGl2ZSA9IHRoaXMucGFyYW1zLmtlZXBBbGl2ZTtcbiAgICAgIGlmICh0aGlzLmtlZXBBbGl2ZSkge1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgICB9XG4gICAgICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGVcbiAgICAgIGlmICh0aGlzLnBhcmFtcy5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAvLyBleHRyYWN0IGlubGluZSB0ZW1wbGF0ZSBhcyBhIERvY3VtZW50RnJhZ21lbnRcbiAgICAgICAgdGhpcy5pbmxpbmVUZW1wbGF0ZSA9IGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpO1xuICAgICAgfVxuICAgICAgLy8gY29tcG9uZW50IHJlc29sdXRpb24gcmVsYXRlZCBzdGF0ZVxuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSB0aGlzLkNvbXBvbmVudCA9IG51bGw7XG4gICAgICAvLyB0cmFuc2l0aW9uIHJlbGF0ZWQgc3RhdGVcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzID0gMDtcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxDYiA9IG51bGw7XG4gICAgICAvLyBjcmVhdGUgYSByZWYgYW5jaG9yXG4gICAgICB0aGlzLmFuY2hvciA9IGNyZWF0ZUFuY2hvcigndi1jb21wb25lbnQnKTtcbiAgICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgICAgLy8gcmVtb3ZlIGlzIGF0dHJpYnV0ZS5cbiAgICAgIC8vIHRoaXMgaXMgcmVtb3ZlZCBkdXJpbmcgY29tcGlsYXRpb24sIGJ1dCBiZWNhdXNlIGNvbXBpbGF0aW9uIGlzXG4gICAgICAvLyBjYWNoZWQsIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1c2VkIGVsc2V3aGVyZSB0aGlzIGF0dHJpYnV0ZVxuICAgICAgLy8gd2lsbCByZW1haW4gYXQgbGluayB0aW1lLlxuICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgICAvLyByZW1vdmUgcmVmLCBzYW1lIGFzIGFib3ZlXG4gICAgICBpZiAodGhpcy5kZXNjcmlwdG9yLnJlZikge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZSgndi1yZWY6JyArIGh5cGhlbmF0ZSh0aGlzLmRlc2NyaXB0b3IucmVmKSk7XG4gICAgICB9XG4gICAgICAvLyBpZiBzdGF0aWMsIGJ1aWxkIHJpZ2h0IG5vdy5cbiAgICAgIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgdGhpcy5zZXRDb21wb25lbnQodGhpcy5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdjYW5ub3QgbW91bnQgY29tcG9uZW50IFwiJyArIHRoaXMuZXhwcmVzc2lvbiArICdcIiAnICsgJ29uIGFscmVhZHkgbW91bnRlZCBlbGVtZW50OiAnICsgdGhpcy5lbCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdXBkYXRlLCBjYWxsZWQgYnkgdGhlIHdhdGNoZXIgaW4gdGhlIGR5bmFtaWNcbiAgICogbGl0ZXJhbCBzY2VuYXJpbywgZS5nLiA8Y29tcG9uZW50IDppcz1cInZpZXdcIj5cbiAgICovXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMubGl0ZXJhbCkge1xuICAgICAgdGhpcy5zZXRDb21wb25lbnQodmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3dpdGNoIGR5bmFtaWMgY29tcG9uZW50cy4gTWF5IHJlc29sdmUgdGhlIGNvbXBvbmVudFxuICAgKiBhc3luY2hyb25vdXNseSwgYW5kIHBlcmZvcm0gdHJhbnNpdGlvbiBiYXNlZCBvblxuICAgKiBzcGVjaWZpZWQgdHJhbnNpdGlvbiBtb2RlLiBBY2NlcHRzIGEgZmV3IGFkZGl0aW9uYWxcbiAgICogYXJndW1lbnRzIHNwZWNpZmljYWxseSBmb3IgdnVlLXJvdXRlci5cbiAgICpcbiAgICogVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBmdWxsIHRyYW5zaXRpb24gaXNcbiAgICogZmluaXNoZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KHZhbHVlLCBjYikge1xuICAgIHRoaXMuaW52YWxpZGF0ZVBlbmRpbmcoKTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAvLyBqdXN0IHJlbW92ZSBjdXJyZW50XG4gICAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgICB0aGlzLnJlbW92ZSh0aGlzLmNoaWxkVk0sIGNiKTtcbiAgICAgIHRoaXMuY2hpbGRWTSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMucmVzb2x2ZUNvbXBvbmVudCh2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLm1vdW50Q29tcG9uZW50KGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIHRvIHVzZSB3aGVuIGNyZWF0aW5nXG4gICAqIHRoZSBjaGlsZCB2bS5cbiAgICovXG5cbiAgcmVzb2x2ZUNvbXBvbmVudDogZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChpZCwgY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IgPSBjYW5jZWxsYWJsZShmdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gICAgICBzZWxmLkNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQub3B0aW9ucy5uYW1lIHx8IGlkO1xuICAgICAgc2VsZi5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgICBjYigpO1xuICAgIH0pO1xuICAgIHRoaXMudm0uX3Jlc29sdmVDb21wb25lbnQoaWQsIHRoaXMucGVuZGluZ0NvbXBvbmVudENiKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBjdXJyZW50IGNvbnN0cnVjdG9yIGFuZFxuICAgKiByZXBsYWNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS4gVGhpcyBtZXRob2QgZG9lc24ndCBjYXJlXG4gICAqIHdoZXRoZXIgdGhlIG5ldyBjb21wb25lbnQgYW5kIHRoZSBvbGQgb25lIGFyZSBhY3R1YWxseVxuICAgKiB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gbW91bnRDb21wb25lbnQoY2IpIHtcbiAgICAvLyBhY3R1YWwgbW91bnRcbiAgICB0aGlzLnVuYnVpbGQodHJ1ZSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhY3RpdmF0ZUhvb2sgPSB0aGlzLkNvbXBvbmVudC5vcHRpb25zLmFjdGl2YXRlO1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLmdldENhY2hlZCgpO1xuICAgIHZhciBuZXdDb21wb25lbnQgPSB0aGlzLmJ1aWxkKCk7XG4gICAgaWYgKGFjdGl2YXRlSG9vayAmJiAhY2FjaGVkKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IgPSBuZXdDb21wb25lbnQ7XG4gICAgICBhY3RpdmF0ZUhvb2suY2FsbChuZXdDb21wb25lbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYud2FpdGluZ0ZvciAhPT0gbmV3Q29tcG9uZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgICAgIHNlbGYudHJhbnNpdGlvbihuZXdDb21wb25lbnQsIGNiKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgcmVmIGZvciBrZXB0LWFsaXZlIGNvbXBvbmVudFxuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBuZXdDb21wb25lbnQuX3VwZGF0ZVJlZigpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2l0aW9uKG5ld0NvbXBvbmVudCwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgY29tcG9uZW50IGNoYW5nZXMgb3IgdW5iaW5kcyBiZWZvcmUgYW4gYXN5bmNcbiAgICogY29uc3RydWN0b3IgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG8gaW52YWxpZGF0ZSBpdHNcbiAgICogcGVuZGluZyBjYWxsYmFjay5cbiAgICovXG5cbiAgaW52YWxpZGF0ZVBlbmRpbmc6IGZ1bmN0aW9uIGludmFsaWRhdGVQZW5kaW5nKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb21wb25lbnRDYikge1xuICAgICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q2IuY2FuY2VsKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDb21wb25lbnRDYiA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZS9pbnNlcnQgYSBuZXcgY2hpbGQgdm0uXG4gICAqIElmIGtlZXAgYWxpdmUgYW5kIGhhcyBjYWNoZWQgaW5zdGFuY2UsIGluc2VydCB0aGF0XG4gICAqIGluc3RhbmNlOyBvdGhlcndpc2UgYnVpbGQgYSBuZXcgb25lIGFuZCBjYWNoZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRyYU9wdGlvbnNdXG4gICAqIEByZXR1cm4ge1Z1ZX0gLSB0aGUgY3JlYXRlZCBpbnN0YW5jZVxuICAgKi9cblxuICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZXh0cmFPcHRpb25zKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGVkKCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQ29tcG9uZW50KSB7XG4gICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBuYW1lOiB0aGlzLkNvbXBvbmVudE5hbWUsXG4gICAgICAgIGVsOiBjbG9uZU5vZGUodGhpcy5lbCksXG4gICAgICAgIHRlbXBsYXRlOiB0aGlzLmlubGluZVRlbXBsYXRlLFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYWRkIHRoZSBjaGlsZCB3aXRoIGNvcnJlY3QgcGFyZW50XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGl0cyBwYXJlbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRoZSB0cmFuc2NsdXNpb24gaG9zdC5cbiAgICAgICAgcGFyZW50OiB0aGlzLl9ob3N0IHx8IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIG5vIGlubGluZS10ZW1wbGF0ZSwgdGhlbiB0aGUgY29tcGlsZWRcbiAgICAgICAgLy8gbGlua2VyIGNhbiBiZSBjYWNoZWQgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAgX2xpbmtlckNhY2hhYmxlOiAhdGhpcy5pbmxpbmVUZW1wbGF0ZSxcbiAgICAgICAgX3JlZjogdGhpcy5kZXNjcmlwdG9yLnJlZixcbiAgICAgICAgX2FzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfaXNSb3V0ZXJWaWV3OiB0aGlzLl9pc1JvdXRlclZpZXcsXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSB0cmFuc2NsdWRlZCBjb21wb25lbnQsIGNvbnRleHRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGUgY29tbW9uIHBhcmVudCB2bSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICAgIC8vIGFuZCBpdHMgaG9zdC5cbiAgICAgICAgX2NvbnRleHQ6IHRoaXMudm0sXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgaW5zaWRlIGFuIGlubGluZSB2LWZvciwgdGhlIHNjb3BlXG4gICAgICAgIC8vIHdpbGwgYmUgdGhlIGludGVybWVkaWF0ZSBzY29wZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAgIC8vIHJlcGVhdCBmcmFnbWVudC4gdGhpcyBpcyB1c2VkIGZvciBsaW5raW5nIHByb3BzXG4gICAgICAgIC8vIGFuZCBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICAgICAgX3Njb3BlOiB0aGlzLl9zY29wZSxcbiAgICAgICAgLy8gcGFzcyBpbiB0aGUgb3duZXIgZnJhZ21lbnQgb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IHNvIHRoYXQgdGhlIGZyYWdtZW50IGNhbiBrZWVwXG4gICAgICAgIC8vIHRyYWNrIG9mIGl0cyBjb250YWluZWQgY29tcG9uZW50cyBpbiBvcmRlciB0b1xuICAgICAgICAvLyBjYWxsIGF0dGFjaC9kZXRhY2ggaG9va3MgZm9yIHRoZW0uXG4gICAgICAgIF9mcmFnOiB0aGlzLl9mcmFnXG4gICAgICB9O1xuICAgICAgLy8gZXh0cmEgb3B0aW9uc1xuICAgICAgLy8gaW4gMS4wLjAgdGhpcyBpcyB1c2VkIGJ5IHZ1ZS1yb3V0ZXIgb25seVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChvcHRpb25zLCBleHRyYU9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuQ29tcG9uZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICAgIHRoaXMuY2FjaGVbdGhpcy5Db21wb25lbnQuY2lkXSA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgndHJhbnNpdGlvbicpICYmIGNoaWxkLl9pc0ZyYWdtZW50KSB7XG4gICAgICAgIHdhcm4oJ1RyYW5zaXRpb25zIHdpbGwgbm90IHdvcmsgb24gYSBmcmFnbWVudCBpbnN0YW5jZS4gJyArICdUZW1wbGF0ZTogJyArIGNoaWxkLiRvcHRpb25zLnRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyeSB0byBnZXQgYSBjYWNoZWQgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtWdWV8dW5kZWZpbmVkfVxuICAgKi9cblxuICBnZXRDYWNoZWQ6IGZ1bmN0aW9uIGdldENhY2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5rZWVwQWxpdmUgJiYgdGhpcy5jYWNoZVt0aGlzLkNvbXBvbmVudC5jaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZWFyZG93biB0aGUgY3VycmVudCBjaGlsZCwgYnV0IGRlZmVycyBjbGVhbnVwIHNvXG4gICAqIHRoYXQgd2UgY2FuIHNlcGFyYXRlIHRoZSBkZXN0cm95IGFuZCByZW1vdmFsIHN0ZXBzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZmVyXG4gICAqL1xuXG4gIHVuYnVpbGQ6IGZ1bmN0aW9uIHVuYnVpbGQoZGVmZXIpIHtcbiAgICBpZiAodGhpcy53YWl0aW5nRm9yKSB7XG4gICAgICB0aGlzLndhaXRpbmdGb3IuJGRlc3Ryb3koKTtcbiAgICAgIHRoaXMud2FpdGluZ0ZvciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRWTTtcbiAgICBpZiAoIWNoaWxkIHx8IHRoaXMua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZlxuICAgICAgICBjaGlsZC5fdXBkYXRlUmVmKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB0aGUgc29sZSBwdXJwb3NlIG9mIGBkZWZlckNsZWFudXBgIGlzIHNvIHRoYXQgd2UgY2FuXG4gICAgLy8gXCJkZWFjdGl2YXRlXCIgdGhlIHZtIHJpZ2h0IG5vdyBhbmQgcGVyZm9ybSBET00gcmVtb3ZhbFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLiRkZXN0cm95KGZhbHNlLCBkZWZlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjdXJyZW50IGRlc3Ryb3llZCBjaGlsZCBhbmQgbWFudWFsbHkgZG9cbiAgICogdGhlIGNsZWFudXAgYWZ0ZXIgcmVtb3ZhbC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICovXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoY2hpbGQsIGNiKSB7XG4gICAgdmFyIGtlZXBBbGl2ZSA9IHRoaXMua2VlcEFsaXZlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgLy8gd2UgbWF5IGhhdmUgYSBjb21wb25lbnQgc3dpdGNoIHdoZW4gYSBwcmV2aW91c1xuICAgICAgLy8gY29tcG9uZW50IGlzIHN0aWxsIGJlaW5nIHRyYW5zaXRpb25lZCBvdXQuXG4gICAgICAvLyB3ZSB3YW50IHRvIHRyaWdnZXIgb25seSBvbmUgbGFzdGVzdCBpbnNlcnRpb24gY2JcbiAgICAgIC8vIHdoZW4gdGhlIGV4aXN0aW5nIHRyYW5zaXRpb24gZmluaXNoZXMuICgjMTExOSlcbiAgICAgIHRoaXMucGVuZGluZ1JlbW92YWxzKys7XG4gICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsQ2IgPSBjYjtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGNoaWxkLiRyZW1vdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFscy0tO1xuICAgICAgICBpZiAoIWtlZXBBbGl2ZSkgY2hpbGQuX2NsZWFudXAoKTtcbiAgICAgICAgaWYgKCFzZWxmLnBlbmRpbmdSZW1vdmFscyAmJiBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IpIHtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IoKTtcbiAgICAgICAgICBzZWxmLnBlbmRpbmdSZW1vdmFsQ2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWN0dWFsbHkgc3dhcCB0aGUgY29tcG9uZW50cywgZGVwZW5kaW5nIG9uIHRoZVxuICAgKiB0cmFuc2l0aW9uIG1vZGUuIERlZmF1bHRzIHRvIHNpbXVsdGFuZW91cy5cbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqL1xuXG4gIHRyYW5zaXRpb246IGZ1bmN0aW9uIHRyYW5zaXRpb24odGFyZ2V0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hpbGRWTTtcbiAgICAvLyBmb3IgZGV2dG9vbCBpbnNwZWN0aW9uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjdXJyZW50KSBjdXJyZW50Ll9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICB0YXJnZXQuX2luYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2hpbGRWTSA9IHRhcmdldDtcbiAgICBzd2l0Y2ggKHNlbGYucGFyYW1zLnRyYW5zaXRpb25Nb2RlKSB7XG4gICAgICBjYXNlICdpbi1vdXQnOlxuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3V0LWluJzpcbiAgICAgICAgc2VsZi5yZW1vdmUoY3VycmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC4kYmVmb3JlKHNlbGYuYW5jaG9yLCBjYik7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNlbGYucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICB0YXJnZXQuJGJlZm9yZShzZWxmLmFuY2hvciwgY2IpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVW5iaW5kLlxuICAgKi9cblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICB0aGlzLmludmFsaWRhdGVQZW5kaW5nKCk7XG4gICAgLy8gRG8gbm90IGRlZmVyIGNsZWFudXAgd2hlbiB1bmJpbmRpbmdcbiAgICB0aGlzLnVuYnVpbGQoKTtcbiAgICAvLyBkZXN0cm95IGFsbCBrZWVwLWFsaXZlIGNhY2hlZCBpbnN0YW5jZXNcbiAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldLiRkZXN0cm95KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2Q2xhc3MgPSB7XG5cbiAgZGVlcDogdHJ1ZSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmhhbmRsZU9iamVjdChzdHJpbmdUb09iamVjdCh2YWx1ZSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aGlzLmhhbmRsZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9LFxuXG4gIGhhbmRsZU9iamVjdDogZnVuY3Rpb24gaGFuZGxlT2JqZWN0KHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhbnVwKHZhbHVlKTtcbiAgICB2YXIga2V5cyA9IHRoaXMucHJldktleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLmVsLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlQXJyYXk6IGZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbHVlKSB7XG4gICAgdGhpcy5jbGVhbnVwKHZhbHVlKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuZWwsIHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wcmV2S2V5cyA9IHZhbHVlLnNsaWNlKCk7XG4gIH0sXG5cbiAgY2xlYW51cDogZnVuY3Rpb24gY2xlYW51cCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnByZXZLZXlzKSB7XG4gICAgICB2YXIgaSA9IHRoaXMucHJldktleXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5wcmV2S2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSAmJiAoIXZhbHVlIHx8ICFjb250YWlucyQxKHZhbHVlLCBrZXkpKSkge1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmluZ1RvT2JqZWN0KHZhbHVlKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGtleXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJlc1trZXlzW2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY29udGFpbnMkMSh2YWx1ZSwga2V5KSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmluZGV4T2Yoa2V5KSA+IC0xIDogaGFzT3duKHZhbHVlLCBrZXkpO1xufVxuXG52YXIgaW50ZXJuYWxEaXJlY3RpdmVzID0ge1xuICBzdHlsZTogc3R5bGUsXG4gICdjbGFzcyc6IHZDbGFzcyxcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIHByb3A6IHByb3BEZWYsXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbn07XG5cbnZhciBwcm9wQmluZGluZ01vZGVzID0gY29uZmlnLl9wcm9wQmluZGluZ01vZGVzO1xudmFyIGVtcHR5ID0ge307XG5cbi8vIHJlZ2V4ZXNcbnZhciBpZGVudFJFJDEgPSAvXlskX2EtekEtWl0rW1xcdyRdKiQvO1xudmFyIHNldHRhYmxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKihcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFtbXlxcW1xcXV0rXFxdKSokLztcblxuLyoqXG4gKiBDb21waWxlIHByb3BzIG9uIGEgcm9vdCBlbGVtZW50IGFuZCByZXR1cm5cbiAqIGEgcHJvcHMgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BPcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gcHJvcHNMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlUHJvcHMoZWwsIHByb3BPcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wT3B0aW9ucyk7XG4gIHZhciBpID0gbmFtZXMubGVuZ3RoO1xuICB2YXIgb3B0aW9ucywgbmFtZSwgYXR0ciwgdmFsdWUsIHBhdGgsIHBhcnNlZCwgcHJvcDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBvcHRpb25zID0gcHJvcE9wdGlvbnNbbmFtZV0gfHwgZW1wdHk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnJGRhdGEnKSB7XG4gICAgICB3YXJuKCdEbyBub3QgdXNlICRkYXRhIGFzIHByb3AuJyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBwcm9wcyBjb3VsZCBjb250YWluIGRhc2hlcywgd2hpY2ggd2lsbCBiZVxuICAgIC8vIGludGVycHJldGVkIGFzIG1pbnVzIGNhbGN1bGF0aW9ucyBieSB0aGUgcGFyc2VyXG4gICAgLy8gc28gd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUgcGF0aCBoZXJlXG4gICAgcGF0aCA9IGNhbWVsaXplKG5hbWUpO1xuICAgIGlmICghaWRlbnRSRSQxLnRlc3QocGF0aCkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCBwcm9wIGtleTogXCInICsgbmFtZSArICdcIi4gUHJvcCBrZXlzICcgKyAnbXVzdCBiZSB2YWxpZCBpZGVudGlmaWVycy4nKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb3AgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBtb2RlOiBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVksXG4gICAgICByYXc6IG51bGxcbiAgICB9O1xuXG4gICAgYXR0ciA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgICAvLyBmaXJzdCBjaGVjayBkeW5hbWljIHZlcnNpb25cbiAgICBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIpKSA9PT0gbnVsbCkge1xuICAgICAgaWYgKCh2YWx1ZSA9IGdldEJpbmRBdHRyKGVsLCBhdHRyICsgJy5zeW5jJykpICE9PSBudWxsKSB7XG4gICAgICAgIHByb3AubW9kZSA9IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWTtcbiAgICAgIH0gZWxzZSBpZiAoKHZhbHVlID0gZ2V0QmluZEF0dHIoZWwsIGF0dHIgKyAnLm9uY2UnKSkgIT09IG51bGwpIHtcbiAgICAgICAgcHJvcC5tb2RlID0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAvLyBoYXMgZHluYW1pYyBiaW5kaW5nIVxuICAgICAgcHJvcC5yYXcgPSB2YWx1ZTtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRGlyZWN0aXZlKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgICBwcm9wLmZpbHRlcnMgPSBwYXJzZWQuZmlsdGVycztcbiAgICAgIC8vIGNoZWNrIGJpbmRpbmcgdHlwZVxuICAgICAgaWYgKGlzTGl0ZXJhbCh2YWx1ZSkgJiYgIXBhcnNlZC5maWx0ZXJzKSB7XG4gICAgICAgIC8vIGZvciBleHByZXNzaW9ucyBjb250YWluaW5nIGxpdGVyYWwgbnVtYmVycyBhbmRcbiAgICAgICAgLy8gYm9vbGVhbnMsIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZXR1cCBhIHByb3AgYmluZGluZyxcbiAgICAgICAgLy8gc28gd2UgY2FuIG9wdGltaXplIHRoZW0gYXMgYSBvbmUtdGltZSBzZXQuXG4gICAgICAgIHByb3Aub3B0aW1pemVkTGl0ZXJhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmR5bmFtaWMgPSB0cnVlO1xuICAgICAgICAvLyBjaGVjayBub24tc2V0dGFibGUgcGF0aCBmb3IgdHdvLXdheSBiaW5kaW5nc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBwcm9wLm1vZGUgPT09IHByb3BCaW5kaW5nTW9kZXMuVFdPX1dBWSAmJiAhc2V0dGFibGVQYXRoUkUudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICBwcm9wLm1vZGUgPSBwcm9wQmluZGluZ01vZGVzLk9ORV9XQVk7XG4gICAgICAgICAgd2FybignQ2Fubm90IGJpbmQgdHdvLXdheSBwcm9wIHdpdGggbm9uLXNldHRhYmxlICcgKyAncGFyZW50IHBhdGg6ICcgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3AucGFyZW50UGF0aCA9IHZhbHVlO1xuXG4gICAgICAvLyB3YXJuIHJlcXVpcmVkIHR3by13YXlcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMudHdvV2F5ICYmIHByb3AubW9kZSAhPT0gcHJvcEJpbmRpbmdNb2Rlcy5UV09fV0FZKSB7XG4gICAgICAgIHdhcm4oJ1Byb3AgXCInICsgbmFtZSArICdcIiBleHBlY3RzIGEgdHdvLXdheSBiaW5kaW5nIHR5cGUuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgodmFsdWUgPSBnZXRBdHRyKGVsLCBhdHRyKSkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhcyBsaXRlcmFsIGJpbmRpbmchXG4gICAgICBwcm9wLnJhdyA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZXF1aXJlZCkge1xuICAgICAgLy8gd2FybiBtaXNzaW5nIHJlcXVpcmVkXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogJyArIG5hbWUpO1xuICAgIH1cbiAgICAvLyBwdXNoIHByb3BcbiAgICBwcm9wcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiBtYWtlUHJvcHNMaW5rRm4ocHJvcHMpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZnVuY3Rpb24gdGhhdCBhcHBsaWVzIHByb3BzIHRvIGEgdm0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBwcm9wc0xpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VQcm9wc0xpbmtGbihwcm9wcykge1xuICByZXR1cm4gZnVuY3Rpb24gcHJvcHNMaW5rRm4odm0sIHNjb3BlKSB7XG4gICAgLy8gc3RvcmUgcmVzb2x2ZWQgcHJvcHMgaW5mb1xuICAgIHZtLl9wcm9wcyA9IHt9O1xuICAgIHZhciBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHZhciBwcm9wLCBwYXRoLCBvcHRpb25zLCB2YWx1ZSwgcmF3O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHJhdyA9IHByb3AucmF3O1xuICAgICAgcGF0aCA9IHByb3AucGF0aDtcbiAgICAgIG9wdGlvbnMgPSBwcm9wLm9wdGlvbnM7XG4gICAgICB2bS5fcHJvcHNbcGF0aF0gPSBwcm9wO1xuICAgICAgaWYgKHJhdyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIGFic2VudCBwcm9wXG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCBnZXREZWZhdWx0KHZtLCBvcHRpb25zKSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgICAvLyBkeW5hbWljIHByb3BcbiAgICAgICAgaWYgKHZtLl9jb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHByb3AubW9kZSA9PT0gcHJvcEJpbmRpbmdNb2Rlcy5PTkVfVElNRSkge1xuICAgICAgICAgICAgLy8gb25lIHRpbWUgYmluZGluZ1xuICAgICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0uX2NvbnRleHQpLiRnZXQocHJvcC5wYXJlbnRQYXRoKTtcbiAgICAgICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGR5bmFtaWMgYmluZGluZ1xuICAgICAgICAgICAgdm0uX2JpbmREaXIoe1xuICAgICAgICAgICAgICBuYW1lOiAncHJvcCcsXG4gICAgICAgICAgICAgIGRlZjogcHJvcERlZixcbiAgICAgICAgICAgICAgcHJvcDogcHJvcFxuICAgICAgICAgICAgfSwgbnVsbCwgbnVsbCwgc2NvcGUpOyAvLyBlbCwgaG9zdCwgc2NvcGVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oJ0Nhbm5vdCBiaW5kIGR5bmFtaWMgcHJvcCBvbiBhIHJvb3QgaW5zdGFuY2UnICsgJyB3aXRoIG5vIHBhcmVudDogJyArIHByb3AubmFtZSArICc9XCInICsgcmF3ICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wLm9wdGltaXplZExpdGVyYWwpIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxpdGVyYWwsIGNhc3QgaXQgYW5kIGp1c3Qgc2V0IG9uY2VcbiAgICAgICAgdmFyIHN0cmlwcGVkID0gc3RyaXBRdW90ZXMocmF3KTtcbiAgICAgICAgdmFsdWUgPSBzdHJpcHBlZCA9PT0gcmF3ID8gdG9Cb29sZWFuKHRvTnVtYmVyKHJhdykpIDogc3RyaXBwZWQ7XG4gICAgICAgIGluaXRQcm9wKHZtLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbCwgYnV0IHdlIG5lZWQgdG8gY2F0ZXIgZm9yXG4gICAgICAgIC8vIEJvb2xlYW4gcHJvcHMgd2l0aCBubyB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMudHlwZSA9PT0gQm9vbGVhbiAmJiByYXcgPT09ICcnID8gdHJ1ZSA6IHJhdztcbiAgICAgICAgaW5pdFByb3Aodm0sIHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cbmZ1bmN0aW9uIGdldERlZmF1bHQodm0sIG9wdGlvbnMpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihvcHRpb25zLCAnZGVmYXVsdCcpKSB7XG4gICAgLy8gYWJzZW50IGJvb2xlYW4gdmFsdWUgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICByZXR1cm4gb3B0aW9ucy50eXBlID09PSBCb29sZWFuID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIGRlZiA9IG9wdGlvbnNbJ2RlZmF1bHQnXTtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignT2JqZWN0L0FycmF5IGFzIGRlZmF1bHQgcHJvcCB2YWx1ZXMgd2lsbCBiZSBzaGFyZWQgJyArICdhY3Jvc3MgbXVsdGlwbGUgaW5zdGFuY2VzLiBVc2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgKyAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlIGluc3RlYWQuJyk7XG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy50eXBlICE9PSBGdW5jdGlvbiA/IGRlZi5jYWxsKHZtKSA6IGRlZjtcbn1cblxuLy8gc3BlY2lhbCBiaW5kaW5nIHByZWZpeGVzXG52YXIgYmluZFJFID0gL152LWJpbmQ6fF46LztcbnZhciBvblJFID0gL152LW9uOnxeQC87XG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBtb2RpZmllclJFID0gL1xcLlteXFwuXSsvZztcbnZhciB0cmFuc2l0aW9uUkUgPSAvXih2LWJpbmQ6fDopP3RyYW5zaXRpb24kLztcblxuLy8gdGVybWluYWwgZGlyZWN0aXZlc1xudmFyIHRlcm1pbmFsRGlyZWN0aXZlcyA9IFsnZm9yJywgJ2lmJ107XG5cbi8vIGRlZmF1bHQgZGlyZWN0aXZlIHByaW9yaXR5XG52YXIgREVGQVVMVF9QUklPUklUWSA9IDEwMDA7XG5cbi8qKlxuICogQ29tcGlsZSBhIHRlbXBsYXRlIGFuZCByZXR1cm4gYSByZXVzYWJsZSBjb21wb3NpdGUgbGlua1xuICogZnVuY3Rpb24sIHdoaWNoIHJlY3Vyc2l2ZWx5IGNvbnRhaW5zIG1vcmUgbGluayBmdW5jdGlvbnNcbiAqIGluc2lkZS4gVGhpcyB0b3AgbGV2ZWwgY29tcGlsZSBmdW5jdGlvbiB3b3VsZCBub3JtYWxseVxuICogYmUgY2FsbGVkIG9uIGluc3RhbmNlIHJvb3Qgbm9kZXMsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkXG4gKiBmb3IgcGFydGlhbCBjb21waWxhdGlvbiBpZiB0aGUgcGFydGlhbCBhcmd1bWVudCBpcyB0cnVlLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjb21wb3NpdGUgbGluayBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGxcbiAqIHJldHVybiBhbiB1bmxpbmsgZnVuY3Rpb24gdGhhdCB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXNcbiAqIGNyZWF0ZWQgZHVyaW5nIHRoZSBsaW5raW5nIHBoYXNlLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFydGlhbFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZShlbCwgb3B0aW9ucywgcGFydGlhbCkge1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgbm9kZSBpdHNlbGYuXG4gIHZhciBub2RlTGlua0ZuID0gcGFydGlhbCB8fCAhb3B0aW9ucy5fYXNDb21wb25lbnQgPyBjb21waWxlTm9kZShlbCwgb3B0aW9ucykgOiBudWxsO1xuICAvLyBsaW5rIGZ1bmN0aW9uIGZvciB0aGUgY2hpbGROb2Rlc1xuICB2YXIgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgZWwudGFnTmFtZSAhPT0gJ1NDUklQVCcgJiYgZWwuaGFzQ2hpbGROb2RlcygpID8gY29tcGlsZU5vZGVMaXN0KGVsLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcblxuICAvKipcbiAgICogQSBjb21wb3NpdGUgbGlua2VyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhIGFscmVhZHlcbiAgICogY29tcGlsZWQgcGllY2Ugb2YgRE9NLCB3aGljaCBpbnN0YW50aWF0ZXMgYWxsIGRpcmVjdGl2ZVxuICAgKiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIGhvc3Qgdm0gb2YgdHJhbnNjbHVkZWQgY29udGVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIGxpbmsgY29udGV4dCBmcmFnbWVudFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21wb3NpdGVMaW5rRm4odm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICAgIC8vIGNhY2hlIGNoaWxkTm9kZXMgYmVmb3JlIGxpbmtpbmcgcGFyZW50LCBmaXggIzY1N1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShlbC5jaGlsZE5vZGVzKTtcbiAgICAvLyBsaW5rXG4gICAgdmFyIGRpcnMgPSBsaW5rQW5kQ2FwdHVyZShmdW5jdGlvbiBjb21wb3NpdGVMaW5rQ2FwdHVyZXIoKSB7XG4gICAgICBpZiAobm9kZUxpbmtGbikgbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICAgIGlmIChjaGlsZExpbmtGbikgY2hpbGRMaW5rRm4odm0sIGNoaWxkTm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgICB9LCB2bSk7XG4gICAgcmV0dXJuIG1ha2VVbmxpbmtGbih2bSwgZGlycyk7XG4gIH07XG59XG5cbi8qKlxuICogQXBwbHkgYSBsaW5rZXIgdG8gYSB2bS9lbGVtZW50IHBhaXIgYW5kIGNhcHR1cmUgdGhlXG4gKiBkaXJlY3RpdmVzIGNyZWF0ZWQgZHVyaW5nIHRoZSBwcm9jZXNzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpbmtlclxuICogQHBhcmFtIHtWdWV9IHZtXG4gKi9cblxuZnVuY3Rpb24gbGlua0FuZENhcHR1cmUobGlua2VyLCB2bSkge1xuICB2YXIgb3JpZ2luYWxEaXJDb3VudCA9IHZtLl9kaXJlY3RpdmVzLmxlbmd0aDtcbiAgbGlua2VyKCk7XG4gIHZhciBkaXJzID0gdm0uX2RpcmVjdGl2ZXMuc2xpY2Uob3JpZ2luYWxEaXJDb3VudCk7XG4gIGRpcnMuc29ydChkaXJlY3RpdmVDb21wYXJhdG9yKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpcnNbaV0uX2JpbmQoKTtcbiAgfVxuICByZXR1cm4gZGlycztcbn1cblxuLyoqXG4gKiBEaXJlY3RpdmUgcHJpb3JpdHkgc29ydCBjb21wYXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aXZlQ29tcGFyYXRvcihhLCBiKSB7XG4gIGEgPSBhLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIGIgPSBiLmRlc2NyaXB0b3IuZGVmLnByaW9yaXR5IHx8IERFRkFVTFRfUFJJT1JJVFk7XG4gIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuXG4vKipcbiAqIExpbmtlciBmdW5jdGlvbnMgcmV0dXJuIGFuIHVubGluayBmdW5jdGlvbiB0aGF0XG4gKiB0ZWFyc2Rvd24gYWxsIGRpcmVjdGl2ZXMgaW5zdGFuY2VzIGdlbmVyYXRlZCBkdXJpbmdcbiAqIHRoZSBwcm9jZXNzLlxuICpcbiAqIFdlIGNyZWF0ZSB1bmxpbmsgZnVuY3Rpb25zIHdpdGggb25seSB0aGUgbmVjZXNzYXJ5XG4gKiBpbmZvcm1hdGlvbiB0byBhdm9pZCByZXRhaW5pbmcgYWRkaXRpb25hbCBjbG9zdXJlcy5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7QXJyYXl9IGRpcnNcbiAqIEBwYXJhbSB7VnVlfSBbY29udGV4dF1cbiAqIEBwYXJhbSB7QXJyYXl9IFtjb250ZXh0RGlyc11cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIG1ha2VVbmxpbmtGbih2bSwgZGlycywgY29udGV4dCwgY29udGV4dERpcnMpIHtcbiAgZnVuY3Rpb24gdW5saW5rKGRlc3Ryb3lpbmcpIHtcbiAgICB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHREaXJzKSB7XG4gICAgICB0ZWFyZG93bkRpcnMoY29udGV4dCwgY29udGV4dERpcnMpO1xuICAgIH1cbiAgfVxuICAvLyBleHBvc2UgbGlua2VkIGRpcmVjdGl2ZXNcbiAgdW5saW5rLmRpcnMgPSBkaXJzO1xuICByZXR1cm4gdW5saW5rO1xufVxuXG4vKipcbiAqIFRlYXJkb3duIHBhcnRpYWwgbGlua2VkIGRpcmVjdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge0FycmF5fSBkaXJzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lpbmdcbiAqL1xuXG5mdW5jdGlvbiB0ZWFyZG93bkRpcnModm0sIGRpcnMsIGRlc3Ryb3lpbmcpIHtcbiAgdmFyIGkgPSBkaXJzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGRpcnNbaV0uX3RlYXJkb3duKCk7XG4gICAgaWYgKCFkZXN0cm95aW5nKSB7XG4gICAgICB2bS5fZGlyZWN0aXZlcy4kcmVtb3ZlKGRpcnNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgbGluayBwcm9wcyBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge1Z1ZX0gdm1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVBbmRMaW5rUHJvcHModm0sIGVsLCBwcm9wcywgc2NvcGUpIHtcbiAgdmFyIHByb3BzTGlua0ZuID0gY29tcGlsZVByb3BzKGVsLCBwcm9wcyk7XG4gIHZhciBwcm9wRGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9wc0xpbmtGbih2bSwgc2NvcGUpO1xuICB9LCB2bSk7XG4gIHJldHVybiBtYWtlVW5saW5rRm4odm0sIHByb3BEaXJzKTtcbn1cblxuLyoqXG4gKiBDb21waWxlIHRoZSByb290IGVsZW1lbnQgb2YgYW4gaW5zdGFuY2UuXG4gKlxuICogMS4gYXR0cnMgb24gY29udGV4dCBjb250YWluZXIgKGNvbnRleHQgc2NvcGUpXG4gKiAyLiBhdHRycyBvbiB0aGUgY29tcG9uZW50IHRlbXBsYXRlIHJvb3Qgbm9kZSwgaWZcbiAqICAgIHJlcGxhY2U6dHJ1ZSAoY2hpbGQgc2NvcGUpXG4gKlxuICogSWYgdGhpcyBpcyBhIGZyYWdtZW50IGluc3RhbmNlLCB3ZSBvbmx5IG5lZWQgdG8gY29tcGlsZSAxLlxuICpcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0T3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZVJvb3QoZWwsIG9wdGlvbnMsIGNvbnRleHRPcHRpb25zKSB7XG4gIHZhciBjb250YWluZXJBdHRycyA9IG9wdGlvbnMuX2NvbnRhaW5lckF0dHJzO1xuICB2YXIgcmVwbGFjZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnM7XG4gIHZhciBjb250ZXh0TGlua0ZuLCByZXBsYWNlckxpbmtGbjtcblxuICAvLyBvbmx5IG5lZWQgdG8gY29tcGlsZSBvdGhlciBhdHRyaWJ1dGVzIGZvclxuICAvLyBub24tZnJhZ21lbnQgaW5zdGFuY2VzXG4gIGlmIChlbC5ub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAvLyBmb3IgY29tcG9uZW50cywgY29udGFpbmVyIGFuZCByZXBsYWNlciBuZWVkIHRvIGJlXG4gICAgLy8gY29tcGlsZWQgc2VwYXJhdGVseSBhbmQgbGlua2VkIGluIGRpZmZlcmVudCBzY29wZXMuXG4gICAgaWYgKG9wdGlvbnMuX2FzQ29tcG9uZW50KSB7XG4gICAgICAvLyAyLiBjb250YWluZXIgYXR0cmlidXRlc1xuICAgICAgaWYgKGNvbnRhaW5lckF0dHJzICYmIGNvbnRleHRPcHRpb25zKSB7XG4gICAgICAgIGNvbnRleHRMaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhjb250YWluZXJBdHRycywgY29udGV4dE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGxhY2VyQXR0cnMpIHtcbiAgICAgICAgLy8gMy4gcmVwbGFjZXIgYXR0cmlidXRlc1xuICAgICAgICByZXBsYWNlckxpbmtGbiA9IGNvbXBpbGVEaXJlY3RpdmVzKHJlcGxhY2VyQXR0cnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub24tY29tcG9uZW50LCBqdXN0IGNvbXBpbGUgYXMgYSBub3JtYWwgZWxlbWVudC5cbiAgICAgIHJlcGxhY2VyTGlua0ZuID0gY29tcGlsZURpcmVjdGl2ZXMoZWwuYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29udGFpbmVyQXR0cnMpIHtcbiAgICAvLyB3YXJuIGNvbnRhaW5lciBkaXJlY3RpdmVzIGZvciBmcmFnbWVudCBpbnN0YW5jZXNcbiAgICB2YXIgbmFtZXMgPSBjb250YWluZXJBdHRycy5maWx0ZXIoZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8vIGFsbG93IHZ1ZS1sb2FkZXIvdnVlaWZ5IHNjb3BlZCBjc3MgYXR0cmlidXRlc1xuICAgICAgcmV0dXJuIGF0dHIubmFtZS5pbmRleE9mKCdfdi0nKSA8IDAgJiZcbiAgICAgIC8vIGFsbG93IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgIW9uUkUudGVzdChhdHRyLm5hbWUpICYmXG4gICAgICAvLyBhbGxvdyBzbG90c1xuICAgICAgYXR0ci5uYW1lICE9PSAnc2xvdCc7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIGF0dHIubmFtZSArICdcIic7XG4gICAgfSk7XG4gICAgaWYgKG5hbWVzLmxlbmd0aCkge1xuICAgICAgdmFyIHBsdXJhbCA9IG5hbWVzLmxlbmd0aCA+IDE7XG4gICAgICB3YXJuKCdBdHRyaWJ1dGUnICsgKHBsdXJhbCA/ICdzICcgOiAnICcpICsgbmFtZXMuam9pbignLCAnKSArIChwbHVyYWwgPyAnIGFyZScgOiAnIGlzJykgKyAnIGlnbm9yZWQgb24gY29tcG9uZW50ICcgKyAnPCcgKyBvcHRpb25zLmVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSArICc+IGJlY2F1c2UgJyArICd0aGUgY29tcG9uZW50IGlzIGEgZnJhZ21lbnQgaW5zdGFuY2U6ICcgKyAnaHR0cDovL3Z1ZWpzLm9yZy9ndWlkZS9jb21wb25lbnRzLmh0bWwjRnJhZ21lbnRfSW5zdGFuY2UnKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gcm9vdExpbmtGbih2bSwgZWwsIHNjb3BlKSB7XG4gICAgLy8gbGluayBjb250ZXh0IHNjb3BlIGRpcnNcbiAgICB2YXIgY29udGV4dCA9IHZtLl9jb250ZXh0O1xuICAgIHZhciBjb250ZXh0RGlycztcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0TGlua0ZuKSB7XG4gICAgICBjb250ZXh0RGlycyA9IGxpbmtBbmRDYXB0dXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dExpbmtGbihjb250ZXh0LCBlbCwgbnVsbCwgc2NvcGUpO1xuICAgICAgfSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gbGluayBzZWxmXG4gICAgdmFyIHNlbGZEaXJzID0gbGlua0FuZENhcHR1cmUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJlcGxhY2VyTGlua0ZuKSByZXBsYWNlckxpbmtGbih2bSwgZWwpO1xuICAgIH0sIHZtKTtcblxuICAgIC8vIHJldHVybiB0aGUgdW5saW5rIGZ1bmN0aW9uIHRoYXQgdGVhcnNkb3duIGNvbnRleHRcbiAgICAvLyBjb250YWluZXIgZGlyZWN0aXZlcy5cbiAgICByZXR1cm4gbWFrZVVubGlua0ZuKHZtLCBzZWxmRGlycywgY29udGV4dCwgY29udGV4dERpcnMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBub2RlIGFuZCByZXR1cm4gYSBub2RlTGlua0ZuIGJhc2VkIG9uIHRoZVxuICogbm9kZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9XG4gKi9cblxuZnVuY3Rpb24gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucykge1xuICB2YXIgdHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gIGlmICh0eXBlID09PSAxICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcpIHtcbiAgICByZXR1cm4gY29tcGlsZUVsZW1lbnQobm9kZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gMyAmJiBub2RlLmRhdGEudHJpbSgpKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBpbGUgYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlRWxlbWVudChlbCwgb3B0aW9ucykge1xuICAvLyBwcmVwcm9jZXNzIHRleHRhcmVhcy5cbiAgLy8gdGV4dGFyZWEgdHJlYXRzIGl0cyB0ZXh0IGNvbnRlbnQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vIGp1c3QgYmluZCBpdCBhcyBhbiBhdHRyIGRpcmVjdGl2ZSBmb3IgdmFsdWUuXG4gIGlmIChlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgdmFyIHRva2VucyA9IHBhcnNlVGV4dChlbC52YWx1ZSk7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCc6dmFsdWUnLCB0b2tlbnNUb0V4cCh0b2tlbnMpKTtcbiAgICAgIGVsLnZhbHVlID0gJyc7XG4gICAgfVxuICB9XG4gIHZhciBsaW5rRm47XG4gIHZhciBoYXNBdHRycyA9IGVsLmhhc0F0dHJpYnV0ZXMoKTtcbiAgLy8gY2hlY2sgdGVybWluYWwgZGlyZWN0aXZlcyAoZm9yICYgaWYpXG4gIGlmIChoYXNBdHRycykge1xuICAgIGxpbmtGbiA9IGNoZWNrVGVybWluYWxEaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBlbGVtZW50IGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBjaGVjayBjb21wb25lbnRcbiAgaWYgKCFsaW5rRm4pIHtcbiAgICBsaW5rRm4gPSBjaGVja0NvbXBvbmVudChlbCwgb3B0aW9ucyk7XG4gIH1cbiAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgaWYgKCFsaW5rRm4gJiYgaGFzQXR0cnMpIHtcbiAgICBsaW5rRm4gPSBjb21waWxlRGlyZWN0aXZlcyhlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbGlua0ZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSB0ZXh0Tm9kZSBhbmQgcmV0dXJuIGEgbm9kZUxpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb258bnVsbH0gdGV4dE5vZGVMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgb3B0aW9ucykge1xuICAvLyBza2lwIG1hcmtlZCB0ZXh0IG5vZGVzXG4gIGlmIChub2RlLl9za2lwKSB7XG4gICAgcmV0dXJuIHJlbW92ZVRleHQ7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KG5vZGUud2hvbGVUZXh0KTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIG1hcmsgYWRqYWNlbnQgdGV4dCBub2RlcyBhcyBza2lwcGVkLFxuICAvLyBiZWNhdXNlIHdlIGFyZSB1c2luZyBub2RlLndob2xlVGV4dCB0byBjb21waWxlXG4gIC8vIGFsbCBhZGphY2VudCB0ZXh0IG5vZGVzIHRvZ2V0aGVyLiBUaGlzIGZpeGVzXG4gIC8vIGlzc3VlcyBpbiBJRSB3aGVyZSBzb21ldGltZXMgaXQgc3BsaXRzIHVwIGEgc2luZ2xlXG4gIC8vIHRleHQgbm9kZSBpbnRvIG11bHRpcGxlIG9uZXMuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSA9PT0gMykge1xuICAgIG5leHQuX3NraXAgPSB0cnVlO1xuICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHZhciBlbCwgdG9rZW47XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGVsID0gdG9rZW4udGFnID8gcHJvY2Vzc1RleHRUb2tlbih0b2tlbiwgb3B0aW9ucykgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gIH1cbiAgcmV0dXJuIG1ha2VUZXh0Tm9kZUxpbmtGbih0b2tlbnMsIGZyYWcsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIExpbmtlciBmb3IgYW4gc2tpcHBlZCB0ZXh0IG5vZGUuXG4gKlxuICogQHBhcmFtIHtWdWV9IHZtXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVUZXh0KHZtLCBub2RlKSB7XG4gIHJlbW92ZShub2RlKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIHRleHQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBwcm9jZXNzVGV4dFRva2VuKHRva2VuLCBvcHRpb25zKSB7XG4gIHZhciBlbDtcbiAgaWYgKHRva2VuLm9uZVRpbWUpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd2LWh0bWwnKTtcbiAgICAgIHNldFRva2VuVHlwZSgnaHRtbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJRSB3aWxsIGNsZWFuIHVwIGVtcHR5IHRleHROb2RlcyBkdXJpbmdcbiAgICAgIC8vIGZyYWcuY2xvbmVOb2RlKHRydWUpLCBzbyB3ZSBoYXZlIHRvIGdpdmUgaXRcbiAgICAgIC8vIHNvbWV0aGluZyBoZXJlLi4uXG4gICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICBzZXRUb2tlblR5cGUoJ3RleHQnKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0VG9rZW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodG9rZW4uZGVzY3JpcHRvcikgcmV0dXJuO1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh0b2tlbi52YWx1ZSk7XG4gICAgdG9rZW4uZGVzY3JpcHRvciA9IHtcbiAgICAgIG5hbWU6IHR5cGUsXG4gICAgICBkZWY6IHB1YmxpY0RpcmVjdGl2ZXNbdHlwZV0sXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQuZXhwcmVzc2lvbixcbiAgICAgIGZpbHRlcnM6IHBhcnNlZC5maWx0ZXJzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbi8qKlxuICogQnVpbGQgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHRleHROb2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gdG9rZW5zXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdcbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGV4dE5vZGVMaW5rRm4odG9rZW5zLCBmcmFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0ZXh0Tm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlKSB7XG4gICAgdmFyIGZyYWdDbG9uZSA9IGZyYWcuY2xvbmVOb2RlKHRydWUpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShmcmFnQ2xvbmUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIHRva2VuLCB2YWx1ZSwgbm9kZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGlmICh0b2tlbi50YWcpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIGlmICh0b2tlbi5vbmVUaW1lKSB7XG4gICAgICAgICAgdmFsdWUgPSAoc2NvcGUgfHwgdm0pLiRldmFsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodG9rZW4uaHRtbCkge1xuICAgICAgICAgICAgcmVwbGFjZShub2RlLCBwYXJzZVRlbXBsYXRlKHZhbHVlLCB0cnVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bS5fYmluZERpcih0b2tlbi5kZXNjcmlwdG9yLCBub2RlLCBob3N0LCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShlbCwgZnJhZ0Nsb25lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgbm9kZSBsaXN0IGFuZCByZXR1cm4gYSBjaGlsZExpbmtGbi5cbiAqXG4gKiBAcGFyYW0ge05vZGVMaXN0fSBub2RlTGlzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlTm9kZUxpc3Qobm9kZUxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGxpbmtGbnMgPSBbXTtcbiAgdmFyIG5vZGVMaW5rRm4sIGNoaWxkTGlua0ZuLCBub2RlO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5vZGUgPSBub2RlTGlzdFtpXTtcbiAgICBub2RlTGlua0ZuID0gY29tcGlsZU5vZGUobm9kZSwgb3B0aW9ucyk7XG4gICAgY2hpbGRMaW5rRm4gPSAhKG5vZGVMaW5rRm4gJiYgbm9kZUxpbmtGbi50ZXJtaW5hbCkgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJyAmJiBub2RlLmhhc0NoaWxkTm9kZXMoKSA/IGNvbXBpbGVOb2RlTGlzdChub2RlLmNoaWxkTm9kZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgICBsaW5rRm5zLnB1c2gobm9kZUxpbmtGbiwgY2hpbGRMaW5rRm4pO1xuICB9XG4gIHJldHVybiBsaW5rRm5zLmxlbmd0aCA/IG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSA6IG51bGw7XG59XG5cbi8qKlxuICogTWFrZSBhIGNoaWxkIGxpbmsgZnVuY3Rpb24gZm9yIGEgbm9kZSdzIGNoaWxkTm9kZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxGdW5jdGlvbj59IGxpbmtGbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjaGlsZExpbmtGblxuICovXG5cbmZ1bmN0aW9uIG1ha2VDaGlsZExpbmtGbihsaW5rRm5zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGlsZExpbmtGbih2bSwgbm9kZXMsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgdmFyIG5vZGUsIG5vZGVMaW5rRm4sIGNoaWxkcmVuTGlua0ZuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gMCwgbCA9IGxpbmtGbnMubGVuZ3RoOyBpIDwgbDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICBub2RlTGlua0ZuID0gbGlua0Zuc1tpKytdO1xuICAgICAgY2hpbGRyZW5MaW5rRm4gPSBsaW5rRm5zW2krK107XG4gICAgICAvLyBjYWNoZSBjaGlsZE5vZGVzIGJlZm9yZSBsaW5raW5nIHBhcmVudCwgZml4ICM2NTdcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgaWYgKG5vZGVMaW5rRm4pIHtcbiAgICAgICAgbm9kZUxpbmtGbih2bSwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkcmVuTGlua0ZuKSB7XG4gICAgICAgIGNoaWxkcmVuTGlua0ZuKHZtLCBjaGlsZE5vZGVzLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBlbGVtZW50IGRpcmVjdGl2ZXMgKGN1c3RvbSBlbGVtZW50cyB0aGF0IHNob3VsZFxuICogYmUgcmVzb3ZsZWQgYXMgdGVybWluYWwgZGlyZWN0aXZlcykuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBjaGVja0VsZW1lbnREaXJlY3RpdmVzKGVsLCBvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChjb21tb25UYWdSRS50ZXN0KHRhZykpIHJldHVybjtcbiAgLy8gc3BlY2lhbCBjYXNlOiBnaXZlIG5hbWVkIHNsb3QgYSBoaWdoZXIgcHJpb3JpdHlcbiAgLy8gdGhhbiB1bm5hbWVkIHNsb3RzXG4gIGlmICh0YWcgPT09ICdzbG90JyAmJiBoYXNCaW5kQXR0cihlbCwgJ25hbWUnKSkge1xuICAgIHRhZyA9ICdfbmFtZWRTbG90JztcbiAgfVxuICB2YXIgZGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdlbGVtZW50RGlyZWN0aXZlcycsIHRhZyk7XG4gIGlmIChkZWYpIHtcbiAgICByZXR1cm4gbWFrZVRlcm1pbmFsTm9kZUxpbmtGbihlbCwgdGFnLCAnJywgb3B0aW9ucywgZGVmKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQuIElmIHllcywgcmV0dXJuXG4gKiBhIGNvbXBvbmVudCBsaW5rIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gKi9cblxuZnVuY3Rpb24gY2hlY2tDb21wb25lbnQoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbXBvbmVudCA9IGNoZWNrQ29tcG9uZW50QXR0cihlbCwgb3B0aW9ucyk7XG4gIGlmIChjb21wb25lbnQpIHtcbiAgICB2YXIgcmVmID0gZmluZFJlZihlbCk7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB7XG4gICAgICBuYW1lOiAnY29tcG9uZW50JyxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZXhwcmVzc2lvbjogY29tcG9uZW50LmlkLFxuICAgICAgZGVmOiBpbnRlcm5hbERpcmVjdGl2ZXMuY29tcG9uZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIGxpdGVyYWw6ICFjb21wb25lbnQuZHluYW1pY1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudExpbmtGbiA9IGZ1bmN0aW9uIGNvbXBvbmVudExpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKChzY29wZSB8fCB2bSkuJHJlZnMsIHJlZiwgbnVsbCk7XG4gICAgICB9XG4gICAgICB2bS5fYmluZERpcihkZXNjcmlwdG9yLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH07XG4gICAgY29tcG9uZW50TGlua0ZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgICByZXR1cm4gY29tcG9uZW50TGlua0ZuO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYW4gZWxlbWVudCBmb3IgdGVybWluYWwgZGlyZWN0aXZlcyBpbiBmaXhlZCBvcmRlci5cbiAqIElmIGl0IGZpbmRzIG9uZSwgcmV0dXJuIGEgdGVybWluYWwgbGluayBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259IHRlcm1pbmFsTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbERpcmVjdGl2ZXMoZWwsIG9wdGlvbnMpIHtcbiAgLy8gc2tpcCB2LXByZVxuICBpZiAoZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc2tpcDtcbiAgfVxuICAvLyBza2lwIHYtZWxzZSBibG9jaywgYnV0IG9ubHkgaWYgZm9sbG93aW5nIHYtaWZcbiAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndi1lbHNlJykpIHtcbiAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgaWYgKHByZXYgJiYgcHJldi5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgcmV0dXJuIHNraXA7XG4gICAgfVxuICB9XG4gIHZhciB2YWx1ZSwgZGlyTmFtZTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB0ZXJtaW5hbERpcmVjdGl2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyTmFtZSA9IHRlcm1pbmFsRGlyZWN0aXZlc1tpXTtcbiAgICB2YWx1ZSA9IGVsLmdldEF0dHJpYnV0ZSgndi0nICsgZGlyTmFtZSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNraXAoKSB7fVxuc2tpcC50ZXJtaW5hbCA9IHRydWU7XG5cbi8qKlxuICogQnVpbGQgYSBub2RlIGxpbmsgZnVuY3Rpb24gZm9yIGEgdGVybWluYWwgZGlyZWN0aXZlLlxuICogQSB0ZXJtaW5hbCBsaW5rIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgdGhlIGN1cnJlbnRcbiAqIGNvbXBpbGF0aW9uIHJlY3Vyc2lvbiBhbmQgaGFuZGxlcyBjb21waWxhdGlvbiBvZiB0aGVcbiAqIHN1YnRyZWUgaW4gdGhlIGRpcmVjdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtkZWZdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGVybWluYWxMaW5rRm5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGVybWluYWxOb2RlTGlua0ZuKGVsLCBkaXJOYW1lLCB2YWx1ZSwgb3B0aW9ucywgZGVmKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gIHZhciBkZXNjcmlwdG9yID0ge1xuICAgIG5hbWU6IGRpck5hbWUsXG4gICAgZXhwcmVzc2lvbjogcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgZmlsdGVyczogcGFyc2VkLmZpbHRlcnMsXG4gICAgcmF3OiB2YWx1ZSxcbiAgICAvLyBlaXRoZXIgYW4gZWxlbWVudCBkaXJlY3RpdmUsIG9yIGlmL2ZvclxuICAgIGRlZjogZGVmIHx8IHB1YmxpY0RpcmVjdGl2ZXNbZGlyTmFtZV1cbiAgfTtcbiAgLy8gY2hlY2sgcmVmIGZvciB2LWZvciBhbmQgcm91dGVyLXZpZXdcbiAgaWYgKGRpck5hbWUgPT09ICdmb3InIHx8IGRpck5hbWUgPT09ICdyb3V0ZXItdmlldycpIHtcbiAgICBkZXNjcmlwdG9yLnJlZiA9IGZpbmRSZWYoZWwpO1xuICB9XG4gIHZhciBmbiA9IGZ1bmN0aW9uIHRlcm1pbmFsTm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgaWYgKGRlc2NyaXB0b3IucmVmKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSgoc2NvcGUgfHwgdm0pLiRyZWZzLCBkZXNjcmlwdG9yLnJlZiwgbnVsbCk7XG4gICAgfVxuICAgIHZtLl9iaW5kRGlyKGRlc2NyaXB0b3IsIGVsLCBob3N0LCBzY29wZSwgZnJhZyk7XG4gIH07XG4gIGZuLnRlcm1pbmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIENvbXBpbGUgdGhlIGRpcmVjdGl2ZXMgb24gYW4gZWxlbWVudCBhbmQgcmV0dXJuIGEgbGlua2VyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfSBhdHRyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVEaXJlY3RpdmVzKGF0dHJzLCBvcHRpb25zKSB7XG4gIHZhciBpID0gYXR0cnMubGVuZ3RoO1xuICB2YXIgZGlycyA9IFtdO1xuICB2YXIgYXR0ciwgbmFtZSwgdmFsdWUsIHJhd05hbWUsIHJhd1ZhbHVlLCBkaXJOYW1lLCBhcmcsIG1vZGlmaWVycywgZGlyRGVmLCB0b2tlbnM7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgbmFtZSA9IHJhd05hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFsdWUgPSByYXdWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgdG9rZW5zID0gcGFyc2VUZXh0KHZhbHVlKTtcbiAgICAvLyByZXNldCBhcmdcbiAgICBhcmcgPSBudWxsO1xuICAgIC8vIGNoZWNrIG1vZGlmaWVyc1xuICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuXG4gICAgLy8gYXR0cmlidXRlIGludGVycG9sYXRpb25zXG4gICAgaWYgKHRva2Vucykge1xuICAgICAgdmFsdWUgPSB0b2tlbnNUb0V4cCh0b2tlbnMpO1xuICAgICAgYXJnID0gbmFtZTtcbiAgICAgIHB1c2hEaXIoJ2JpbmQnLCBwdWJsaWNEaXJlY3RpdmVzLmJpbmQsIHRva2Vucyk7XG4gICAgICAvLyB3YXJuIGFnYWluc3QgbWl4aW5nIG11c3RhY2hlcyB3aXRoIHYtYmluZFxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci5uYW1lID09PSAnOmNsYXNzJyB8fCBhdHRyLm5hbWUgPT09ICd2LWJpbmQ6Y2xhc3MnO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHdhcm4oJ2NsYXNzPVwiJyArIHJhd1ZhbHVlICsgJ1wiOiBEbyBub3QgbWl4IG11c3RhY2hlIGludGVycG9sYXRpb24gJyArICdhbmQgdi1iaW5kIGZvciBcImNsYXNzXCIgb24gdGhlIHNhbWUgZWxlbWVudC4gVXNlIG9uZSBvciB0aGUgb3RoZXIuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2VcblxuICAgICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGU6IHRyYW5zaXRpb25cbiAgICAgIGlmICh0cmFuc2l0aW9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICBtb2RpZmllcnMubGl0ZXJhbCA9ICFiaW5kUkUudGVzdChuYW1lKTtcbiAgICAgICAgcHVzaERpcigndHJhbnNpdGlvbicsIGludGVybmFsRGlyZWN0aXZlcy50cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZVxuXG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBhcmcgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIHB1c2hEaXIoJ29uJywgcHVibGljRGlyZWN0aXZlcy5vbik7XG4gICAgICAgIH0gZWxzZVxuXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGJpbmRpbmdzXG4gICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBkaXJOYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdzdHlsZScgfHwgZGlyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGludGVybmFsRGlyZWN0aXZlc1tkaXJOYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcmcgPSBkaXJOYW1lO1xuICAgICAgICAgICAgICBwdXNoRGlyKCdiaW5kJywgcHVibGljRGlyZWN0aXZlcy5iaW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcblxuICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoJ3YtJykgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgYXJnXG4gICAgICAgICAgICAgIGFyZyA9IChhcmcgPSBuYW1lLm1hdGNoKGFyZ1JFKSkgJiYgYXJnWzFdO1xuICAgICAgICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShhcmdSRSwgJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4dHJhY3QgZGlyZWN0aXZlIG5hbWVcbiAgICAgICAgICAgICAgZGlyTmFtZSA9IG5hbWUuc2xpY2UoMik7XG5cbiAgICAgICAgICAgICAgLy8gc2tpcCB2LWVsc2UgKHdoZW4gdXNlZCB3aXRoIHYtc2hvdylcbiAgICAgICAgICAgICAgaWYgKGRpck5hbWUgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlyRGVmID0gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyTmFtZSk7XG5cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBc3NldChkaXJEZWYsICdkaXJlY3RpdmUnLCBkaXJOYW1lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkaXJEZWYpIHtcbiAgICAgICAgICAgICAgICBwdXNoRGlyKGRpck5hbWUsIGRpckRlZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gZGVmXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtpbnRlcnBUb2tlbnNdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHB1c2hEaXIoZGlyTmFtZSwgZGVmLCBpbnRlcnBUb2tlbnMpIHtcbiAgICB2YXIgaGFzT25lVGltZVRva2VuID0gaW50ZXJwVG9rZW5zICYmIGhhc09uZVRpbWUoaW50ZXJwVG9rZW5zKTtcbiAgICB2YXIgcGFyc2VkID0gIWhhc09uZVRpbWVUb2tlbiAmJiBwYXJzZURpcmVjdGl2ZSh2YWx1ZSk7XG4gICAgZGlycy5wdXNoKHtcbiAgICAgIG5hbWU6IGRpck5hbWUsXG4gICAgICBhdHRyOiByYXdOYW1lLFxuICAgICAgcmF3OiByYXdWYWx1ZSxcbiAgICAgIGRlZjogZGVmLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBtb2RpZmllcnM6IG1vZGlmaWVycyxcbiAgICAgIC8vIGNvbnZlcnNpb24gZnJvbSBpbnRlcnBvbGF0aW9uIHN0cmluZ3Mgd2l0aCBvbmUtdGltZSB0b2tlblxuICAgICAgLy8gdG8gZXhwcmVzc2lvbiBpcyBkaWZmZXJlZCB1bnRpbCBkaXJlY3RpdmUgYmluZCB0aW1lIHNvIHRoYXQgd2VcbiAgICAgIC8vIGhhdmUgYWNjZXNzIHRvIHRoZSBhY3R1YWwgdm0gY29udGV4dCBmb3Igb25lLXRpbWUgYmluZGluZ3MuXG4gICAgICBleHByZXNzaW9uOiBwYXJzZWQgJiYgcGFyc2VkLmV4cHJlc3Npb24sXG4gICAgICBmaWx0ZXJzOiBwYXJzZWQgJiYgcGFyc2VkLmZpbHRlcnMsXG4gICAgICBpbnRlcnA6IGludGVycFRva2VucyxcbiAgICAgIGhhc09uZVRpbWU6IGhhc09uZVRpbWVUb2tlblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGRpcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG1ha2VOb2RlTGlua0ZuKGRpcnMpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgbW9kaWZpZXJzIGZyb20gZGlyZWN0aXZlIGF0dHJpYnV0ZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMobmFtZSkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGkgPSBtYXRjaC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcmVzW21hdGNoW2ldLnNsaWNlKDEpXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQnVpbGQgYSBsaW5rIGZ1bmN0aW9uIGZvciBhbGwgZGlyZWN0aXZlcyBvbiBhIHNpbmdsZSBub2RlLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBkaXJlY3RpdmVzTGlua0ZuXG4gKi9cblxuZnVuY3Rpb24gbWFrZU5vZGVMaW5rRm4oZGlyZWN0aXZlcykge1xuICByZXR1cm4gZnVuY3Rpb24gbm9kZUxpbmtGbih2bSwgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKSB7XG4gICAgLy8gcmV2ZXJzZSBhcHBseSBiZWNhdXNlIGl0J3Mgc29ydGVkIGxvdyB0byBoaWdoXG4gICAgdmFyIGkgPSBkaXJlY3RpdmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fYmluZERpcihkaXJlY3RpdmVzW2ldLCBlbCwgaG9zdCwgc2NvcGUsIGZyYWcpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBpbnRlcnBvbGF0aW9uIHN0cmluZyBjb250YWlucyBvbmUtdGltZSB0b2tlbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGhhc09uZVRpbWUodG9rZW5zKSB7XG4gIHZhciBpID0gdG9rZW5zLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmICh0b2tlbnNbaV0ub25lVGltZSkgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIHNwZWNpYWxDaGFyUkUgPSAvW15cXHdcXC06XFwuXS87XG5cbi8qKlxuICogUHJvY2VzcyBhbiBlbGVtZW50IG9yIGEgRG9jdW1lbnRGcmFnbWVudCBiYXNlZCBvbiBhXG4gKiBpbnN0YW5jZSBvcHRpb24gb2JqZWN0LiBUaGlzIGFsbG93cyB1cyB0byB0cmFuc2NsdWRlXG4gKiBhIHRlbXBsYXRlIG5vZGUvZnJhZ21lbnQgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBjcmVhdGVkLFxuICogc28gdGhlIHByb2Nlc3NlZCBmcmFnbWVudCBjYW4gdGhlbiBiZSBjbG9uZWQgYW5kIHJldXNlZFxuICogaW4gdi1mb3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKSB7XG4gIC8vIGV4dHJhY3QgY29udGFpbmVyIGF0dHJpYnV0ZXMgdG8gcGFzcyB0aGVtIGRvd25cbiAgLy8gdG8gY29tcGlsZXIsIGJlY2F1c2UgdGhleSBuZWVkIHRvIGJlIGNvbXBpbGVkIGluXG4gIC8vIHBhcmVudCBzY29wZS4gd2UgYXJlIG11dGF0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBoZXJlXG4gIC8vIGFzc3VtaW5nIHRoZSBzYW1lIG9iamVjdCB3aWxsIGJlIHVzZWQgZm9yIGNvbXBpbGVcbiAgLy8gcmlnaHQgYWZ0ZXIgdGhpcy5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLl9jb250YWluZXJBdHRycyA9IGV4dHJhY3RBdHRycyhlbCk7XG4gIH1cbiAgLy8gZm9yIHRlbXBsYXRlIHRhZ3MsIHdoYXQgd2Ugd2FudCBpcyBpdHMgY29udGVudCBhc1xuICAvLyBhIGRvY3VtZW50RnJhZ21lbnQgKGZvciBmcmFnbWVudCBpbnN0YW5jZXMpXG4gIGlmIChpc1RlbXBsYXRlKGVsKSkge1xuICAgIGVsID0gcGFyc2VUZW1wbGF0ZShlbCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQgJiYgIW9wdGlvbnMudGVtcGxhdGUpIHtcbiAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSAnPHNsb3Q+PC9zbG90Pic7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbXBsYXRlKSB7XG4gICAgICBvcHRpb25zLl9jb250ZW50ID0gZXh0cmFjdENvbnRlbnQoZWwpO1xuICAgICAgZWwgPSB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgLy8gYW5jaG9ycyBmb3IgZnJhZ21lbnQgaW5zdGFuY2VcbiAgICAvLyBwYXNzaW5nIGluIGBwZXJzaXN0OiB0cnVlYCB0byBhdm9pZCB0aGVtIGJlaW5nXG4gICAgLy8gZGlzY2FyZGVkIGJ5IElFIGR1cmluZyB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgcHJlcGVuZChjcmVhdGVBbmNob3IoJ3Ytc3RhcnQnLCB0cnVlKSwgZWwpO1xuICAgIGVsLmFwcGVuZENoaWxkKGNyZWF0ZUFuY2hvcigndi1lbmQnLCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlIG9wdGlvbi5cbiAqIElmIHRoZSByZXBsYWNlIG9wdGlvbiBpcyB0cnVlIHRoaXMgd2lsbCBzd2FwIHRoZSAkZWwuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2NsdWRlVGVtcGxhdGUoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgdmFyIGZyYWcgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0cnVlKTtcbiAgaWYgKGZyYWcpIHtcbiAgICB2YXIgcmVwbGFjZXIgPSBmcmFnLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHRhZyA9IHJlcGxhY2VyLnRhZ05hbWUgJiYgcmVwbGFjZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignWW91IGFyZSBtb3VudGluZyBhbiBpbnN0YW5jZSB3aXRoIGEgdGVtcGxhdGUgdG8gJyArICc8Ym9keT4uIFRoaXMgd2lsbCByZXBsYWNlIDxib2R5PiBlbnRpcmVseS4gWW91ICcgKyAnc2hvdWxkIHByb2JhYmx5IHVzZSBgcmVwbGFjZTogZmFsc2VgIGhlcmUuJyk7XG4gICAgICB9XG4gICAgICAvLyB0aGVyZSBhcmUgbWFueSBjYXNlcyB3aGVyZSB0aGUgaW5zdGFuY2UgbXVzdFxuICAgICAgLy8gYmVjb21lIGEgZnJhZ21lbnQgaW5zdGFuY2U6IGJhc2ljYWxseSBhbnl0aGluZyB0aGF0XG4gICAgICAvLyBjYW4gY3JlYXRlIG1vcmUgdGhhbiAxIHJvb3Qgbm9kZXMuXG4gICAgICBpZiAoXG4gICAgICAvLyBtdWx0aS1jaGlsZHJlbiB0ZW1wbGF0ZVxuICAgICAgZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEgfHxcbiAgICAgIC8vIG5vbi1lbGVtZW50IHRlbXBsYXRlXG4gICAgICByZXBsYWNlci5ub2RlVHlwZSAhPT0gMSB8fFxuICAgICAgLy8gc2luZ2xlIG5lc3RlZCBjb21wb25lbnRcbiAgICAgIHRhZyA9PT0gJ2NvbXBvbmVudCcgfHwgcmVzb2x2ZUFzc2V0KG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSB8fCBoYXNCaW5kQXR0cihyZXBsYWNlciwgJ2lzJykgfHxcbiAgICAgIC8vIGVsZW1lbnQgZGlyZWN0aXZlXG4gICAgICByZXNvbHZlQXNzZXQob3B0aW9ucywgJ2VsZW1lbnREaXJlY3RpdmVzJywgdGFnKSB8fFxuICAgICAgLy8gZm9yIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtZm9yJykgfHxcbiAgICAgIC8vIGlmIGJsb2NrXG4gICAgICByZXBsYWNlci5oYXNBdHRyaWJ1dGUoJ3YtaWYnKSkge1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuX3JlcGxhY2VyQXR0cnMgPSBleHRyYWN0QXR0cnMocmVwbGFjZXIpO1xuICAgICAgICBtZXJnZUF0dHJzKGVsLCByZXBsYWNlcik7XG4gICAgICAgIHJldHVybiByZXBsYWNlcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignSW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246ICcgKyB0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBhIGNvbXBvbmVudCBjb250YWluZXIncyBhdHRyaWJ1dGVzXG4gKiBpbnRvIGEgcGxhaW4gb2JqZWN0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RBdHRycyhlbCkge1xuICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZWwuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZWwuYXR0cmlidXRlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0aGUgYXR0cmlidXRlcyBvZiB0d28gZWxlbWVudHMsIGFuZCBtYWtlIHN1cmVcbiAqIHRoZSBjbGFzcyBuYW1lcyBhcmUgbWVyZ2VkIHByb3Blcmx5LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbVxuICogQHBhcmFtIHtFbGVtZW50fSB0b1xuICovXG5cbmZ1bmN0aW9uIG1lcmdlQXR0cnMoZnJvbSwgdG8pIHtcbiAgdmFyIGF0dHJzID0gZnJvbS5hdHRyaWJ1dGVzO1xuICB2YXIgaSA9IGF0dHJzLmxlbmd0aDtcbiAgdmFyIG5hbWUsIHZhbHVlO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgdmFsdWUgPSBhdHRyc1tpXS52YWx1ZTtcbiAgICBpZiAoIXRvLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhc3BlY2lhbENoYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICB0by5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJyAmJiAhcGFyc2VUZXh0KHZhbHVlKSkge1xuICAgICAgdmFsdWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgYWRkQ2xhc3ModG8sIGNscyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGNvbXBpbGVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNvbXBpbGU6IGNvbXBpbGUsXG5cdGNvbXBpbGVBbmRMaW5rUHJvcHM6IGNvbXBpbGVBbmRMaW5rUHJvcHMsXG5cdGNvbXBpbGVSb290OiBjb21waWxlUm9vdCxcblx0dGVybWluYWxEaXJlY3RpdmVzOiB0ZXJtaW5hbERpcmVjdGl2ZXMsXG5cdHRyYW5zY2x1ZGU6IHRyYW5zY2x1ZGVcbn0pO1xuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcblxuICAvKipcbiAgICogQWNjZXNzb3IgZm9yIGAkZGF0YWAgcHJvcGVydHksIHNpbmNlIHNldHRpbmcgJGRhdGFcbiAgICogcmVxdWlyZXMgb2JzZXJ2aW5nIHRoZSBuZXcgb2JqZWN0IGFuZCB1cGRhdGluZ1xuICAgKiBwcm94aWVkIHByb3BlcnRpZXMuXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld0RhdGEpIHtcbiAgICAgIGlmIChuZXdEYXRhICE9PSB0aGlzLl9kYXRhKSB7XG4gICAgICAgIHRoaXMuX3NldERhdGEobmV3RGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogU2V0dXAgdGhlIHNjb3BlIG9mIGFuIGluc3RhbmNlLCB3aGljaCBjb250YWluczpcbiAgICogLSBvYnNlcnZlZCBkYXRhXG4gICAqIC0gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgKiAtIHVzZXIgbWV0aG9kc1xuICAgKiAtIG1ldGEgcHJvcGVydGllc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5pdFByb3BzKCk7XG4gICAgdGhpcy5faW5pdE1ldGEoKTtcbiAgICB0aGlzLl9pbml0TWV0aG9kcygpO1xuICAgIHRoaXMuX2luaXREYXRhKCk7XG4gICAgdGhpcy5faW5pdENvbXB1dGVkKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgcHJvcHMuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXRQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgdmFyIGVsID0gb3B0aW9ucy5lbDtcbiAgICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChwcm9wcyAmJiAhZWwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignUHJvcHMgd2lsbCBub3QgYmUgY29tcGlsZWQgaWYgbm8gYGVsYCBvcHRpb24gaXMgJyArICdwcm92aWRlZCBhdCBpbnN0YW50aWF0aW9uLicpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgdG8gY29udmVydCBzdHJpbmcgc2VsZWN0b3JzIGludG8gZWxlbWVudCBub3dcbiAgICBlbCA9IG9wdGlvbnMuZWwgPSBxdWVyeShlbCk7XG4gICAgdGhpcy5fcHJvcHNVbmxpbmtGbiA9IGVsICYmIGVsLm5vZGVUeXBlID09PSAxICYmIHByb3BzXG4gICAgLy8gcHJvcHMgbXVzdCBiZSBsaW5rZWQgaW4gcHJvcGVyIHNjb3BlIGlmIGluc2lkZSB2LWZvclxuICAgID8gY29tcGlsZUFuZExpbmtQcm9wcyh0aGlzLCBlbCwgcHJvcHMsIHRoaXMuX3Njb3BlKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIGRhdGEuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2luaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wc0RhdGEgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBvcHRpb25zRGF0YUZuID0gdGhpcy4kb3B0aW9ucy5kYXRhO1xuICAgIHZhciBvcHRpb25zRGF0YSA9IG9wdGlvbnNEYXRhRm4gJiYgb3B0aW9uc0RhdGFGbigpO1xuICAgIGlmIChvcHRpb25zRGF0YSkge1xuICAgICAgdGhpcy5fZGF0YSA9IG9wdGlvbnNEYXRhO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wc0RhdGEpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzT3duKG9wdGlvbnNEYXRhLCBwcm9wKSkge1xuICAgICAgICAgIHdhcm4oJ0RhdGEgZmllbGQgXCInICsgcHJvcCArICdcIiBpcyBhbHJlYWR5IGRlZmluZWQgJyArICdhcyBhIHByb3AuIFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJvcHNbcHJvcF0ucmF3ICE9PSBudWxsIHx8ICFoYXNPd24ob3B0aW9uc0RhdGEsIHByb3ApKSB7XG4gICAgICAgICAgc2V0KG9wdGlvbnNEYXRhLCBwcm9wLCBwcm9wc0RhdGFbcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgaSwga2V5O1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgdGhpcy5fcHJveHkoa2V5KTtcbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgb2JzZXJ2ZShkYXRhLCB0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogU3dhcCB0aGUgaW5zdGFuY2UncyAkZGF0YS4gQ2FsbGVkIGluICRkYXRhJ3Mgc2V0dGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbmV3RGF0YVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9zZXREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICBuZXdEYXRhID0gbmV3RGF0YSB8fCB7fTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgdGhpcy5fZGF0YSA9IG5ld0RhdGE7XG4gICAgdmFyIGtleXMsIGtleSwgaTtcbiAgICAvLyB1bnByb3h5IGtleXMgbm90IHByZXNlbnQgaW4gbmV3IGRhdGFcbiAgICBrZXlzID0gT2JqZWN0LmtleXMob2xkRGF0YSk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIShrZXkgaW4gbmV3RGF0YSkpIHtcbiAgICAgICAgdGhpcy5fdW5wcm94eShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBwcm94eSBrZXlzIG5vdCBhbHJlYWR5IHByb3hpZWQsXG4gICAgLy8gYW5kIHRyaWdnZXIgY2hhbmdlIGZvciBjaGFuZ2VkIHZhbHVlc1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhuZXdEYXRhKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghaGFzT3duKHRoaXMsIGtleSkpIHtcbiAgICAgICAgLy8gbmV3IHByb3BlcnR5XG4gICAgICAgIHRoaXMuX3Byb3h5KGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9sZERhdGEuX19vYl9fLnJlbW92ZVZtKHRoaXMpO1xuICAgIG9ic2VydmUobmV3RGF0YSwgdGhpcyk7XG4gICAgdGhpcy5fZGlnZXN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3h5IGEgcHJvcGVydHksIHNvIHRoYXRcbiAgICogdm0ucHJvcCA9PT0gdm0uX2RhdGEucHJvcFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAvLyBuZWVkIHRvIHN0b3JlIHJlZiB0byBzZWxmIGhlcmVcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgZ2V0dGVyL3NldHRlcnMgbWlnaHRcbiAgICAgIC8vIGJlIGNhbGxlZCBieSBjaGlsZCBzY29wZXMgdmlhXG4gICAgICAvLyBwcm90b3R5cGUgaW5oZXJpdGFuY2UuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlcigpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5fZGF0YVtrZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHByb3h5U2V0dGVyKHZhbCkge1xuICAgICAgICAgIHNlbGYuX2RhdGFba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBVbnByb3h5IGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fdW5wcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlIHVwZGF0ZSBvbiBldmVyeSB3YXRjaGVyIGluIHNjb3BlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuX3dhdGNoZXJzW2ldLnVwZGF0ZSh0cnVlKTsgLy8gc2hhbGxvdyB1cGRhdGVzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXR1cCBjb21wdXRlZCBwcm9wZXJ0aWVzLiBUaGV5IGFyZSBlc3NlbnRpYWxseVxuICAgKiBzcGVjaWFsIGdldHRlci9zZXR0ZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICBWdWUucHJvdG90eXBlLl9pbml0Q29tcHV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gdGhpcy4kb3B0aW9ucy5jb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICAgIHZhciBkZWYgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB0aGlzKTtcbiAgICAgICAgICBkZWYuc2V0ID0gbm9vcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWYuZ2V0ID0gdXNlckRlZi5nZXQgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZSA/IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLmdldCwgdGhpcykgOiBiaW5kJDEodXNlckRlZi5nZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgICBkZWYuc2V0ID0gdXNlckRlZi5zZXQgPyBiaW5kJDEodXNlckRlZi5zZXQsIHRoaXMpIDogbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIoZ2V0dGVyLCBvd25lcikge1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIob3duZXIsIGdldHRlciwgbnVsbCwge1xuICAgICAgbGF6eTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGluc3RhbmNlIG1ldGhvZHMuIE1ldGhvZHMgbXVzdCBiZSBib3VuZCB0byB0aGVcbiAgICogaW5zdGFuY2Ugc2luY2UgdGhleSBtaWdodCBiZSBwYXNzZWQgZG93biBhcyBhIHByb3AgdG9cbiAgICogY2hpbGQgY29tcG9uZW50cy5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5faW5pdE1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLiRvcHRpb25zLm1ldGhvZHM7XG4gICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGJpbmQkMShtZXRob2RzW2tleV0sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBtZXRhIGluZm9ybWF0aW9uIGxpa2UgJGluZGV4LCAka2V5ICYgJHZhbHVlLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0TWV0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWV0YXMgPSB0aGlzLiRvcHRpb25zLl9tZXRhO1xuICAgIGlmIChtZXRhcykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGFzKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHRoaXMsIGtleSwgbWV0YXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZXZlbnRSRSA9IC9edi1vbjp8XkAvO1xuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG5cbiAgLyoqXG4gICAqIFNldHVwIHRoZSBpbnN0YW5jZSdzIG9wdGlvbiBldmVudHMgJiB3YXRjaGVycy5cbiAgICogSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCB3ZSBwdWxsIGl0IGZyb20gdGhlXG4gICAqIGluc3RhbmNlJ3MgbWV0aG9kcyBieSBuYW1lLlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5fYXNDb21wb25lbnQpIHtcbiAgICAgIHJlZ2lzdGVyQ29tcG9uZW50RXZlbnRzKHRoaXMsIG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgICByZWdpc3RlckNhbGxiYWNrcyh0aGlzLCAnJG9uJywgb3B0aW9ucy5ldmVudHMpO1xuICAgIHJlZ2lzdGVyQ2FsbGJhY2tzKHRoaXMsICckd2F0Y2gnLCBvcHRpb25zLndhdGNoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgdi1vbiBldmVudHMgb24gYSBjaGlsZCBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IHZtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRFdmVudHModm0sIGVsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cmlidXRlcztcbiAgICB2YXIgbmFtZSwgaGFuZGxlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XG4gICAgICBpZiAoZXZlbnRSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZXZlbnRSRSwgJycpO1xuICAgICAgICBoYW5kbGVyID0gKHZtLl9zY29wZSB8fCB2bS5fY29udGV4dCkuJGV2YWwoYXR0cnNbaV0udmFsdWUsIHRydWUpO1xuICAgICAgICBoYW5kbGVyLl9mcm9tUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgdm0uJG9uKG5hbWUucmVwbGFjZShldmVudFJFKSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrcyBmb3Igb3B0aW9uIGV2ZW50cyBhbmQgd2F0Y2hlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ2FsbGJhY2tzKHZtLCBhY3Rpb24sIGhhc2gpIHtcbiAgICBpZiAoIWhhc2gpIHJldHVybjtcbiAgICB2YXIgaGFuZGxlcnMsIGtleSwgaSwgajtcbiAgICBmb3IgKGtleSBpbiBoYXNoKSB7XG4gICAgICBoYW5kbGVycyA9IGhhc2hba2V5XTtcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2lzdGVyKHZtLCBhY3Rpb24sIGtleSwgaGFuZGxlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gcmVnaXN0ZXIgYW4gZXZlbnQvd2F0Y2ggY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIodm0sIGFjdGlvbiwga2V5LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgaGFuZGxlcjtcbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm1bYWN0aW9uXShrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICAgIHZhciBtZXRob2QgPSBtZXRob2RzICYmIG1ldGhvZHNbaGFuZGxlcl07XG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHZtW2FjdGlvbl0oa2V5LCBtZXRob2QsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdVbmtub3duIG1ldGhvZDogXCInICsgaGFuZGxlciArICdcIiB3aGVuICcgKyAncmVnaXN0ZXJpbmcgY2FsbGJhY2sgZm9yICcgKyBhY3Rpb24gKyAnOiBcIicgKyBrZXkgKyAnXCIuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZWdpc3Rlcih2bSwgYWN0aW9uLCBrZXksIGhhbmRsZXIuaGFuZGxlciwgaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIHJlY3Vyc2l2ZSBhdHRhY2hlZC9kZXRhY2hlZCBjYWxsc1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RE9NSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kb24oJ2hvb2s6YXR0YWNoZWQnLCBvbkF0dGFjaGVkKTtcbiAgICB0aGlzLiRvbignaG9vazpkZXRhY2hlZCcsIG9uRGV0YWNoZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byByZWN1cnNpdmVseSBjYWxsIGF0dGFjaGVkIGhvb2sgb24gY2hpbGRyZW5cbiAgICovXG5cbiAgZnVuY3Rpb24gb25BdHRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjYWxsQXR0YWNoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0b3IgdG8gY2FsbCBhdHRhY2hlZCBob29rXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSBjaGlsZFxuICAgKi9cblxuICBmdW5jdGlvbiBjYWxsQXR0YWNoKGNoaWxkKSB7XG4gICAgaWYgKCFjaGlsZC5faXNBdHRhY2hlZCAmJiBpbkRvYyhjaGlsZC4kZWwpKSB7XG4gICAgICBjaGlsZC5fY2FsbEhvb2soJ2F0dGFjaGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZGV0YWNoZWQgaG9vayBvbiBjaGlsZHJlblxuICAgKi9cblxuICBmdW5jdGlvbiBvbkRldGFjaGVkKCkge1xuICAgIGlmICh0aGlzLl9pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNhbGxEZXRhY2gpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRvciB0byBjYWxsIGRldGFjaGVkIGhvb2tcbiAgICpcbiAgICogQHBhcmFtIHtWdWV9IGNoaWxkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNhbGxEZXRhY2goY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQuX2lzQXR0YWNoZWQgJiYgIWluRG9jKGNoaWxkLiRlbCkpIHtcbiAgICAgIGNoaWxkLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBhbGwgaGFuZGxlcnMgZm9yIGEgaG9va1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaG9va1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9jYWxsSG9vayA9IGZ1bmN0aW9uIChob29rKSB7XG4gICAgdGhpcy4kZW1pdCgncHJlLWhvb2s6JyArIGhvb2spO1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuJG9wdGlvbnNbaG9va107XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgbGlua3MgYSBET00gZWxlbWVudCB3aXRoIGEgcGllY2Ugb2YgZGF0YSxcbiAqIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhbiBleHByZXNzaW9uLlxuICogSXQgcmVnaXN0ZXJzIGEgd2F0Y2hlciB3aXRoIHRoZSBleHByZXNzaW9uIGFuZCBjYWxsc1xuICogdGhlIERPTSB1cGRhdGUgZnVuY3Rpb24gd2hlbiBhIGNoYW5nZSBpcyB0cmlnZ2VyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAqIEBwYXJhbSB7VnVlfSB2bVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0b3JcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IG5hbWVcbiAqICAgICAgICAgICAgICAgICAtIHtPYmplY3R9IGRlZlxuICogICAgICAgICAgICAgICAgIC0ge1N0cmluZ30gZXhwcmVzc2lvblxuICogICAgICAgICAgICAgICAgIC0ge0FycmF5PE9iamVjdD59IFtmaWx0ZXJzXVxuICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGxpdGVyYWxcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGF0dHJcbiAqICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IHJhd1xuICogQHBhcmFtIHtPYmplY3R9IGRlZiAtIGRpcmVjdGl2ZSBkZWZpbml0aW9uIG9iamVjdFxuICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gLSB2LWZvciBzY29wZVxuICogQHBhcmFtIHtGcmFnbWVudH0gW2ZyYWddIC0gb3duZXIgZnJhZ21lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEaXJlY3RpdmUoZGVzY3JpcHRvciwgdm0sIGVsLCBob3N0LCBzY29wZSwgZnJhZykge1xuICB0aGlzLnZtID0gdm07XG4gIHRoaXMuZWwgPSBlbDtcbiAgLy8gY29weSBkZXNjcmlwdG9yIHByb3BlcnRpZXNcbiAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgdGhpcy5uYW1lID0gZGVzY3JpcHRvci5uYW1lO1xuICB0aGlzLmV4cHJlc3Npb24gPSBkZXNjcmlwdG9yLmV4cHJlc3Npb247XG4gIHRoaXMuYXJnID0gZGVzY3JpcHRvci5hcmc7XG4gIHRoaXMubW9kaWZpZXJzID0gZGVzY3JpcHRvci5tb2RpZmllcnM7XG4gIHRoaXMuZmlsdGVycyA9IGRlc2NyaXB0b3IuZmlsdGVycztcbiAgdGhpcy5saXRlcmFsID0gdGhpcy5tb2RpZmllcnMgJiYgdGhpcy5tb2RpZmllcnMubGl0ZXJhbDtcbiAgLy8gcHJpdmF0ZVxuICB0aGlzLl9sb2NrZWQgPSBmYWxzZTtcbiAgdGhpcy5fYm91bmQgPSBmYWxzZTtcbiAgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgLy8gbGluayBjb250ZXh0XG4gIHRoaXMuX2hvc3QgPSBob3N0O1xuICB0aGlzLl9zY29wZSA9IHNjb3BlO1xuICB0aGlzLl9mcmFnID0gZnJhZztcbiAgLy8gc3RvcmUgZGlyZWN0aXZlcyBvbiBub2RlIGluIGRldiBtb2RlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuZWwpIHtcbiAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcyA9IHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzIHx8IFtdO1xuICAgIHRoaXMuZWwuX3Z1ZV9kaXJlY3RpdmVzLnB1c2godGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBkaXJlY3RpdmUsIG1peGluIGRlZmluaXRpb24gcHJvcGVydGllcyxcbiAqIHNldHVwIHRoZSB3YXRjaGVyLCBjYWxsIGRlZmluaXRpb24gYmluZCgpIGFuZCB1cGRhdGUoKVxuICogaWYgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gIHZhciBkZXNjcmlwdG9yID0gdGhpcy5kZXNjcmlwdG9yO1xuXG4gIC8vIHJlbW92ZSBhdHRyaWJ1dGVcbiAgaWYgKChuYW1lICE9PSAnY2xvYWsnIHx8IHRoaXMudm0uX2lzQ29tcGlsZWQpICYmIHRoaXMuZWwgJiYgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUpIHtcbiAgICB2YXIgYXR0ciA9IGRlc2NyaXB0b3IuYXR0ciB8fCAndi0nICsgbmFtZTtcbiAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgfVxuXG4gIC8vIGNvcHkgZGVmIHByb3BlcnRpZXNcbiAgdmFyIGRlZiA9IGRlc2NyaXB0b3IuZGVmO1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMudXBkYXRlID0gZGVmO1xuICB9IGVsc2Uge1xuICAgIGV4dGVuZCh0aGlzLCBkZWYpO1xuICB9XG5cbiAgLy8gc2V0dXAgZGlyZWN0aXZlIHBhcmFtc1xuICB0aGlzLl9zZXR1cFBhcmFtcygpO1xuXG4gIC8vIGluaXRpYWwgYmluZFxuICBpZiAodGhpcy5iaW5kKSB7XG4gICAgdGhpcy5iaW5kKCk7XG4gIH1cbiAgdGhpcy5fYm91bmQgPSB0cnVlO1xuXG4gIGlmICh0aGlzLmxpdGVyYWwpIHtcbiAgICB0aGlzLnVwZGF0ZSAmJiB0aGlzLnVwZGF0ZShkZXNjcmlwdG9yLnJhdyk7XG4gIH0gZWxzZSBpZiAoKHRoaXMuZXhwcmVzc2lvbiB8fCB0aGlzLm1vZGlmaWVycykgJiYgKHRoaXMudXBkYXRlIHx8IHRoaXMudHdvV2F5KSAmJiAhdGhpcy5fY2hlY2tTdGF0ZW1lbnQoKSkge1xuICAgIC8vIHdyYXBwZWQgdXBkYXRlciBmb3IgY29udGV4dFxuICAgIHZhciBkaXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgICAgIGlmICghZGlyLl9sb2NrZWQpIHtcbiAgICAgICAgICBkaXIudXBkYXRlKHZhbCwgb2xkVmFsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlID0gbm9vcDtcbiAgICB9XG4gICAgdmFyIHByZVByb2Nlc3MgPSB0aGlzLl9wcmVQcm9jZXNzID8gYmluZCQxKHRoaXMuX3ByZVByb2Nlc3MsIHRoaXMpIDogbnVsbDtcbiAgICB2YXIgcG9zdFByb2Nlc3MgPSB0aGlzLl9wb3N0UHJvY2VzcyA/IGJpbmQkMSh0aGlzLl9wb3N0UHJvY2VzcywgdGhpcykgOiBudWxsO1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHRoaXMudm0sIHRoaXMuZXhwcmVzc2lvbiwgdGhpcy5fdXBkYXRlLCAvLyBjYWxsYmFja1xuICAgIHtcbiAgICAgIGZpbHRlcnM6IHRoaXMuZmlsdGVycyxcbiAgICAgIHR3b1dheTogdGhpcy50d29XYXksXG4gICAgICBkZWVwOiB0aGlzLmRlZXAsXG4gICAgICBwcmVQcm9jZXNzOiBwcmVQcm9jZXNzLFxuICAgICAgcG9zdFByb2Nlc3M6IHBvc3RQcm9jZXNzLFxuICAgICAgc2NvcGU6IHRoaXMuX3Njb3BlXG4gICAgfSk7XG4gICAgLy8gdi1tb2RlbCB3aXRoIGluaXRhbCBpbmxpbmUgdmFsdWUgbmVlZCB0byBzeW5jIGJhY2sgdG9cbiAgICAvLyBtb2RlbCBpbnN0ZWFkIG9mIHVwZGF0ZSB0byBET00gb24gaW5pdC4gVGhleSB3b3VsZFxuICAgIC8vIHNldCB0aGUgYWZ0ZXJCaW5kIGhvb2sgdG8gaW5kaWNhdGUgdGhhdC5cbiAgICBpZiAodGhpcy5hZnRlckJpbmQpIHtcbiAgICAgIHRoaXMuYWZ0ZXJCaW5kKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGUod2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGFsbCBwYXJhbSBhdHRyaWJ1dGVzLCBlLmcuIHRyYWNrLWJ5LFxuICogdHJhbnNpdGlvbi1tb2RlLCBldGMuLi5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl9zZXR1cFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhcmFtcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gIC8vIHN3YXAgdGhlIHBhcmFtcyBhcnJheSB3aXRoIGEgZnJlc2ggb2JqZWN0LlxuICB0aGlzLnBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBpID0gcGFyYW1zLmxlbmd0aDtcbiAgdmFyIGtleSwgdmFsLCBtYXBwZWRLZXk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBwYXJhbXNbaV07XG4gICAgbWFwcGVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICB2YWwgPSBnZXRCaW5kQXR0cih0aGlzLmVsLCBrZXkpO1xuICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgLy8gZHluYW1pY1xuICAgICAgdGhpcy5fc2V0dXBQYXJhbVdhdGNoZXIobWFwcGVkS2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGF0aWNcbiAgICAgIHZhbCA9IGdldEF0dHIodGhpcy5lbCwga2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnBhcmFtc1ttYXBwZWRLZXldID0gdmFsID09PSAnJyA/IHRydWUgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNldHVwIGEgd2F0Y2hlciBmb3IgYSBkeW5hbWljIHBhcmFtLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXG4gKi9cblxuRGlyZWN0aXZlLnByb3RvdHlwZS5fc2V0dXBQYXJhbVdhdGNoZXIgPSBmdW5jdGlvbiAoa2V5LCBleHByZXNzaW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgdW53YXRjaCA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLnZtKS4kd2F0Y2goZXhwcmVzc2lvbiwgZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XG4gICAgc2VsZi5wYXJhbXNba2V5XSA9IHZhbDtcbiAgICAvLyBzaW5jZSB3ZSBhcmUgaW4gaW1tZWRpYXRlIG1vZGUsXG4gICAgLy8gb25seSBjYWxsIHRoZSBwYXJhbSBjaGFuZ2UgY2FsbGJhY2tzIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgdmFyIGNiID0gc2VsZi5wYXJhbVdhdGNoZXJzICYmIHNlbGYucGFyYW1XYXRjaGVyc1trZXldO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFsLCBvbGRWYWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICB1c2VyOiBmYWxzZVxuICB9KTsodGhpcy5fcGFyYW1VbndhdGNoRm5zIHx8ICh0aGlzLl9wYXJhbVVud2F0Y2hGbnMgPSBbXSkpLnB1c2godW53YXRjaCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkaXJlY3RpdmUgaXMgYSBmdW5jdGlvbiBjYWxsZXJcbiAqIGFuZCBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGNhbGxhYmxlIG9uZS4gSWYgYm90aCB0cnVlLFxuICogd2Ugd3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBhbmQgdXNlIGl0IGFzIHRoZSBldmVudFxuICogaGFuZGxlci5cbiAqXG4gKiBlLmcuIG9uLWNsaWNrPVwiYSsrXCJcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrU3RhdGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgaWYgKGV4cHJlc3Npb24gJiYgdGhpcy5hY2NlcHRTdGF0ZW1lbnQgJiYgIWlzU2ltcGxlUGF0aChleHByZXNzaW9uKSkge1xuICAgIHZhciBmbiA9IHBhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKS5nZXQ7XG4gICAgdmFyIHNjb3BlID0gdGhpcy5fc2NvcGUgfHwgdGhpcy52bTtcbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgc2NvcGUuJGV2ZW50ID0gZTtcbiAgICAgIGZuLmNhbGwoc2NvcGUsIHNjb3BlKTtcbiAgICAgIHNjb3BlLiRldmVudCA9IG51bGw7XG4gICAgfTtcbiAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICBoYW5kbGVyID0gc2NvcGUuX2FwcGx5RmlsdGVycyhoYW5kbGVyLCBudWxsLCB0aGlzLmZpbHRlcnMpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShoYW5kbGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgd2l0aCB0aGUgc2V0dGVyLlxuICogVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIHR3by13YXkgZGlyZWN0aXZlc1xuICogZS5nLiB2LW1vZGVsLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwdWJsaWNcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy50d29XYXkpIHtcbiAgICB0aGlzLl93aXRoTG9jayhmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl93YXRjaGVyLnNldCh2YWx1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oJ0RpcmVjdGl2ZS5zZXQoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB0d29XYXknICsgJ2RpcmVjdGl2ZXMuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGZ1bmN0aW9uIHdoaWxlIHByZXZlbnRpbmcgdGhhdCBmdW5jdGlvbiBmcm9tXG4gKiB0cmlnZ2VyaW5nIHVwZGF0ZXMgb24gdGhpcyBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLl93aXRoTG9jayA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX2xvY2tlZCA9IHRydWU7XG4gIGZuLmNhbGwoc2VsZik7XG4gIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9sb2NrZWQgPSBmYWxzZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF0dGFjaGVzIGEgRE9NIGV2ZW50IGxpc3RlbmVyXG4gKiB0byB0aGUgZGlyZWN0aXZlIGVsZW1lbnQgYW5kIGF1dG9tZXRpY2FsbHkgdGVhcnMgaXQgZG93blxuICogZHVyaW5nIHVuYmluZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuXG5EaXJlY3RpdmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gIG9uJDEodGhpcy5lbCwgZXZlbnQsIGhhbmRsZXIpOyh0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSkucHVzaChbZXZlbnQsIGhhbmRsZXJdKTtcbn07XG5cbi8qKlxuICogVGVhcmRvd24gdGhlIHdhdGNoZXIgYW5kIGNhbGwgdW5iaW5kLlxuICovXG5cbkRpcmVjdGl2ZS5wcm90b3R5cGUuX3RlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fYm91bmQpIHtcbiAgICB0aGlzLl9ib3VuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnVuYmluZCkge1xuICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhdGNoZXIpIHtcbiAgICAgIHRoaXMuX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgaTtcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgb2ZmKHRoaXMuZWwsIGxpc3RlbmVyc1tpXVswXSwgbGlzdGVuZXJzW2ldWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVud2F0Y2hGbnMgPSB0aGlzLl9wYXJhbVVud2F0Y2hGbnM7XG4gICAgaWYgKHVud2F0Y2hGbnMpIHtcbiAgICAgIGkgPSB1bndhdGNoRm5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdW53YXRjaEZuc1tpXSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLl92dWVfZGlyZWN0aXZlcy4kcmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnZtID0gdGhpcy5lbCA9IHRoaXMuX3dhdGNoZXIgPSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB2LXJlZiBmb3IgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl91cGRhdGVSZWYgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuJG9wdGlvbnMuX3JlZjtcbiAgICBpZiAocmVmKSB7XG4gICAgICB2YXIgcmVmcyA9ICh0aGlzLl9zY29wZSB8fCB0aGlzLl9jb250ZXh0KS4kcmVmcztcbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgaWYgKHJlZnNbcmVmXSA9PT0gdGhpcykge1xuICAgICAgICAgIHJlZnNbcmVmXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNbcmVmXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2NsdWRlLCBjb21waWxlIGFuZCBsaW5rIGVsZW1lbnQuXG4gICAqXG4gICAqIElmIGEgcHJlLWNvbXBpbGVkIGxpbmtlciBpcyBhdmFpbGFibGUsIHRoYXQgbWVhbnMgdGhlXG4gICAqIHBhc3NlZCBpbiBlbGVtZW50IHdpbGwgYmUgcHJlLXRyYW5zY2x1ZGVkIGFuZCBjb21waWxlZFxuICAgKiBhcyB3ZWxsIC0gYWxsIHdlIG5lZWQgdG8gZG8gaXMgdG8gY2FsbCB0aGUgbGlua2VyLlxuICAgKlxuICAgKiBPdGhlcndpc2Ugd2UgbmVlZCB0byBjYWxsIHRyYW5zY2x1ZGUvY29tcGlsZS9saW5rIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcblxuICAgIC8vIHRyYW5zY2x1ZGUgYW5kIGluaXQgZWxlbWVudFxuICAgIC8vIHRyYW5zY2x1ZGUgY2FuIHBvdGVudGlhbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgcmVmZXJlbmNlOyB0aGlzIHN0ZXAgYWxzbyBpbmplY3RzXG4gICAgLy8gdGhlIHRlbXBsYXRlIGFuZCBjYWNoZXMgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgICAvLyBvbiB0aGUgY29udGFpbmVyIG5vZGUgYW5kIHJlcGxhY2VyIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsID0gZWw7XG4gICAgZWwgPSB0cmFuc2NsdWRlKGVsLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pbml0RWxlbWVudChlbCk7XG5cbiAgICAvLyBoYW5kbGUgdi1wcmUgb24gcm9vdCBub2RlICgjMjAyNilcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEgJiYgZ2V0QXR0cihlbCwgJ3YtcHJlJykgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByb290IGlzIGFsd2F5cyBjb21waWxlZCBwZXItaW5zdGFuY2UsIGJlY2F1c2VcbiAgICAvLyBjb250YWluZXIgYXR0cnMgYW5kIHByb3BzIGNhbiBiZSBkaWZmZXJlbnQgZXZlcnkgdGltZS5cbiAgICB2YXIgY29udGV4dE9wdGlvbnMgPSB0aGlzLl9jb250ZXh0ICYmIHRoaXMuX2NvbnRleHQuJG9wdGlvbnM7XG4gICAgdmFyIHJvb3RMaW5rZXIgPSBjb21waWxlUm9vdChlbCwgb3B0aW9ucywgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgLy8gY29tcGlsZSBhbmQgbGluayB0aGUgcmVzdFxuICAgIHZhciBjb250ZW50TGlua0ZuO1xuICAgIHZhciBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjb21wb25lbnQgY29tcGlsYXRpb24gY2FuIGJlIGNhY2hlZFxuICAgIC8vIGFzIGxvbmcgYXMgaXQncyBub3QgdXNpbmcgaW5saW5lLXRlbXBsYXRlXG4gICAgaWYgKG9wdGlvbnMuX2xpbmtlckNhY2hhYmxlKSB7XG4gICAgICBjb250ZW50TGlua0ZuID0gY3Rvci5saW5rZXI7XG4gICAgICBpZiAoIWNvbnRlbnRMaW5rRm4pIHtcbiAgICAgICAgY29udGVudExpbmtGbiA9IGN0b3IubGlua2VyID0gY29tcGlsZShlbCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbGluayBwaGFzZVxuICAgIC8vIG1ha2Ugc3VyZSB0byBsaW5rIHJvb3Qgd2l0aCBwcm9wIHNjb3BlIVxuICAgIHZhciByb290VW5saW5rRm4gPSByb290TGlua2VyKHRoaXMsIGVsLCB0aGlzLl9zY29wZSk7XG4gICAgdmFyIGNvbnRlbnRVbmxpbmtGbiA9IGNvbnRlbnRMaW5rRm4gPyBjb250ZW50TGlua0ZuKHRoaXMsIGVsKSA6IGNvbXBpbGUoZWwsIG9wdGlvbnMpKHRoaXMsIGVsKTtcblxuICAgIC8vIHJlZ2lzdGVyIGNvbXBvc2l0ZSB1bmxpbmsgZnVuY3Rpb25cbiAgICAvLyB0byBiZSBjYWxsZWQgZHVyaW5nIGluc3RhbmNlIGRlc3RydWN0aW9uXG4gICAgdGhpcy5fdW5saW5rRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByb290VW5saW5rRm4oKTtcbiAgICAgIC8vIHBhc3NpbmcgZGVzdHJveWluZzogdHJ1ZSB0byBhdm9pZCBzZWFyY2hpbmcgYW5kXG4gICAgICAvLyBzcGxpY2luZyB0aGUgZGlyZWN0aXZlc1xuICAgICAgY29udGVudFVubGlua0ZuKHRydWUpO1xuICAgIH07XG5cbiAgICAvLyBmaW5hbGx5IHJlcGxhY2Ugb3JpZ2luYWxcbiAgICBpZiAob3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICByZXBsYWNlKG9yaWdpbmFsLCBlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNDb21waWxlZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2NvbXBpbGVkJyk7XG4gICAgcmV0dXJuIGVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGluc3RhbmNlIGVsZW1lbnQuIENhbGxlZCBpbiB0aGUgcHVibGljXG4gICAqICRtb3VudCgpIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2lzRnJhZ21lbnQgPSB0cnVlO1xuICAgICAgdGhpcy4kZWwgPSB0aGlzLl9mcmFnbWVudFN0YXJ0ID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50RW5kID0gZWwubGFzdENoaWxkO1xuICAgICAgLy8gc2V0IHBlcnNpc3RlZCB0ZXh0IGFuY2hvcnMgdG8gZW1wdHlcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudFN0YXJ0Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U3RhcnQuZGF0YSA9IHRoaXMuX2ZyYWdtZW50RW5kLmRhdGEgPSAnJztcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGVsID0gZWw7XG4gICAgfVxuICAgIHRoaXMuJGVsLl9fdnVlX18gPSB0aGlzO1xuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVDb21waWxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYmluZCBhIGRpcmVjdGl2ZSB0byBhbiBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGRpcmVjdGl2ZSBuYW1lXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAgIC0gdGFyZ2V0IG5vZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2MgLSBwYXJzZWQgZGlyZWN0aXZlIGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlZiAgLSBkaXJlY3RpdmUgZGVmaW5pdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XSAtIHRyYW5zY2x1c2lvbiBob3N0IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSAtIHYtZm9yIHNjb3BlXG4gICAqIEBwYXJhbSB7RnJhZ21lbnR9IFtmcmFnXSAtIG93bmVyIGZyYWdtZW50XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2JpbmREaXIgPSBmdW5jdGlvbiAoZGVzY3JpcHRvciwgbm9kZSwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICB0aGlzLl9kaXJlY3RpdmVzLnB1c2gobmV3IERpcmVjdGl2ZShkZXNjcmlwdG9yLCB0aGlzLCBub2RlLCBob3N0LCBzY29wZSwgZnJhZykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZWFyZG93biBhbiBpbnN0YW5jZSwgdW5vYnNlcnZlcyB0aGUgZGF0YSwgdW5iaW5kIGFsbCB0aGVcbiAgICogZGlyZWN0aXZlcywgdHVybiBvZmYgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgLSB3aGV0aGVyIHRvIHJlbW92ZSB0aGUgRE9NIG5vZGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVmZXJDbGVhbnVwIC0gaWYgdHJ1ZSwgZGVmZXIgY2xlYW51cCB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGNhbGxlZCBsYXRlclxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSwgZGVmZXJDbGVhbnVwKSB7XG4gICAgaWYgKHRoaXMuX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVzdHJveVJlYWR5O1xuICAgIHZhciBwZW5kaW5nUmVtb3ZhbDtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDbGVhbnVwIHNob3VsZCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3lzbHkgYXNcbiAgICAvLyBjYWxsYmFjayBvZiB0aGlzLiRyZW1vdmUoKSwgb3IgaWYgcmVtb3ZlIGFuZCBkZWZlckNsZWFudXAgYXJlIGZhbHNlLlxuICAgIC8vIEluIGFueSBjYXNlIGl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIG90aGVyIHJlbW92aW5nLCB1bmJpbmRpbmcgYW5kXG4gICAgLy8gdHVybmluZyBvZiBpcyBkb25lXG4gICAgdmFyIGNsZWFudXBJZlBvc3NpYmxlID0gZnVuY3Rpb24gY2xlYW51cElmUG9zc2libGUoKSB7XG4gICAgICBpZiAoZGVzdHJveVJlYWR5ICYmICFwZW5kaW5nUmVtb3ZhbCAmJiAhZGVmZXJDbGVhbnVwKSB7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIERPTSBlbGVtZW50XG4gICAgaWYgKHJlbW92ZSAmJiB0aGlzLiRlbCkge1xuICAgICAgcGVuZGluZ1JlbW92YWwgPSB0cnVlO1xuICAgICAgdGhpcy4kcmVtb3ZlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGVuZGluZ1JlbW92YWwgPSBmYWxzZTtcbiAgICAgICAgY2xlYW51cElmUG9zc2libGUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2NhbGxIb29rKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdGhpcy5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnQuIG9ubHkgbmVjZXNzYXJ5XG4gICAgLy8gaWYgcGFyZW50IGlzIG5vdCBiZWluZyBkZXN0cm95ZWQgYXMgd2VsbC5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcGFyZW50LiRjaGlsZHJlbi4kcmVtb3ZlKHRoaXMpO1xuICAgICAgLy8gdW5yZWdpc3RlciByZWYgKHJlbW92ZTogdHJ1ZSlcbiAgICAgIHRoaXMuX3VwZGF0ZVJlZih0cnVlKTtcbiAgICB9XG4gICAgLy8gZGVzdHJveSBhbGwgY2hpbGRyZW4uXG4gICAgaSA9IHRoaXMuJGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzLiRjaGlsZHJlbltpXS4kZGVzdHJveSgpO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biBwcm9wc1xuICAgIGlmICh0aGlzLl9wcm9wc1VubGlua0ZuKSB7XG4gICAgICB0aGlzLl9wcm9wc1VubGlua0ZuKCk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIGFsbCBkaXJlY3RpdmVzLiB0aGlzIGFsc28gdGVhcnNkb3duIGFsbFxuICAgIC8vIGRpcmVjdGl2ZS1vd25lZCB3YXRjaGVycy5cbiAgICBpZiAodGhpcy5fdW5saW5rRm4pIHtcbiAgICAgIHRoaXMuX3VubGlua0ZuKCk7XG4gICAgfVxuICAgIGkgPSB0aGlzLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBzZWxmIG9uICRlbFxuICAgIGlmICh0aGlzLiRlbCkge1xuICAgICAgdGhpcy4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveVJlYWR5ID0gdHJ1ZTtcbiAgICBjbGVhbnVwSWZQb3NzaWJsZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCB0byBlbnN1cmUgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgKiBUaGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgbGVhdmUgdHJhbnNpdGlvbiBpZiB0aGVyZVxuICAgKiBpcyBhbnkuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2lzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gb3duZXIgZnJhZ21lbnRcbiAgICAvLyBkbyBpdCBpbiBjbGVhbnVwIHNvIHRoYXQgd2UgY2FuIGNhbGwgJGRlc3Ryb3kgd2l0aFxuICAgIC8vIGRlZmVyIHJpZ2h0IHdoZW4gYSBmcmFnbWVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkLlxuICAgIGlmICh0aGlzLl9mcmFnKSB7XG4gICAgICB0aGlzLl9mcmFnLmNoaWxkcmVuLiRyZW1vdmUodGhpcyk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHRoaXMuX2RhdGEuX19vYl9fKSB7XG4gICAgICB0aGlzLl9kYXRhLl9fb2JfXy5yZW1vdmVWbSh0aGlzKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgcmVmZXJlbmNlcyB0byBwcml2YXRlIHByb3BlcnRpZXMgYW5kIG90aGVyXG4gICAgLy8gaW5zdGFuY2VzLiBwcmVzZXJ2ZSByZWZlcmVuY2UgdG8gX2RhdGEgc28gdGhhdCBwcm94eVxuICAgIC8vIGFjY2Vzc29ycyBzdGlsbCB3b3JrLiBUaGUgb25seSBwb3RlbnRpYWwgc2lkZSBlZmZlY3RcbiAgICAvLyBoZXJlIGlzIHRoYXQgbXV0YXRpbmcgdGhlIGluc3RhbmNlIGFmdGVyIGl0J3MgZGVzdHJveWVkXG4gICAgLy8gbWF5IGFmZmVjdCB0aGUgc3RhdGUgb2Ygb3RoZXIgY29tcG9uZW50cyB0aGF0IGFyZSBzdGlsbFxuICAgIC8vIG9ic2VydmluZyB0aGUgc2FtZSBvYmplY3QsIGJ1dCB0aGF0IHNlZW1zIHRvIGJlIGFcbiAgICAvLyByZWFzb25hYmxlIHJlc3BvbnNpYmlsaXR5IGZvciB0aGUgdXNlciByYXRoZXIgdGhhblxuICAgIC8vIGFsd2F5cyB0aHJvd2luZyBhbiBlcnJvciBvbiB0aGVtLlxuICAgIHRoaXMuJGVsID0gdGhpcy4kcGFyZW50ID0gdGhpcy4kcm9vdCA9IHRoaXMuJGNoaWxkcmVuID0gdGhpcy5fd2F0Y2hlcnMgPSB0aGlzLl9jb250ZXh0ID0gdGhpcy5fc2NvcGUgPSB0aGlzLl9kaXJlY3RpdmVzID0gbnVsbDtcbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB0aGlzLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5fY2FsbEhvb2soJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdGhpcy4kb2ZmKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1pc2NNaXhpbiAoVnVlKSB7XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgbGlzdCBvZiBmaWx0ZXIgKGRlc2NyaXB0b3JzKSB0byBhIHZhbHVlLlxuICAgKiBVc2luZyBwbGFpbiBmb3IgbG9vcHMgaGVyZSBiZWNhdXNlIHRoaXMgd2lsbCBiZSBjYWxsZWQgaW5cbiAgICogdGhlIGdldHRlciBvZiBhbnkgd2F0Y2hlciB3aXRoIGZpbHRlcnMgc28gaXQgaXMgdmVyeVxuICAgKiBwZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHsqfSBbb2xkVmFsdWVdXG4gICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnNcbiAgICogQHBhcmFtIHtCb29sZWFufSB3cml0ZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9hcHBseUZpbHRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG9sZFZhbHVlLCBmaWx0ZXJzLCB3cml0ZSkge1xuICAgIHZhciBmaWx0ZXIsIGZuLCBhcmdzLCBhcmcsIG9mZnNldCwgaSwgbCwgaiwgaztcbiAgICBmb3IgKGkgPSAwLCBsID0gZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZpbHRlciA9IGZpbHRlcnNbaV07XG4gICAgICBmbiA9IHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGZpbHRlci5uYW1lKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydEFzc2V0KGZuLCAnZmlsdGVyJywgZmlsdGVyLm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmbikgY29udGludWU7XG4gICAgICBmbiA9IHdyaXRlID8gZm4ud3JpdGUgOiBmbi5yZWFkIHx8IGZuO1xuICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgY29udGludWU7XG4gICAgICBhcmdzID0gd3JpdGUgPyBbdmFsdWUsIG9sZFZhbHVlXSA6IFt2YWx1ZV07XG4gICAgICBvZmZzZXQgPSB3cml0ZSA/IDIgOiAxO1xuICAgICAgaWYgKGZpbHRlci5hcmdzKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGsgPSBmaWx0ZXIuYXJncy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICBhcmcgPSBmaWx0ZXIuYXJnc1tqXTtcbiAgICAgICAgICBhcmdzW2ogKyBvZmZzZXRdID0gYXJnLmR5bmFtaWMgPyB0aGlzLiRnZXQoYXJnLnZhbHVlKSA6IGFyZy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgY29tcG9uZW50LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgY29tcG9uZW50XG4gICAqIGlzIGRlZmluZWQgbm9ybWFsbHkgb3IgdXNpbmcgYW4gYXN5bmMgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICogUmVzb2x2ZXMgc3luY2hyb25vdXNseSBpZiBhbHJlYWR5IHJlc29sdmVkLCBvdGhlcndpc2VcbiAgICogcmVzb2x2ZXMgYXN5bmNocm9ub3VzbHkgYW5kIGNhY2hlcyB0aGUgcmVzb2x2ZWRcbiAgICogY29uc3RydWN0b3Igb24gdGhlIGZhY3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLl9yZXNvbHZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGlkLCBjYikge1xuICAgIHZhciBmYWN0b3J5ID0gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdjb21wb25lbnRzJywgaWQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRBc3NldChmYWN0b3J5LCAnY29tcG9uZW50JywgaWQpO1xuICAgIH1cbiAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnlcbiAgICBpZiAoIWZhY3Rvcnkub3B0aW9ucykge1xuICAgICAgaWYgKGZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgICAgLy8gY2FjaGVkXG4gICAgICAgIGNiKGZhY3RvcnkucmVzb2x2ZWQpO1xuICAgICAgfSBlbHNlIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgICAgICAvLyBwb29sIGNhbGxiYWNrc1xuICAgICAgICBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MucHVzaChjYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWN0b3J5LnJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHZhciBjYnMgPSBmYWN0b3J5LnBlbmRpbmdDYWxsYmFja3MgPSBbY2JdO1xuICAgICAgICBmYWN0b3J5KGZ1bmN0aW9uIHJlc29sdmUocmVzKSB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gVnVlLmV4dGVuZChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY2JzW2ldKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKCdGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6ICcgKyBpZCArICcuICcgKyAocmVhc29uID8gJ1xcblJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3JtYWwgY29tcG9uZW50XG4gICAgICBjYihmYWN0b3J5KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdsb2JhbEFQSSAoVnVlKSB7XG5cbiAgLyoqXG4gICAqIEV4cG9zZSB1c2VmdWwgaW50ZXJuYWxzXG4gICAqL1xuXG4gIFZ1ZS51dGlsID0gdXRpbDtcbiAgVnVlLmNvbmZpZyA9IGNvbmZpZztcbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlWydkZWxldGUnXSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLyoqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIGV4cG9zZWQgZm9yIGFkdmFuY2VkIHVzYWdlIC8gcGx1Z2luc1xuICAgKi9cblxuICBWdWUuY29tcGlsZXIgPSBjb21waWxlcjtcbiAgVnVlLkZyYWdtZW50RmFjdG9yeSA9IEZyYWdtZW50RmFjdG9yeTtcbiAgVnVlLmludGVybmFsRGlyZWN0aXZlcyA9IGludGVybmFsRGlyZWN0aXZlcztcbiAgVnVlLnBhcnNlcnMgPSB7XG4gICAgcGF0aDogcGF0aCxcbiAgICB0ZXh0OiB0ZXh0JDEsXG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIGRpcmVjdGl2ZTogZGlyZWN0aXZlLFxuICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgfTtcblxuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuZE9wdGlvbnNcbiAgICovXG5cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgaXNGaXJzdEV4dGVuZCA9IFN1cGVyLmNpZCA9PT0gMDtcbiAgICBpZiAoaXNGaXJzdEV4dGVuZCAmJiBleHRlbmRPcHRpb25zLl9DdG9yKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kT3B0aW9ucy5fQ3RvcjtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0rJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiAnICsgbmFtZSk7XG4gICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgU3ViID0gY3JlYXRlQ2xhc3MobmFtZSB8fCAnVnVlQ29tcG9uZW50Jyk7XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvblxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBjb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGlmIChpc0ZpcnN0RXh0ZW5kKSB7XG4gICAgICBleHRlbmRPcHRpb25zLl9DdG9yID0gU3ViO1xuICAgIH1cbiAgICByZXR1cm4gU3ViO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHN1Yi1jbGFzcyBjb25zdHJ1Y3RvciB3aXRoIHRoZVxuICAgKiBnaXZlbiBuYW1lLiBUaGlzIGdpdmVzIHVzIG11Y2ggbmljZXIgb3V0cHV0IHdoZW5cbiAgICogbG9nZ2luZyBpbnN0YW5jZXMgaW4gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uICcgKyBjbGFzc2lmeShuYW1lKSArICcgKG9wdGlvbnMpIHsgdGhpcy5faW5pdChvcHRpb25zKSB9JykoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQbHVnaW4gc3lzdGVtXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5cbiAgICovXG5cbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQXBwbHkgYSBnbG9iYWwgbWl4aW4gYnkgbWVyZ2luZyBpdCBpbnRvIHRoZSBkZWZhdWx0XG4gICAqIG9wdGlvbnMuXG4gICAqL1xuXG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIFZ1ZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFZ1ZS5vcHRpb25zLCBtaXhpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcyB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogc2lnbmF0dXJlOlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAgICogQHBhcmFtIHsqfSBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgKGNvbW1vblRhZ1JFLnRlc3QoaWQpIHx8IHJlc2VydmVkVGFnUkUudGVzdChpZCkpKSB7XG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgKyAnaWQ6ICcgKyBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IFZ1ZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG52YXIgZmlsdGVyUkUgPSAvW158XVxcfFtefF0vO1xuXG5mdW5jdGlvbiBkYXRhQVBJIChWdWUpIHtcblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIGFuIGV4cHJlc3Npb24gb24gdGhpcyB2bS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV4cFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthc1N0YXRlbWVudF1cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKGV4cCwgYXNTdGF0ZW1lbnQpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VFeHByZXNzaW9uKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgaWYgKGFzU3RhdGVtZW50ICYmICFpc1NpbXBsZVBhdGgoZXhwKSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZW1lbnRIYW5kbGVyKCkge1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzLmdldC5jYWxsKHNlbGYsIHNlbGYpO1xuICAgICAgICAgIHNlbGYuJGFyZ3VtZW50cyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy5nZXQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgZnJvbSBhbiBleHByZXNzaW9uIG9uIHRoaXMgdm0uXG4gICAqIFRoZSBleHByZXNzaW9uIG11c3QgYmUgYSB2YWxpZCBsZWZ0LWhhbmRcbiAgICogZXhwcmVzc2lvbiBpbiBhbiBhc3NpZ25tZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwXG4gICAqIEBwYXJhbSB7Kn0gdmFsXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IGZ1bmN0aW9uIChleHAsIHZhbCkge1xuICAgIHZhciByZXMgPSBwYXJzZUV4cHJlc3Npb24oZXhwLCB0cnVlKTtcbiAgICBpZiAocmVzICYmIHJlcy5zZXQpIHtcbiAgICAgIHJlcy5zZXQuY2FsbCh0aGlzLCB0aGlzLCB2YWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgb24gdGhlIFZNXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbCh0aGlzLl9kYXRhLCBrZXkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYXRjaCBhbiBleHByZXNzaW9uLCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gaXRzXG4gICAqIHZhbHVlIGNoYW5nZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBleHBPckZuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGRlZXBcbiAgICogICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IGltbWVkaWF0ZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSB1bndhdGNoRm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwYXJzZWQ7XG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyc2VkID0gcGFyc2VEaXJlY3RpdmUoZXhwT3JGbik7XG4gICAgICBleHBPckZuID0gcGFyc2VkLmV4cHJlc3Npb247XG4gICAgfVxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCB7XG4gICAgICBkZWVwOiBvcHRpb25zICYmIG9wdGlvbnMuZGVlcCxcbiAgICAgIHN5bmM6IG9wdGlvbnMgJiYgb3B0aW9ucy5zeW5jLFxuICAgICAgZmlsdGVyczogcGFyc2VkICYmIHBhcnNlZC5maWx0ZXJzLFxuICAgICAgdXNlcjogIW9wdGlvbnMgfHwgb3B0aW9ucy51c2VyICE9PSBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhIHRleHQgZGlyZWN0aXZlLCBpbmNsdWRpbmcgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNTdGF0ZW1lbnRdXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZXZhbCA9IGZ1bmN0aW9uICh0ZXh0LCBhc1N0YXRlbWVudCkge1xuICAgIC8vIGNoZWNrIGZvciBmaWx0ZXJzLlxuICAgIGlmIChmaWx0ZXJSRS50ZXN0KHRleHQpKSB7XG4gICAgICB2YXIgZGlyID0gcGFyc2VEaXJlY3RpdmUodGV4dCk7XG4gICAgICAvLyB0aGUgZmlsdGVyIHJlZ2V4IGNoZWNrIG1pZ2h0IGdpdmUgZmFsc2UgcG9zaXRpdmVcbiAgICAgIC8vIGZvciBwaXBlcyBpbnNpZGUgc3RyaW5ncywgc28gaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgICAvLyB3ZSBkb24ndCBnZXQgYW55IGZpbHRlcnMgaGVyZVxuICAgICAgdmFyIHZhbCA9IHRoaXMuJGdldChkaXIuZXhwcmVzc2lvbiwgYXNTdGF0ZW1lbnQpO1xuICAgICAgcmV0dXJuIGRpci5maWx0ZXJzID8gdGhpcy5fYXBwbHlGaWx0ZXJzKHZhbCwgbnVsbCwgZGlyLmZpbHRlcnMpIDogdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBmaWx0ZXJcbiAgICAgIHJldHVybiB0aGlzLiRnZXQodGV4dCwgYXNTdGF0ZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW50ZXJwb2xhdGUgYSBwaWVjZSBvZiB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGludGVycG9sYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gcGFyc2VUZXh0KHRleHQpO1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZtLiRldmFsKHRva2Vuc1swXS52YWx1ZSkgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHJldHVybiB0b2tlbi50YWcgPyB2bS4kZXZhbCh0b2tlbi52YWx1ZSkgOiB0b2tlbi52YWx1ZTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTG9nIGluc3RhbmNlIGRhdGEgYXMgYSBwbGFpbiBKUyBvYmplY3RcbiAgICogc28gdGhhdCBpdCBpcyBlYXNpZXIgdG8gaW5zcGVjdCBpbiBjb25zb2xlLlxuICAgKiBUaGlzIG1ldGhvZCBhc3N1bWVzIGNvbnNvbGUgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGxvZyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGRhdGEgPSBwYXRoID8gZ2V0UGF0aCh0aGlzLl9kYXRhLCBwYXRoKSA6IHRoaXMuX2RhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGRhdGEgPSBjbGVhbihkYXRhKTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBjb21wdXRlZCBmaWVsZHNcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLiRvcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGNsZWFuKHRoaXNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBcImNsZWFuXCIgYSBnZXR0ZXIvc2V0dGVyIGNvbnZlcnRlZCBvYmplY3QgaW50byBhIHBsYWluXG4gICAqIG9iamVjdCBjb3B5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gLSBvYmpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBjbGVhbihvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21BUEkgKFZ1ZSkge1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBvbi1pbnN0YW5jZSBuZXh0VGljay4gVGhlIGNhbGxiYWNrIGlzXG4gICAqIGF1dG8tYm91bmQgdG8gdGhlIGluc3RhbmNlLCBhbmQgdGhpcyBhdm9pZHMgY29tcG9uZW50XG4gICAqIG1vZHVsZXMgaGF2aW5nIHRvIHJlbHkgb24gdGhlIGdsb2JhbCBWdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgbmV4dFRpY2soZm4sIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmQgaW5zdGFuY2UgdG8gdGFyZ2V0XG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbd2l0aFRyYW5zaXRpb25dIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRhcHBlbmRUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIHJldHVybiBpbnNlcnQodGhpcywgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIGFwcGVuZCwgYXBwZW5kV2l0aFRyYW5zaXRpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGluc3RhbmNlIHRvIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcHJlcGVuZFRvID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgdGhpcy4kYmVmb3JlKHRhcmdldC5maXJzdENoaWxkLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgaW5zdGFuY2UgYmVmb3JlIHRhcmdldFxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kYmVmb3JlID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluc2VydCh0aGlzLCB0YXJnZXQsIGNiLCB3aXRoVHJhbnNpdGlvbiwgYmVmb3JlV2l0aENiLCBiZWZvcmVXaXRoVHJhbnNpdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBpbnN0YW5jZSBhZnRlciB0YXJnZXRcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt3aXRoVHJhbnNpdGlvbl0gLSBkZWZhdWx0cyB0byB0cnVlXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGFmdGVyID0gZnVuY3Rpb24gKHRhcmdldCwgY2IsIHdpdGhUcmFuc2l0aW9uKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Lm5leHRTaWJsaW5nKSB7XG4gICAgICB0aGlzLiRiZWZvcmUodGFyZ2V0Lm5leHRTaWJsaW5nLCBjYiwgd2l0aFRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRhcHBlbmRUbyh0YXJnZXQucGFyZW50Tm9kZSwgY2IsIHdpdGhUcmFuc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBpbnN0YW5jZSBmcm9tIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXSAtIGRlZmF1bHRzIHRvIHRydWVcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kcmVtb3ZlID0gZnVuY3Rpb24gKGNiLCB3aXRoVHJhbnNpdGlvbikge1xuICAgIGlmICghdGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfVxuICAgIHZhciBpbkRvY3VtZW50ID0gdGhpcy5faXNBdHRhY2hlZCAmJiBpbkRvYyh0aGlzLiRlbCk7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBpbiBkb2N1bWVudCwgbm8gbmVlZCB0byBjaGVja1xuICAgIC8vIGZvciB0cmFuc2l0aW9uc1xuICAgIGlmICghaW5Eb2N1bWVudCkgd2l0aFRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlYWxDYiA9IGZ1bmN0aW9uIHJlYWxDYigpIHtcbiAgICAgIGlmIChpbkRvY3VtZW50KSBzZWxmLl9jYWxsSG9vaygnZGV0YWNoZWQnKTtcbiAgICAgIGlmIChjYikgY2IoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLl9pc0ZyYWdtZW50KSB7XG4gICAgICByZW1vdmVOb2RlUmFuZ2UodGhpcy5fZnJhZ21lbnRTdGFydCwgdGhpcy5fZnJhZ21lbnRFbmQsIHRoaXMsIHRoaXMuX2ZyYWdtZW50LCByZWFsQ2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3AgPSB3aXRoVHJhbnNpdGlvbiA9PT0gZmFsc2UgPyByZW1vdmVXaXRoQ2IgOiByZW1vdmVXaXRoVHJhbnNpdGlvbjtcbiAgICAgIG9wKHRoaXMuJGVsLCB0aGlzLCByZWFsQ2IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2hhcmVkIERPTSBpbnNlcnRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VnVlfSB2bVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3dpdGhUcmFuc2l0aW9uXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcDEgLSBvcCBmb3Igbm9uLXRyYW5zaXRpb24gaW5zZXJ0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wMiAtIG9wIGZvciB0cmFuc2l0aW9uIGluc2VydFxuICAgKiBAcmV0dXJuIHZtXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluc2VydCh2bSwgdGFyZ2V0LCBjYiwgd2l0aFRyYW5zaXRpb24sIG9wMSwgb3AyKSB7XG4gICAgdGFyZ2V0ID0gcXVlcnkodGFyZ2V0KTtcbiAgICB2YXIgdGFyZ2V0SXNEZXRhY2hlZCA9ICFpbkRvYyh0YXJnZXQpO1xuICAgIHZhciBvcCA9IHdpdGhUcmFuc2l0aW9uID09PSBmYWxzZSB8fCB0YXJnZXRJc0RldGFjaGVkID8gb3AxIDogb3AyO1xuICAgIHZhciBzaG91bGRDYWxsSG9vayA9ICF0YXJnZXRJc0RldGFjaGVkICYmICF2bS5faXNBdHRhY2hlZCAmJiAhaW5Eb2Modm0uJGVsKTtcbiAgICBpZiAodm0uX2lzRnJhZ21lbnQpIHtcbiAgICAgIG1hcE5vZGVSYW5nZSh2bS5fZnJhZ21lbnRTdGFydCwgdm0uX2ZyYWdtZW50RW5kLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBvcChub2RlLCB0YXJnZXQsIHZtKTtcbiAgICAgIH0pO1xuICAgICAgY2IgJiYgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aodm0uJGVsLCB0YXJnZXQsIHZtLCBjYik7XG4gICAgfVxuICAgIGlmIChzaG91bGRDYWxsSG9vaykge1xuICAgICAgdm0uX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgZm9yIHNlbGVjdG9yc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fSBlbFxuICAgKi9cblxuICBmdW5jdGlvbiBxdWVyeShlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZWwgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCkgOiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgb3BlcmF0aW9uIHRoYXQgdGFrZXMgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1Z1ZX0gdm0gLSB1bnVzZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXVxuICAgKi9cblxuICBmdW5jdGlvbiBhcHBlbmQoZWwsIHRhcmdldCwgdm0sIGNiKSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0QmVmb3JlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gYmVmb3JlV2l0aENiKGVsLCB0YXJnZXQsIHZtLCBjYikge1xuICAgIGJlZm9yZShlbCwgdGFyZ2V0KTtcbiAgICBpZiAoY2IpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG9wZXJhdGlvbiB0aGF0IHRha2VzIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICogQHBhcmFtIHtWdWV9IHZtIC0gdW51c2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl1cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlV2l0aENiKGVsLCB2bSwgY2IpIHtcbiAgICByZW1vdmUoZWwpO1xuICAgIGlmIChjYikgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudHNBUEkgKFZ1ZSkge1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgKHRoaXMuX2V2ZW50c1tldmVudF0gfHwgKHRoaXMuX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgIG1vZGlmeUxpc3RlbmVyQ291bnQodGhpcywgZXZlbnQsIDEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAgICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgc2VsZi4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHRoaXMuJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gICAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciBjYnM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgIGZvciAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgY2JzID0gdGhpcy5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtY2JzLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNicyA9IHRoaXMuX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbW9kaWZ5TGlzdGVuZXJDb3VudCh0aGlzLCBldmVudCwgLWNicy5sZW5ndGgpO1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBtb2RpZnlMaXN0ZW5lckNvdW50KHRoaXMsIGV2ZW50LCAtMSk7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZ2dlciBhbiBldmVudCBvbiBzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHNob3VsZFByb3BhZ2F0ZVxuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlzU291cmNlID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJztcbiAgICBldmVudCA9IGlzU291cmNlID8gZXZlbnQgOiBldmVudC5uYW1lO1xuICAgIHZhciBjYnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHZhciBzaG91bGRQcm9wYWdhdGUgPSBpc1NvdXJjZSB8fCAhY2JzO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGhhY2t5IHNvbHV0aW9uIHRvIHRoZSBxdWVzdGlvbiByYWlzZWRcbiAgICAgIC8vIGluICMyMTAyOiBmb3IgYW4gaW5saW5lIGNvbXBvbmVudCBsaXN0ZW5lciBsaWtlIDxjb21wIEB0ZXN0PVwiZG9UaGlzXCI+LFxuICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhhbmRsaW5nIGlzIHNvbWV3aGF0IGJyb2tlbi4gVGhlcmVmb3JlIHdlXG4gICAgICAvLyBuZWVkIHRvIHRyZWF0IHRoZXNlIGlubGluZSBjYWxsYmFja3MgZGlmZmVyZW50bHkuXG4gICAgICB2YXIgaGFzUGFyZW50Q2JzID0gaXNTb3VyY2UgJiYgY2JzLnNvbWUoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYi5fZnJvbVBhcmVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc1BhcmVudENicykge1xuICAgICAgICBzaG91bGRQcm9wYWdhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcbiAgICAgICAgdmFyIHJlcyA9IGNiLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzID09PSB0cnVlICYmICghaGFzUGFyZW50Q2JzIHx8IGNiLl9mcm9tUGFyZW50KSkge1xuICAgICAgICAgIHNob3VsZFByb3BhZ2F0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFByb3BhZ2F0ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYnJvYWRjYXN0IGFuIGV2ZW50IHRvIGFsbCBjaGlsZHJlbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHsuLi4qfSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgKi9cblxuICBWdWUucHJvdG90eXBlLiRicm9hZGNhc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaXNTb3VyY2UgPSB0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnO1xuICAgIGV2ZW50ID0gaXNTb3VyY2UgPyBldmVudCA6IGV2ZW50Lm5hbWU7XG4gICAgLy8gaWYgbm8gY2hpbGQgaGFzIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnQsXG4gICAgLy8gdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gYnJvYWRjYXN0LlxuICAgIGlmICghdGhpcy5fZXZlbnRzQ291bnRbZXZlbnRdKSByZXR1cm47XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kY2hpbGRyZW47XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgaWYgKGlzU291cmNlKSB7XG4gICAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgICAgLy8gb24gY2hpbGRyZW5cbiAgICAgIGFyZ3NbMF0gPSB7IG5hbWU6IGV2ZW50LCBzb3VyY2U6IHRoaXMgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIHNob3VsZFByb3BhZ2F0ZSA9IGNoaWxkLiRlbWl0LmFwcGx5KGNoaWxkLCBhcmdzKTtcbiAgICAgIGlmIChzaG91bGRQcm9wYWdhdGUpIHtcbiAgICAgICAgY2hpbGQuJGJyb2FkY2FzdC5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBwcm9wYWdhdGUgYW4gZXZlbnQgdXAgdGhlIHBhcmVudCBjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Li4uKn0gYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc2hvdWxkUHJvcGFnYXRlID0gdGhpcy4kZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghc2hvdWxkUHJvcGFnYXRlKSByZXR1cm47XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuJHBhcmVudDtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAvLyB1c2Ugb2JqZWN0IGV2ZW50IHRvIGluZGljYXRlIG5vbi1zb3VyY2UgZW1pdFxuICAgIC8vIG9uIHBhcmVudHNcbiAgICBhcmdzWzBdID0geyBuYW1lOiBldmVudCwgc291cmNlOiB0aGlzIH07XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgc2hvdWxkUHJvcGFnYXRlID0gcGFyZW50LiRlbWl0LmFwcGx5KHBhcmVudCwgYXJncyk7XG4gICAgICBwYXJlbnQgPSBzaG91bGRQcm9wYWdhdGUgPyBwYXJlbnQuJHBhcmVudCA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIGxpc3RlbmVyIGNvdW50cyBvbiBhbGwgcGFyZW50cy5cbiAgICogVGhpcyBib29ra2VlcGluZyBhbGxvd3MgJGJyb2FkY2FzdCB0byByZXR1cm4gZWFybHkgd2hlblxuICAgKiBubyBjaGlsZCBoYXMgbGlzdGVuZWQgdG8gYSBjZXJ0YWluIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1Z1ZX0gdm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICAgKi9cblxuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIGZ1bmN0aW9uIG1vZGlmeUxpc3RlbmVyQ291bnQodm0sIGV2ZW50LCBjb3VudCkge1xuICAgIHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIC8vIGhvb2tzIGRvIG5vdCBnZXQgYnJvYWRjYXN0ZWQgc28gbm8gbmVlZFxuICAgIC8vIHRvIGRvIGJvb2trZWVwaW5nIGZvciB0aGVtXG4gICAgaWYgKCFwYXJlbnQgfHwgIWNvdW50IHx8IGhvb2tSRS50ZXN0KGV2ZW50KSkgcmV0dXJuO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdID0gKHBhcmVudC5fZXZlbnRzQ291bnRbZXZlbnRdIHx8IDApICsgY291bnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlQVBJIChWdWUpIHtcblxuICAvKipcbiAgICogU2V0IGluc3RhbmNlIHRhcmdldCBlbGVtZW50IGFuZCBraWNrIG9mZiB0aGUgY29tcGlsYXRpb25cbiAgICogcHJvY2Vzcy4gVGhlIHBhc3NlZCBpbiBgZWxgIGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZywgYW5cbiAgICogZXhpc3RpbmcgRWxlbWVudCwgb3IgYSBEb2N1bWVudEZyYWdtZW50IChmb3IgYmxvY2tcbiAgICogaW5zdGFuY2VzKS5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR8c3RyaW5nfSBlbFxuICAgKiBAcHVibGljXG4gICAqL1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29tcGlsZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybignJG1vdW50KCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsID0gcXVlcnkoZWwpO1xuICAgIGlmICghZWwpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfVxuICAgIHRoaXMuX2NvbXBpbGUoZWwpO1xuICAgIHRoaXMuX2luaXRET01Ib29rcygpO1xuICAgIGlmIChpbkRvYyh0aGlzLiRlbCkpIHtcbiAgICAgIHRoaXMuX2NhbGxIb29rKCdhdHRhY2hlZCcpO1xuICAgICAgcmVhZHkuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kb25jZSgnaG9vazphdHRhY2hlZCcsIHJlYWR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmsgYW4gaW5zdGFuY2UgYXMgcmVhZHkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgIHRoaXMuX2lzQXR0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuX2NhbGxIb29rKCdyZWFkeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlYXJkb3duIHRoZSBpbnN0YW5jZSwgc2ltcGx5IGRlbGVnYXRlIHRvIHRoZSBpbnRlcm5hbFxuICAgKiBfZGVzdHJveS5cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUsIGRlZmVyQ2xlYW51cCkge1xuICAgIHRoaXMuX2Rlc3Ryb3kocmVtb3ZlLCBkZWZlckNsZWFudXApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJ0aWFsbHkgY29tcGlsZSBhIHBpZWNlIG9mIERPTSBhbmQgcmV0dXJuIGFcbiAgICogZGVjb21waWxlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxcbiAgICogQHBhcmFtIHtWdWV9IFtob3N0XVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICovXG5cbiAgVnVlLnByb3RvdHlwZS4kY29tcGlsZSA9IGZ1bmN0aW9uIChlbCwgaG9zdCwgc2NvcGUsIGZyYWcpIHtcbiAgICByZXR1cm4gY29tcGlsZShlbCwgdGhpcy4kb3B0aW9ucywgdHJ1ZSkodGhpcywgZWwsIGhvc3QsIHNjb3BlLCBmcmFnKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgZXhwb3NlZCBWdWUgY29uc3RydWN0b3IuXG4gKlxuICogQVBJIGNvbnZlbnRpb25zOlxuICogLSBwdWJsaWMgQVBJIG1ldGhvZHMvcHJvcGVydGllcyBhcmUgcHJlZml4ZWQgd2l0aCBgJGBcbiAqIC0gaW50ZXJuYWwgbWV0aG9kcy9wcm9wZXJ0aWVzIGFyZSBwcmVmaXhlZCB3aXRoIGBfYFxuICogLSBub24tcHJlZml4ZWQgcHJvcGVydGllcyBhcmUgYXNzdW1lZCB0byBiZSBwcm94aWVkIHVzZXJcbiAqICAgZGF0YS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG4vLyBpbnN0YWxsIGludGVybmFsc1xuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbm1pc2NNaXhpbihWdWUpO1xuXG4vLyBpbnN0YWxsIEFQSXNcbmdsb2JhbEFQSShWdWUpO1xuZGF0YUFQSShWdWUpO1xuZG9tQVBJKFZ1ZSk7XG5ldmVudHNBUEkoVnVlKTtcbmxpZmVjeWNsZUFQSShWdWUpO1xuXG52YXIgY29udmVydEFycmF5ID0gdkZvci5fcG9zdFByb2Nlc3M7XG5cbi8qKlxuICogTGltaXQgZmlsdGVyIGZvciBhcnJheXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAoRGVjaW1hbCBleHBlY3RlZClcbiAqL1xuXG5mdW5jdGlvbiBsaW1pdEJ5KGFyciwgbiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCwgMTApIDogMDtcbiAgbiA9IHRvTnVtYmVyKG4pO1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInID8gYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbikgOiBhcnI7XG59XG5cbi8qKlxuICogRmlsdGVyIGZpbHRlciBmb3IgYXJyYXlzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtTdHJpbmd9IFtkZWxpbWl0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gLi4uZGF0YUtleXNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJCeShhcnIsIHNlYXJjaCwgZGVsaW1pdGVyKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoc2VhcmNoID09IG51bGwpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoc2VhcmNoKTtcbiAgfVxuICAvLyBjYXN0IHRvIGxvd2VyY2FzZSBzdHJpbmdcbiAgc2VhcmNoID0gKCcnICsgc2VhcmNoKS50b0xvd2VyQ2FzZSgpO1xuICAvLyBhbGxvdyBvcHRpb25hbCBgaW5gIGRlbGltaXRlclxuICAvLyBiZWNhdXNlIHdoeSBub3RcbiAgdmFyIG4gPSBkZWxpbWl0ZXIgPT09ICdpbicgPyAzIDogMjtcbiAgLy8gZXh0cmFjdCBhbmQgZmxhdHRlbiBrZXlzXG4gIHZhciBrZXlzID0gdG9BcnJheShhcmd1bWVudHMsIG4pLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgcmV0dXJuIHByZXYuY29uY2F0KGN1cik7XG4gIH0sIFtdKTtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaXRlbSwga2V5LCB2YWwsIGo7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGl0ZW0gPSBhcnJbaV07XG4gICAgdmFsID0gaXRlbSAmJiBpdGVtLiR2YWx1ZSB8fCBpdGVtO1xuICAgIGogPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaikge1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBrZXkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoa2V5ID09PSAnJGtleScgJiYgY29udGFpbnMoaXRlbS4ka2V5LCBzZWFyY2gpIHx8IGNvbnRhaW5zKGdldFBhdGgodmFsLCBrZXkpLCBzZWFyY2gpKSB7XG4gICAgICAgICAgcmVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zKGl0ZW0sIHNlYXJjaCkpIHtcbiAgICAgIHJlcy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEZpbHRlciBmaWx0ZXIgZm9yIGFycmF5c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3J0S2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gcmV2ZXJzZVxuICovXG5cbmZ1bmN0aW9uIG9yZGVyQnkoYXJyLCBzb3J0S2V5LCByZXZlcnNlKSB7XG4gIGFyciA9IGNvbnZlcnRBcnJheShhcnIpO1xuICBpZiAoIXNvcnRLZXkpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG4gIHZhciBvcmRlciA9IHJldmVyc2UgJiYgcmV2ZXJzZSA8IDAgPyAtMSA6IDE7XG4gIC8vIHNvcnQgb24gYSBjb3B5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGFycmF5XG4gIHJldHVybiBhcnIuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKHNvcnRLZXkgIT09ICcka2V5Jykge1xuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICckdmFsdWUnIGluIGEpIGEgPSBhLiR2YWx1ZTtcbiAgICAgIGlmIChpc09iamVjdChiKSAmJiAnJHZhbHVlJyBpbiBiKSBiID0gYi4kdmFsdWU7XG4gICAgfVxuICAgIGEgPSBpc09iamVjdChhKSA/IGdldFBhdGgoYSwgc29ydEtleSkgOiBhO1xuICAgIGIgPSBpc09iamVjdChiKSA/IGdldFBhdGgoYiwgc29ydEtleSkgOiBiO1xuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gb3JkZXIgOiAtb3JkZXI7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN0cmluZyBjb250YWluIGhlbHBlclxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG4gKi9cblxuZnVuY3Rpb24gY29udGFpbnModmFsLCBzZWFyY2gpIHtcbiAgdmFyIGk7XG4gIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjb250YWlucyh2YWxba2V5c1tpXV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjb250YWlucyh2YWxbaV0sIHNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID4gLTE7XG4gIH1cbn1cblxudmFyIGRpZ2l0c1JFID0gLyhcXGR7M30pKD89XFxkKS9nO1xuXG4vLyBhc3NldCBjb2xsZWN0aW9ucyBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LlxudmFyIGZpbHRlcnMgPSB7XG5cbiAgb3JkZXJCeTogb3JkZXJCeSxcbiAgZmlsdGVyQnk6IGZpbHRlckJ5LFxuICBsaW1pdEJ5OiBsaW1pdEJ5LFxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZnkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRlbnRcbiAgICovXG5cbiAganNvbjoge1xuICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQodmFsdWUsIGluZGVudCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCBOdW1iZXIoaW5kZW50KSB8fCAyKTtcbiAgICB9LFxuICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiAnYWJjJyA9PiAnQWJjJ1xuICAgKi9cblxuICBjYXBpdGFsaXplOiBmdW5jdGlvbiBjYXBpdGFsaXplKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkgcmV0dXJuICcnO1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKTtcbiAgfSxcblxuICAvKipcbiAgICogJ2FiYycgPT4gJ0FCQydcbiAgICovXG5cbiAgdXBwZXJjYXNlOiBmdW5jdGlvbiB1cHBlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogJ0FiQycgPT4gJ2FiYydcbiAgICovXG5cbiAgbG93ZXJjYXNlOiBmdW5jdGlvbiBsb3dlcmNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfSxcblxuICAvKipcbiAgICogMTIzNDUgPT4gJDEyLDM0NS4wMFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnblxuICAgKi9cblxuICBjdXJyZW5jeTogZnVuY3Rpb24gY3VycmVuY3kodmFsdWUsIF9jdXJyZW5jeSkge1xuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkgfHwgIXZhbHVlICYmIHZhbHVlICE9PSAwKSByZXR1cm4gJyc7XG4gICAgX2N1cnJlbmN5ID0gX2N1cnJlbmN5ICE9IG51bGwgPyBfY3VycmVuY3kgOiAnJCc7XG4gICAgdmFyIHN0cmluZ2lmaWVkID0gTWF0aC5hYnModmFsdWUpLnRvRml4ZWQoMik7XG4gICAgdmFyIF9pbnQgPSBzdHJpbmdpZmllZC5zbGljZSgwLCAtMyk7XG4gICAgdmFyIGkgPSBfaW50Lmxlbmd0aCAlIDM7XG4gICAgdmFyIGhlYWQgPSBpID4gMCA/IF9pbnQuc2xpY2UoMCwgaSkgKyAoX2ludC5sZW5ndGggPiAzID8gJywnIDogJycpIDogJyc7XG4gICAgdmFyIF9mbG9hdCA9IHN0cmluZ2lmaWVkLnNsaWNlKC0zKTtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/ICctJyA6ICcnO1xuICAgIHJldHVybiBfY3VycmVuY3kgKyBzaWduICsgaGVhZCArIF9pbnQuc2xpY2UoaSkucmVwbGFjZShkaWdpdHNSRSwgJyQxLCcpICsgX2Zsb2F0O1xuICB9LFxuXG4gIC8qKlxuICAgKiAnaXRlbScgPT4gJ2l0ZW1zJ1xuICAgKlxuICAgKiBAcGFyYW1zXG4gICAqICBhbiBhcnJheSBvZiBzdHJpbmdzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICogIHRoZSBzaW5nbGUsIGRvdWJsZSwgdHJpcGxlIC4uLiBmb3JtcyBvZiB0aGUgd29yZCB0b1xuICAgKiAgYmUgcGx1cmFsaXplZC4gV2hlbiB0aGUgbnVtYmVyIHRvIGJlIHBsdXJhbGl6ZWRcbiAgICogIGV4Y2VlZHMgdGhlIGxlbmd0aCBvZiB0aGUgYXJncywgaXQgd2lsbCB1c2UgdGhlIGxhc3RcbiAgICogIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICpcbiAgICogIGUuZy4gWydzaW5nbGUnLCAnZG91YmxlJywgJ3RyaXBsZScsICdtdWx0aXBsZSddXG4gICAqL1xuXG4gIHBsdXJhbGl6ZTogZnVuY3Rpb24gcGx1cmFsaXplKHZhbHVlKSB7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gMSA/IGFyZ3NbdmFsdWUgJSAxMCAtIDFdIHx8IGFyZ3NbYXJncy5sZW5ndGggLSAxXSA6IGFyZ3NbMF0gKyAodmFsdWUgPT09IDEgPyAnJyA6ICdzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlYm91bmNlIGEgaGFuZGxlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgPSAzMDBcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuXG4gIGRlYm91bmNlOiBmdW5jdGlvbiBkZWJvdW5jZShoYW5kbGVyLCBkZWxheSkge1xuICAgIGlmICghaGFuZGxlcikgcmV0dXJuO1xuICAgIGlmICghZGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gMzAwO1xuICAgIH1cbiAgICByZXR1cm4gX2RlYm91bmNlKGhhbmRsZXIsIGRlbGF5KTtcbiAgfVxufTtcblxudmFyIHBhcnRpYWwgPSB7XG5cbiAgcHJpb3JpdHk6IFBBUlRJQUwsXG5cbiAgcGFyYW1zOiBbJ25hbWUnXSxcblxuICAvLyB3YXRjaCBjaGFuZ2VzIHRvIG5hbWUgZm9yIGR5bmFtaWMgcGFydGlhbHNcbiAgcGFyYW1XYXRjaGVyczoge1xuICAgIG5hbWU6IGZ1bmN0aW9uIG5hbWUodmFsdWUpIHtcbiAgICAgIHZJZi5yZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmluc2VydCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdGhpcy5hbmNob3IgPSBjcmVhdGVBbmNob3IoJ3YtcGFydGlhbCcpO1xuICAgIHJlcGxhY2UodGhpcy5lbCwgdGhpcy5hbmNob3IpO1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMucGFyYW1zLm5hbWUpO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KGlkKSB7XG4gICAgdmFyIHBhcnRpYWwgPSByZXNvbHZlQXNzZXQodGhpcy52bS4kb3B0aW9ucywgJ3BhcnRpYWxzJywgaWQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRBc3NldChwYXJ0aWFsLCAncGFydGlhbCcsIGlkKTtcbiAgICB9XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRoaXMuZmFjdG9yeSA9IG5ldyBGcmFnbWVudEZhY3RvcnkodGhpcy52bSwgcGFydGlhbCk7XG4gICAgICB2SWYuaW5zZXJ0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKCkge1xuICAgIGlmICh0aGlzLmZyYWcpIHtcbiAgICAgIHRoaXMuZnJhZy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBlbGVtZW50RGlyZWN0aXZlIHRoYXQgaGFuZGxlcyA8Y29udGVudD5cbi8vIHRyYW5zY2x1c2lvbnMuIEl0IHJlbGllcyBvbiB0aGUgcmF3IGNvbnRlbnQgb2YgYW5cbi8vIGluc3RhbmNlIGJlaW5nIHN0b3JlZCBhcyBgJG9wdGlvbnMuX2NvbnRlbnRgIGR1cmluZ1xuLy8gdGhlIHRyYW5zY2x1ZGUgcGhhc2UuXG5cbi8vIFdlIGFyZSBleHBvcnRpbmcgdHdvIHZlcnNpb25zLCBvbmUgZm9yIG5hbWVkIGFuZCBvbmVcbi8vIGZvciB1bm5hbWVkLCBiZWNhdXNlIHRoZSB1bm5hbWVkIHNsb3RzIG11c3QgYmUgY29tcGlsZWRcbi8vIEFGVEVSIGFsbCBuYW1lZCBzbG90cyBoYXZlIHNlbGVjdGVkIHRoZWlyIGNvbnRlbnQuIFNvXG4vLyB3ZSBuZWVkIHRvIGdpdmUgdGhlbSBkaWZmZXJlbnQgcHJpb3JpdGllcyBpbiB0aGUgY29tcGlsYXRpb25cbi8vIHByb2Nlc3MuIChTZWUgIzE5NjUpXG5cbnZhciBzbG90ID0ge1xuXG4gIHByaW9yaXR5OiBTTE9ULFxuXG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgdmFyIGhvc3QgPSB0aGlzLnZtO1xuICAgIHZhciByYXcgPSBob3N0LiRvcHRpb25zLl9jb250ZW50O1xuICAgIGlmICghcmF3KSB7XG4gICAgICB0aGlzLmZhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb250ZXh0ID0gaG9zdC5fY29udGV4dDtcbiAgICB2YXIgc2xvdE5hbWUgPSB0aGlzLnBhcmFtcyAmJiB0aGlzLnBhcmFtcy5uYW1lO1xuICAgIGlmICghc2xvdE5hbWUpIHtcbiAgICAgIC8vIERlZmF1bHQgc2xvdFxuICAgICAgdGhpcy50cnlDb21waWxlKGV4dHJhY3RGcmFnbWVudChyYXcuY2hpbGROb2RlcywgcmF3LCB0cnVlKSwgY29udGV4dCwgaG9zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5hbWVkIHNsb3RcbiAgICAgIHZhciBzZWxlY3RvciA9ICdbc2xvdD1cIicgKyBzbG90TmFtZSArICdcIl0nO1xuICAgICAgdmFyIG5vZGVzID0gcmF3LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRyeUNvbXBpbGUoZXh0cmFjdEZyYWdtZW50KG5vZGVzLCByYXcpLCBjb250ZXh0LCBob3N0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmFsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJ5Q29tcGlsZTogZnVuY3Rpb24gdHJ5Q29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KSB7XG4gICAgaWYgKGNvbnRlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICB0aGlzLmNvbXBpbGUoY29udGVudCwgY29udGV4dCwgaG9zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFsbGJhY2soKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShjb250ZW50LCBjb250ZXh0LCBob3N0KSB7XG4gICAgaWYgKGNvbnRlbnQgJiYgY29udGV4dCkge1xuICAgICAgdmFyIHNjb3BlID0gaG9zdCA/IGhvc3QuX3Njb3BlIDogdGhpcy5fc2NvcGU7XG4gICAgICB0aGlzLnVubGluayA9IGNvbnRleHQuJGNvbXBpbGUoY29udGVudCwgaG9zdCwgc2NvcGUsIHRoaXMuX2ZyYWcpO1xuICAgIH1cbiAgICBpZiAoY29udGVudCkge1xuICAgICAgcmVwbGFjZSh0aGlzLmVsLCBjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKHRoaXMuZWwpO1xuICAgIH1cbiAgfSxcblxuICBmYWxsYmFjazogZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgdGhpcy5jb21waWxlKGV4dHJhY3RDb250ZW50KHRoaXMuZWwsIHRydWUpLCB0aGlzLnZtKTtcbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICBpZiAodGhpcy51bmxpbmspIHtcbiAgICAgIHRoaXMudW5saW5rKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgbmFtZWRTbG90ID0gZXh0ZW5kKGV4dGVuZCh7fSwgc2xvdCksIHtcbiAgcHJpb3JpdHk6IHNsb3QucHJpb3JpdHkgKyAxLFxuICBwYXJhbXM6IFsnbmFtZSddXG59KTtcblxuLyoqXG4gKiBFeHRyYWN0IHF1YWxpZmllZCBjb250ZW50IG5vZGVzIGZyb20gYSBub2RlIGxpc3QuXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdH0gbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG1haW5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cblxuZnVuY3Rpb24gZXh0cmFjdEZyYWdtZW50KG5vZGVzLCBwYXJlbnQsIG1haW4pIHtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBpZiB0aGlzIGlzIHRoZSBtYWluIG91dGxldCwgd2Ugd2FudCB0byBza2lwIGFsbFxuICAgIC8vIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZXM7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSB3YW50IHRvIG1hcmsgdGhlIG5vZGUgYXMgc2VsZWN0ZWQuXG4gICAgLy8gY2xvbmUgdGhlIG5vZGUgc28gdGhlIG9yaWdpbmFsIHJhdyBjb250ZW50IHJlbWFpbnNcbiAgICAvLyBpbnRhY3QuIHRoaXMgZW5zdXJlcyBwcm9wZXIgcmUtY29tcGlsYXRpb24gaW4gY2FzZXNcbiAgICAvLyB3aGVyZSB0aGUgb3V0bGV0IGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJsb2NrXG4gICAgaWYgKG1haW4gJiYgIW5vZGUuX192X3NlbGVjdGVkKSB7XG4gICAgICBhcHBlbmQobm9kZSk7XG4gICAgfSBlbHNlIGlmICghbWFpbiAmJiBub2RlLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgbm9kZS5fX3Zfc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgYXBwZW5kKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJhZztcblxuICBmdW5jdGlvbiBhcHBlbmQobm9kZSkge1xuICAgIGlmIChpc1RlbXBsYXRlKG5vZGUpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1pZicpICYmICFub2RlLmhhc0F0dHJpYnV0ZSgndi1mb3InKSkge1xuICAgICAgbm9kZSA9IHBhcnNlVGVtcGxhdGUobm9kZSk7XG4gICAgfVxuICAgIG5vZGUgPSBjbG9uZU5vZGUobm9kZSk7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgfVxufVxuXG52YXIgZWxlbWVudERpcmVjdGl2ZXMgPSB7XG4gIHNsb3Q6IHNsb3QsXG4gIF9uYW1lZFNsb3Q6IG5hbWVkU2xvdCwgLy8gc2FtZSBhcyBzbG90IGJ1dCB3aXRoIGhpZ2hlciBwcmlvcml0eVxuICBwYXJ0aWFsOiBwYXJ0aWFsXG59O1xuXG5WdWUudmVyc2lvbiA9ICcxLjAuMTUnO1xuXG4vKipcbiAqIFZ1ZSBhbmQgZXZlcnkgY29uc3RydWN0b3IgdGhhdCBleHRlbmRzIFZ1ZSBoYXMgYW5cbiAqIGFzc29jaWF0ZWQgb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBkdXJpbmdcbiAqIGNvbXBpbGF0aW9uIHN0ZXBzIGFzIGB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnNgLlxuICpcbiAqIFRoZXNlIGNhbiBiZSBzZWVuIGFzIHRoZSBkZWZhdWx0IG9wdGlvbnMgb2YgZXZlcnlcbiAqIFZ1ZSBpbnN0YW5jZS5cbiAqL1xuXG5WdWUub3B0aW9ucyA9IHtcbiAgZGlyZWN0aXZlczogcHVibGljRGlyZWN0aXZlcyxcbiAgZWxlbWVudERpcmVjdGl2ZXM6IGVsZW1lbnREaXJlY3RpdmVzLFxuICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICB0cmFuc2l0aW9uczoge30sXG4gIGNvbXBvbmVudHM6IHt9LFxuICBwYXJ0aWFsczoge30sXG4gIHJlcGxhY2U6IHRydWVcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGluQnJvd3Nlcikge1xuICBpZiAod2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHtcbiAgICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5lbWl0KCdpbml0JywgVnVlKTtcbiAgfSBlbHNlIGlmICgvQ2hyb21lXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIGNvbnNvbGUubG9nKCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgKyAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scycpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlOyIsIm1vZHVsZS5leHBvcnRzID0gJzwhLS0gIC0tPlxcblxcbjxkaXYgY2xhc3M9XCJiYXIgYmFyLWhlYWRlciBiYXItcG9zaXRpdmVcIiB2LXRvdWNoOnRhcGhvbGQ9XCJzaG93VHV0c1wiPlxcbiAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1pY29uIGljb24tbGVmdCBpY29uIGlvbi1wZXJzb24tYWRkXCIgdi1saW5rPVwieyBuYW1lOiBcXCdwdWJsaWMucmVnaXN0ZXJcXCcgfVwiPlJlZ2lzdGVyPC9idXR0b24+XFxuICAgIDxoMSBjbGFzcz1cInRpdGxlXCI+Q29udm95PC9oMT5cXG4gICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBidXR0b24taWNvbiBpY29uLXJpZ2h0IGljb24gaW9uLXBlcnNvblwiIHYtbGluaz1cInsgbmFtZTogXFwncHVibGljLmxvZ2luXFwnIH1cIj5Mb2dpbjwvYnV0dG9uPlxcbjwvZGl2PlxcblxcbjxkaXYgaWQ9XCJjb250ZW50XCI+XFxuICAgIDxkaXYgY2xhc3M9XCJjYXJkXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbSBpdGVtLXRleHQtd3JhcFwiPlxcbiAgICAgICAgICAgIDxjZW50ZXI+XFxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiL2ltZy9sb2dvX2Jsay5wbmdcIiBjbGFzcz1cIlwiPlxcbiAgICAgICAgICAgIDwvY2VudGVyPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8bGkgY2xhc3M9XCJpdGVtIGl0ZW0tZGl2aWRlclwiPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWJsb2NrIGJ1dHRvbi1wb3NpdGl2ZVwiIHYtdG91Y2g6dGFwPVwiZGV2MVwiPk9wZW48L2J1dHRvbj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1ibG9jayBidXR0b24tcG9zaXRpdmVcIiB2LXRvdWNoOnRhcD1cImRldjJcIj5DbG9zZTwvYnV0dG9uPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWJsb2NrIGJ1dHRvbi1wb3NpdGl2ZVwiIHYtdG91Y2g6dGFwPVwiZGV2M1wiPkRldjM8L2J1dHRvbj5cXG4gICAgICAgIDwvbGk+XFxuICAgIDwvZGl2PlxcbjwvZGl2Plxcblxcbic7IiwibW9kdWxlLmV4cG9ydHMgPSAnPCEtLSAgLS0+XFxuXFxuPGRpdiBjbGFzcz1cInJvd1wiPlxcbiAgICA8ZGl2IGNsYXNzPVwiY29sIGNvbC0xMDBcIj5cXG4gICAgICAgIDxwIGNsYXNzPVwidC1jZW50ZXIgdC1odWdlXCI+R2V0dGluZyBTdGFydGVkPC9wPlxcbiAgICA8L2Rpdj5cXG48L2Rpdj5cXG5cXG48aHI+XFxuXFxuPGRpdiBjbGFzcz1cInJvd1wiPlxcbiAgICA8ZGl2IGNsYXNzPVwiY29sIGNvbC0xMDBcIj5cXG4gICAgICAgIDxwIGNsYXNzPVwidC1iaWdcIj5cXG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVwiY29sb3ItYmFsYW5jZWRcIj5BY3RpdmF0ZSBxdWljayB0dXRvcmlhbHM8L3N0cm9uZz4gYnkgb25lIG9mOlxcbiAgICAgICAgPC9wPlxcbiAgICAgICAgPHVsIGNsYXNzPVwidC1saXN0XCI+XFxuICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVwiY29sb3ItZW5lcmdpemVkXCI+VEFQIEhPTEQ8L3N0cm9uZz4gdGhlXFxuICAgICAgICAgICAgICAgIDxzdHJvbmcgY2xhc3M9XCJjb2xvci1jYWxtXCI+dG9wIHRpdGxlIGJhcjwvc3Ryb25nPlxcbiAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVwiY29sb3ItZW5lcmdpemVkXCI+U1dJUEUgVVA8L3N0cm9uZz4gb24gdGhlXFxuICAgICAgICAgICAgICAgIDxzdHJvbmcgY2xhc3M9XCJjb2xvci1jYWxtXCI+c3dpcGUgYmFyPC9zdHJvbmc+XFxuICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8bGk+XFxuICAgICAgICAgICAgICAgIEVhY2ggdmlldyBoYXMgYSBkaWZmZXJlbnQgdHV0b3JpYWxcXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXFxuPGhyPlxcblxcbjxkaXYgY2xhc3M9XCJyb3dcIj5cXG4gICAgPGRpdiBjbGFzcz1cImNvbCBjb2wtMTAwXCI+XFxuICAgICAgICA8IS0tIDxwIGNsYXNzPVwidC1iaWdcIj5Vc2luZyB0aGUgc3dpcGUgYmFyOjwvcD4gLS0+XFxuICAgICAgICA8dWwgY2xhc3M9XCJ0LWxpc3RcIj5cXG4gICAgICAgICAgICA8IS0tIDxsaT48dT5Zb3UgZG9uXFwndCBoYXZlIHRvIHVzZSB0aGUgc3dpcGUgYmFyLjwvdT48L2xpPiAtLT5cXG4gICAgICAgICAgICA8bGk+VGhlIHN3aXBlIGJhciBwcm92aWRlcyB0aGUgdXNlciBhbiBlYXN5ICZhbXA7IGZsdWVudCBleHBlcmllbmNlLiBJdCBhZGFwdHMgdG8gdGhlIGN1cnJlbnQgdmlldyB5b3VcXCdyZSBvbiBwcm92aWRpbmdcXG4gICAgICAgICAgICAgICAgeW91IGR5bmFtaWMgYWN0aW9uIGJ1dHRvbnMgZGlyZWN0bHkgYmVsb3cgeW91ciB0aHVtYi5cXG4gICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgPC91bD5cXG4gICAgPC9kaXY+XFxuPC9kaXY+XFxuXFxuXFxuXFxuPGRpdiBjbGFzcz1cInJvdyBib3R0b20tM1wiPlxcbiAgICA8ZGl2IGNsYXNzPVwiY29sIGNvbC0zMyB0LWNlbnRlclwiPlxcbiAgICAgICAgPHA+XFxuICAgICAgICAgICAgPHN0cm9uZyBjbGFzcz1cImNvbG9yLWVuZXJnaXplZFwiPlNXSVBFIFJJR0hUPC9zdHJvbmc+XFxuICAgICAgICA8L3A+XFxuICAgICAgICA8cD5cXG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVwiY29sb3ItY2FsbVwiPkdvIEJhY2s8L3N0cm9uZz5cXG4gICAgICAgIDwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJjb2wgY29sLTMzIHQtY2VudGVyXCI+XFxuICAgICAgICA8cD5cXG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVwiY29sb3ItZW5lcmdpemVkXCI+U1dJUEUgVVA8L3N0cm9uZz5cXG4gICAgICAgIDwvcD5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgICAgIDxzdHJvbmcgY2xhc3M9XCJjb2xvci1jYWxtXCI+VHV0b3JpYWw8L3N0cm9uZz5cXG4gICAgICAgIDwvcD5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XCJjb2wgY29sLTMzIHQtY2VudGVyXCI+XFxuICAgICAgICA8cD5cXG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVwiY29sb3ItZW5lcmdpemVkXCI+U1dJUEUgTEVGVDwvc3Ryb25nPlxcbiAgICAgICAgPC9wPlxcbiAgICAgICAgPHA+XFxuICAgICAgICAgICAgPHN0cm9uZyBjbGFzcz1cImNvbG9yLWNhbG1cIj5FeHRyYSBBY3Rpb25zPC9zdHJvbmc+XFxuICAgICAgICA8L3A+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XCJyb3cgYm90dG9tLTJcIj5cXG4gICAgPGRpdiBjbGFzcz1cImNvbCB0LWNlbnRlclwiPlxcbiAgICAgICAgPGkgY2xhc3M9XCJpY29uIGlvbi1hcnJvdy1kb3duLWFcIj48L2k+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVwiY29sIGNvbC01MCB0LWNlbnRlciB0LW1hc3NpdmVcIj5TV0lQRSBCQVI8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cImNvbCB0LWNlbnRlclwiPlxcbiAgICAgICAgPGkgY2xhc3M9XCJpY29uIGlvbi1hcnJvdy1kb3duLWFcIj48L2k+XFxuICAgIDwvZGl2PlxcbjwvZGl2Plxcblxcbic7IiwiLy9cblxudmFyIF8kZGIgPSByZXF1aXJlKCAnLi4vLi4vLi4vYXBwL2RiLmpzJyApXG52YXIgXyRodHRwID0gcmVxdWlyZSggJy4uLy4uLy4uL2FwcC9odHRwLmpzJyApXG52YXIgXyR1dGlscyA9IHJlcXVpcmUoICcuLi8uLi8uLi9hcHAvdXRpbHMuanMnIClcbnZhciBfJHNhbXNhcmEgPSByZXF1aXJlKCAnLi4vLi4vLi4vYXBwL3NhbXNhcmEuanMnIClcblxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR0ZW1wbGF0ZTogcmVxdWlyZSggJy4vYWJvdXQtdGVtcGxhdGUuaHRtbCcgKSxcblxuXHRyZWFkeTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5pbmZvKCAnYWJvdXQgPiBfJGRiID4nLCBfJGRiIClcblxuXHRcdC8vIF8kZGIuc2F2ZSgneWF5eScpXG5cblx0XHQvLyBjb25zb2xlLmxvZyggJ18kZGIudGVtcCA+JywgSlNPTi5zdHJpbmdpZnkoIF8kZGIudGVtcCwgdHJ1ZSwgNCApIClcblxuXHRcdC8vIF8kc2Ftc2FyYS5zQmFyLnVwZGF0ZSggWyB7XG5cdFx0Ly8gXHRfdGV4dDogXCJCYWNrXCIsXG5cdFx0Ly8gXHRfaWNvbjogXCJpb24tYXJyb3ctbGVmdC1jXCIsXG5cdFx0Ly8gXHRfY29sb3I6ICdhc3NlcnRpdmUnLFxuXHRcdC8vIFx0X2hyZWY6IHRydWUsXG5cdFx0Ly8gXHRfY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBcdFx0Y29uc29sZS53YXJuKCAnZ28gYmFjaycgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzIClcblx0XHQvLyB9LCB7XG5cdFx0Ly8gXHRfdGV4dDogXCJCb3VuZGFyaWVzXCIsXG5cdFx0Ly8gXHRfaWNvbjogXCJpb24tbG9nLW91dFwiLFxuXHRcdC8vIFx0X2hyZWY6IHRydWUsXG5cdFx0Ly8gXHRfY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBcdFx0Y29uc29sZS53YXJuKCAnYm91bmRhcmllcycgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzIClcblx0XHQvLyB9LCB7XG5cdFx0Ly8gXHRfdGV4dDogXCJHb3RvIE1hcFwiLFxuXHRcdC8vIFx0X2ljb246IFwiaW9uLWFuZHJvaWQtZXhwYW5kXCIsXG5cdFx0Ly8gXHRfaHJlZjogdHJ1ZSxcblx0XHQvLyBcdF9jbGljazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0XHRjb25zb2xlLndhcm4oICdtYXAnIClcblx0XHQvLyBcdH0uYmluZCggdGhpcyApLFxuXHRcdC8vIFx0X2NsaWNrSG9sZDogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0XHRjb25zb2xlLndhcm4oICdtYXAgX2NsaWNrSG9sZCcgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzIClcblx0XHQvLyB9LCB7XG5cdFx0Ly8gXHRfdGV4dDogXCJBY3Rpdml0aWVzXCIsXG5cdFx0Ly8gXHRfaWNvbjogXCJpb24taW9zLXB1bHNlLXN0cm9uZ1wiLFxuXHRcdC8vIFx0X2hyZWY6IHRydWUsXG5cdFx0Ly8gXHRfY2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBcdFx0Y29uc29sZS53YXJuKCAnQWN0aXZpdGllcycgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzICksXG5cdFx0Ly8gXHRfY2xpY2tIb2xkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gXHRcdGNvbnNvbGUud2FybiggJ0FjdGl2aXRpZXMgX2NsaWNrSG9sZCcgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzIClcblx0XHQvLyB9LCB7XG5cdFx0Ly8gXHRfdGV4dDogXCJTdWJtaXRcIixcblx0XHQvLyBcdF9pY29uOiBcImlvbi1jaGVja21hcmsgZG9uZVwiLFxuXHRcdC8vIFx0X2NsaWNrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gXHRcdGNvbnNvbGUud2FybiggJ1N1Ym1pdCcgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzIClcblx0XHQvLyB9LCB7XG5cdFx0Ly8gXHRfdGV4dDogXCJNb3JlIEFjdGlvbnNcIixcblx0XHQvLyBcdF9pY29uOiBcImlvbi1hbmRyb2lkLW1vcmUtdmVydGljYWxcIixcblx0XHQvLyBcdF9jb2xvcjogJ2JhbGFuY2VkJyxcblx0XHQvLyBcdF9jbGljazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0XHRjb25zb2xlLndhcm4oICdzbWVudScgKVxuXHRcdC8vIFx0fS5iaW5kKCB0aGlzIClcblx0XHQvLyB9IF0gKVxuXG5cblx0XHQvLyB0aGlzLnNob3dUdXRzKClcblxuXG5cblx0XHR0aGlzLiRuZXh0VGljayggZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCAhd2luZG93LnBsdWdpbnMgKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0d2luZG93LnBsdWdpbnMubmF0aXZlcGFnZXRyYW5zaXRpb25zLmV4ZWN1dGVQZW5kaW5nVHJhbnNpdGlvbigpXG5cdFx0fSApXG5cblx0fSxcblxuXHRtZXRob2RzOiB7XG5cdFx0ZGV2MTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gXyR1dGlscy5ldmVudHMuZW1pdCggJ3NhbXNhcmEubU1lbnUub3BlbicgKVxuXG5cdFx0XHR2YXIgZCA9IHtcblx0XHRcdFx0dW5hbWU6ICdyb2InLFxuXHRcdFx0XHRwYXNzOiAnYWJjMTIzJ1xuXHRcdFx0fVxuXG5cdFx0XHRfJGh0dHAucG9zdCggJy9wdWJsaWMvbG9naW4nLCBkLCBmdW5jdGlvbiAoIGVyciwgcmVzcG9uc2UgKSB7XG5cdFx0XHRcdGlmICggZXJyICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVyciApXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfJGRiLnB1dGl0bG9naW4oIHJlc3BvbnNlIClcblxuXHRcdFx0fSApXG5cblxuXG5cblxuXG5cblxuXHRcdH0sXG5cdFx0ZGV2MjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gXyR1dGlscy5ldmVudHMuZW1pdCggJ3NhbXNhcmEubU1lbnUuY2xvc2UnIClcblxuXHRcdFx0dmFyIGQgPSB7XG5cdFx0XHRcdHN0YW1wOiAxXG5cdFx0XHR9XG5cblx0XHRcdF8kaHR0cC5wb3N0KCAnL3NvY2tldC91cGRhdGUnLCBkLCBmdW5jdGlvbiAoIGVyciwgcmVzcG9uc2UgKSB7XG5cdFx0XHRcdGlmICggZXJyICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVyciApXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfJGRiLnB1dGl0c29ja2V0KCByZXNwb25zZSApXG5cblx0XHRcdH0gKVxuXG5cblxuXHRcdH0sXG5cdFx0ZGV2MzogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnZGV2MycgKVxuXHRcdH0sXG5cblx0XHRzaG93VHV0czogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGh0bWwgPSByZXF1aXJlKCAnLi9hYm91dC10dXRzLmh0bWwnIClcblx0XHRcdFx0Ly8gXyRzYW1zYXJhLnR1dHMub3BlbiggaHRtbCApXG5cdFx0fVxuXHR9XG5cbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSAnPCEtLSAgLS0+XFxuXFxuPGRpdiBjbGFzcz1cImJhciBiYXItaGVhZGVyIGJhci1wb3NpdGl2ZVwiIHYtdG91Y2g6dGFwaG9sZD1cInNob3dUdXRzXCI+XFxuICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWljb24gaWNvbi1sZWZ0IGljb24gaW9uLXBlcnNvbi1hZGRcIiB2LWxpbms9XCJ7IG5hbWU6IFxcJ3B1YmxpYy5yZWdpc3RlclxcJyB9XCI+UmVnaXN0ZXI8L2J1dHRvbj5cXG4gICAgPGgxIGNsYXNzPVwidGl0bGVcIj5Mb2dpbjwvaDE+XFxuICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWljb24gaWNvbi1yaWdodCBpY29uIGlvbi1pbmZvcm1hdGlvblwiIHYtbGluaz1cInsgbmFtZTogXFwncHVibGljLmFib3V0XFwnIH1cIj5Db252b3k8L2J1dHRvbj5cXG48L2Rpdj5cXG5cXG48ZGl2IGlkPVwiY29udGVudFwiPlxcbiAgICA8Zm9ybSBjbGFzcz1cImxpc3QgbGlzdC1pbnNldFwiPlxcbiAgICA8IS0tIDx1bCBjbGFzcz1cImxpc3QgbGlzdC1pbnNldFwiPiAtLT5cXG4gICAgPCEtLSA8Zm9ybSBjbGFzcz1cImxpc3QgbGlzdC1pbnNldFwiPiAtLT5cXG5cXG4gICAgICAgIDxsaSBjbGFzcz1cIml0ZW0gaXRlbS1kaXZpZGVyXCI+XFxuICAgICAgICAgICAgVXNlcm5hbWVcXG4gICAgICAgIDwvbGk+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJpdGVtIGl0ZW0taW5wdXRcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB2LW1vZGVsPVwidW5hbWVcIj5cXG4gICAgICAgIDwvbGFiZWw+XFxuXFxuICAgICAgICA8bGkgY2xhc3M9XCJpdGVtIGl0ZW0tZGl2aWRlclwiPlxcbiAgICAgICAgICAgIFBhc3N3b3JkXFxuICAgICAgICA8L2xpPlxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiaXRlbSBpdGVtLWlucHV0XCI+XFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdi1tb2RlbD1cInBhc3NcIj5cXG4gICAgICAgIDwvbGFiZWw+XFxuXFxuICAgICAgICA8bGkgY2xhc3M9XCJpdGVtIGl0ZW0tZGl2aWRlclwiPlxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1ibG9jayBidXR0b24tcG9zaXRpdmVcIj5Mb2dpbjwvYnV0dG9uPlxcbiAgICAgICAgPC9saT5cXG5cXG48IS0tICAgICAgICAgPGxpIGNsYXNzPVwiaXRlbSBpdGVtLWRpdmlkZXJcIj5cXG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1ibG9jayBidXR0b24tcG9zaXRpdmVcIiB2LW9uOmNsaWNrPVwibG9naW4oXFwnYW5kcm9pZHBcXCcpXCI+TG9naW4gQW5kcm9pZCBQaG9uZTwvYnV0dG9uPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWJsb2NrIGJ1dHRvbi1wb3NpdGl2ZVwiIHYtb246Y2xpY2s9XCJsb2dpbihcXCdhcHBsZXBcXCcpXCI+TG9naW4gQXBwbGUgaVBob25lPC9idXR0b24+XFxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBidXR0b24tYmxvY2sgYnV0dG9uLXBvc2l0aXZlXCIgdi1vbjpjbGljaz1cImxvZ2luKFxcJ2FuZHJvaWR0XFwnKVwiPkxvZ2luIEFuZHJvaWQgVGFibGV0PC9idXR0b24+XFxuICAgICAgICA8L2xpPiAtLT5cXG5cXG4gICAgICAgIDwhLS0gICAgICAgICA8bGkgY2xhc3M9XCJpdGVtIGl0ZW0tZGl2aWRlclwiPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWJsb2NrIGJ1dHRvbi1wb3NpdGl2ZVwiIG5nLWNsaWNrPVwibG9naW5fREVWKFxcJ2NlbDEyM1xcJylcIj5Mb2dpbiBjbDEyMzwvYnV0dG9uPlxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLWJsb2NrIGJ1dHRvbi1wb3NpdGl2ZVwiIG5nLWNsaWNrPVwibG9naW5fREVWKFxcJ2xsMTIzXFwnKVwiPkxvZ2luIGxsMTIzPC9idXR0b24+XFxuICAgICAgICA8L2xpPiAtLT5cXG4gICAgICAgIDwhLS0gPC91bD4gLS0+XFxuICAgIDwvZm9ybT5cXG5cXG48L2Rpdj5cXG5cXG4nOyIsIi8vXG5cbnZhciBfJHNhbXNhcmEgPSByZXF1aXJlKCAnLi4vLi4vLi4vYXBwL3NhbXNhcmEuanMnIClcblxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR0ZW1wbGF0ZTogcmVxdWlyZSggJy4vbG9naW4tdGVtcGxhdGUuaHRtbCcgKSxcblxuXHRkYXRhOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGRhdGEgPSB7fVxuXHRcdGRhdGEudW5hbWUgPSBcIlwiXG5cdFx0ZGF0YS5wYXNzID0gXCJcIlxuXHRcdHJldHVybiBkYXRhXG5cdH0sXG5cblx0cmVhZHk6IGZ1bmN0aW9uICgpIHtcblxuXG5cblx0XHR0aGlzLiRuZXh0VGljayggZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCAhd2luZG93LnBsdWdpbnMgKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0d2luZG93LnBsdWdpbnMubmF0aXZlcGFnZXRyYW5zaXRpb25zLmV4ZWN1dGVQZW5kaW5nVHJhbnNpdGlvbigpXG5cdFx0fSApXG5cblx0fSxcblxuXHRtZXRob2RzOiB7XG5cblx0fVxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9ICc8IS0tICAtLT5cXG5cXG48ZGl2IGNsYXNzPVwiYmFyIGJhci1oZWFkZXIgYmFyLXBvc2l0aXZlXCIgdi10b3VjaDp0YXBob2xkPVwic2hvd1R1dHNcIj5cXG4gICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBidXR0b24taWNvbiBpY29uLWxlZnQgaWNvbiBpb24taW5mb3JtYXRpb25cIiB2LWxpbms9XCJ7IG5hbWU6IFxcJ3B1YmxpYy5hYm91dFxcJyB9XCI+Q29udm95PC9idXR0b24+XFxuICAgIDxoMSBjbGFzcz1cInRpdGxlXCI+UmVnaXN0ZXI8L2gxPlxcbiAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1pY29uIGljb24tcmlnaHQgaWNvbiBpb24tcGVyc29uXCIgdi1saW5rPVwieyBuYW1lOiBcXCdwdWJsaWMubG9naW5cXCcgfVwiPkxvZ2luPC9idXR0b24+XFxuPC9kaXY+XFxuXFxuPGRpdiBpZD1cImNvbnRlbnRcIj5cXG4gICAgPGZvcm0gY2xhc3M9XCJsaXN0IGxpc3QtaW5zZXRcIj5cXG4gICAgICAgIDwhLS0gPHVsIGNsYXNzPVwibGlzdCBsaXN0LWluc2V0XCI+IC0tPlxcbiAgICAgICAgXFxuICAgICAgICA8bGkgY2xhc3M9XCJpdGVtIGl0ZW0tZGl2aWRlclwiPlxcbiAgICAgICAgICAgIERpc3BsYXkgTmFtZVxcbiAgICAgICAgICAgIDxwIGNsYXNzPVwiXCI+V2UgcmVjb21tZW5kIHVzaW5nIHlvdXIgZmlyc3QgYW5kIGxhc3QgbmFtZSwgYnV0IHlvdSBjZXJ0YWlubHkgZG9uXFwndCBoYXZlIHRvLjwvcD5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJpdGVtIGl0ZW0taW5wdXRcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB2LW1vZGVsPVwiZG5hbWVcIiByZXF1aXJlZD5cXG4gICAgICAgIDwvbGFiZWw+XFxuXFxuICAgICAgICA8IS0tICAgICAgICAgPGxpIGNsYXNzPVwiaXRlbSBpdGVtLWRpdmlkZXIgaXRlbS1pY29uLXJpZ2h0XCI+XFxuICAgICAgICAgICAgUGhvbmUgTnVtYmVyXFxuICAgICAgICAgICAgPGkgY2xhc3M9XCJpY29uIGlvbi1pb3MtZmxhZy1vdXRsaW5lXCI+PC9pPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaXRlbS1ub3RlXCI+XFxuICAgICAgICAgICAgICAgIFVTQVxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvbGk+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJpdGVtIGl0ZW0taW5wdXRcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRlbFwiIHYtbW9kZWw9XCJwaG9uZVwiPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgIDxsaSBjbGFzcz1cIml0ZW1cIj5cXG4gICAgICAgICAgICA8cD5XZSB3aWxsIHNlbmQgeW91IGEgdmVyaWZpY2F0aW9uIGxpbmsgdmlhIFNNUy5cXG4gICAgICAgICAgICAgICAgPGJyPiBPdXIgbnVtYmVyIDY2Mi0zMzctNjQzM1xcbiAgICAgICAgICAgICAgICA8YnI+XFxuICAgICAgICAgICAgICAgIDxzbWFsbD5Zb3UgbWF5IG9wdCBvdXQgb2YgcHJvdmlkaW5nIHRoaXMgaW5mby4gWW91ciBhY2NvdW50IHdpbGwgYmUgZmxhZ2dlZCBhcyB1bnZlcmlmaWVkLjwvc21hbGw+XFxuICAgICAgICAgICAgPC9wPiBERVZWVlZWVlZcXG4gICAgICAgIDwvbGk+IC0tPlxcblxcbiAgICAgICAgPGxpIGNsYXNzPVwiaXRlbSBpdGVtLWRpdmlkZXJcIj5cXG4gICAgICAgICAgICBVc2VybmFtZVxcbiAgICAgICAgPC9saT5cXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cIml0ZW0gaXRlbS1pbnB1dFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHYtbW9kZWw9XCJ1bmFtZVwiIHJlcXVpcmVkPlxcbiAgICAgICAgPC9sYWJlbD5cXG5cXG4gICAgICAgIDxsaSBjbGFzcz1cIml0ZW0gaXRlbS1kaXZpZGVyXCI+XFxuICAgICAgICAgICAgUGFzc3dvcmRcXG4gICAgICAgIDwvbGk+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJpdGVtIGl0ZW0taW5wdXRcIj5cXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB2LW1vZGVsPVwicGFzc1wiIHJlcXVpcmVkPlxcbiAgICAgICAgPC9sYWJlbD5cXG5cXG4gICAgICAgIDxsaSBjbGFzcz1cIml0ZW0gaXRlbS1kaXZpZGVyXCI+XFxuICAgICAgICAgICAgPCEtLSA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImJ1dHRvbiBidXR0b24tYmxvY2sgYnV0dG9uLXBvc2l0aXZlXCIgdi1vbjpjbGljaz1cInJlZ2lzdGVyXCI+UmVnaXN0ZXI8L2J1dHRvbj4gLS0+XFxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLWJsb2NrIGJ1dHRvbi1wb3NpdGl2ZVwiPlJlZ2lzdGVyPC9idXR0b24+XFxuICAgICAgICA8L2xpPlxcbiAgICA8L2Zvcm0+XFxuPC9kaXY+XFxuXFxuJzsiLCIvL1xuXG52YXIgXyRzYW1zYXJhID0gcmVxdWlyZSggJy4uLy4uLy4uL2FwcC9zYW1zYXJhLmpzJyApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHR0ZW1wbGF0ZTogcmVxdWlyZSggJy4vcmVnaXN0ZXItdGVtcGxhdGUuaHRtbCcgKSxcblxuXHRkYXRhOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGRhdGEgPSB7fVxuXHRcdGRhdGEuZG5hbWUgPSBcIlwiXG5cdFx0Ly8gZGF0YS5waG9uZSA9IFwiNDAxODY0MzQ2NFwiXG5cdFx0ZGF0YS51bmFtZSA9IFwiXCJcblx0XHRkYXRhLnBhc3MgPSBcIlwiXG5cdFx0XG5cdFx0Ly8gZGF0YS5kbmFtZSA9IFwiUm9iZXJ0IExhdmVydHlcIlxuXHRcdC8vIGRhdGEudW5hbWUgPSBcInJvYmxhdjk2XCJcblx0XHQvLyBkYXRhLnBhc3MgPSBcImFiYzEyM1wiXG5cdFx0cmV0dXJuIGRhdGFcblx0fSxcblxuXHRyZWFkeTogZnVuY3Rpb24gKCkge1xuXHRcdFxuXG5cblx0XHR0aGlzLiRuZXh0VGljayggZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCAhd2luZG93LnBsdWdpbnMgKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0d2luZG93LnBsdWdpbnMubmF0aXZlcGFnZXRyYW5zaXRpb25zLmV4ZWN1dGVQZW5kaW5nVHJhbnNpdGlvbigpXG5cdFx0fSApXG5cblx0fSxcblxuXHQvLyB3YXRjaDoge1xuXHQvLyBcdCdwaG9uZSc6IGZ1bmN0aW9uICggdmFsLCBvbGRWYWwgKSB7XG5cdC8vIFx0XHR2YXIgcGhvbmUxID0gdmFsLnJlcGxhY2UoIC9bXjAtOV0vZywgJycgKS5zdWJzdHIoIDAsIDEwIClcblx0Ly8gXHRcdHRoaXMuJG5leHRUaWNrKCBmdW5jdGlvbiAoKSB7XG5cdC8vIFx0XHRcdGlmICggcGhvbmUxLmxlbmd0aCA9PSAxMCApIHtcblx0Ly8gXHRcdFx0XHR0aGlzLnBob25lID0gXyR1dGlscy5wcmV0dHlQaG9uZU51bWJlciggcGhvbmUxIClcblx0Ly8gXHRcdFx0XHRyZXR1cm5cblx0Ly8gXHRcdFx0fVxuXHQvLyBcdFx0XHR0aGlzLnBob25lID0gcGhvbmUxXG5cdC8vIFx0XHR9IClcblx0Ly8gXHR9XG5cdC8vIH0sXG5cblx0bWV0aG9kczoge1xuXG5cdFx0Ly8gZm9ybWF0UGhvbmU6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBcdC8vIHZhciBzdHIgPSBfJHV0aWxzLnByZXR0eVBob25lTnVtYmVyKCB0aGlzLnBob25lIClcblx0XHQvLyBcdC8vIGNvbnNvbGUubG9nKCAnc3RyID4nLCBzdHIgKVxuXHRcdC8vIFx0dGhpcy5waG9uZSA9IHRoaXMucGhvbmUucmVwbGFjZSggL1teMC05XS9nLCAnJyApXG5cdFx0Ly8gfSxcblxuXHRcdC8vIGdldEtleTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFx0XyRwdWIuZ2V0SW5pdEtleSgpXG5cdFx0Ly8gfVxuXHR9XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vXG5cbiIsIm1vZHVsZS5leHBvcnRzID0gJzwhLS0gIC0tPlxcblxcbjxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3Plxcblxcbic7IiwiLy9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dGVtcGxhdGU6IHJlcXVpcmUoICcuL3RhYnMtdGVtcGxhdGUuaHRtbCcgKSxcblxuXHQvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdD0gICAgICAgICAgICBST1VURSAgICAgICAgICAgID1cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXHRyb3V0ZToge1xuXHRcdGFjdGl2YXRlOiBmdW5jdGlvbiAoIHRyYW5zICkge1xuXHRcdFx0dHJhbnMubmV4dCgpXG5cdFx0fVxuXHR9XG5cblx0Ly8gbWV0aG9kczoge1xuXHQvLyBcdGhyZWY6IGZ1bmN0aW9uICggdG9TdGF0ZSwgZSApIHtcblx0Ly8gXHRcdHZhciBjdXJTdGF0ZSA9IF8kcm91dGVyLl9jdXJyZW50Um91dGUubmFtZVxuXHQvLyBcdFx0aWYgKCB0b1N0YXRlID09IGN1clN0YXRlICkge1xuXHQvLyBcdFx0XHRyZXR1cm5cblx0Ly8gXHRcdH1cblxuXHQvLyBcdFx0dmFyIHN0ciA9IGN1clN0YXRlLnRvU3RyaW5nKClcblx0Ly8gXHRcdHZhciBocmVmU3RhdGUgPSB0b1N0YXRlLnN1YnN0ciggNywgdG9TdGF0ZS5sZW5ndGggKVxuXHQvLyBcdFx0dmFyIGN1clN0YXRlID0gc3RyLnN1YnN0ciggNywgc3RyLmxlbmd0aCApXG5cblx0Ly8gXHRcdHZhciBkaXJlY3Rpb24gPSB7fVxuXHQvLyBcdFx0ZGlyZWN0aW9uWyAncmVnaXN0ZXInIF0gPSB7fVxuXHQvLyBcdFx0ZGlyZWN0aW9uWyAncmVnaXN0ZXInIF1bICdhYm91dCcgXSA9ICdyaWdodCdcblx0Ly8gXHRcdGRpcmVjdGlvblsgJ3JlZ2lzdGVyJyBdWyAnbG9naW4nIF0gPSAncmlnaHQnXG5cdC8vIFx0XHRkaXJlY3Rpb25bICdsb2dpbicgXSA9IHt9XG5cdC8vIFx0XHRkaXJlY3Rpb25bICdsb2dpbicgXVsgJ2Fib3V0JyBdID0gJ2xlZnQnXG5cdC8vIFx0XHRkaXJlY3Rpb25bICdsb2dpbicgXVsgJ3JlZ2lzdGVyJyBdID0gJ2xlZnQnXG5cdC8vIFx0XHRkaXJlY3Rpb25bICdhYm91dCcgXSA9IHt9XG5cdC8vIFx0XHRkaXJlY3Rpb25bICdhYm91dCcgXVsgJ2xvZ2luJyBdID0gJ3JpZ2h0J1xuXHQvLyBcdFx0ZGlyZWN0aW9uWyAnYWJvdXQnIF1bICdyZWdpc3RlcicgXSA9ICdsZWZ0J1xuXG5cdC8vIFx0XHRfJGZhbW91cy5ocmVmKCB0b1N0YXRlLCBkaXJlY3Rpb25bIGN1clN0YXRlIF1bIGhyZWZTdGF0ZSBdIClcblx0Ly8gXHR9XG5cblx0Ly8gXHQvLyBjbGFzc09iamVjdDogZnVuY3Rpb24gKCBpc1N0YXRlICkge1xuXHQvLyBcdC8vIFx0dmFyIGN1clN0YXRlID0gXyRyb3V0ZXIuX2N1cnJlbnRSb3V0ZS5uYW1lXG5cdC8vIFx0Ly8gXHRjb25zb2xlLmxvZyggJ2N1clN0YXRlID4nLCBjdXJTdGF0ZSApXG5cdC8vIFx0Ly8gXHRjb25zb2xlLmxvZyggJ2lzU3RhdGUgPicsIGlzU3RhdGUgKVxuXHQvLyBcdC8vIFx0cmV0dXJuIGN1clN0YXRlID09IGlzU3RhdGVcblx0Ly8gXHQvLyB9XG5cdC8vIH0sXG5cblx0Ly8gZGF0YTogZnVuY3Rpb24gKCkge1xuXHQvLyBcdHZhciBkYXRhID0ge31cblx0Ly8gXHRkYXRhLmNsYXNzT2JqZWN0ID0ge1xuXHQvLyBcdFx0J2FjdGl2ZSc6IHRoaXMuY2xhc3NPYmplY3QoKVxuXHQvLyBcdH1cblx0Ly8gXHRyZXR1cm4gZGF0YVxuXHQvLyB9XG5cblxuXHQvLyBjb21wdXRlZDoge1xuXHQvLyBcdGNsYXNzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cdC8vIFx0XHRjb25zb2xlLmluZm8oICdpZGsnIClcblx0Ly8gXHRcdHJldHVybiB7XG5cdC8vIFx0XHRcdCdhY3RpdmUnOiB0cnVlXG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0Ly8gY29tcHV0ZWQ6IHtcblx0Ly8gXHRhY3RpdmVDbGFzczogZnVuY3Rpb24gKCBpc1N0YXRlICkge1xuXHQvLyBcdFx0dmFyIGN1clN0YXRlID0gXyRyb3V0ZXIuX2N1cnJlbnRSb3V0ZS5uYW1lXG5cdC8vIFx0XHRjb25zb2xlLmxvZyggJ2lzU3RhdGUgPicsIGlzU3RhdGUgKVxuXHQvLyBcdFx0cmV0dXJuIHRydWVcblx0Ly8gXHR9XG5cdC8vIH1cbn1cblxuIl19
